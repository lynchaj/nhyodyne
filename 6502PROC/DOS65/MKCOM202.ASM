;MAKECOM
;CONVERT .KIM FILES TO .COM FILES FOR DOS/65
;VERSION 2.02-A
;RELEASED:	25 SEPTEMBER 1982
;LAST REVISION:
;	27 MARCH 2008
;		ELIMINATED PAGE ZERO 0 & 1
;		REFORMATTED FOR TASM & ASM210
;	2 APRIL 2008
;		CORRECTED ERROR IN PAGE ZERO ADDRESSING
;		PUT COM BUFFER ON PAGE BOUNDARY
;		ADDED MISSING '
;READ KIM FORMAT OBJECT CODE FILES AND GENERATE
;EXECUTABLE COMMAND (COM) FILE BEGINNING AT TEA.
;CONVERSION IS TERMINATED BY EOF CHAR, ZERO
;LENGTH RECORD, $ CHAR OR PHYSICAL EOF.  RECORDS MUST BE
;MONOTONICALLY INCREASING BUT MAY HAVE GAPS.
;ANY GAPS ARE FILLED WITH ZEROS. UPON ENTRY
;FILE TYPE IS OR IS ASSUMED TO BE "KIM".
;BASE ADDRESSES
BOOT	=	$100		;WARM BOOT
PEM	=	$103		;PEM ENTRY POINT
DFLFCB	=	$107		;SOURCE FCB
DFLBUF	=	$128		;SOURCE BUFFER
TEA	=	$800		;TEA START
;FIXED PARAMETERS
NULL	=	0		;NULL
LF	=	10		;LINEFEED $A
CR	=	13		;RETURN $D
EOF	=	26		;END OF FILE $1A
SEMICO	=	59		;SEMICOLON $3B
;ZERO PAGE STORAGE - START AT 2 FOR C64 & 128 COMPATIBILITY
KIMPNT	=$02			;KIM RECORD INDEX
COMPNT	=$03			;COM RECORD POINTER
CURENT	=$05			;CURRENT COM PC
START	=$07			;CURRENT KIM START
COUNT	=$09			;CURRENT RECORD BYTE COUNT
BYTES	=$0A			;NUMBER BYTES READ
RECORD	=$0C			;NUMBER RECORDS READ
NUMBER	=$0E			;BYTE ASSEMBLY BUFFER
COMMAX	=$0F			;MAX COM POINTER
COMFCB	=$20			;COM FCB
LASTZP	=$41			;
;MAIN PROGRAM
	*=	TEA
	JMP	LOAD		;GO EXECUTE
	.BYTE	"COPYRIGHT (C) 2008 -"
	.BYTE	" RICHARD A. LEARY"
;FIRST CLEAR PAGE ZERO INCLUDING .COM FCB
LOAD	LDX	#LASTZP-1	;SET INDEX TO MAX
	LDA	#0		;CLEAR ACCUM
CLRMRE	STA	0,X		;CLEAR
	DEX			;DROP INDEX
	CPX	#1		;IF MORE
	BNE	CLRMRE		;LOOP
;START .COM FILE BUILD AT TEA
	LDA	#(TEA & $FF)		;SET CURRENT
	STA	CURENT		;TO TEA
	LDY	#((TEA / $100)& $FF)		;BOTH LOW
	STY	CURENT+1	;AND HIGH
;CALCULATE MAXIMUM .COM FILE BUFFER LENGTH 
	SEC			;SET CARRY
	LDA	PEM+1		;GET PEM
	LDY	PEM+2		;DESTINATION
	SBC	#(COMBUF & $FF)	;START
	AND	#128		;MAKE MOD 128
	STA	COMMAX		;AND SAVE
	TYA			;GET HIGH
	SBC	#((COMBUF / $100)& $FF)	;SUBTRACT AGAIN
	STA	COMMAX+1	;AND SAVE IT
;COMMAX IS MAXIMUM LENGTH - NOW DROP BY A PAGE
	DEC	COMMAX+1
;NOW CALCULATE END OF BUFFER + 1 BYTE
	CLC			;THEN
	LDA	COMMAX		;ADD
	ADC	#(COMBUF & $FF)	;START
	STA	COMMAX		;BACK
	LDA	COMMAX+1	;IN TO
	ADC	#((COMBUF / $100)& $FF)	;GET BUFFER
	STA	COMMAX+1	;LIMIT
;INITIALIZE POINTERS
	JSR	CLRCOM		;CLEAR COM POINTER
	LDA	#128		;SET POINTERS
	STA	KIMPNT		;TO INVALID
;CHECK TO MAKE SURE FILE NAME IS UFN
	LDX	#11		;CHECK ALL CHAR
	LDA	#'?'		;FOR AMBIGUOUS
TSTAMB	CMP	DFLFCB,X	;IF NOT TRY
	BNE	TSTNXT		;FOR NEXT
	JMP	INPERR		;ELSE AN ERROR
TSTNXT	DEX			;COUNT DOWN
	BNE	TSTAMB		;AND LOOP
;NOW SEE IF TYPE EITHER KIM OR BLANK
	LDX	#2		;IF TYPE
CHKMKM	LDA	KIMTYP,X	;IS NOT
	CMP	DFLFCB+9,X	;KIM THEN
	BNE	CHKSPC		;TRY FOR SPACES
	DEX			;ELSE COUNT DOWN
	BPL	CHKMKM		;AND LOOP
	BMI	TYPEOK		;OK IF KIM
CHKSPC	LDX	#2		;CHECK FOR
	LDA	#' '		;SPACES
CHKMSP	CMP	DFLFCB+9,X	;IF SO
	BEQ	TNXSPC		;TEST NEXT
	JMP	INPERR		;ELSE ERROR
TNXSPC	DEX			;COUNT DOWN
	BPL	CHKMSP		;AND LOOP
;INPUT FILE NAME IS OK SO BUILD .COM FCB FROM INPUT
TYPEOK	LDX	#8		;SET UP
MOVFCB	LDA	DFLFCB,X	;AND MOVE
	STA	COMFCB,X	;NAME TO
	DEX			;COM
	BPL	MOVFCB		;FCB
;SET INPUT EXTENSION TO KIM AND OUTPUT TO COM
	LDX	#2		;THEN MAKE
SETTYP	LDA	KIMTYP,X	;SURE KIM
	STA	DFLFCB+9,X	;TYPE IS
	LDA	COMTYP,X	;SET AND COM
	STA	COMFCB+9,X	;TYPE IS SET
	DEX			;IN
	BPL	SETTYP		;FCBS
;FILE NAME ARE OK SO SEE IF .KIM EXISTS
	JSR	SRHKIM		;SEARCH FOR KIM
	BNE	KIMOK		;IF THERE OK
	JMP	INPERR		;ELSE ERROR
;INPUT EXISTS SO DELETE AND THEN CREATE .COM FILE
KIMOK	JSR	DLTCOM		;DELETE COM FILE
	JSR	CRTCOM		;CREATE NEW COM
	BNE	COMOK		;IF OK CONTINUE
	JMP	OUTERR		;ELSE ERROR
;FINALLY WE OPEN THE .KIM AND .COM FILES
COMOK	JSR	OPNKIM		;OPEN SOURCE
	BNE	KIMOPN		;CONTINUE IF OK
	JMP	INPERR		;ELSE ERROR
KIMOPN	JSR	OPNCOM		;OPEN COM FILE
	BNE	MAIN		;CONTINUE IF OK
	JMP	OUTERR		;ELSE ERROR
;READ LOOP - GET CHARACTERS FROM .KIM FILE AND PROCESS THEM
MAIN	JSR	GETCHR		;GET CHAR
	CMP	#'$'		;IF $
	BEQ	ENDIT		;THEN DONE
	CMP	#EOF		;IF EOF
	BEQ	ENDIT		;THEN DONE
	CMP	#SEMICO		;IF NOT FILE
	BNE	MAIN		;MARK TRY AGAIN
;FIRST TWO CHARACTERS AFTER ; ARE NUMBER OF BYTES OF DATA IN RECORD (COUNT)
	JSR	GETTWO		;GET LENGTH
	BEQ	ENDIT		;IF ZERO DONE
	STA	COUNT		;ELSE SET COUNT
;UPDATE CUMULATIVE COUNT
	CLC			;ADD TO 
	ADC	BYTES		;CUMULATIVE COUNT
	STA	BYTES		;AND 
	BCC	NOHIBY		;SAVE
	INC	BYTES+1		;LOW AND HIGH
;NEXT FOUR CHARACTERS ARE START ADDRESS OF RECORD IN HL ORDER
NOHIBY	JSR	GETTWO		;GET HIGH
	STA	START+1		;ADDRESS
	JSR	GETTWO		;AND GET
	STA	START		;LOW
;MAKE SURE START >= CURENT
	CMP	CURENT		;COMPARE TO
	LDA	START+1		;START
	SBC	CURENT+1	;ADDRESS SAVED
	BCS	TSTEQL		;IF >= THEN OK
	JMP	SEQERR		;ELSE ERROR
;SEE IF START > CURRENT AND FILL BUFFER WITH 0 UNTIL CURENT = START
TSTEQL	LDA	START		;SEE IF
	CMP	CURENT		;SAME AS CURRRENT
	BNE	FILLMR		;IF NOT FILL MORE
	LDA	START+1		;TRY HIGH
	CMP	CURENT+1	;COMPARISON
	BEQ	FILLOK		;IF SAME BEGIN READ
FILLMR	LDA	#NULL		;ELSE
	JSR	INSERT		;FILL COM
	INC	CURENT		;THEN 
	BNE	TSTEQL		;BUMP
	INC	CURENT+1	;CURRENT AND
	JMP	TSTEQL		;LOOP
;UPDATE CURENT <-- CURENT + COUNT
FILLOK	LDA	COUNT		;FIRST
	CLC			;UPDATE
	ADC	CURENT		;CURRENT
	STA	CURENT		;POINTER
	BCC	DOFILL		;WITH
	INC	CURENT+1	;CARRY
;GET COUNT BYTES FROM .KIM AND CONVERT TO BINARY AND PUT IN .COM BUFFER
DOFILL	JSR	GETTWO		;GET BYTE
	JSR	INSERT		;PUT IN COM
	DEC	COUNT		;COUNT DOWN
	BNE	DOFILL		;AND LOOP
;IGNORE TWO CHECKSUM BYTES
	JSR	GETTWO		;IGNORE
	JSR	GETTWO		;CHECKSUM
	JMP	MAIN		;AND GET NEXT
;EXIT SEQUENCE
ENDIT	SEC			;SET CARRY
	LDA	COMPNT		;IF POINTER
	SBC	#(COMBUF & $FF)	;AT EVEN
	AND	#127		;RECORD
	BEQ	NOEXCY		;THEN OK
	LDA	#EOF		;ELSE ADD
	JSR	INSERT		;EOF AND
	JMP	ENDIT		;LOOP
NOEXCY	LDA	COMPNT		;GET
	LDY	COMPNT+1	;POINTER
	STA	COMMAX		;AND SET
	STY	COMMAX+1	;LIMIT
	JSR	WRTBUF		;DO ONE MORE
	JSR	BUFCOM		;GO BACK TO FRONT OF BUFFER
WRTDNE	JSR	CLSCOM		;CLOSE COM FILE
	BNE	WRTCLS		;IF OK CONTINUE
	JMP	OUTERR		;ELSE ERROR
WRTCLS	LDA	#(NXTADR & $FF)	;POINT TO
	LDY	#((NXTADR / $100)& $FF)	;NEXT MESSAGE
	JSR	OUTBUF		;AND SEND
	LDA	CURENT+1	;SEND HIGH
	JSR	OUTBYT		;BYTE
	LDA	CURENT		;AND LOW
	JSR	OUTBYT		;BYTE
	LDA	#(BYTRDE & $FF)	;POINT TO
	LDY	#((BYTRDE / $100)& $FF)	;NUMBER READ MESSAGE
	JSR	OUTBUF		;AND SEND
	LDA	BYTES+1		;SEND HIGH
	JSR	OUTBYT		;BYTE
	LDA	BYTES		;AND LOW
	JSR	OUTBYT		;BYTE
	LDA	#(RECWRT & $FF)	;POINT TO
	LDY	#((RECWRT / $100)& $FF)	;NUMBER WRITTEN MESSAGE
	JSR	OUTBUF		;SEND
	LDA	RECORD+1	;GET HIGH
	JSR	OUTBYT		;COUNT
	LDA	RECORD		;AND LOW
	JSR	OUTBYT		;THEN RETURN
	JMP	BOOT		;WITH WARM BOOT
;SUBROUTINES
;GET CHARACTER FROM KIM FILE
GETCHR	LDX	KIMPNT		;GET POINTER
	BPL	NOREAD		;IF OK USE
	JSR	BUFKIM		;POINT TO KIM
	JSR	RDEKIM		;READ RECORD
	BNE	*+5		;IF NO ERROR CHECK FOR EOF
	JMP	INPERR		;ELSE INPUT ERROR
	CMP	#0		;IF NOT EOF
	BEQ	READOK		;CONTINUE
	LDA	#EOF		;ELSE AN EOF
	STA	DFLBUF		;INSERT IN BUFFER
	LDA	#0		;CLEAR FOR OK
READOK	TAX			;SET POINTER
	STX	KIMPNT		;AND SAVE
NOREAD	INC	KIMPNT		;BUMP POINTER
	LDA	DFLBUF,X	;GET CHAR
	AND	#%01111111	;MASK OUT MSB
	RTS			;RETURN
;GET BYTE
GETTWO	JSR	GETONE		;GET FIRST AND CONTINUE
;GET NIBBLE
GETONE	JSR	GETCHR		;GET CHAR
	CMP	#'0'		;IF LESS THAN "0"
	BMI	PACKER		;IS AN ERROR
	CMP	#'9'+1		;IF 0 TO 9 IS
	BMI	DECNUM		;DECIMAL
	CMP	#'A'		;IF LESS THAN A
	BMI	PACKER		;IS ERROR
	CMP	#'F'+1		;IF MORE THAN F
	BPL	PACKER		;IS ERROR
	CLC			;ADD 9
	ADC	#9		;FOR A TO F
DECNUM	ROL	A		;SHIFT
	ROL	A		;TO 
	ROL	A		;HIGH
	ROL	A		;NIBBLE
	LDX	#4		;THEN
PACKLP	ROL	A		;SHIFT A
	ROL	NUMBER		;TO NUMBER
	DEX			;FOUR
	BNE	PACKLP		;TIMES
	LDA	NUMBER		;RETURN
	RTS			;WITH NUMBER
PACKER	JMP	NTHXER		;ERROR HANDLER
;NIBBLE TO ASCII
HEX	AND	#$F		;LOOK AT LOW
	ORA	#'0'		;ADD "0"
	CMP	#'9'+1		;IF 0 TO 9
	BMI	NOTALP		;OK
	CLC			;ELSE ADD
	ADC	#7		;7 FOR A TO F
NOTALP	JMP	CHROUT		;SEND
;BYTE TO ASCII
OUTBYT	PHA			;SAVE BYTE
	LSR	A		;MOVE
	LSR	A		;HIGH
	LSR	A		;TO
	LSR	A		;LOW
	JSR	HEX		;CONVERT AND PRINT
	PLA			;SAME
	JMP	HEX		;FOR LOW
;KIM FILE REFERENCES
BUFKIM	LDA	#(DFLBUF & $FF) 	;POINT TO
	LDY	#((DFLBUF / $100)& $FF)	;BUFFER
	LDX	#26		;SET BUFFER
	BNE	PEMGO
SRHKIM	LDX	#17		;SEARCH FOR FIRST
	BNE	SETKIM
OPNKIM	LDX	#15		;OPEN
	BNE	SETKIM
RDEKIM	LDX	#20		;READ RECORD
SETKIM	LDA	#(DFLFCB & $FF)	;SET FCB
	LDY	#((DFLFCB / $100)& $FF)	;TO DEFAULT
	JMP	PEMGO
;COM FILE REFERENCES
BUFCOM	LDA	#(COMBUF & $FF)	;SET BUFFER
	LDY	#((COMBUF / $100)& $FF)	;TO COM
	LDX	#26		;SET BUFFER
	BNE	PEMGO
DLTCOM	LDX	#19		;DELETE FILE
	BNE	SETCOM
CRTCOM	LDX	#22		;CREATE FILE
	BNE	SETCOM
WRTCOM	LDX	#21		;WRITE RECORD
	BNE	SETCOM
CLSCOM	LDX	#16		;CLOSE FILE
	BNE	SETCOM
OPNCOM	LDX	#15		;OPEN FILE
SETCOM	LDA	#(COMFCB & $FF)	;POINT TO
	LDY	#((COMFCB / $100)& $FF)	;COM FCB
	JMP	PEMGO
;GENERAL PEM REFERENCES
WRMBTE	LDX	#0		;WARM BOOT
	BEQ	PEMGO
CHROUT	LDX	#2		;CHARACTER OUTPUT
	BNE	PEMGO
OUTBUF	LDX	#9		;STRING OUTPUT
PEMGO	JSR	PEM		;EXECUTE
	CMP	#255		;TEST FOR INVALID
	RTS
;ERROR ROUTINES
INPERR	LDA	#(INERMS & $FF)	;INPUT FILE ERROR
	LDY	#((INERMS / $100)& $FF)
	JMP	ERRSND
NTHXER	LDA	#(ICERMS & $FF)	;INVALID CHARACTER
	LDY	#((ICERMS / $100)& $FF)
	JMP	ERRSND
OUTERR	LDA	#(OTERMS & $FF)	;OUTPUT FILE ERROR
	LDY	#((OTERMS / $100)& $FF)
	JMP	ERRSND
SEQERR	LDA	#(SQERMS & $FF)	;SEQUENCE ERROR
	LDY	#((SQERMS / $100)& $FF)
ERRSND	JSR	OUTBUF		;SEND
	JMP	WRMBTE		;DO WARM BOOT
;ERROR MESSAGES
INERMS	.BYTE	"INPUT ERROR$"
OTERMS	.BYTE	"OUTPUT ERROR$"
SQERMS	.BYTE	"BAD SEQUENCE ERROR$"
ICERMS	.BYTE	"INVALID CHARACTER$"
;CLEAR COM POINTER
CLRCOM	LDA	#(COMBUF & $FF)	;GET LOW
	LDY	#((COMBUF / $100)& $FF)	;AND HIGH
	STA	COMPNT		;POINTER
	STY	COMPNT+1	;AND SET
	RTS
;INSERT BYTE INTO COM FILE
INSERT	LDX	COMPNT		;COMPARE LOW POINTER
	CPX	COMMAX		;TO MAX
	BNE	NOCMWR		;BRANCH IF NOT THERE
	LDX	COMPNT+1	;DO SAME
	CPX	COMMAX+1	;FOR HIGH
	BNE	NOCMWR		;BYTES
	PHA			;SAVE BYTE
	JSR	WRTBUF		;WRITE FILE
	PLA			;GET BYTE
NOCMWR	LDY	#0		;CLEAR INDEX
	STA	(COMPNT),Y	;SAVE BYTE
	INC	COMPNT		;BUMP
	BNE	*+4		;POINTER
	INC	COMPNT+1	;FOR NEXT
	RTS
;WRITE COM BUFFER
WRTBUF	JSR	CLRCOM		;CLEAR POINTER
WRTCLP	LDA	COMPNT		;SET
	LDY	COMPNT+1	;POINTER
	LDX	#26		;AND SET
	JSR	PEM		;BUFFER ADDRESS
	LDA	COMPNT		;GET LOW POINTER
	CMP	COMMAX		;COMPARE TO MAX
	BNE	DOCWRT		;WRITE IF NOT THERE
	LDA	COMPNT+1	;ALSO CHECK
	CMP	COMMAX+1	;HIGH POINTER
	BNE	DOCWRT		;WRITE IF DIFFERENT
	JMP	CLRCOM		;ELSE CLEAR POINTER AND EXIT
DOCWRT	JSR	WRTCOM		;WRITE RECORD
	CMP	#0		;TEST FOR OK
	BEQ	*+5		;CONTINUE IF OK
	JMP	OUTERR		;ELSE ERROR
	CLC			;BUMP
	LDA	COMPNT		;POINTER
	ADC	#128		;BY 128
	STA	COMPNT		;AND
	BCC	*+4		;SAVE FOR
	INC	COMPNT+1	;NEXT
	INC	RECORD		;ALSO
	BNE	*+4		;BUMP
	INC	RECORD+1	;RECORD COUNT
	JMP	WRTCLP		;AND LOOP
;TABLES
KIMTYP	.BYTE	"KIM"
COMTYP	.BYTE	"COM"
;MESSAGES
NXTADR	.BYTE	CR,LF,"NEXT ADDRESS=$"
BYTRDE	.BYTE	CR,LF,"BYTES READ=$"
RECWRT	.BYTE	CR,LF,"RECORDS WRITTEN=$"
;COM FILE BUFFER
	*=	*/256*256+256
COMBUF
	.END
	