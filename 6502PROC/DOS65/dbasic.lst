ca65 V2.18 - Ubuntu 2.19-1
Main file   : dbasic.asm
Current file: dbasic.asm

000000r 1               
000000r 1               ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.23
000000r 1               ; THIS WORK IS DERIVED FROM ehBASIC BY LEE DAVIDSON
000000r 1               ;
000000r 1               ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
000000r 1               
000000r 1               ; 2.00	new revision numbers start here
000000r 1               ; 2.01	fixed LCASE$() and UCASE$()
000000r 1               ; 2.02	new get value routine done
000000r 1               ; 2.03	changed RND() to galoise method
000000r 1               ; 2.04	fixed SPC()
000000r 1               ; 2.05	new get value routine fixedf
000000r 1               ; 2.06	changed USR() code
000000r 1               ; 2.07	fixed STR$()
000000r 1               ; 2.08	changed INPUT and READ to remove need for $00 start to input buffer
000000r 1               ; 2.09	fixed RND()
000000r 1               ; 2.10	integrated missed changes from an earlier version
000000r 1               ; 2.20	added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
000000r 1               ; 2.21	fixed IF .. THEN RETURN to not cause error
000000r 1               ; 2.22	fixed RND() breaking the get byte routine
000000r 1               ; 2.23  ADDED "KILL" COMMAND TO RETURN TO DOS/65
000000r 1               
000000r 1               ; zero page use ..
000000r 1               
000000r 1               LAB_WARM 		= $00		; BASIC warm start entry point
000000r 1               Wrmjpl 		= LAB_WARM+1; BASIC warm start vector jump low byte
000000r 1               Wrmjph 		= LAB_WARM+2; BASIC warm start vector jump high byte
000000r 1               
000000r 1               Usrjmp		= $0A		; USR function JMP address
000000r 1               Usrjpl		= Usrjmp+1	; USR function JMP vector low byte
000000r 1               Usrjph		= Usrjmp+2	; USR function JMP vector high byte
000000r 1               Nullct		= $0D		; nulls output after each line
000000r 1               TPos			= $0E		; BASIC terminal position byte
000000r 1               TWidth		= $0F		; BASIC terminal width byte
000000r 1               Iclim			= $10		; input column limit
000000r 1               Itempl		= $11		; temporary integer low byte
000000r 1               Itemph		= Itempl+1	; temporary integer high byte
000000r 1               
000000r 1               nums_1		= Itempl	; number to bin/hex string convert MSB
000000r 1               nums_2		= nums_1+1	; number to bin/hex string convert
000000r 1               nums_3		= nums_1+2	; number to bin/hex string convert LSB
000000r 1               
000000r 1               Srchc			= $5B		; search character
000000r 1               Temp3			= Srchc	; temp byte used in number routines
000000r 1               Scnquo		= $5C		; scan-between-quotes flag
000000r 1               Asrch			= Scnquo	; alt search character
000000r 1               
000000r 1               XOAw_l		= Srchc	; eXclusive OR, OR and AND word low byte
000000r 1               XOAw_h		= Scnquo	; eXclusive OR, OR and AND word high byte
000000r 1               
000000r 1               Ibptr			= $5D		; input buffer pointer
000000r 1               Dimcnt		= Ibptr	; # of dimensions
000000r 1               Tindx			= Ibptr	; token index
000000r 1               
000000r 1               Defdim		= $5E		; default DIM flag
000000r 1               Dtypef		= $5F		; data type flag, $FF=string, $00=numeric
000000r 1               Oquote		= $60		; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
000000r 1               Gclctd		= $60		; garbage collected flag
000000r 1               Sufnxf		= $61		; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
000000r 1               Imode			= $62		; input mode flag, $00=INPUT, $80=READ
000000r 1               
000000r 1               Cflag			= $63		; comparison evaluation flag
000000r 1               
000000r 1               TabSiz		= $64		; TAB step size (was input flag)
000000r 1               
000000r 1               next_s		= $65		; next descriptor stack address
000000r 1               
000000r 1               					; these two bytes form a word pointer to the item
000000r 1               					; currently on top of the descriptor stack
000000r 1               last_sl		= $66		; last descriptor stack address low byte
000000r 1               last_sh		= $67		; last descriptor stack address high byte (always $00)
000000r 1               
000000r 1               des_sk		= $68		; descriptor stack start address (temp strings)
000000r 1               
000000r 1               ;			= $70		; End of descriptor stack
000000r 1               
000000r 1               ut1_pl		= $71		; utility pointer 1 low byte
000000r 1               ut1_ph		= ut1_pl+1	; utility pointer 1 high byte
000000r 1               ut2_pl		= $73		; utility pointer 2 low byte
000000r 1               ut2_ph		= ut2_pl+1	; utility pointer 2 high byte
000000r 1               
000000r 1               Temp_2		= ut1_pl	; temp byte for block move
000000r 1               
000000r 1               FACt_1		= $75		; FAC temp mantissa1
000000r 1               FACt_2		= FACt_1+1	; FAC temp mantissa2
000000r 1               FACt_3		= FACt_2+1	; FAC temp mantissa3
000000r 1               
000000r 1               dims_l		= FACt_2	; array dimension size low byte
000000r 1               dims_h		= FACt_3	; array dimension size high byte
000000r 1               
000000r 1               TempB			= $78		; temp page 0 byte
000000r 1               
000000r 1               Smeml			= $79		; start of mem low byte		(Start-of-Basic)
000000r 1               Smemh			= Smeml+1	; start of mem high byte	(Start-of-Basic)
000000r 1               Svarl			= $7B		; start of vars low byte	(Start-of-Variables)
000000r 1               Svarh			= Svarl+1	; start of vars high byte	(Start-of-Variables)
000000r 1               Sarryl		= $7D		; var mem end low byte		(Start-of-Arrays)
000000r 1               Sarryh		= Sarryl+1	; var mem end high byte		(Start-of-Arrays)
000000r 1               Earryl		= $7F		; array mem end low byte	(End-of-Arrays)
000000r 1               Earryh		= Earryl+1	; array mem end high byte	(End-of-Arrays)
000000r 1               Sstorl		= $81		; string storage low byte	(String storage (moving down))
000000r 1               Sstorh		= Sstorl+1	; string storage high byte	(String storage (moving down))
000000r 1               Sutill		= $83		; string utility ptr low byte
000000r 1               Sutilh		= Sutill+1	; string utility ptr high byte
000000r 1               Ememl			= $85		; end of mem low byte		(Limit-of-memory)
000000r 1               Ememh			= Ememl+1	; end of mem high byte		(Limit-of-memory)
000000r 1               Clinel		= $87		; current line low byte		(Basic line number)
000000r 1               Clineh		= Clinel+1	; current line high byte	(Basic line number)
000000r 1               Blinel		= $89		; break line low byte		(Previous Basic line number)
000000r 1               Blineh		= Blinel+1	; break line high byte		(Previous Basic line number)
000000r 1               
000000r 1               Cpntrl		= $8B		; continue pointer low byte
000000r 1               Cpntrh		= Cpntrl+1	; continue pointer high byte
000000r 1               
000000r 1               Dlinel		= $8D		; current DATA line low byte
000000r 1               Dlineh		= Dlinel+1	; current DATA line high byte
000000r 1               
000000r 1               Dptrl			= $8F		; DATA pointer low byte
000000r 1               Dptrh			= Dptrl+1	; DATA pointer high byte
000000r 1               
000000r 1               Rdptrl		= $91		; read pointer low byte
000000r 1               Rdptrh		= Rdptrl+1	; read pointer high byte
000000r 1               
000000r 1               Varnm1		= $93		; current var name 1st byte
000000r 1               Varnm2		= Varnm1+1	; current var name 2nd byte
000000r 1               
000000r 1               Cvaral		= $95		; current var address low byte
000000r 1               Cvarah		= Cvaral+1	; current var address high byte
000000r 1               
000000r 1               Frnxtl		= $97		; var pointer for FOR/NEXT low byte
000000r 1               Frnxth		= Frnxtl+1	; var pointer for FOR/NEXT high byte
000000r 1               
000000r 1               Tidx1			= Frnxtl	; temp line index
000000r 1               
000000r 1               Lvarpl		= Frnxtl	; let var pointer low byte
000000r 1               Lvarph		= Frnxth	; let var pointer high byte
000000r 1               
000000r 1               prstk			= $99		; precedence stacked flag
000000r 1               
000000r 1               comp_f		= $9B		; compare function flag, bits 0,1 and 2 used
000000r 1               					; bit 2 set if >
000000r 1               					; bit 1 set if =
000000r 1               					; bit 0 set if <
000000r 1               
000000r 1               func_l		= $9C		; function pointer low byte
000000r 1               func_h		= func_l+1	; function pointer high byte
000000r 1               
000000r 1               garb_l		= func_l	; garbage collection working pointer low byte
000000r 1               garb_h		= func_h	; garbage collection working pointer high byte
000000r 1               
000000r 1               des_2l		= $9E		; string descriptor_2 pointer low byte
000000r 1               des_2h		= des_2l+1	; string descriptor_2 pointer high byte
000000r 1               
000000r 1               g_step		= $A0		; garbage collect step size
000000r 1               
000000r 1               Fnxjmp		= $A1		; jump vector for functions
000000r 1               Fnxjpl		= Fnxjmp+1	; functions jump vector low byte
000000r 1               Fnxjph		= Fnxjmp+2	; functions jump vector high byte
000000r 1               
000000r 1               g_indx		= Fnxjpl	; garbage collect temp index
000000r 1               
000000r 1               FAC2_r		= $A3		; FAC2 rounding byte
000000r 1               
000000r 1               Adatal		= $A4		; array data pointer low byte
000000r 1               Adatah		= Adatal+1	; array data pointer high  byte
000000r 1               
000000r 1               Nbendl		= Adatal	; new block end pointer low byte
000000r 1               Nbendh		= Adatah	; new block end pointer high  byte
000000r 1               
000000r 1               Obendl		= $A6		; old block end pointer low byte
000000r 1               Obendh		= Obendl+1	; old block end pointer high  byte
000000r 1               
000000r 1               numexp		= $A8		; string to float number exponent count
000000r 1               expcnt		= $A9		; string to float exponent count
000000r 1               
000000r 1               numbit		= numexp	; bit count for array element calculations
000000r 1               
000000r 1               numdpf		= $AA		; string to float decimal point flag
000000r 1               expneg		= $AB		; string to float eval exponent -ve flag
000000r 1               
000000r 1               Astrtl		= numdpf	; array start pointer low byte
000000r 1               Astrth		= expneg	; array start pointer high  byte
000000r 1               
000000r 1               Histrl		= numdpf	; highest string low byte
000000r 1               Histrh		= expneg	; highest string high  byte
000000r 1               
000000r 1               Baslnl		= numdpf	; BASIC search line pointer low byte
000000r 1               Baslnh		= expneg	; BASIC search line pointer high  byte
000000r 1               
000000r 1               Fvar_l		= numdpf	; find/found variable pointer low byte
000000r 1               Fvar_h		= expneg	; find/found variable pointer high  byte
000000r 1               
000000r 1               Ostrtl		= numdpf	; old block start pointer low byte
000000r 1               Ostrth		= expneg	; old block start pointer high  byte
000000r 1               
000000r 1               Vrschl		= numdpf	; variable search pointer low byte
000000r 1               Vrschh		= expneg	; variable search pointer high  byte
000000r 1               
000000r 1               FAC1_e		= $AC		; FAC1 exponent
000000r 1               FAC1_1		= FAC1_e+1	; FAC1 mantissa1
000000r 1               FAC1_2		= FAC1_e+2	; FAC1 mantissa2
000000r 1               FAC1_3		= FAC1_e+3	; FAC1 mantissa3
000000r 1               FAC1_s		= FAC1_e+4	; FAC1 sign (b7)
000000r 1               
000000r 1               str_ln		= FAC1_e	; string length
000000r 1               str_pl		= FAC1_1	; string pointer low byte
000000r 1               str_ph		= FAC1_2	; string pointer high byte
000000r 1               
000000r 1               des_pl		= FAC1_2	; string descriptor pointer low byte
000000r 1               des_ph		= FAC1_3	; string descriptor pointer high byte
000000r 1               
000000r 1               mids_l		= FAC1_3	; MID$ string temp length byte
000000r 1               
000000r 1               negnum		= $B1		; string to float eval -ve flag
000000r 1               numcon		= $B1		; series evaluation constant count
000000r 1               
000000r 1               FAC1_o		= $B2		; FAC1 overflow byte
000000r 1               
000000r 1               FAC2_e		= $B3		; FAC2 exponent
000000r 1               FAC2_1		= FAC2_e+1	; FAC2 mantissa1
000000r 1               FAC2_2		= FAC2_e+2	; FAC2 mantissa2
000000r 1               FAC2_3		= FAC2_e+3	; FAC2 mantissa3
000000r 1               FAC2_s		= FAC2_e+4	; FAC2 sign (b7)
000000r 1               
000000r 1               FAC_sc		= $B8		; FAC sign comparison, Acc#1 vs #2
000000r 1               FAC1_r		= $B9		; FAC1 rounding byte
000000r 1               
000000r 1               ssptr_l		= FAC_sc	; string start pointer low byte
000000r 1               ssptr_h		= FAC1_r	; string start pointer high byte
000000r 1               
000000r 1               sdescr		= FAC_sc	; string descriptor pointer
000000r 1               
000000r 1               csidx			= $BA		; line crunch save index
000000r 1               Asptl			= csidx	; array size/pointer low byte
000000r 1               Aspth			= $BB		; array size/pointer high byte
000000r 1               
000000r 1               Btmpl			= Asptl	; BASIC pointer temp low byte
000000r 1               Btmph			= Aspth	; BASIC pointer temp low byte
000000r 1               
000000r 1               Cptrl			= Asptl	; BASIC pointer temp low byte
000000r 1               Cptrh			= Aspth	; BASIC pointer temp low byte
000000r 1               
000000r 1               Sendl			= Asptl	; BASIC pointer temp low byte
000000r 1               Sendh			= Aspth	; BASIC pointer temp low byte
000000r 1               
000000r 1               LAB_IGBY		= $BC		; get next BASIC byte subroutine
000000r 1               
000000r 1               LAB_GBYT		= $C2		; get current BASIC byte subroutine
000000r 1               Bpntrl		= $C3		; BASIC execute (get byte) pointer low byte
000000r 1               Bpntrh		= Bpntrl+1	; BASIC execute (get byte) pointer high byte
000000r 1               
000000r 1               ;			= $D7		; end of get BASIC char subroutine
000000r 1               
000000r 1               Rbyte4		= $D8		; extra PRNG byte
000000r 1               Rbyte1		= Rbyte4+1	; most significant PRNG byte
000000r 1               Rbyte2		= Rbyte4+2	; middle PRNG byte
000000r 1               Rbyte3		= Rbyte4+3	; least significant PRNG byte
000000r 1               
000000r 1               NmiBase		= $DC		; NMI handler enabled/setup/triggered flags
000000r 1               					; bit	function
000000r 1               					; ===	========
000000r 1               					; 7	interrupt enabled
000000r 1               					; 6	interrupt setup
000000r 1               					; 5	interrupt happened
000000r 1               ;			= $DD		; NMI handler addr low byte
000000r 1               ;			= $DE		; NMI handler addr high byte
000000r 1               IrqBase		= $DF		; IRQ handler enabled/setup/triggered flags
000000r 1               ;			= $E0		; IRQ handler addr low byte
000000r 1               ;			= $E1		; IRQ handler addr high byte
000000r 1               FCBPTR		=	$E2		; POINTER TO FCB FOR FILE OPS
000000r 1               ;			= $E6		; unused
000000r 1               ;			= $E7		; unused
000000r 1               ;			= $E8		; unused
000000r 1               ;			= $E9		; unused
000000r 1               ;			= $EA		; unused
000000r 1               ;			= $EB		; unused
000000r 1               ;			= $EC		; unused
000000r 1               ;			= $ED		; unused
000000r 1               ;			= $EE		; unused
000000r 1               
000000r 1               Decss			= $EF		; number to decimal string start
000000r 1               Decssp1		= Decss+1	; number to decimal string start
000000r 1               
000000r 1               ;			= $FF		; decimal string end
000000r 1               
000000r 1               ; token values needed for BASIC
000000r 1               
000000r 1               ; primary command tokens (can start a statement)
000000r 1               
000000r 1               TK_END		= $80			; END token
000000r 1               TK_FOR		= TK_END+1		; FOR token
000000r 1               TK_NEXT		= TK_FOR+1		; NEXT token
000000r 1               TK_DATA		= TK_NEXT+1		; DATA token
000000r 1               TK_INPUT		= TK_DATA+1		; INPUT token
000000r 1               TK_DIM		= TK_INPUT+1	; DIM token
000000r 1               TK_READ		= TK_DIM+1		; READ token
000000r 1               TK_LET		= TK_READ+1		; LET token
000000r 1               TK_DEC		= TK_LET+1		; DEC token
000000r 1               TK_GOTO		= TK_DEC+1		; GOTO token
000000r 1               TK_RUN		= TK_GOTO+1		; RUN token
000000r 1               TK_IF			= TK_RUN+1		; IF token
000000r 1               TK_RESTORE		= TK_IF+1		; RESTORE token
000000r 1               TK_GOSUB		= TK_RESTORE+1	; GOSUB token
000000r 1               TK_RETIRQ		= TK_GOSUB+1	; RETIRQ token
000000r 1               TK_RETNMI		= TK_RETIRQ+1	; RETNMI token
000000r 1               TK_RETURN		= TK_RETNMI+1	; RETURN token
000000r 1               TK_REM		= TK_RETURN+1	; REM token
000000r 1               TK_STOP		= TK_REM+1		; STOP token
000000r 1               TK_ON			= TK_STOP+1		; ON token
000000r 1               TK_NULL		= TK_ON+1		; NULL token
000000r 1               TK_INC		= TK_NULL+1		; INC token
000000r 1               TK_WAIT		= TK_INC+1		; WAIT token
000000r 1               TK_LOAD		= TK_WAIT+1		; LOAD token
000000r 1               TK_SAVE		= TK_LOAD+1		; SAVE token
000000r 1               TK_DEF		= TK_SAVE+1		; DEF token
000000r 1               TK_POKE		= TK_DEF+1		; POKE token
000000r 1               TK_DOKE		= TK_POKE+1		; DOKE token
000000r 1               TK_CALL		= TK_DOKE+1		; CALL token
000000r 1               TK_DO			= TK_CALL+1		; DO token
000000r 1               TK_LOOP		= TK_DO+1		; LOOP token
000000r 1               TK_PRINT		= TK_LOOP+1		; PRINT token
000000r 1               TK_CONT		= TK_PRINT+1	; CONT token
000000r 1               TK_LIST		= TK_CONT+1		; LIST token
000000r 1               TK_CLEAR		= TK_LIST+1		; CLEAR token
000000r 1               TK_NEW		= TK_CLEAR+1	; NEW token
000000r 1               TK_WIDTH		= TK_NEW+1		; WIDTH token
000000r 1               TK_GET		= TK_WIDTH+1	; GET token
000000r 1               TK_SWAP		= TK_GET+1		; SWAP token
000000r 1               TK_BITSET		= TK_SWAP+1		; BITSET token
000000r 1               TK_BITCLR		= TK_BITSET+1	; BITCLR token
000000r 1               TK_IRQ		= TK_BITCLR+1	; IRQ token
000000r 1               TK_NMI		= TK_IRQ+1		; NMI token
000000r 1               TK_KILL		= TK_NMI+1		; NMI token
000000r 1               
000000r 1               ; secondary command tokens, can't start a statement
000000r 1               
000000r 1               TK_TAB		= TK_KILL+1		; TAB token
000000r 1               TK_ELSE		= TK_TAB+1		; ELSE token
000000r 1               TK_TO			= TK_ELSE+1		; TO token
000000r 1               TK_FN			= TK_TO+1		; FN token
000000r 1               TK_SPC		= TK_FN+1		; SPC token
000000r 1               TK_THEN		= TK_SPC+1		; THEN token
000000r 1               TK_NOT		= TK_THEN+1		; NOT token
000000r 1               TK_STEP		= TK_NOT+1		; STEP token
000000r 1               TK_UNTIL		= TK_STEP+1		; UNTIL token
000000r 1               TK_WHILE		= TK_UNTIL+1	; WHILE token
000000r 1               TK_OFF		= TK_WHILE+1	; OFF token
000000r 1               
000000r 1               ; opperator tokens
000000r 1               
000000r 1               TK_PLUS		= TK_OFF+1		; + token
000000r 1               TK_MINUS		= TK_PLUS+1		; - token
000000r 1               TK_MUL		= TK_MINUS+1	; * token
000000r 1               TK_DIV		= TK_MUL+1		; / token
000000r 1               TK_POWER		= TK_DIV+1		; ^ token
000000r 1               TK_AND		= TK_POWER+1	; AND token
000000r 1               TK_EOR		= TK_AND+1		; EOR token
000000r 1               TK_OR			= TK_EOR+1		; OR token
000000r 1               TK_RSHIFT		= TK_OR+1		; RSHIFT token
000000r 1               TK_LSHIFT		= TK_RSHIFT+1	; LSHIFT token
000000r 1               TK_GT			= TK_LSHIFT+1	; > token
000000r 1               TK_EQUAL		= TK_GT+1		; = token
000000r 1               TK_LT			= TK_EQUAL+1	; < token
000000r 1               
000000r 1               ; functions tokens
000000r 1               
000000r 1               TK_SGN		= TK_LT+1		; SGN token
000000r 1               TK_INT		= TK_SGN+1		; INT token
000000r 1               TK_ABS		= TK_INT+1		; ABS token
000000r 1               TK_USR		= TK_ABS+1		; USR token
000000r 1               TK_FRE		= TK_USR+1		; FRE token
000000r 1               TK_POS		= TK_FRE+1		; POS token
000000r 1               TK_SQR		= TK_POS+1		; SQR token
000000r 1               TK_RND		= TK_SQR+1		; RND token
000000r 1               TK_LOG		= TK_RND+1		; LOG token
000000r 1               TK_EXP		= TK_LOG+1		; EXP token
000000r 1               TK_COS		= TK_EXP+1		; COS token
000000r 1               TK_SIN		= TK_COS+1		; SIN token
000000r 1               TK_TAN		= TK_SIN+1		; TAN token
000000r 1               TK_ATN		= TK_TAN+1		; ATN token
000000r 1               TK_PEEK		= TK_ATN+1		; PEEK token
000000r 1               TK_DEEK		= TK_PEEK+1		; DEEK token
000000r 1               TK_SADD		= TK_DEEK+1		; SADD token
000000r 1               TK_LEN		= TK_SADD+1		; LEN token
000000r 1               TK_STRS		= TK_LEN+1		; STR$ token
000000r 1               TK_VAL		= TK_STRS+1		; VAL token
000000r 1               TK_ASC		= TK_VAL+1		; ASC token
000000r 1               TK_UCASES		= TK_ASC+1		; UCASE$ token
000000r 1               TK_LCASES		= TK_UCASES+1	; LCASE$ token
000000r 1               TK_CHRS		= TK_LCASES+1	; CHR$ token
000000r 1               TK_HEXS		= TK_CHRS+1		; HEX$ token
000000r 1               TK_BINS		= TK_HEXS+1		; BIN$ token
000000r 1               TK_BITTST		= TK_BINS+1		; BITTST token
000000r 1               TK_MAX		= TK_BITTST+1	; MAX token
000000r 1               TK_MIN		= TK_MAX+1		; MIN token
000000r 1               TK_PI			= TK_MIN+1		; PI token
000000r 1               TK_TWOPI		= TK_PI+1		; TWOPI token
000000r 1               TK_VPTR		= TK_TWOPI+1	; VARPTR token
000000r 1               TK_LEFTS		= TK_VPTR+1		; LEFT$ token
000000r 1               TK_RIGHTS		= TK_LEFTS+1	; RIGHT$ token
000000r 1               TK_MIDS		= TK_RIGHTS+1	; MID$ token
000000r 1               
000000r 1               ; offsets from a base of X or Y
000000r 1               
000000r 1               PLUS_0		= $00		; X or Y plus 0
000000r 1               PLUS_1		= $01		; X or Y plus 1
000000r 1               PLUS_2		= $02		; X or Y plus 2
000000r 1               PLUS_3		= $03		; X or Y plus 3
000000r 1               
000000r 1               LAB_STAK		= $0100	; stack bottom, no offset
000000r 1               
000000r 1               LAB_SKFE		= LAB_STAK+$FE
000000r 1               					; flushed stack address
000000r 1               LAB_SKFF		= LAB_STAK+$FF
000000r 1               					; flushed stack address
000000r 1               
000000r 1               ccflag		= $0200	; BASIC CTRL-C flag, 00 = enabled, 01 = dis
000000r 1               ccbyte		= ccflag+1	; BASIC CTRL-C byte
000000r 1               ccnull		= ccbyte+1	; BASIC CTRL-C byte timeout
000000r 1               
000000r 1               VEC_CC		= ccnull+1	; ctrl c check vector
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               ; This start can be changed to suit your system (TEA START)
000000r 1               
000000r 1               		.FEATURE labels_without_colons
000000r 1                		.segment "TEA"
000000r 1               		.ORG $0800
000800  1               
000800  1               BASICBEGIN:
000800  1  AD 04 01     	LDA	$0104
000803  1  8D 4E 30     	STA	PEMVEC
000806  1  AD 05 01     	LDA	$0105
000809  1  8D 4F 30     	STA	PEMVEC+1
00080C  1               
00080C  1               
00080C  1               LAB_COLD
00080C  1  A0 04        	LDY	#PG2_TABE-PG2_TABS-1
00080E  1               					; byte count-1
00080E  1               LAB_2D13
00080E  1  B9 D6 28     	LDA	PG2_TABS,Y		; get byte
000811  1  99 00 02     	STA	ccflag,Y		; store in page 2
000814  1  88           	DEY				; decrement count
000815  1  10 F7        	BPL	LAB_2D13		; loop if not done
000817  1               
000817  1  A2 FF        	LDX	#$FF			; set byte
000819  1  86 88        	STX	Clineh		; set current line high byte (set immediate mode)
00081B  1  9A           	TXS				; reset stack pointer
00081C  1               
00081C  1  A9 4C        	LDA	#$4C			; code for JMP
00081E  1  85 A1        	STA	Fnxjmp		; save for jump vector for functions
000820  1               
000820  1               ; copy block from LAB_2CEE to $00BC - $00D3
000820  1               
000820  1  A2 1C        	LDX	#StrTab-LAB_2CEE	; set byte count
000822  1               LAB_2D4E
000822  1  BD DA 28     	LDA	LAB_2CEE-1,X	; get byte from table
000825  1  95 BB        	STA	LAB_IGBY-1,X	; save byte in page zero
000827  1  CA           	DEX				; decrement count
000828  1  D0 F8        	BNE	LAB_2D4E		; loop if not all done
00082A  1               
00082A  1               ; copy block from StrTab to $0000 - $0012
00082A  1               
00082A  1               LAB_GMEM
00082A  1  A2 12        	LDX	#EndTab-StrTab-1	; set byte count-1
00082C  1               TabLoop
00082C  1  BD F7 28     	LDA	StrTab,X		; get byte from table
00082F  1  95 00        	STA	PLUS_0,X		; save byte in page zero
000831  1  CA           	DEX				; decrement count
000832  1  10 F8        	BPL	TabLoop		; loop if not all done
000834  1               
000834  1               ; set-up start values
000834  1               
000834  1  A9 00        	LDA	#$00			; clear A
000836  1  85 DC        	STA	NmiBase		; clear NMI handler enabled flag
000838  1  85 DF        	STA	IrqBase		; clear IRQ handler enabled flag
00083A  1  85 B2        	STA	FAC1_o		; clear FAC1 overflow byte
00083C  1  85 67        	STA	last_sh		; clear descriptor stack top item pointer high byte
00083E  1               
00083E  1  A9 0E        	LDA	#$0E			; set default tab size
000840  1  85 64        	STA	TabSiz		; save it
000842  1  A9 03        	LDA	#$03			; set garbage collect step size for descriptor stack
000844  1  85 A0        	STA	g_step		; save it
000846  1  A2 68        	LDX	#des_sk		; descriptor stack start
000848  1  86 65        	STX	next_s		; set descriptor stack pointer
00084A  1  20 7B 10     	JSR	LAB_CRLF		; print CR/LF
00084D  1               ;	LDA	#LAB_MSZM_LO		; point to memory size message (low addr)
00084D  1               ;	LDY	#LAB_MSZM_HI		; point to memory size message (high addr)
00084D  1               ;	JSR	LAB_18C3		; print null terminated string from memory
00084D  1               ;	JSR	LAB_INLN		; print "? " and get BASIC input
00084D  1               ;	STX	Bpntrl		; set BASIC execute pointer low byte
00084D  1               ;	STY	Bpntrh		; set BASIC execute pointer high byte
00084D  1               ;	JSR	LAB_GBYT		; get last byte back
00084D  1               
00084D  1               ;	BNE	LAB_2DAA		; branch if not null (user typed something)
00084D  1               
00084D  1  A0 00        	LDY	#$00			; else clear Y
00084F  1               					; character was null so get memory size the hard way
00084F  1               					; we get here with Y=0 and Itempl/h = Ram_base
00084F  1               LAB_2D93
00084F  1  E6 11        	INC	Itempl		; increment temporary integer low byte
000851  1  D0 08        	BNE	LAB_2D99		; branch if no overflow
000853  1               
000853  1  E6 12        	INC	Itemph		; increment temporary integer high byte
000855  1  A5 12        	LDA	Itemph		; get high byte
000857  1  C9 B8        	CMP	#Ram_top_HI		; compare with top of RAM+1
000859  1  F0 0F        	BEQ	LAB_2DB6		; branch if match (end of user RAM)
00085B  1               
00085B  1               LAB_2D99
00085B  1  A9 55        	LDA	#$55			; set test byte
00085D  1  91 11        	STA	(Itempl),Y		; save via temporary integer
00085F  1  D1 11        	CMP	(Itempl),Y		; compare via temporary integer
000861  1  D0 07        	BNE	LAB_2DB6		; branch if fail
000863  1               
000863  1  0A           	ASL	A			; shift test byte left (now $AA)
000864  1  91 11        	STA	(Itempl),Y		; save via temporary integer
000866  1  D1 11        	CMP	(Itempl),Y		; compare via temporary integer
000868  1  F0 E5        	BEQ	LAB_2D93		; if ok go do next byte
00086A  1               
00086A  1               ;	BNE	LAB_2DB6		; branch if fail
00086A  1               
00086A  1               ;LAB_2DAA
00086A  1               ;	JSR	LAB_2887		; get FAC1 from string
00086A  1               ;	LDA	FAC1_e		; get FAC1 exponent
00086A  1               ;	CMP	#$98			; compare with exponent = 2^24
00086A  1               ;	BCS	LAB_GMEM		; if too large go try again
00086A  1               ;
00086A  1               ;	JSR	LAB_F2FU		; save integer part of FAC1 in temporary integer
00086A  1               ;					; (no range check)
00086A  1               
00086A  1               LAB_2DB6
00086A  1  A5 11        	LDA	Itempl		; get temporary integer low byte
00086C  1  A4 12        	LDY	Itemph		; get temporary integer high byte
00086E  1  C0 01        	CPY	#Ram_base_LO+1	; compare with start of RAM+$100 high byte
000870  1  90 B8        	BCC	LAB_GMEM		; if too small go try again
000872  1               
000872  1               
000872  1               ; uncomment these lines if you want to check on the high limit of memory. Note if
000872  1               ; Ram_top is set too low then this will fail. default is ignore it and assume the
000872  1               ; users know what they're doing!
000872  1               
000872  1               ;	CPY	#>Ram_top		; compare with top of RAM high byte
000872  1               ;	BCC	MEM_OK		; branch if < RAM top
000872  1               
000872  1               ;	BNE	LAB_GMEM		; if too large go try again
000872  1               					; else was = so compare low bytes
000872  1               ;	CMP	#<Ram_top		; compare with top of RAM low byte
000872  1               ;	BEQ	MEM_OK		; branch if = RAM top
000872  1               
000872  1               ;	BCS	LAB_GMEM		; if too large go try again
000872  1               
000872  1               ;MEM_OK
000872  1  85 85        	STA	Ememl			; set end of mem low byte
000874  1  84 86        	STY	Ememh			; set end of mem high byte
000876  1  85 81        	STA	Sstorl		; set bottom of string space low byte
000878  1  84 82        	STY	Sstorh		; set bottom of string space high byte
00087A  1               
00087A  1  A0 00        	LDY	#Ram_base_LO		; set start addr low byte
00087C  1  A2 34        	LDX	#Ram_base_HI		; set start addr high byte
00087E  1  84 79        	STY	Smeml			; save start of mem low byte
000880  1  86 7A        	STX	Smemh			; save start of mem high byte
000882  1               
000882  1               ; this line is only needed if Ram_base is not $xx00
000882  1               
000882  1               ;	LDY	#$00			; clear Y
000882  1  98           	TYA				; clear A
000883  1  91 79        	STA	(Smeml),Y		; clear first byte
000885  1  E6 79        	INC	Smeml			; increment start of mem low byte
000887  1               
000887  1               ; these two lines are only needed if Ram_base is $xxFF
000887  1               
000887  1               ;	BNE	LAB_2E05		; branch if no rollover
000887  1               
000887  1               ;	INC	Smemh			; increment start of mem high byte
000887  1               LAB_2E05
000887  1  20 7B 10     	JSR	LAB_CRLF		; print CR/LF
00088A  1  20 39 0B     	JSR	LAB_1463		; do "NEW" and "CLEAR"
00088D  1  A5 85        	LDA	Ememl			; get end of mem low byte
00088F  1  38           	SEC				; set carry for subtract
000890  1  E5 79        	SBC	Smeml			; subtract start of mem low byte
000892  1  AA           	TAX				; copy to X
000893  1  A5 86        	LDA	Ememh			; get end of mem high byte
000895  1  E5 7A        	SBC	Smemh			; subtract start of mem high byte
000897  1  20 6E 22     	JSR	LAB_295E		; print XA as unsigned integer (bytes free)
00089A  1  A9 19        	LDA	#LAB_SMSG_LO		; point to sign-on message (low addr)
00089C  1  A0 29        	LDY	#LAB_SMSG_HI		; point to sign-on message (high addr)
00089E  1  20 BC 10     	JSR	LAB_18C3		; print null terminated string from memory
0008A1  1  A9 45        	LDA	#LAB_1274_LO		; warm start vector low byte
0008A3  1  A0 09        	LDY	#LAB_1274_HI		; warm start vector high byte
0008A5  1  85 01        	STA	Wrmjpl		; save warm start vector low byte
0008A7  1  84 02        	STY	Wrmjph		; save warm start vector high byte
0008A9  1  6C 01 00     	JMP	(Wrmjpl)		; go do warm start
0008AC  1               
0008AC  1               ; open up space in memory
0008AC  1               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
0008AC  1               
0008AC  1               ; Nbendl,Nbendh - new block end address (A/Y)
0008AC  1               ; Obendl,Obendh - old block end address
0008AC  1               ; Ostrtl,Ostrth - old block start address
0008AC  1               
0008AC  1               ; returns with ..
0008AC  1               
0008AC  1               ; Nbendl,Nbendh - new block start address (high byte - $100)
0008AC  1               ; Obendl,Obendh - old block start address (high byte - $100)
0008AC  1               ; Ostrtl,Ostrth - old block start address (unchanged)
0008AC  1               
0008AC  1               LAB_11CF
0008AC  1  20 F6 08     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
0008AF  1               					; addr to check is in AY (low/high)
0008AF  1  85 7F        	STA	Earryl		; save new array mem end low byte
0008B1  1  84 80        	STY	Earryh		; save new array mem end high byte
0008B3  1               
0008B3  1               ; open up space in memory
0008B3  1               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
0008B3  1               ; don't set array end
0008B3  1               
0008B3  1               LAB_11D6
0008B3  1  38           	SEC				; set carry for subtract
0008B4  1  A5 A6        	LDA	Obendl		; get block end low byte
0008B6  1  E5 AA        	SBC	Ostrtl		; subtract block start low byte
0008B8  1  A8           	TAY				; copy MOD(block length/$100) byte to Y
0008B9  1  A5 A7        	LDA	Obendh		; get block end high byte
0008BB  1  E5 AB        	SBC	Ostrth		; subtract block start high byte
0008BD  1  AA           	TAX				; copy block length high byte to X
0008BE  1  E8           	INX				; +1 to allow for count=0 exit
0008BF  1  98           	TYA				; copy block length low byte to A
0008C0  1  F0 24        	BEQ	LAB_120A		; branch if length low byte=0
0008C2  1               
0008C2  1               					; block is (X-1)*256+Y bytes, do the Y bytes first
0008C2  1               
0008C2  1  38           	SEC				; set carry for add + 1, two's complement
0008C3  1  49 FF        	EOR	#$FF			; invert low byte for subtract
0008C5  1  65 A6        	ADC	Obendl		; add block end low byte
0008C7  1               
0008C7  1  85 A6        	STA	Obendl		; save corrected old block end low byte
0008C9  1  B0 03        	BCS	LAB_11F3		; branch if no underflow
0008CB  1               
0008CB  1  C6 A7        	DEC	Obendh		; else decrement block end high byte
0008CD  1  38           	SEC				; set carry for add + 1, two's complement
0008CE  1               LAB_11F3
0008CE  1  98           	TYA				; get MOD(block length/$100) byte
0008CF  1  49 FF        	EOR	#$FF			; invert low byte for subtract
0008D1  1  65 A4        	ADC	Nbendl		; add destination end low byte
0008D3  1  85 A4        	STA	Nbendl		; save modified new block end low byte
0008D5  1  B0 08        	BCS	LAB_1203		; branch if no underflow
0008D7  1               
0008D7  1  C6 A5        	DEC	Nbendh		; else decrement block end high byte
0008D9  1  90 04        	BCC	LAB_1203		; branch always
0008DB  1               
0008DB  1               LAB_11FF
0008DB  1  B1 A6        	LDA	(Obendl),Y		; get byte from source
0008DD  1  91 A4        	STA	(Nbendl),Y		; copy byte to destination
0008DF  1               LAB_1203
0008DF  1  88           	DEY				; decrement index
0008E0  1  D0 F9        	BNE	LAB_11FF		; loop until Y=0
0008E2  1               
0008E2  1               					; now do Y=0 indexed byte
0008E2  1  B1 A6        	LDA	(Obendl),Y		; get byte from source
0008E4  1  91 A4        	STA	(Nbendl),Y		; save byte to destination
0008E6  1               LAB_120A
0008E6  1  C6 A7        	DEC	Obendh		; decrement source pointer high byte
0008E8  1  C6 A5        	DEC	Nbendh		; decrement destination pointer high byte
0008EA  1  CA           	DEX				; decrement block count
0008EB  1  D0 F2        	BNE	LAB_1203		; loop until count = $0
0008ED  1               
0008ED  1  60           	RTS
0008EE  1               
0008EE  1               ; check room on stack for A bytes
0008EE  1               ; stack too deep? do OM error
0008EE  1               
0008EE  1               LAB_1212
0008EE  1  85 78        	STA	TempB			; save result in temp byte
0008F0  1  BA           	TSX				; copy stack
0008F1  1  E4 78        	CPX	TempB			; compare new "limit" with stack
0008F3  1  90 30        	BCC	LAB_OMER		; if stack < limit do "Out of memory" error then warm start
0008F5  1               
0008F5  1  60           	RTS
0008F6  1               
0008F6  1               ; check available memory, "Out of memory" error if no room
0008F6  1               ; addr to check is in AY (low/high)
0008F6  1               
0008F6  1               LAB_121F
0008F6  1  C4 82        	CPY	Sstorh		; compare bottom of string mem high byte
0008F8  1  90 2A        	BCC	LAB_124B		; if less then exit (is ok)
0008FA  1               
0008FA  1  D0 04        	BNE	LAB_1229		; skip next test if greater (tested <)
0008FC  1               
0008FC  1               					; high byte was =, now do low byte
0008FC  1  C5 81        	CMP	Sstorl		; compare with bottom of string mem low byte
0008FE  1  90 24        	BCC	LAB_124B		; if less then exit (is ok)
000900  1               
000900  1               					; addr is > string storage ptr (oops!)
000900  1               LAB_1229
000900  1  48           	PHA				; push addr low byte
000901  1  A2 08        	LDX	#$08			; set index to save Adatal to expneg inclusive
000903  1  98           	TYA				; copy addr high byte (to push on stack)
000904  1               
000904  1               					; save misc numeric work area
000904  1               LAB_122D
000904  1  48           	PHA				; push byte
000905  1  B5 A3        	LDA	Adatal-1,X		; get byte from Adatal to expneg ( ,$00 not pushed)
000907  1  CA           	DEX				; decrement index
000908  1  10 FA        	BPL	LAB_122D		; loop until all done
00090A  1               
00090A  1  20 C8 19     	JSR	LAB_GARB		; garbage collection routine
00090D  1               
00090D  1               					; restore misc numeric work area
00090D  1  A2 00        	LDX	#$00			; clear the index to restore bytes
00090F  1               LAB_1238
00090F  1  68           	PLA				; pop byte
000910  1  95 A4        	STA	Adatal,X		; save byte to Adatal to expneg
000912  1  E8           	INX				; increment index
000913  1  E0 08        	CPX	#$08			; compare with end + 1
000915  1  30 F8        	BMI	LAB_1238		; loop if more to do
000917  1               
000917  1  68           	PLA				; pop addr high byte
000918  1  A8           	TAY				; copy back to Y
000919  1  68           	PLA				; pop addr low byte
00091A  1  C4 82        	CPY	Sstorh		; compare bottom of string mem high byte
00091C  1  90 06        	BCC	LAB_124B		; if less then exit (is ok)
00091E  1               
00091E  1  D0 05        	BNE	LAB_OMER		; if greater do "Out of memory" error then warm start
000920  1               
000920  1               					; high byte was =, now do low byte
000920  1  C5 81        	CMP	Sstorl		; compare with bottom of string mem low byte
000922  1  B0 01        	BCS	LAB_OMER		; if >= do "Out of memory" error then warm start
000924  1               
000924  1               					; ok exit, carry clear
000924  1               LAB_124B
000924  1  60           	RTS
000925  1               
000925  1               ; do "Out of memory" error then warm start
000925  1               
000925  1               LAB_OMER
000925  1  A2 0C        	LDX	#$0C			; error code $0C ("Out of memory" error)
000927  1               
000927  1               ; do error #X, then warm start
000927  1               
000927  1               LAB_XERR
000927  1  20 7B 10     	JSR	LAB_CRLF		; print CR/LF
00092A  1               
00092A  1  BD 96 2E     	LDA	LAB_BAER,X		; get error message pointer low byte
00092D  1  BC 97 2E     	LDY	LAB_BAER+1,X	; get error message pointer high byte
000930  1  20 BC 10     	JSR	LAB_18C3		; print null terminated string from memory
000933  1               
000933  1  20 72 0B     	JSR	LAB_1491		; flush stack and clear continue flag
000936  1  A9 D3        	LDA	#LAB_EMSG_LO		; point to " Error" low addr
000938  1  A0 2F        	LDY	#LAB_EMSG_HI		; point to " Error" high addr
00093A  1               LAB_1269
00093A  1  20 BC 10     	JSR	LAB_18C3		; print null terminated string from memory
00093D  1  A4 88        	LDY	Clineh		; get current line high byte
00093F  1  C8           	INY				; increment it
000940  1  F0 03        	BEQ	LAB_1274		; go do warm start (was immediate mode)
000942  1               
000942  1               					; else print line number
000942  1  20 63 22     	JSR	LAB_2953		; print " in line [LINE #]"
000945  1               
000945  1               ; BASIC warm start entry point
000945  1               ; wait for Basic command
000945  1               
000945  1               LAB_1274
000945  1               					; clear ON IRQ/NMI bytes
000945  1  A9 00        	LDA	#$00			; clear A
000947  1  85 DF        	STA	IrqBase		; clear enabled byte
000949  1  85 DC        	STA	NmiBase		; clear enabled byte
00094B  1  A9 E4        	LDA	#LAB_RMSG_LO		; point to "Ready" message low byte
00094D  1  A0 2F        	LDY	#LAB_RMSG_HI		; point to "Ready" message high byte
00094F  1               
00094F  1  20 BC 10     	JSR	LAB_18C3		; go do print string
000952  1               
000952  1               ; wait for Basic command (no "Ready")
000952  1               
000952  1               LAB_127D
000952  1  20 38 0A     	JSR	LAB_1357		; call for BASIC input
000955  1               LAB_1280
000955  1  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
000957  1  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
000959  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
00095C  1  F0 F4        	BEQ	LAB_127D		; loop while null
00095E  1               
00095E  1               ; got to interpret input line now ..
00095E  1               
00095E  1  A2 FF        	LDX	#$FF			; current line to null value
000960  1  86 88        	STX	Clineh		; set current line high byte
000962  1  90 06        	BCC	LAB_1295		; branch if numeric character (handle new BASIC line)
000964  1               
000964  1               					; no line number .. immediate mode
000964  1  20 67 0A     	JSR	LAB_13A6		; crunch keywords into Basic tokens
000967  1  4C DC 0C     	JMP	LAB_15F6		; go scan and interpret code
00096A  1               
00096A  1               ; handle new BASIC line
00096A  1               
00096A  1               LAB_1295
00096A  1  20 3E 0F     	JSR	LAB_GFPN		; get fixed-point number into temp integer
00096D  1  20 67 0A     	JSR	LAB_13A6		; crunch keywords into Basic tokens
000970  1  84 5D        	STY	Ibptr			; save index pointer to end of crunched line
000972  1  20 0D 0B     	JSR	LAB_SSLN		; search BASIC for temp integer line number
000975  1  90 44        	BCC	LAB_12E6		; branch if not found
000977  1               
000977  1               					; aroooogah! line # already exists! delete it
000977  1  A0 01        	LDY	#$01			; set index to next line pointer high byte
000979  1  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
00097B  1  85 72        	STA	ut1_ph		; save it
00097D  1  A5 7B        	LDA	Svarl			; get start of vars low byte
00097F  1  85 71        	STA	ut1_pl		; save it
000981  1  A5 AB        	LDA	Baslnh		; get found line pointer high byte
000983  1  85 74        	STA	ut2_ph		; save it
000985  1  A5 AA        	LDA	Baslnl		; get found line pointer low byte
000987  1  88           	DEY				; decrement index
000988  1  F1 AA        	SBC	(Baslnl),Y		; subtract next line pointer low byte
00098A  1  18           	CLC				; clear carry for add
00098B  1  65 7B        	ADC	Svarl			; add start of vars low byte
00098D  1  85 7B        	STA	Svarl			; save new start of vars low byte
00098F  1  85 73        	STA	ut2_pl		; save destination pointer low byte
000991  1  A5 7C        	LDA	Svarh			; get start of vars high byte
000993  1  69 FF        	ADC	#$FF			; -1 + carry
000995  1  85 7C        	STA	Svarh			; save start of vars high byte
000997  1  E5 AB        	SBC	Baslnh		; subtract found line pointer high byte
000999  1  AA           	TAX				; copy to block count
00099A  1  38           	SEC				; set carry for subtract
00099B  1  A5 AA        	LDA	Baslnl		; get found line pointer low byte
00099D  1  E5 7B        	SBC	Svarl			; subtract start of vars low byte
00099F  1  A8           	TAY				; copy to bytes in first block count
0009A0  1  B0 03        	BCS	LAB_12D0		; branch if overflow
0009A2  1               
0009A2  1  E8           	INX				; increment block count (correct for =0 loop exit)
0009A3  1  C6 74        	DEC	ut2_ph		; decrement destination high byte
0009A5  1               LAB_12D0
0009A5  1  18           	CLC				; clear carry for add
0009A6  1  65 71        	ADC	ut1_pl		; add source pointer low byte
0009A8  1  90 03        	BCC	LAB_12D8		; branch if no overflow
0009AA  1               
0009AA  1  C6 72        	DEC	ut1_ph		; else decrement source pointer high byte
0009AC  1  18           	CLC				; clear carry
0009AD  1               
0009AD  1               					; close up memory to delete old line
0009AD  1               LAB_12D8
0009AD  1  B1 71        	LDA	(ut1_pl),Y		; get byte from source
0009AF  1  91 73        	STA	(ut2_pl),Y		; copy to destination
0009B1  1  C8           	INY				; increment index
0009B2  1  D0 F9        	BNE	LAB_12D8		; while <> 0 do this block
0009B4  1               
0009B4  1  E6 72        	INC	ut1_ph		; increment source pointer high byte
0009B6  1  E6 74        	INC	ut2_ph		; increment destination pointer high byte
0009B8  1  CA           	DEX				; decrement block count
0009B9  1  D0 F2        	BNE	LAB_12D8		; loop until all done
0009BB  1               
0009BB  1               					; got new line in buffer and no existing same #
0009BB  1               LAB_12E6
0009BB  1  AD 81 33     	LDA	Ibuffs		; get byte from start of input buffer
0009BE  1  F0 3F        	BEQ	LAB_1319		; if null line just go flush stack/vars and exit
0009C0  1               
0009C0  1               					; got new line and it isn't empty line
0009C0  1  A5 85        	LDA	Ememl			; get end of mem low byte
0009C2  1  A4 86        	LDY	Ememh			; get end of mem high byte
0009C4  1  85 81        	STA	Sstorl		; set bottom of string space low byte
0009C6  1  84 82        	STY	Sstorh		; set bottom of string space high byte
0009C8  1  A5 7B        	LDA	Svarl			; get start of vars low byte	(end of BASIC)
0009CA  1  85 A6        	STA	Obendl		; save old block end low byte
0009CC  1  A4 7C        	LDY	Svarh			; get start of vars high byte	(end of BASIC)
0009CE  1  84 A7        	STY	Obendh		; save old block end high byte
0009D0  1  65 5D        	ADC	Ibptr			; add input buffer pointer	(also buffer length)
0009D2  1  90 01        	BCC	LAB_1301		; branch if no overflow from add
0009D4  1               
0009D4  1  C8           	INY				; else increment high byte
0009D5  1               LAB_1301
0009D5  1  85 A4        	STA	Nbendl		; save new block end low byte	(move to, low byte)
0009D7  1  84 A5        	STY	Nbendh		; save new block end high byte
0009D9  1  20 AC 08     	JSR	LAB_11CF		; open up space in memory
0009DC  1               					; old start pointer Ostrtl,Ostrth set by the find line call
0009DC  1  A5 7F        	LDA	Earryl		; get array mem end low byte
0009DE  1  A4 80        	LDY	Earryh		; get array mem end high byte
0009E0  1  85 7B        	STA	Svarl			; save start of vars low byte
0009E2  1  84 7C        	STY	Svarh			; save start of vars high byte
0009E4  1  A4 5D        	LDY	Ibptr			; get input buffer pointer	(also buffer length)
0009E6  1  88           	DEY				; adjust for loop type
0009E7  1               LAB_1311
0009E7  1  B9 7D 33     	LDA	Ibuffs-4,Y		; get byte from crunched line
0009EA  1  91 AA        	STA	(Baslnl),Y		; save it to program memory
0009EC  1  88           	DEY				; decrement count
0009ED  1  C0 03        	CPY	#$03			; compare with first byte-1
0009EF  1  D0 F6        	BNE	LAB_1311		; continue while count <> 3
0009F1  1               
0009F1  1  A5 12        	LDA	Itemph		; get line # high byte
0009F3  1  91 AA        	STA	(Baslnl),Y		; save it to program memory
0009F5  1  88           	DEY				; decrement count
0009F6  1  A5 11        	LDA	Itempl		; get line # low byte
0009F8  1  91 AA        	STA	(Baslnl),Y		; save it to program memory
0009FA  1  88           	DEY				; decrement count
0009FB  1  A9 FF        	LDA	#$FF			; set byte to allow chain rebuild. if you didn't set this
0009FD  1               					; byte then a zero already here would stop the chain rebuild
0009FD  1               					; as it would think it was the [EOT] marker.
0009FD  1  91 AA        	STA	(Baslnl),Y		; save it to program memory
0009FF  1               
0009FF  1               LAB_1319
0009FF  1  20 4E 0B     	JSR	LAB_1477		; reset execution to start, clear vars and flush stack
000A02  1  A6 79        	LDX	Smeml			; get start of mem low byte
000A04  1  A5 7A        	LDA	Smemh			; get start of mem high byte
000A06  1  A0 01        	LDY	#$01			; index to high byte of next line pointer
000A08  1               LAB_1325
000A08  1  86 71        	STX	ut1_pl		; set line start pointer low byte
000A0A  1  85 72        	STA	ut1_ph		; set line start pointer high byte
000A0C  1  B1 71        	LDA	(ut1_pl),Y		; get it
000A0E  1  F0 18        	BEQ	LAB_133E		; exit if end of program
000A10  1               
000A10  1               ; rebuild chaining of Basic lines
000A10  1               
000A10  1  A0 04        	LDY	#$04			; point to first code byte of line
000A12  1               					; there is always 1 byte + [EOL] as null entries are deleted
000A12  1               LAB_1330
000A12  1  C8           	INY				; next code byte
000A13  1  B1 71        	LDA	(ut1_pl),Y		; get byte
000A15  1  D0 FB        	BNE	LAB_1330		; loop if not [EOL]
000A17  1               
000A17  1  38           	SEC				; set carry for add + 1
000A18  1  98           	TYA				; copy end index
000A19  1  65 71        	ADC	ut1_pl		; add to line start pointer low byte
000A1B  1  AA           	TAX				; copy to X
000A1C  1  A0 00        	LDY	#$00			; clear index, point to this line's next line pointer
000A1E  1  91 71        	STA	(ut1_pl),Y		; set next line pointer low byte
000A20  1  98           	TYA				; clear A
000A21  1  65 72        	ADC	ut1_ph		; add line start pointer high byte + carry
000A23  1  C8           	INY				; increment index to high byte
000A24  1  91 71        	STA	(ut1_pl),Y		; save next line pointer low byte
000A26  1  90 E0        	BCC	LAB_1325		; go do next line, branch always, carry clear
000A28  1               
000A28  1               
000A28  1               LAB_133E
000A28  1  4C 52 09     	JMP	LAB_127D		; else we just wait for Basic command, no "Ready"
000A2B  1               
000A2B  1               ; print "? " and get BASIC input
000A2B  1               
000A2B  1               LAB_INLN
000A2B  1  20 D4 10     	JSR	LAB_18E3		; print "?" character
000A2E  1  20 D1 10     	JSR	LAB_18E0		; print " "
000A31  1  D0 05        	BNE	LAB_1357		; call for BASIC input and return
000A33  1               
000A33  1               ; receive line from keyboard
000A33  1               
000A33  1               					; $08 as delete key (BACKSPACE on standard keyboard)
000A33  1               LAB_134B
000A33  1  20 D6 10     	JSR	LAB_PRNA		; go print the character
000A36  1  CA           	DEX				; decrement the buffer counter (delete)
000A37  1  2C           	.byte	$2C			; make LDX into BIT abs
000A38  1               
000A38  1               ; call for BASIC input (main entry point)
000A38  1               
000A38  1               LAB_1357
000A38  1  A2 00        	LDX	#$00			; clear BASIC line buffer pointer
000A3A  1               LAB_1359
000A3A  1  20 12 30     	JSR	V_INPT		; call scan input device
000A3D  1  90 FB        	BCC	LAB_1359		; loop if no byte
000A3F  1               
000A3F  1               	;BEQ	LAB_1359		; loop until valid input (ignore NULLs)
000A3F  1               
000A3F  1  C9 07        	CMP	#$07			; compare with [BELL]
000A41  1  F0 10        	BEQ	LAB_1378		; branch if [BELL]
000A43  1               
000A43  1  C9 0D        	CMP	#$0D			; compare with [CR]
000A45  1  F0 19        	BEQ	LAB_1384		; do CR/LF exit if [CR]
000A47  1               
000A47  1  E0 00        	CPX	#$00			; compare pointer with $00
000A49  1  D0 04        	BNE	LAB_1374		; branch if not empty
000A4B  1               
000A4B  1               ; next two lines ignore any non print character and [SPACE] if input buffer empty
000A4B  1               
000A4B  1  C9 21        	CMP	#$21			; compare with [SP]+1
000A4D  1  90 EB        	BCC	LAB_1359		; if < ignore character
000A4F  1               
000A4F  1               LAB_1374
000A4F  1  C9 08        	CMP	#$08			; compare with [BACKSPACE] (delete last character)
000A51  1  F0 E0        	BEQ	LAB_134B		; go delete last character
000A53  1               
000A53  1               LAB_1378
000A53  1  E0 47        	CPX	#Ibuffe-Ibuffs	; compare character count with max
000A55  1  B0 0C        	BCS	LAB_138E		; skip store and do [BELL] if buffer full
000A57  1               
000A57  1  9D 81 33     	STA	Ibuffs,X		; else store in buffer
000A5A  1  E8           	INX				; increment pointer
000A5B  1               LAB_137F
000A5B  1  20 D6 10     	JSR	LAB_PRNA		; go print the character
000A5E  1  D0 DA        	BNE	LAB_1359		; always loop for next character
000A60  1               
000A60  1               LAB_1384
000A60  1  4C 72 10     	JMP	LAB_1866		; do CR/LF exit to BASIC
000A63  1               
000A63  1               ; announce buffer full
000A63  1               
000A63  1               LAB_138E
000A63  1  A9 07        	LDA	#$07			; [BELL] character into A
000A65  1  D0 F4        	BNE	LAB_137F		; go print the [BELL] but ignore input character
000A67  1               					; branch always
000A67  1               
000A67  1               ; crunch keywords into Basic tokens
000A67  1               ; position independent buffer version ..
000A67  1               ; faster, dictionary search version ....
000A67  1               
000A67  1               LAB_13A6
000A67  1  A0 FF        	LDY	#$FF			; set save index (makes for easy math later)
000A69  1               
000A69  1  38           	SEC				; set carry for subtract
000A6A  1  A5 C3        	LDA	Bpntrl		; get basic execute pointer low byte
000A6C  1  E9 81        	SBC	#Ibuffs_LO		; subtract input buffer start pointer
000A6E  1  AA           	TAX				; copy result to X (index past line # if any)
000A6F  1               
000A6F  1  86 60        	STX	Oquote		; clear open quote/DATA flag
000A71  1               LAB_13AC
000A71  1  BD 81 33     	LDA	Ibuffs,X		; get byte from input buffer
000A74  1  F0 51        	BEQ	LAB_13EC		; if null save byte then exit
000A76  1               
000A76  1  C9 5F        	CMP	#'_'			; compare with "_"
000A78  1  B0 4D        	BCS	LAB_13EC		; if >= go save byte then continue crunching
000A7A  1               
000A7A  1  C9 3C        	CMP	#'<'			; compare with "<"
000A7C  1  B0 0E        	BCS	LAB_13CC		; if >= go crunch now
000A7E  1               
000A7E  1  C9 30        	CMP	#'0'			; compare with "0"
000A80  1  B0 45        	BCS	LAB_13EC		; if >= go save byte then continue crunching
000A82  1               
000A82  1  85 5C        	STA	Scnquo		; save buffer byte as search character
000A84  1  C9 22        	CMP	#$22			; is it quote character?
000A86  1  F0 61        	BEQ	LAB_1410		; branch if so (copy quoted string)
000A88  1               
000A88  1  C9 2A        	CMP	#'*'			; compare with "*"
000A8A  1  90 3B        	BCC	LAB_13EC		; if < go save byte then continue crunching
000A8C  1               
000A8C  1               					; else crunch now
000A8C  1               LAB_13CC
000A8C  1  24 60        	BIT	Oquote		; get open quote/DATA token flag
000A8E  1  70 37        	BVS	LAB_13EC		; branch if b6 of Oquote set (was DATA)
000A90  1               					; go save byte then continue crunching
000A90  1               
000A90  1  86 78        	STX	TempB			; save buffer read index
000A92  1  84 BA        	STY	csidx			; copy buffer save index
000A94  1  A0 F2        	LDY	#TAB_1STC_LO		; get keyword first character table low address
000A96  1  84 73        	STY	ut2_pl		; save pointer low byte
000A98  1  A0 2A        	LDY	#TAB_1STC_HI		; get keyword first character table high address
000A9A  1  84 74        	STY	ut2_ph		; save pointer high byte
000A9C  1  A0 00        	LDY	#$00			; clear table pointer
000A9E  1               
000A9E  1               LAB_13D0
000A9E  1  D1 73        	CMP	(ut2_pl),Y		; compare with keyword first character table byte
000AA0  1  F0 05        	BEQ	LAB_13D1		; go do word_table_chr if match
000AA2  1               
000AA2  1  90 21        	BCC	LAB_13EA		; if < keyword first character table byte go restore
000AA4  1               					; Y and save to crunched
000AA4  1               
000AA4  1  C8           	INY				; else increment pointer
000AA5  1  D0 F7        	BNE	LAB_13D0		; and loop (branch always)
000AA7  1               
000AA7  1               ; have matched first character of some keyword
000AA7  1               
000AA7  1               LAB_13D1
000AA7  1  98           	TYA				; copy matching index
000AA8  1  0A           	ASL	A			; *2 (bytes per pointer)
000AA9  1  AA           	TAX				; copy to new index
000AAA  1  BD 11 2B     	LDA	TAB_CHRT,X		; get keyword table pointer low byte
000AAD  1  85 73        	STA	ut2_pl		; save pointer low byte
000AAF  1  BD 12 2B     	LDA	TAB_CHRT+1,X	; get keyword table pointer high byte
000AB2  1  85 74        	STA	ut2_ph		; save pointer high byte
000AB4  1               
000AB4  1  A0 FF        	LDY	#$FF			; clear table pointer (make -1 for start)
000AB6  1               
000AB6  1  A6 78        	LDX	TempB			; restore buffer read index
000AB8  1               
000AB8  1               LAB_13D6
000AB8  1  C8           	INY				; next table byte
000AB9  1  B1 73        	LDA	(ut2_pl),Y		; get byte from table
000ABB  1               LAB_13D8
000ABB  1  30 08        	BMI	LAB_13EA		; all bytes matched so go save token
000ABD  1               
000ABD  1  E8           	INX				; next buffer byte
000ABE  1  DD 81 33     	CMP	Ibuffs,X		; compare with byte from input buffer
000AC1  1  F0 F5        	BEQ	LAB_13D6		; go compare next if match
000AC3  1               
000AC3  1  D0 2B        	BNE	LAB_1417		; branch if >< (not found keyword)
000AC5  1               
000AC5  1               LAB_13EA
000AC5  1  A4 BA        	LDY	csidx			; restore save index
000AC7  1               
000AC7  1               					; save crunched to output
000AC7  1               LAB_13EC
000AC7  1  E8           	INX				; increment buffer index (to next input byte)
000AC8  1  C8           	INY				; increment save index (to next output byte)
000AC9  1  99 81 33     	STA	Ibuffs,Y		; save byte to output
000ACC  1  C9 00        	CMP	#$00			; set the flags, set carry
000ACE  1  F0 32        	BEQ	LAB_142A		; do exit if was null [EOL]
000AD0  1               
000AD0  1               					; A holds token or byte here
000AD0  1  E9 3A        	SBC	#':'			; subtract ":" (carry set by CMP #00)
000AD2  1  F0 04        	BEQ	LAB_13FF		; branch if it was ":" (is now $00)
000AD4  1               
000AD4  1               					; A now holds token-$3A
000AD4  1  C9 49        	CMP	#TK_DATA-$3A	; compare with DATA token - $3A
000AD6  1  D0 02        	BNE	LAB_1401		; branch if not DATA
000AD8  1               
000AD8  1               					; token was : or DATA
000AD8  1               LAB_13FF
000AD8  1  85 60        	STA	Oquote		; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
000ADA  1               LAB_1401
000ADA  1  49 57        	EOR	#TK_REM-$3A		; effectively subtract REM token offset
000ADC  1  D0 93        	BNE	LAB_13AC		; If wasn't REM then go crunch rest of line
000ADE  1               
000ADE  1  85 5C        	STA	Asrch			; else was REM so set search for [EOL]
000AE0  1               
000AE0  1               					; loop for REM, "..." etc.
000AE0  1               LAB_1408
000AE0  1  BD 81 33     	LDA	Ibuffs,X		; get byte from input buffer
000AE3  1  F0 E2        	BEQ	LAB_13EC		; branch if null [EOL]
000AE5  1               
000AE5  1  C5 5C        	CMP	Asrch			; compare with stored character
000AE7  1  F0 DE        	BEQ	LAB_13EC		; branch if match (end quote)
000AE9  1               
000AE9  1               					; entry for copy string in quotes, don't crunch
000AE9  1               LAB_1410
000AE9  1  C8           	INY				; increment buffer save index
000AEA  1  99 81 33     	STA	Ibuffs,Y		; save byte to output
000AED  1  E8           	INX				; increment buffer read index
000AEE  1  D0 F0        	BNE	LAB_1408		; loop while <> 0 (should never be 0!)
000AF0  1               
000AF0  1               					; not found keyword this go
000AF0  1               LAB_1417
000AF0  1  A6 78        	LDX	TempB			; compare has failed, restore buffer index (start byte!)
000AF2  1               
000AF2  1               					; now find the end of this word in the table
000AF2  1               LAB_141B
000AF2  1  B1 73        	LDA	(ut2_pl),Y		; get table byte
000AF4  1  08           	PHP				; save status
000AF5  1  C8           	INY				; increment table index
000AF6  1  28           	PLP				; restore byte status
000AF7  1  10 F9        	BPL	LAB_141B		; if not end of keyword go do next
000AF9  1               
000AF9  1  B1 73        	LDA	(ut2_pl),Y		; get byte from keyword table
000AFB  1  D0 BE        	BNE	LAB_13D8		; go test next word if not zero byte (end of table)
000AFD  1               
000AFD  1               					; reached end of table with no match
000AFD  1  BD 81 33     	LDA	Ibuffs,X		; restore byte from input buffer
000B00  1  10 C3        	BPL	LAB_13EA		; branch always (all bytes in buffer are $00-$7F)
000B02  1               					; go save byte in output and continue crunching
000B02  1               
000B02  1               					; reached [EOL]
000B02  1               LAB_142A
000B02  1  C8           	INY				; increment pointer
000B03  1  C8           	INY				; increment pointer (makes it next line pointer high byte)
000B04  1  99 81 33     	STA	Ibuffs,Y		; save [EOL] (marks [EOT] in immediate mode)
000B07  1  C8           	INY				; adjust for line copy
000B08  1  C8           	INY				; adjust for line copy
000B09  1  C8           	INY				; adjust for line copy
000B0A  1  C6 C3        	DEC	Bpntrl		; allow for increment (change if buffer starts at $xxFF)
000B0C  1  60           	RTS
000B0D  1               
000B0D  1               ; search Basic for temp integer line number from start of mem
000B0D  1               
000B0D  1               LAB_SSLN
000B0D  1  A5 79        	LDA	Smeml			; get start of mem low byte
000B0F  1  A6 7A        	LDX	Smemh			; get start of mem high byte
000B11  1               
000B11  1               ; search Basic for temp integer line number from AX
000B11  1               ; returns carry set if found
000B11  1               ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
000B11  1               
000B11  1               ; old 541 new 507
000B11  1               
000B11  1               LAB_SHLN
000B11  1  A0 01        	LDY	#$01			; set index
000B13  1  85 AA        	STA	Baslnl		; save low byte as current
000B15  1  86 AB        	STX	Baslnh		; save high byte as current
000B17  1  B1 AA        	LDA	(Baslnl),Y		; get pointer high byte from addr
000B19  1  F0 1A        	BEQ	LAB_145F		; pointer was zero so we're done, do 'not found' exit
000B1B  1               
000B1B  1  A0 03        	LDY	#$03			; set index to line # high byte
000B1D  1  B1 AA        	LDA	(Baslnl),Y		; get line # high byte
000B1F  1  88           	DEY				; decrement index (point to low byte)
000B20  1  C5 12        	CMP	Itemph		; compare with temporary integer high byte
000B22  1  D0 04        	BNE	LAB_1455		; if <> skip low byte check
000B24  1               
000B24  1  B1 AA        	LDA	(Baslnl),Y		; get line # low byte
000B26  1  C5 11        	CMP	Itempl		; compare with temporary integer low byte
000B28  1               LAB_1455
000B28  1  B0 09        	BCS	LAB_145E		; else if temp < this line, exit (passed line#)
000B2A  1               
000B2A  1               LAB_1456
000B2A  1  88           	DEY				; decrement index to next line ptr high byte
000B2B  1  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
000B2D  1  AA           	TAX				; copy to X
000B2E  1  88           	DEY				; decrement index to next line ptr low byte
000B2F  1  B1 AA        	LDA	(Baslnl),Y		; get next line pointer low byte
000B31  1  90 DE        	BCC	LAB_SHLN		; go search for line # in temp (Itempl/Itemph) from AX
000B33  1               					; (carry always clear)
000B33  1               
000B33  1               LAB_145E
000B33  1  F0 01        	BEQ	LAB_1460		; exit if temp = found line #, carry is set
000B35  1               
000B35  1               LAB_145F
000B35  1  18           	CLC				; clear found flag
000B36  1               LAB_1460
000B36  1  60           	RTS
000B37  1               
000B37  1               ; perform NEW
000B37  1               
000B37  1               LAB_NEW
000B37  1  D0 FD        	BNE	LAB_1460		; exit if not end of statement (to do syntax error)
000B39  1               
000B39  1               LAB_1463
000B39  1  A9 00        	LDA	#$00			; clear A
000B3B  1  A8           	TAY				; clear Y
000B3C  1  91 79        	STA	(Smeml),Y		; clear first line, next line pointer, low byte
000B3E  1  C8           	INY				; increment index
000B3F  1  91 79        	STA	(Smeml),Y		; clear first line, next line pointer, high byte
000B41  1  18           	CLC				; clear carry
000B42  1  A5 79        	LDA	Smeml			; get start of mem low byte
000B44  1  69 02        	ADC	#$02			; calculate end of BASIC low byte
000B46  1  85 7B        	STA	Svarl			; save start of vars low byte
000B48  1  A5 7A        	LDA	Smemh			; get start of mem high byte
000B4A  1  69 00        	ADC	#$00			; add any carry
000B4C  1  85 7C        	STA	Svarh			; save start of vars high byte
000B4E  1               
000B4E  1               ; reset execution to start, clear vars and flush stack
000B4E  1               
000B4E  1               LAB_1477
000B4E  1  18           	CLC				; clear carry
000B4F  1  A5 79        	LDA	Smeml			; get start of mem low byte
000B51  1  69 FF        	ADC	#$FF			; -1
000B53  1  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
000B55  1  A5 7A        	LDA	Smemh			; get start of mem high byte
000B57  1  69 FF        	ADC	#$FF			; -1+carry
000B59  1  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
000B5B  1               
000B5B  1               ; "CLEAR" command gets here
000B5B  1               
000B5B  1               LAB_147A
000B5B  1  A5 85        	LDA	Ememl			; get end of mem low byte
000B5D  1  A4 86        	LDY	Ememh			; get end of mem high byte
000B5F  1  85 81        	STA	Sstorl		; set bottom of string space low byte
000B61  1  84 82        	STY	Sstorh		; set bottom of string space high byte
000B63  1  A5 7B        	LDA	Svarl			; get start of vars low byte
000B65  1  A4 7C        	LDY	Svarh			; get start of vars high byte
000B67  1  85 7D        	STA	Sarryl		; save var mem end low byte
000B69  1  84 7E        	STY	Sarryh		; save var mem end high byte
000B6B  1  85 7F        	STA	Earryl		; save array mem end low byte
000B6D  1  84 80        	STY	Earryh		; save array mem end high byte
000B6F  1  20 2D 0D     	JSR	LAB_161A		; perform RESTORE command
000B72  1               
000B72  1               ; flush stack and clear continue flag
000B72  1               
000B72  1               LAB_1491
000B72  1  A2 68        	LDX	#des_sk		; set descriptor stack pointer
000B74  1  86 65        	STX	next_s		; save descriptor stack pointer
000B76  1  68           	PLA				; pull return address low byte
000B77  1  AA           	TAX				; copy return address low byte
000B78  1  68           	PLA				; pull return address high byte
000B79  1  8E FE 01     	STX	LAB_SKFE		; save to cleared stack
000B7C  1  8D FF 01     	STA	LAB_SKFF		; save to cleared stack
000B7F  1  A2 FD        	LDX	#$FD			; new stack pointer
000B81  1  9A           	TXS				; reset stack
000B82  1  A9 00        	LDA	#$00			; clear byte
000B84  1  85 8C        	STA	Cpntrh		; clear continue pointer high byte
000B86  1  85 61        	STA	Sufnxf		; clear subscript/FNX flag
000B88  1               LAB_14A6
000B88  1  60           	RTS
000B89  1               
000B89  1               ; perform CLEAR
000B89  1               
000B89  1               LAB_CLEAR
000B89  1  F0 D0        	BEQ	LAB_147A		; if no following token go do "CLEAR"
000B8B  1               
000B8B  1               					; else there was a following token (go do syntax error)
000B8B  1  60           	RTS
000B8C  1               
000B8C  1               ; perform LIST [n][-m]
000B8C  1               ; bigger, faster version (a _lot_ faster)
000B8C  1               
000B8C  1               LAB_LIST
000B8C  1  90 06        	BCC	LAB_14BD		; branch if next character numeric (LIST n..)
000B8E  1               
000B8E  1  F0 04        	BEQ	LAB_14BD		; branch if next character [NULL] (LIST)
000B90  1               
000B90  1  C9 B8        	CMP	#TK_MINUS		; compare with token for -
000B92  1  D0 F4        	BNE	LAB_14A6		; exit if not - (LIST -m)
000B94  1               
000B94  1               					; LIST [[n][-m]]
000B94  1               					; this bit sets the n , if present, as the start and end
000B94  1               LAB_14BD
000B94  1  20 3E 0F     	JSR	LAB_GFPN		; get fixed-point number into temp integer
000B97  1  20 0D 0B     	JSR	LAB_SSLN		; search BASIC for temp integer line number
000B9A  1               					; (pointer in Baslnl/Baslnh)
000B9A  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
000B9D  1  F0 0C        	BEQ	LAB_14D4		; branch if no more characters
000B9F  1               
000B9F  1               					; this bit checks the - is present
000B9F  1  C9 B8        	CMP	#TK_MINUS		; compare with token for -
000BA1  1  D0 93        	BNE	LAB_1460		; return if not "-" (will be Syntax error)
000BA3  1               
000BA3  1               					; LIST [n]-m
000BA3  1               					; the - was there so set m as the end value
000BA3  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
000BA6  1  20 3E 0F     	JSR	LAB_GFPN		; get fixed-point number into temp integer
000BA9  1  D0 8B        	BNE	LAB_1460		; exit if not ok
000BAB  1               
000BAB  1               LAB_14D4
000BAB  1  A5 11        	LDA	Itempl		; get temporary integer low byte
000BAD  1  05 12        	ORA	Itemph		; OR temporary integer high byte
000BAF  1  D0 06        	BNE	LAB_14E2		; branch if start set
000BB1  1               
000BB1  1  A9 FF        	LDA	#$FF			; set for -1
000BB3  1  85 11        	STA	Itempl		; set temporary integer low byte
000BB5  1  85 12        	STA	Itemph		; set temporary integer high byte
000BB7  1               LAB_14E2
000BB7  1  A0 01        	LDY	#$01			; set index for line
000BB9  1  84 60        	STY	Oquote		; clear open quote flag
000BBB  1  20 7B 10     	JSR	LAB_CRLF		; print CR/LF
000BBE  1  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
000BC0  1               					; pointer initially set by search at LAB_14BD
000BC0  1  F0 3E        	BEQ	LAB_152B		; if null all done so exit
000BC2  1  20 FD 0C     	JSR	LAB_1629		; do CRTL-C check vector
000BC5  1               
000BC5  1  C8           	INY				; increment index for line
000BC6  1  B1 AA        	LDA	(Baslnl),Y		; get line # low byte
000BC8  1  AA           	TAX				; copy to X
000BC9  1  C8           	INY				; increment index
000BCA  1  B1 AA        	LDA	(Baslnl),Y		; get line # high byte
000BCC  1  C5 12        	CMP	Itemph		; compare with temporary integer high byte
000BCE  1  D0 04        	BNE	LAB_14FF		; branch if no high byte match
000BD0  1               
000BD0  1  E4 11        	CPX	Itempl		; compare with temporary integer low byte
000BD2  1  F0 02        	BEQ	LAB_1501		; branch if = last line to do (< will pass next branch)
000BD4  1               
000BD4  1               LAB_14FF				; else ..
000BD4  1  B0 2A        	BCS	LAB_152B		; if greater all done so exit
000BD6  1               
000BD6  1               LAB_1501
000BD6  1  84 97        	STY	Tidx1			; save index for line
000BD8  1  20 6E 22     	JSR	LAB_295E		; print XA as unsigned integer
000BDB  1  A9 20        	LDA	#$20			; space is the next character
000BDD  1               LAB_1508
000BDD  1  A4 97        	LDY	Tidx1			; get index for line
000BDF  1  29 7F        	AND	#$7F			; mask top out bit of character
000BE1  1               LAB_150C
000BE1  1  20 D6 10     	JSR	LAB_PRNA		; go print the character
000BE4  1  C9 22        	CMP	#$22			; was it " character
000BE6  1  D0 06        	BNE	LAB_1519		; branch if not
000BE8  1               
000BE8  1               					; we are either entering or leaving a pair of quotes
000BE8  1  A5 60        	LDA	Oquote		; get open quote flag
000BEA  1  49 FF        	EOR	#$FF			; toggle it
000BEC  1  85 60        	STA	Oquote		; save it back
000BEE  1               LAB_1519
000BEE  1  C8           	INY				; increment index
000BEF  1  B1 AA        	LDA	(Baslnl),Y		; get next byte
000BF1  1  D0 0E        	BNE	LAB_152E		; branch if not [EOL] (go print character)
000BF3  1  A8           	TAY				; else clear index
000BF4  1  B1 AA        	LDA	(Baslnl),Y		; get next line pointer low byte
000BF6  1  AA           	TAX				; copy to X
000BF7  1  C8           	INY				; increment index
000BF8  1  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
000BFA  1  86 AA        	STX	Baslnl		; set pointer to line low byte
000BFC  1  85 AB        	STA	Baslnh		; set pointer to line high byte
000BFE  1  D0 B7        	BNE	LAB_14E2		; go do next line if not [EOT]
000C00  1               					; else ..
000C00  1               LAB_152B
000C00  1  60           	RTS
000C01  1               
000C01  1               LAB_152E
000C01  1  10 DE        	BPL	LAB_150C		; just go print it if not token byte
000C03  1               
000C03  1               					; else was token byte so uncrunch it (maybe)
000C03  1  24 60        	BIT	Oquote		; test the open quote flag
000C05  1  30 DA        	BMI	LAB_150C		; just go print character if open quote set
000C07  1               
000C07  1  A2 2C        	LDX	#LAB_KEYT_HI		; get table address high byte
000C09  1  0A           	ASL	A			; *2
000C0A  1  0A           	ASL	A			; *4
000C0B  1  90 02        	BCC	LAB_152F		; branch if no carry
000C0D  1               
000C0D  1  E8           	INX				; else increment high byte
000C0E  1  18           	CLC				; clear carry for add
000C0F  1               LAB_152F
000C0F  1  69 FA        	ADC	#LAB_KEYT_LO		; add low byte
000C11  1  90 01        	BCC	LAB_1530		; branch if no carry
000C13  1               
000C13  1  E8           	INX				; else increment high byte
000C14  1               LAB_1530
000C14  1  85 73        	STA	ut2_pl		; save table pointer low byte
000C16  1  86 74        	STX	ut2_ph		; save table pointer high byte
000C18  1  84 97        	STY	Tidx1			; save index for line
000C1A  1  A0 00        	LDY	#$00			; clear index
000C1C  1  B1 73        	LDA	(ut2_pl),Y		; get length
000C1E  1  AA           	TAX				; copy length
000C1F  1  C8           	INY				; increment index
000C20  1  B1 73        	LDA	(ut2_pl),Y		; get 1st character
000C22  1  CA           	DEX				; decrement length
000C23  1  F0 B8        	BEQ	LAB_1508		; if no more characters exit and print
000C25  1               
000C25  1  20 D6 10     	JSR	LAB_PRNA		; go print the character
000C28  1  C8           	INY				; increment index
000C29  1  B1 73        	LDA	(ut2_pl),Y		; get keyword address low byte
000C2B  1  48           	PHA				; save it for now
000C2C  1  C8           	INY				; increment index
000C2D  1  B1 73        	LDA	(ut2_pl),Y		; get keyword address high byte
000C2F  1  A0 00        	LDY	#$00
000C31  1  85 74        	STA	ut2_ph		; save keyword pointer high byte
000C33  1  68           	PLA				; pull low byte
000C34  1  85 73        	STA	ut2_pl		; save keyword pointer low byte
000C36  1               LAB_1540
000C36  1  B1 73        	LDA	(ut2_pl),Y		; get character
000C38  1  CA           	DEX				; decrement character count
000C39  1  F0 A2        	BEQ	LAB_1508		; if last character exit and print
000C3B  1               
000C3B  1  20 D6 10     	JSR	LAB_PRNA		; go print the character
000C3E  1  C8           	INY				; increment index
000C3F  1  D0 F5        	BNE	LAB_1540		; loop for next character
000C41  1               
000C41  1               ; perform FOR
000C41  1               
000C41  1               LAB_FOR
000C41  1  A9 80        	LDA	#$80			; set FNX
000C43  1  85 61        	STA	Sufnxf		; set subscript/FNX flag
000C45  1  20 9D 0F     	JSR	LAB_LET		; go do LET
000C48  1  68           	PLA				; pull return address
000C49  1  68           	PLA				; pull return address
000C4A  1  A9 10        	LDA	#$10			; we need 16d bytes !
000C4C  1  20 EE 08     	JSR	LAB_1212		; check room on stack for A bytes
000C4F  1  20 86 0E     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
000C52  1  18           	CLC				; clear carry for add
000C53  1  98           	TYA				; copy index to A
000C54  1  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
000C56  1  48           	PHA				; push onto stack
000C57  1  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
000C59  1  69 00        	ADC	#$00			; add carry
000C5B  1  48           	PHA				; push onto stack
000C5C  1  A5 88        	LDA	Clineh		; get current line high byte
000C5E  1  48           	PHA				; push onto stack
000C5F  1  A5 87        	LDA	Clinel		; get current line low byte
000C61  1  48           	PHA				; push onto stack
000C62  1  A9 AE        	LDA	#TK_TO		; get "TO" token
000C64  1  20 DA 13     	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
000C67  1  20 B9 12     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
000C6A  1  20 B6 12     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
000C6D  1               					; else do type mismatch
000C6D  1  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
000C6F  1  09 7F        	ORA	#$7F			; set all non sign bits
000C71  1  25 AD        	AND	FAC1_1		; and FAC1 mantissa1
000C73  1  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
000C75  1  A9 80        	LDA	#LAB_159F_LO		; set return address low byte
000C77  1  A0 0C        	LDY	#LAB_159F_HI		; set return address high byte
000C79  1  85 71        	STA	ut1_pl		; save return address low byte
000C7B  1  84 72        	STY	ut1_ph		; save return address high byte
000C7D  1  4C 6D 13     	JMP	LAB_1B66		; round FAC1 and put on stack (returns to next instruction)
000C80  1               
000C80  1               LAB_159F
000C80  1  A9 C0        	LDA	#LAB_259C_LO		; set 1 pointer low addr (default step size)
000C82  1  A0 29        	LDY	#LAB_259C_HI		; set 1 pointer high addr
000C84  1  20 66 20     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
000C87  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
000C8A  1  C9 B3        	CMP	#TK_STEP		; compare with STEP token
000C8C  1  D0 06        	BNE	LAB_15B3		; jump if not "STEP"
000C8E  1               
000C8E  1               					;.was step so ..
000C8E  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
000C91  1  20 B6 12     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
000C94  1               					; else do type mismatch
000C94  1               LAB_15B3
000C94  1  20 D2 20     	JSR	LAB_27CA		; return A=FF,C=1/-ve A=01,C=0/+ve
000C97  1  85 B0        	STA	FAC1_s		; set FAC1 sign (b7)
000C99  1               					; this is +1 for +ve step and -1 for -ve step, in NEXT we
000C99  1               					; compare the FOR value and the TO value and return +1 if
000C99  1               					; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
000C99  1               					; here (+/-1) is then compared to that result and if they
000C99  1               					; are the same (+ve and FOR > TO or -ve and FOR < TO) then
000C99  1               					; the loop is done
000C99  1  20 62 13     	JSR	LAB_1B5B		; push sign, round FAC1 and put on stack
000C9C  1  A5 98        	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
000C9E  1  48           	PHA				; push on stack
000C9F  1  A5 97        	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
000CA1  1  48           	PHA				; push on stack
000CA2  1  A9 81        	LDA	#TK_FOR		; get FOR token
000CA4  1  48           	PHA				; push on stack
000CA5  1               
000CA5  1               ; interpreter inner loop
000CA5  1               
000CA5  1               LAB_15C2
000CA5  1  20 FD 0C     	JSR	LAB_1629		; do CRTL-C check vector
000CA8  1  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
000CAA  1  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
000CAC  1               
000CAC  1  A6 88        	LDX	Clineh		; continue line is $FFxx for immediate mode
000CAE  1               					; ($00xx for RUN from immediate mode)
000CAE  1  E8           	INX				; increment it (now $00 if immediate mode)
000CAF  1  F0 04        	BEQ	LAB_15D1		; branch if null (immediate mode)
000CB1  1               
000CB1  1  85 8B        	STA	Cpntrl		; save continue pointer low byte
000CB3  1  84 8C        	STY	Cpntrh		; save continue pointer high byte
000CB5  1               LAB_15D1
000CB5  1  A0 00        	LDY	#$00			; clear index
000CB7  1  B1 C3        	LDA	(Bpntrl),Y		; get next byte
000CB9  1  F0 07        	BEQ	LAB_15DC		; branch if null [EOL]
000CBB  1               
000CBB  1  C9 3A        	CMP	#':'			; compare with ":"
000CBD  1  F0 1D        	BEQ	LAB_15F6		; branch if = (statement separator)
000CBF  1               
000CBF  1               LAB_15D9
000CBF  1  4C EB 13     	JMP	LAB_SNER		; else syntax error then warm start
000CC2  1               
000CC2  1               					; have reached [EOL]
000CC2  1               LAB_15DC
000CC2  1  A0 02        	LDY	#$02			; set index
000CC4  1  B1 C3        	LDA	(Bpntrl),Y		; get next line pointer high byte
000CC6  1  18           	CLC				; clear carry for no "BREAK" message
000CC7  1  F0 56        	BEQ	LAB_1651		; if null go to immediate mode (was immediate or [EOT]
000CC9  1               					; marker)
000CC9  1               
000CC9  1  C8           	INY				; increment index
000CCA  1  B1 C3        	LDA	(Bpntrl),Y		; get line # low byte
000CCC  1  85 87        	STA	Clinel		; save current line low byte
000CCE  1  C8           	INY				; increment index
000CCF  1  B1 C3        	LDA	(Bpntrl),Y		; get line # high byte
000CD1  1  85 88        	STA	Clineh		; save current line high byte
000CD3  1  98           	TYA				; A now = 4
000CD4  1  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
000CD6  1  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
000CD8  1  90 02        	BCC	LAB_15F6		; branch if no overflow
000CDA  1               
000CDA  1  E6 C4        	INC	Bpntrh		; else increment BASIC execute pointer high byte
000CDC  1               LAB_15F6
000CDC  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
000CDF  1               
000CDF  1               LAB_15F9
000CDF  1  20 E5 0C     	JSR	LAB_15FF		; go interpret BASIC code from (Bpntrl)
000CE2  1               
000CE2  1               LAB_15FC
000CE2  1  4C A5 0C     	JMP	LAB_15C2		; loop
000CE5  1               
000CE5  1               ; interpret BASIC code from (Bpntrl)
000CE5  1               
000CE5  1               LAB_15FF
000CE5  1  F0 54        	BEQ	LAB_1628		; exit if zero [EOL]
000CE7  1               
000CE7  1               LAB_1602
000CE7  1  0A           	ASL	A			; *2 bytes per vector and normalise token
000CE8  1  B0 03        	BCS	LAB_1609		; branch if was token
000CEA  1               
000CEA  1  4C 9D 0F     	JMP	LAB_LET			; else go do implied LET
000CED  1               
000CED  1               LAB_1609
000CED  1               TK_TABUSE = 	(TK_TAB-$80)*2
000CED  1  C9 58        	CMP	#TK_TABUSE		; compare normalised token * 2 with TAB
000CEF  1  B0 CE        	BCS	LAB_15D9		; branch if A>=TAB (do syntax error then warm start)
000CF1  1               					; only tokens before TAB can start a line
000CF1  1  A8           	TAY				; copy to index
000CF2  1  B9 E8 29     	LDA	LAB_CTBL+1,Y		; get vector high byte
000CF5  1  48           	PHA				; onto stack
000CF6  1  B9 E7 29     	LDA	LAB_CTBL,Y		; get vector low byte
000CF9  1  48           	PHA				; onto stack
000CFA  1  4C BC 00     	JMP	LAB_IGBY		; jump to increment and scan memory
000CFD  1               					; then "return" to vector
000CFD  1               
000CFD  1               ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
000CFD  1               ; key press is detected.
000CFD  1               
000CFD  1               LAB_1629
000CFD  1  6C 03 02     	JMP	(VEC_CC)		; ctrl c check vector
000D00  1               
000D00  1               ; if there was a key press it gets back here ..
000D00  1               
000D00  1               LAB_1636
000D00  1  C9 03        	CMP	#$03			; compare with CTRL-C
000D02  1               
000D02  1               ; perform STOP
000D02  1               
000D02  1               LAB_STOP
000D02  1  B0 01        	BCS	LAB_163B		; branch if token follows STOP
000D04  1               					; else just END
000D04  1               ; END
000D04  1               
000D04  1               LAB_END
000D04  1  18           	CLC				; clear the carry, indicate a normal program end
000D05  1               LAB_163B
000D05  1  D0 67        	BNE	LAB_167A		; if wasn't CTRL-C or there is a following byte return
000D07  1               
000D07  1  A5 C4        	LDA	Bpntrh		; get the BASIC execute pointer high byte
000D09  1  49 33        	EOR	#Ibuffs_HI		; compare with buffer address high byte (Cb unchanged)
000D0B  1  F0 10        	BEQ	LAB_164F		; branch if the BASIC pointer is in the input buffer
000D0D  1               					; (can't continue in immediate mode)
000D0D  1               
000D0D  1               					; else ..
000D0D  1  49 33        	EOR	#Ibuffs_HI		; correct the bits
000D0F  1  A4 C3        	LDY	Bpntrl		; get BASIC execute pointer low byte
000D11  1  84 8B        	STY	Cpntrl		; save continue pointer low byte
000D13  1  85 8C        	STA	Cpntrh		; save continue pointer high byte
000D15  1               LAB_1647
000D15  1  A5 87        	LDA	Clinel		; get current line low byte
000D17  1  A4 88        	LDY	Clineh		; get current line high byte
000D19  1  85 89        	STA	Blinel		; save break line low byte
000D1B  1  84 8A        	STY	Blineh		; save break line high byte
000D1D  1               LAB_164F
000D1D  1  68           	PLA				; pull return address low
000D1E  1  68           	PLA				; pull return address high
000D1F  1               LAB_1651
000D1F  1  90 07        	BCC	LAB_165E		; if was program end just do warm start
000D21  1               
000D21  1               					; else ..
000D21  1  A9 CB        	LDA	#LAB_BMSG_LO		; point to "Break" low byte
000D23  1  A0 2F        	LDY	#LAB_BMSG_HI		; point to "Break" high byte
000D25  1  4C 3A 09     	JMP	LAB_1269		; print "Break" and do warm start
000D28  1               
000D28  1               LAB_165E
000D28  1  4C 45 09     	JMP	LAB_1274		; go do warm start
000D2B  1               
000D2B  1               ; perform RESTORE
000D2B  1               
000D2B  1               LAB_RESTORE
000D2B  1  D0 0F        	BNE	LAB_RESTOREn	; branch if next character not null (RESTORE n)
000D2D  1               
000D2D  1               LAB_161A
000D2D  1  38           	SEC				; set carry for subtract
000D2E  1  A5 79        	LDA	Smeml			; get start of mem low byte
000D30  1  E9 01        	SBC	#$01			; -1
000D32  1  A4 7A        	LDY	Smemh			; get start of mem high byte
000D34  1  B0 01        	BCS	LAB_1624		; branch if no underflow
000D36  1               
000D36  1               LAB_uflow
000D36  1  88           	DEY				; else decrement high byte
000D37  1               LAB_1624
000D37  1  85 8F        	STA	Dptrl			; save DATA pointer low byte
000D39  1  84 90        	STY	Dptrh			; save DATA pointer high byte
000D3B  1               LAB_1628
000D3B  1  60           	RTS
000D3C  1               
000D3C  1               					; is RESTORE n
000D3C  1               LAB_RESTOREn
000D3C  1  20 3E 0F     	JSR	LAB_GFPN		; get fixed-point number into temp integer
000D3F  1  20 89 0E     	JSR	LAB_SNBL		; scan for next BASIC line
000D42  1  A5 88        	LDA	Clineh		; get current line high byte
000D44  1  C5 12        	CMP	Itemph		; compare with temporary integer high byte
000D46  1  B0 0B        	BCS	LAB_reset_search	; branch if >= (start search from beginning)
000D48  1               
000D48  1  98           	TYA				; else copy line index to A
000D49  1  38           	SEC				; set carry (+1)
000D4A  1  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
000D4C  1  A6 C4        	LDX	Bpntrh		; get BASIC execute pointer high byte
000D4E  1  90 07        	BCC	LAB_go_search	; branch if no overflow to high byte
000D50  1               
000D50  1  E8           	INX				; increment high byte
000D51  1  B0 04        	BCS	LAB_go_search	; branch always (can never be carry clear)
000D53  1               
000D53  1               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
000D53  1               
000D53  1               LAB_reset_search
000D53  1  A5 79        	LDA	Smeml			; get start of mem low byte
000D55  1  A6 7A        	LDX	Smemh			; get start of mem high byte
000D57  1               
000D57  1               ; search for line # in temp (Itempl/Itemph) from (AX)
000D57  1               
000D57  1               LAB_go_search
000D57  1               
000D57  1  20 11 0B     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
000D5A  1  B0 03        	BCS	LAB_line_found	; if carry set go set pointer
000D5C  1               
000D5C  1  4C 5B 0E     	JMP	LAB_16F7		; else go do "Undefined statement" error
000D5F  1               
000D5F  1               LAB_line_found
000D5F  1               					; carry already set for subtract
000D5F  1  A5 AA        	LDA	Baslnl		; get pointer low byte
000D61  1  E9 01        	SBC	#$01			; -1
000D63  1  A4 AB        	LDY	Baslnh		; get pointer high byte
000D65  1  B0 D0        	BCS	LAB_1624		; branch if no underflow (save DATA pointer and return)
000D67  1               
000D67  1  90 CD        	BCC	LAB_uflow		; else decrement high byte then save DATA pointer and
000D69  1               					; return (branch always)
000D69  1               
000D69  1               ; perform NULL
000D69  1               
000D69  1               LAB_NULL
000D69  1  20 75 1C     	JSR	LAB_GTBY		; get byte parameter
000D6C  1  86 0D        	STX	Nullct		; save new NULL count
000D6E  1               LAB_167A
000D6E  1  60           	RTS
000D6F  1               
000D6F  1               ; perform CONT
000D6F  1               
000D6F  1               LAB_CONT
000D6F  1  D0 FD        	BNE	LAB_167A		; if following byte exit to do syntax error
000D71  1               
000D71  1  A4 8C        	LDY	Cpntrh		; get continue pointer high byte
000D73  1  D0 05        	BNE	LAB_166C		; go do continue if we can
000D75  1               
000D75  1  A2 1E        	LDX	#$1E			; error code $1E ("Can't continue" error)
000D77  1  4C 27 09     	JMP	LAB_XERR		; do error #X, then warm start
000D7A  1               
000D7A  1               					; we can continue so ..
000D7A  1               LAB_166C
000D7A  1  A9 93        	LDA	#TK_ON		; set token for ON
000D7C  1  20 00 27     	JSR	LAB_IRQ		; set IRQ flags
000D7F  1  A9 93        	LDA	#TK_ON		; set token for ON
000D81  1  20 03 27     	JSR	LAB_NMI		; set NMI flags
000D84  1               
000D84  1  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
000D86  1  A5 8B        	LDA	Cpntrl		; get continue pointer low byte
000D88  1  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
000D8A  1  A5 89        	LDA	Blinel		; get break line low byte
000D8C  1  A4 8A        	LDY	Blineh		; get break line high byte
000D8E  1  85 87        	STA	Clinel		; set current line low byte
000D90  1  84 88        	STY	Clineh		; set current line high byte
000D92  1  60           	RTS
000D93  1               
000D93  1               ; perform RUN
000D93  1               
000D93  1               LAB_RUN
000D93  1  D0 03        	BNE	LAB_1696		; branch if RUN n
000D95  1  4C 4E 0B     	JMP	LAB_1477		; reset execution to start, clear variables, flush stack and
000D98  1               					; return
000D98  1               
000D98  1               ; does RUN n
000D98  1               
000D98  1               LAB_1696
000D98  1  20 5B 0B     	JSR	LAB_147A		; go do "CLEAR"
000D9B  1  F0 2E        	BEQ	LAB_16B0		; get n and do GOTO n (branch always as CLEAR sets Z=1)
000D9D  1               
000D9D  1               ; perform DO
000D9D  1               
000D9D  1               LAB_DO
000D9D  1  A9 05        	LDA	#$05			; need 5 bytes for DO
000D9F  1  20 EE 08     	JSR	LAB_1212		; check room on stack for A bytes
000DA2  1  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
000DA4  1  48           	PHA				; push on stack
000DA5  1  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
000DA7  1  48           	PHA				; push on stack
000DA8  1  A5 88        	LDA	Clineh		; get current line high byte
000DAA  1  48           	PHA				; push on stack
000DAB  1  A5 87        	LDA	Clinel		; get current line low byte
000DAD  1  48           	PHA				; push on stack
000DAE  1  A9 9D        	LDA	#TK_DO		; token for DO
000DB0  1  48           	PHA				; push on stack
000DB1  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
000DB4  1  4C A5 0C     	JMP	LAB_15C2		; go do interpreter inner loop
000DB7  1               
000DB7  1               ; perform GOSUB
000DB7  1               
000DB7  1               LAB_GOSUB
000DB7  1  A9 05        	LDA	#$05			; need 5 bytes for GOSUB
000DB9  1  20 EE 08     	JSR	LAB_1212		; check room on stack for A bytes
000DBC  1  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
000DBE  1  48           	PHA				; push on stack
000DBF  1  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
000DC1  1  48           	PHA				; push on stack
000DC2  1  A5 88        	LDA	Clineh		; get current line high byte
000DC4  1  48           	PHA				; push on stack
000DC5  1  A5 87        	LDA	Clinel		; get current line low byte
000DC7  1  48           	PHA				; push on stack
000DC8  1  A9 8D        	LDA	#TK_GOSUB		; token for GOSUB
000DCA  1  48           	PHA				; push on stack
000DCB  1               LAB_16B0
000DCB  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
000DCE  1  20 D4 0D     	JSR	LAB_GOTO		; perform GOTO n
000DD1  1  4C A5 0C     	JMP	LAB_15C2		; go do interpreter inner loop
000DD4  1               					; (can't RTS, we used the stack!)
000DD4  1               
000DD4  1               ; perform GOTO
000DD4  1               
000DD4  1               LAB_GOTO
000DD4  1  20 3E 0F     	JSR	LAB_GFPN		; get fixed-point number into temp integer
000DD7  1  20 89 0E     	JSR	LAB_SNBL		; scan for next BASIC line
000DDA  1  A5 88        	LDA	Clineh		; get current line high byte
000DDC  1  C5 12        	CMP	Itemph		; compare with temporary integer high byte
000DDE  1  B0 0B        	BCS	LAB_16D0		; branch if >= (start search from beginning)
000DE0  1               
000DE0  1  98           	TYA				; else copy line index to A
000DE1  1  38           	SEC				; set carry (+1)
000DE2  1  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
000DE4  1  A6 C4        	LDX	Bpntrh		; get BASIC execute pointer high byte
000DE6  1  90 07        	BCC	LAB_16D4		; branch if no overflow to high byte
000DE8  1               
000DE8  1  E8           	INX				; increment high byte
000DE9  1  B0 04        	BCS	LAB_16D4		; branch always (can never be carry)
000DEB  1               
000DEB  1               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
000DEB  1               
000DEB  1               LAB_16D0
000DEB  1  A5 79        	LDA	Smeml			; get start of mem low byte
000DED  1  A6 7A        	LDX	Smemh			; get start of mem high byte
000DEF  1               
000DEF  1               ; search for line # in temp (Itempl/Itemph) from (AX)
000DEF  1               
000DEF  1               LAB_16D4
000DEF  1  20 11 0B     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
000DF2  1  90 67        	BCC	LAB_16F7		; if carry clear go do "Undefined statement" error
000DF4  1               					; (unspecified statement)
000DF4  1               
000DF4  1               					; carry already set for subtract
000DF4  1  A5 AA        	LDA	Baslnl		; get pointer low byte
000DF6  1  E9 01        	SBC	#$01			; -1
000DF8  1  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
000DFA  1  A5 AB        	LDA	Baslnh		; get pointer high byte
000DFC  1  E9 00        	SBC	#$00			; subtract carry
000DFE  1  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
000E00  1               LAB_16E5
000E00  1  60           	RTS
000E01  1               
000E01  1               LAB_DONOK
000E01  1  A2 22        	LDX	#$22			; error code $22 ("LOOP without DO" error)
000E03  1  4C 27 09     	JMP	LAB_XERR		; do error #X, then warm start
000E06  1               
000E06  1               ; perform LOOP
000E06  1               
000E06  1               LAB_LOOP
000E06  1  A8           	TAY				; save following token
000E07  1  BA           	TSX				; copy stack pointer
000E08  1  BD 03 01     	LDA	LAB_STAK+3,X	; get token byte from stack
000E0B  1  C9 9D        	CMP	#TK_DO		; compare with DO token
000E0D  1  D0 F2        	BNE	LAB_DONOK		; branch if no matching DO
000E0F  1               
000E0F  1  E8           	INX				; dump calling routine return address
000E10  1  E8           	INX				; dump calling routine return address
000E11  1  9A           	TXS				; correct stack
000E12  1  98           	TYA				; get saved following token back
000E13  1  F0 20        	BEQ	LoopAlways		; if no following token loop forever
000E15  1               					; (stack pointer in X)
000E15  1               
000E15  1  C9 3A        	CMP	#':'			; could be ':'
000E17  1  F0 1C        	BEQ	LoopAlways		; if :... loop forever
000E19  1               
000E19  1  E9 B4        	SBC	#TK_UNTIL		; subtract token for UNTIL, we know carry is set here
000E1B  1  AA           	TAX				; copy to X (if it was UNTIL then Y will be correct)
000E1C  1  F0 04        	BEQ	DoRest		; branch if was UNTIL
000E1E  1               
000E1E  1  CA           	DEX				; decrement result
000E1F  1  D0 62        	BNE	LAB_16FC		; if not WHILE go do syntax error and warm start
000E21  1               					; only if the token was WHILE will this fail
000E21  1               
000E21  1  CA           	DEX				; set invert result byte
000E22  1               DoRest
000E22  1  86 98        	STX	Frnxth		; save invert result byte
000E24  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
000E27  1  20 CA 12     	JSR	LAB_EVEX		; evaluate expression
000E2A  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
000E2C  1  F0 02        	BEQ	DoCmp			; if =0 go do straight compare
000E2E  1               
000E2E  1  A9 FF        	LDA	#$FF			; else set all bits
000E30  1               DoCmp
000E30  1  BA           	TSX				; copy stack pointer
000E31  1  45 98        	EOR	Frnxth		; EOR with invert byte
000E33  1  D0 1A        	BNE	LoopDone		; if <> 0 clear stack and back to interpreter loop
000E35  1               
000E35  1               					; loop condition wasn't met so do it again
000E35  1               LoopAlways
000E35  1  BD 02 01     	LDA	LAB_STAK+2,X	; get current line low byte
000E38  1  85 87        	STA	Clinel		; save current line low byte
000E3A  1  BD 03 01     	LDA	LAB_STAK+3,X	; get current line high byte
000E3D  1  85 88        	STA	Clineh		; save current line high byte
000E3F  1  BD 04 01     	LDA	LAB_STAK+4,X	; get BASIC execute pointer low byte
000E42  1  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
000E44  1  BD 05 01     	LDA	LAB_STAK+5,X	; get BASIC execute pointer high byte
000E47  1  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
000E49  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
000E4C  1  4C A5 0C     	JMP	LAB_15C2		; go do interpreter inner loop
000E4F  1               
000E4F  1               					; clear stack and back to interpreter loop
000E4F  1               LoopDone
000E4F  1  E8           	INX				; dump DO token
000E50  1  E8           	INX				; dump current line low byte
000E51  1  E8           	INX				; dump current line high byte
000E52  1  E8           	INX				; dump BASIC execute pointer low byte
000E53  1  E8           	INX				; dump BASIC execute pointer high byte
000E54  1  9A           	TXS				; correct stack
000E55  1  4C 75 0E     	JMP	LAB_DATA		; go perform DATA (find : or [EOL])
000E58  1               
000E58  1               ; do the return without gosub error
000E58  1               
000E58  1               LAB_16F4
000E58  1  A2 04        	LDX	#$04			; error code $04 ("RETURN without GOSUB" error)
000E5A  1  2C           	.byte	$2C			; makes next line BIT LAB_0EA2
000E5B  1               
000E5B  1               LAB_16F7				; do undefined statement error
000E5B  1  A2 0E        	LDX	#$0E			; error code $0E ("Undefined statement" error)
000E5D  1  4C 27 09     	JMP	LAB_XERR		; do error #X, then warm start
000E60  1               
000E60  1               ; perform RETURN
000E60  1               
000E60  1               LAB_RETURN
000E60  1  D0 9E        	BNE	LAB_16E5		; exit if following token (to allow syntax error)
000E62  1               
000E62  1               LAB_16E8
000E62  1  68           	PLA				; dump calling routine return address
000E63  1  68           	PLA				; dump calling routine return address
000E64  1  68           	PLA				; pull token
000E65  1  C9 8D        	CMP	#TK_GOSUB		; compare with GOSUB token
000E67  1  D0 EF        	BNE	LAB_16F4		; branch if no matching GOSUB
000E69  1               
000E69  1               LAB_16FF
000E69  1  68           	PLA				; pull current line low byte
000E6A  1  85 87        	STA	Clinel		; save current line low byte
000E6C  1  68           	PLA				; pull current line high byte
000E6D  1  85 88        	STA	Clineh		; save current line high byte
000E6F  1  68           	PLA				; pull BASIC execute pointer low byte
000E70  1  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
000E72  1  68           	PLA				; pull BASIC execute pointer high byte
000E73  1  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
000E75  1               
000E75  1               					; now do the DATA statement as we could be returning into
000E75  1               					; the middle of an ON <var> GOSUB n,m,p,q line
000E75  1               					; (the return address used by the DATA statement is the one
000E75  1               					; pushed before the GOSUB was executed!)
000E75  1               
000E75  1               ; perform DATA
000E75  1               
000E75  1               LAB_DATA
000E75  1  20 86 0E     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
000E78  1               
000E78  1               					; set BASIC execute pointer
000E78  1               LAB_170F
000E78  1  98           	TYA				; copy index to A
000E79  1  18           	CLC				; clear carry for add
000E7A  1  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
000E7C  1  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
000E7E  1  90 02        	BCC	LAB_1719		; skip next if no carry
000E80  1               
000E80  1  E6 C4        	INC	Bpntrh		; else increment BASIC execute pointer high byte
000E82  1               LAB_1719
000E82  1  60           	RTS
000E83  1               
000E83  1               LAB_16FC
000E83  1  4C EB 13     	JMP	LAB_SNER		; do syntax error then warm start
000E86  1               
000E86  1               ; scan for next BASIC statement ([:] or [EOL])
000E86  1               ; returns Y as index to [:] or [EOL]
000E86  1               
000E86  1               LAB_SNBS
000E86  1  A2 3A        	LDX	#':'			; set look for character = ":"
000E88  1  2C           	.byte	$2C			; makes next line BIT $00A2
000E89  1               
000E89  1               ; scan for next BASIC line
000E89  1               ; returns Y as index to [EOL]
000E89  1               
000E89  1               LAB_SNBL
000E89  1  A2 00        	LDX	#$00			; set alt search character = [EOL]
000E8B  1  A0 00        	LDY	#$00			; set search character = [EOL]
000E8D  1  84 5C        	STY	Asrch			; store search character
000E8F  1               LAB_1725
000E8F  1  8A           	TXA				; get alt search character
000E90  1  45 5C        	EOR	Asrch			; toggle search character, effectively swap with $00
000E92  1  85 5C        	STA	Asrch			; save swapped search character
000E94  1               LAB_172D
000E94  1  B1 C3        	LDA	(Bpntrl),Y		; get next byte
000E96  1  F0 EA        	BEQ	LAB_1719		; exit if null [EOL]
000E98  1               
000E98  1  C5 5C        	CMP	Asrch			; compare with search character
000E9A  1  F0 E6        	BEQ	LAB_1719		; exit if found
000E9C  1               
000E9C  1  C8           	INY				; increment index
000E9D  1  C9 22        	CMP	#$22			; compare current character with open quote
000E9F  1  D0 F3        	BNE	LAB_172D		; if not open quote go get next character
000EA1  1               
000EA1  1  F0 EC        	BEQ	LAB_1725		; if found go swap search character for alt search character
000EA3  1               
000EA3  1               ; perform IF
000EA3  1               
000EA3  1               LAB_IF
000EA3  1  20 CA 12     	JSR	LAB_EVEX		; evaluate the expression
000EA6  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
000EA9  1  C9 B1        	CMP	#TK_THEN		; compare with THEN token
000EAB  1  F0 11        	BEQ	LAB_174B		; if it was THEN go do IF
000EAD  1               
000EAD  1               					; wasn't IF .. THEN so must be IF .. GOTO
000EAD  1  C9 89        	CMP	#TK_GOTO		; compare with GOTO token
000EAF  1  D0 D2        	BNE	LAB_16FC		; if it wasn't GOTO go do syntax error
000EB1  1               
000EB1  1  A6 C3        	LDX	Bpntrl		; save the basic pointer low byte
000EB3  1  A4 C4        	LDY	Bpntrh		; save the basic pointer high byte
000EB5  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
000EB8  1  B0 C9        	BCS	LAB_16FC		; if not numeric go do syntax error
000EBA  1               
000EBA  1  86 C3        	STX	Bpntrl		; restore the basic pointer low byte
000EBC  1  84 C4        	STY	Bpntrh		; restore the basic pointer high byte
000EBE  1               LAB_174B
000EBE  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
000EC0  1  F0 1B        	BEQ	LAB_174E		; if the result was zero go look for an ELSE
000EC2  1               
000EC2  1  20 BC 00     	JSR	LAB_IGBY		; else increment and scan memory
000EC5  1  B0 03        	BCS	LAB_174D		; if not numeric go do var or keyword
000EC7  1               
000EC7  1               LAB_174C
000EC7  1  4C D4 0D     	JMP	LAB_GOTO		; else was numeric so do GOTO n
000ECA  1               
000ECA  1               					; is var or keyword
000ECA  1               LAB_174D
000ECA  1  C9 90        	CMP	#TK_RETURN		; compare the byte with the token for RETURN
000ECC  1  D0 03        	BNE	LAB_174G		; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
000ECE  1               					; and return to this code to process any following code
000ECE  1               
000ECE  1  4C E7 0C     	JMP	LAB_1602		; else it was RETURN so interpret BASIC code from (Bpntrl)
000ED1  1               					; but don't return here
000ED1  1               
000ED1  1               LAB_174G
000ED1  1  20 E5 0C     	JSR	LAB_15FF		; interpret BASIC code from (Bpntrl)
000ED4  1               
000ED4  1               ; the IF was executed and there may be a following ELSE so the code needs to return
000ED4  1               ; here to check and ignore the ELSE if present
000ED4  1               
000ED4  1  A0 00        	LDY	#$00			; clear the index
000ED6  1  B1 C3        	LDA	(Bpntrl),Y		; get the next BASIC byte
000ED8  1  C9 AD        	CMP	#TK_ELSE		; compare it with the token for ELSE
000EDA  1  F0 99        	BEQ	LAB_DATA		; if ELSE ignore the following statement
000EDC  1               
000EDC  1               ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
000EDC  1               ; following ELSE will, correctly, cause a syntax error
000EDC  1               
000EDC  1  60           	RTS				; else return to the interpreter inner loop
000EDD  1               
000EDD  1               ; perform ELSE after IF
000EDD  1               
000EDD  1               LAB_174E
000EDD  1  A0 00        	LDY	#$00			; clear the BASIC byte index
000EDF  1  A2 01        	LDX	#$01			; clear the nesting depth
000EE1  1               LAB_1750
000EE1  1  C8           	INY				; increment the BASIC byte index
000EE2  1  B1 C3        	LDA	(Bpntrl),Y		; get the next BASIC byte
000EE4  1  F0 0F        	BEQ	LAB_1753		; if EOL go add the pointer and return
000EE6  1               
000EE6  1  C9 8B        	CMP	#TK_IF		; compare the byte with the token for IF
000EE8  1  D0 03        	BNE	LAB_1752		; if not IF token skip the depth increment
000EEA  1               
000EEA  1  E8           	INX				; else increment the nesting depth ..
000EEB  1  D0 F4        	BNE	LAB_1750		; .. and continue looking
000EED  1               
000EED  1               LAB_1752
000EED  1  C9 AD        	CMP	#TK_ELSE		; compare the byte with the token for ELSE
000EEF  1  D0 F0        	BNE	LAB_1750		; if not ELSE token continue looking
000EF1  1               
000EF1  1  CA           	DEX				; was ELSE so decrement the nesting depth
000EF2  1  D0 ED        	BNE	LAB_1750		; loop if still nested
000EF4  1               
000EF4  1  C8           	INY				; increment the BASIC byte index past the ELSE
000EF5  1               
000EF5  1               ; found the matching ELSE, now do <{n|statement}>
000EF5  1               
000EF5  1               LAB_1753
000EF5  1  98           	TYA				; else copy line index to A
000EF6  1  18           	CLC				; clear carry for add
000EF7  1  65 C3        	ADC	Bpntrl		; add the BASIC execute pointer low byte
000EF9  1  85 C3        	STA	Bpntrl		; save the BASIC execute pointer low byte
000EFB  1  90 02        	BCC	LAB_1754		; branch if no overflow to high byte
000EFD  1               
000EFD  1  E6 C4        	INC	Bpntrh		; else increment the BASIC execute pointer high byte
000EFF  1               LAB_1754
000EFF  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
000F02  1  90 C3        	BCC	LAB_174C		; if numeric do GOTO n
000F04  1               					; the code will return to the interpreter loop at the
000F04  1               					; tail end of the GOTO <n>
000F04  1               
000F04  1  4C E5 0C     	JMP	LAB_15FF		; interpret BASIC code from (Bpntrl)
000F07  1               					; the code will return to the interpreter loop at the
000F07  1               					; tail end of the <statement>
000F07  1               
000F07  1               ; perform REM, skip (rest of) line
000F07  1               
000F07  1               LAB_REM
000F07  1  20 89 0E     	JSR	LAB_SNBL		; scan for next BASIC line
000F0A  1  4C 78 0E     	JMP	LAB_170F		; go set BASIC execute pointer and return, branch always
000F0D  1               
000F0D  1               LAB_16FD
000F0D  1  4C EB 13     	JMP	LAB_SNER		; do syntax error then warm start
000F10  1               
000F10  1               ; perform ON
000F10  1               
000F10  1               LAB_ON
000F10  1  C9 A9        	CMP	#TK_IRQ		; was it IRQ token ?
000F12  1  D0 03        	BNE	LAB_NOIN		; if not go check NMI
000F14  1               
000F14  1  4C 24 27     	JMP	LAB_SIRQ		; else go set-up IRQ
000F17  1               
000F17  1               LAB_NOIN
000F17  1  C9 AA        	CMP	#TK_NMI		; was it NMI token ?
000F19  1  D0 03        	BNE	LAB_NONM		; if not go do normal ON command
000F1B  1               
000F1B  1  4C 28 27     	JMP	LAB_SNMI		; else go set-up NMI
000F1E  1               
000F1E  1               LAB_NONM
000F1E  1  20 75 1C     	JSR	LAB_GTBY		; get byte parameter
000F21  1  48           	PHA				; push GOTO/GOSUB token
000F22  1  C9 8D        	CMP	#TK_GOSUB		; compare with GOSUB token
000F24  1  F0 04        	BEQ	LAB_176B		; branch if GOSUB
000F26  1               
000F26  1  C9 89        	CMP	#TK_GOTO		; compare with GOTO token
000F28  1               LAB_1767
000F28  1  D0 E3        	BNE	LAB_16FD		; if not GOTO do syntax error then warm start
000F2A  1               
000F2A  1               
000F2A  1               ; next character was GOTO or GOSUB
000F2A  1               
000F2A  1               LAB_176B
000F2A  1  C6 AF        	DEC	FAC1_3		; decrement index (byte value)
000F2C  1  D0 04        	BNE	LAB_1773		; branch if not zero
000F2E  1               
000F2E  1  68           	PLA				; pull GOTO/GOSUB token
000F2F  1  4C E7 0C     	JMP	LAB_1602		; go execute it
000F32  1               
000F32  1               LAB_1773
000F32  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
000F35  1  20 3E 0F     	JSR	LAB_GFPN		; get fixed-point number into temp integer (skip this n)
000F38  1               					; (we could LDX #',' and JSR LAB_SNBL+2, then we
000F38  1               					; just BNE LAB_176B for the loop. should be quicker ..
000F38  1               					; no we can't, what if we meet a colon or [EOL]?)
000F38  1  C9 2C        	CMP	#$2C			; compare next character with ","
000F3A  1  F0 EE        	BEQ	LAB_176B		; loop if ","
000F3C  1               
000F3C  1               LAB_177E
000F3C  1  68           	PLA				; else pull keyword token (run out of options)
000F3D  1               					; also dump +/-1 pointer low byte and exit
000F3D  1               LAB_177F
000F3D  1  60           	RTS
000F3E  1               
000F3E  1               ; takes n * 106 + 11 cycles where n is the number of digits
000F3E  1               
000F3E  1               ; get fixed-point number into temp integer
000F3E  1               
000F3E  1               LAB_GFPN
000F3E  1  A2 00        	LDX	#$00			; clear reg
000F40  1  86 11        	STX	Itempl		; clear temporary integer low byte
000F42  1               LAB_1785
000F42  1  86 12        	STX	Itemph		; save temporary integer high byte
000F44  1  B0 F7        	BCS	LAB_177F		; return if carry set, end of scan, character was
000F46  1               					; not 0-9
000F46  1               
000F46  1  E0 19        	CPX	#$19			; compare high byte with $19
000F48  1  A8           	TAY				; ensure Zb = 0 if the branch is taken
000F49  1  B0 DD        	BCS	LAB_1767		; branch if >=, makes max line # 63999 because next
000F4B  1               					; bit does *$0A, = 64000, compare at target will fail
000F4B  1               					; and do syntax error
000F4B  1               
000F4B  1  E9 2F        	SBC	#'0'-1		; subtract "0", $2F + carry, from byte
000F4D  1  A8           	TAY				; copy binary digit
000F4E  1  A5 11        	LDA	Itempl		; get temporary integer low byte
000F50  1  0A           	ASL	A			; *2 low byte
000F51  1  26 12        	ROL	Itemph		; *2 high byte
000F53  1  0A           	ASL	A		; *2 low byte
000F54  1  26 12        	ROL	Itemph		; *2 high byte, *4
000F56  1  65 11        	ADC	Itempl		; + low byte, *5
000F58  1  85 11        	STA	Itempl		; save it
000F5A  1  8A           	TXA				; get high byte copy to A
000F5B  1  65 12        	ADC	Itemph		; + high byte, *5
000F5D  1  06 11        	ASL	Itempl		; *2 low byte, *10d
000F5F  1  2A           	ROL	A			; *2 high byte, *10d
000F60  1  AA           	TAX				; copy high byte back to X
000F61  1  98           	TYA				; get binary digit back
000F62  1  65 11        	ADC	Itempl		; add number low byte
000F64  1  85 11        	STA	Itempl		; save number low byte
000F66  1  90 01        	BCC	LAB_17B3		; if no overflow to high byte get next character
000F68  1               
000F68  1  E8           	INX				; else increment high byte
000F69  1               LAB_17B3
000F69  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
000F6C  1  4C 42 0F     	JMP	LAB_1785		; loop for next character
000F6F  1               
000F6F  1               ; perform DEC
000F6F  1               
000F6F  1               LAB_DEC
000F6F  1  A9 C4        	LDA	#LAB_2AFD_LO		; set -1 pointer low byte
000F71  1  2C           	.byte	$2C			; BIT abs to skip the LDA below
000F72  1               
000F72  1               ; perform INC
000F72  1               
000F72  1               LAB_INC
000F72  1  A9 C0        	LDA	#LAB_259C_LO		; set 1 pointer low byte
000F74  1               LAB_17B5
000F74  1  48           	PHA				; save +/-1 pointer low byte
000F75  1               LAB_17B7
000F75  1  20 93 15     	JSR	LAB_GVAR		; get var address
000F78  1  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
000F7A  1  30 1E        	BMI	IncrErr		; exit if string
000F7C  1               
000F7C  1  85 97        	STA	Lvarpl		; save var address low byte
000F7E  1  84 98        	STY	Lvarph		; save var address high byte
000F80  1  20 66 20     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
000F83  1  68           	PLA				; get +/-1 pointer low byte
000F84  1  48           	PHA				; save +/-1 pointer low byte
000F85  1  A0 29        	LDY	#LAB_259C_HI		; set +/-1 pointer high byte (both the same)
000F87  1  20 A7 1D     	JSR	LAB_246C		; add (AY) to FAC1
000F8A  1  20 8C 20     	JSR	LAB_PFAC		; pack FAC1 into variable (Lvarpl)
000F8D  1               
000F8D  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
000F90  1  C9 2C        	CMP	#','			; compare with ","
000F92  1  D0 A8        	BNE	LAB_177E		; exit if not "," (either end or error)
000F94  1               
000F94  1               					; was "," so another INCR variable to do
000F94  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
000F97  1  4C 75 0F     	JMP	LAB_17B7		; go do next var
000F9A  1               
000F9A  1               IncrErr
000F9A  1  4C C5 12     	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
000F9D  1               
000F9D  1               ; perform LET
000F9D  1               
000F9D  1               LAB_LET
000F9D  1  20 93 15     	JSR	LAB_GVAR		; get var address
000FA0  1  85 97        	STA	Lvarpl		; save var address low byte
000FA2  1  84 98        	STY	Lvarph		; save var address high byte
000FA4  1  A9 C2        	LDA	#TK_EQUAL		; get = token
000FA6  1  20 DA 13     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
000FA9  1  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
000FAB  1  48           	PHA				; push data type flag
000FAC  1  20 CA 12     	JSR	LAB_EVEX		; evaluate expression
000FAF  1  68           	PLA				; pop data type flag
000FB0  1  2A           	ROL	A			; set carry if type = string
000FB1  1  20 BC 12     	JSR	LAB_CKTM		; type match check, set C for string
000FB4  1  D0 03        	BNE	LAB_17D5		; branch if string
000FB6  1               
000FB6  1  4C 8C 20     	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
000FB9  1               
000FB9  1               ; string LET
000FB9  1               
000FB9  1               LAB_17D5
000FB9  1  A0 02        	LDY	#$02			; set index to pointer high byte
000FBB  1  B1 AE        	LDA	(des_pl),Y		; get string pointer high byte
000FBD  1  C5 82        	CMP	Sstorh		; compare bottom of string space high byte
000FBF  1  90 17        	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
000FC1  1               
000FC1  1  D0 07        	BNE	LAB_17E6		; branch if >
000FC3  1               					; else was equal so compare low bytes
000FC3  1  88           	DEY				; decrement index
000FC4  1  B1 AE        	LDA	(des_pl),Y		; get pointer low byte
000FC6  1  C5 81        	CMP	Sstorl		; compare bottom of string space low byte
000FC8  1  90 0E        	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
000FCA  1               
000FCA  1               					; pointer was >= to bottom of string space pointer
000FCA  1               LAB_17E6
000FCA  1  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
000FCC  1  C4 7C        	CPY	Svarh			; compare start of vars high byte
000FCE  1  90 08        	BCC	LAB_17F4		; branch if less (descriptor is on stack)
000FD0  1               
000FD0  1  D0 0D        	BNE	LAB_17FB		; branch if greater (descriptor is not on stack)
000FD2  1               
000FD2  1               					; else high bytes were equal so ..
000FD2  1  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
000FD4  1  C5 7B        	CMP	Svarl			; compare start of vars low byte
000FD6  1  B0 07        	BCS	LAB_17FB		; branch if >= (descriptor is not on stack)
000FD8  1               
000FD8  1               LAB_17F4
000FD8  1  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
000FDA  1  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
000FDC  1  4C F5 0F     	JMP	LAB_1811		; clean stack, copy descriptor to variable and return
000FDF  1               
000FDF  1               					; make space and copy string
000FDF  1               LAB_17FB
000FDF  1  A0 00        	LDY	#$00			; index to length
000FE1  1  B1 AE        	LDA	(des_pl),Y		; get string length
000FE3  1  20 1B 19     	JSR	LAB_209C		; copy string
000FE6  1  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
000FE8  1  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
000FEA  1  85 B8        	STA	ssptr_l		; save descriptor pointer low byte
000FEC  1  84 B9        	STY	ssptr_h		; save descriptor pointer high byte
000FEE  1  20 FA 1A     	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
000FF1  1  A9 AC        	LDA	#FAC1_e_LO		; set descriptor pointer low byte
000FF3  1  A0 00        	LDY	#FAC1_e_HI		; get descriptor pointer high byte
000FF5  1               
000FF5  1               					; clean stack and assign value to string variable
000FF5  1               LAB_1811
000FF5  1  85 9E        	STA	des_2l		; save descriptor_2 pointer low byte
000FF7  1  84 9F        	STY	des_2h		; save descriptor_2 pointer high byte
000FF9  1  20 5C 1B     	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
000FFC  1  A0 00        	LDY	#$00			; index to length
000FFE  1  B1 9E        	LDA	(des_2l),Y		; get string length
001000  1  91 97        	STA	(Lvarpl),Y		; copy to let string variable
001002  1  C8           	INY				; index to string pointer low byte
001003  1  B1 9E        	LDA	(des_2l),Y		; get string pointer low byte
001005  1  91 97        	STA	(Lvarpl),Y		; copy to let string variable
001007  1  C8           	INY				; index to string pointer high byte
001008  1  B1 9E        	LDA	(des_2l),Y		; get string pointer high byte
00100A  1  91 97        	STA	(Lvarpl),Y		; copy to let string variable
00100C  1  60           	RTS
00100D  1               
00100D  1               ; perform GET
00100D  1               
00100D  1               LAB_GET
00100D  1  20 93 15     	JSR	LAB_GVAR		; get var address
001010  1  85 97        	STA	Lvarpl		; save var address low byte
001012  1  84 98        	STY	Lvarph		; save var address high byte
001014  1  20 EC 26     	JSR	INGET			; get input byte
001017  1  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
001019  1  30 07        	BMI	LAB_GETS		; go get string character
00101B  1               
00101B  1               					; was numeric get
00101B  1  A8           	TAY				; copy character to Y
00101C  1  20 4F 18     	JSR	LAB_1FD0		; convert Y to byte in FAC1
00101F  1  4C 8C 20     	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
001022  1               
001022  1               LAB_GETS
001022  1  48           	PHA				; save character
001023  1  A9 01        	LDA	#$01			; string is single byte
001025  1  B0 01        	BCS	LAB_IsByte		; branch if byte received
001027  1               
001027  1  68           	PLA				; string is null
001028  1               LAB_IsByte
001028  1  20 23 19     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
00102B  1               					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00102B  1  F0 05        	BEQ	LAB_NoSt		; skip store if null string
00102D  1               
00102D  1  68           	PLA				; get character back
00102E  1  A0 00        	LDY	#$00			; clear index
001030  1  91 AD        	STA	(str_pl),Y		; save byte in string (byte IS string!)
001032  1               LAB_NoSt
001032  1  20 6E 19     	JSR	LAB_RTST		; check for space on descriptor stack then put address
001035  1               					; and length on descriptor stack and update stack pointers
001035  1               
001035  1  4C B9 0F     	JMP	LAB_17D5		; do string LET and return
001038  1               
001038  1               ; perform PRINT
001038  1               
001038  1               LAB_1829
001038  1  20 BF 10     	JSR	LAB_18C6		; print string from Sutill/Sutilh
00103B  1               LAB_182C
00103B  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
00103E  1               
00103E  1               ; PRINT
00103E  1               
00103E  1               LAB_PRINT
00103E  1  F0 3B        	BEQ	LAB_CRLF		; if nothing following just print CR/LF
001040  1               
001040  1               LAB_1831
001040  1  C9 AC        	CMP	#TK_TAB		; compare with TAB( token
001042  1  F0 56        	BEQ	LAB_18A2		; go do TAB/SPC
001044  1               
001044  1  C9 B0        	CMP	#TK_SPC		; compare with SPC( token
001046  1  F0 52        	BEQ	LAB_18A2		; go do TAB/SPC
001048  1               
001048  1  C9 2C        	CMP	#','			; compare with ","
00104A  1  F0 38        	BEQ	LAB_188B		; go do move to next TAB mark
00104C  1               
00104C  1  C9 3B        	CMP	#$3B			; compare with ";"
00104E  1  F0 66        	BEQ	LAB_18BD		; if ";" continue with PRINT processing
001050  1               
001050  1  20 CA 12     	JSR	LAB_EVEX		; evaluate expression
001053  1  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
001055  1  30 E1        	BMI	LAB_1829		; branch if string
001057  1               
001057  1  20 81 22     	JSR	LAB_296E		; convert FAC1 to string
00105A  1  20 2D 19     	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
00105D  1  A0 00        	LDY	#$00			; clear index
00105F  1               
00105F  1               ; don't check fit if terminal width byte is zero
00105F  1               
00105F  1  A5 0F        	LDA	TWidth		; get terminal width byte
001061  1  F0 0A        	BEQ	LAB_185E		; skip check if zero
001063  1               
001063  1  38           	SEC				; set carry for subtract
001064  1  E5 0E        	SBC	TPos			; subtract terminal position
001066  1  F1 AE        	SBC	(des_pl),Y		; subtract string length
001068  1  B0 03        	BCS	LAB_185E		; branch if less than terminal width
00106A  1               
00106A  1  20 7B 10     	JSR	LAB_CRLF		; else print CR/LF
00106D  1               LAB_185E
00106D  1  20 BF 10     	JSR	LAB_18C6		; print string from Sutill/Sutilh
001070  1  F0 C9        	BEQ	LAB_182C		; always go continue processing line
001072  1               
001072  1               ; CR/LF return to BASIC from BASIC input handler
001072  1               
001072  1               LAB_1866
001072  1  A9 00        	LDA	#$00			; clear byte
001074  1  9D 81 33     	STA	Ibuffs,X		; null terminate input
001077  1  A2 81        	LDX	#Ibuffs_LO		; set X to buffer start-1 low byte
001079  1  A0 33        	LDY	#Ibuffs_HI		; set Y to buffer start-1 high byte
00107B  1               
00107B  1               ; print CR/LF
00107B  1               
00107B  1               LAB_CRLF
00107B  1  A9 0D        	LDA	#$0D			; load [CR]
00107D  1  20 D6 10     	JSR	LAB_PRNA		; go print the character
001080  1  A9 0A        	LDA	#$0A			; load [LF]
001082  1  D0 52        	BNE	LAB_PRNA		; go print the character and return, branch always
001084  1               
001084  1               LAB_188B
001084  1  A5 0E        	LDA	TPos			; get terminal position
001086  1  C5 10        	CMP	Iclim			; compare with input column limit
001088  1  90 05        	BCC	LAB_1897		; branch if less
00108A  1               
00108A  1  20 7B 10     	JSR	LAB_CRLF		; else print CR/LF (next line)
00108D  1  D0 27        	BNE	LAB_18BD		; continue with PRINT processing (branch always)
00108F  1               
00108F  1               LAB_1897
00108F  1  38           	SEC				; set carry for subtract
001090  1               LAB_1898
001090  1  E5 64        	SBC	TabSiz		; subtract TAB size
001092  1  B0 FC        	BCS	LAB_1898		; loop if result was +ve
001094  1               
001094  1  49 FF        	EOR	#$FF			; complement it
001096  1  69 01        	ADC	#$01			; +1 (twos complement)
001098  1  D0 12        	BNE	LAB_18B6		; always print A spaces (result is never $00)
00109A  1               
00109A  1               					; do TAB/SPC
00109A  1               LAB_18A2
00109A  1  48           	PHA				; save token
00109B  1  20 72 1C     	JSR	LAB_SGBY		; scan and get byte parameter
00109E  1  C9 29        	CMP	#$29			; is next character )
0010A0  1  D0 7B        	BNE	LAB_1910		; if not do syntax error then warm start
0010A2  1               
0010A2  1  68           	PLA				; get token back
0010A3  1  C9 AC        	CMP	#TK_TAB		; was it TAB ?
0010A5  1  D0 06        	BNE	LAB_18B7		; if not go do SPC
0010A7  1               
0010A7  1               					; calculate TAB offset
0010A7  1  8A           	TXA				; copy integer value to A
0010A8  1  E5 0E        	SBC	TPos			; subtract terminal position
0010AA  1  90 0A        	BCC	LAB_18BD		; branch if result was < 0 (can't TAB backwards)
0010AC  1               
0010AC  1               					; print A spaces
0010AC  1               LAB_18B6
0010AC  1  AA           	TAX				; copy result to X
0010AD  1               LAB_18B7
0010AD  1  8A           	TXA				; set flags on size for SPC
0010AE  1  F0 06        	BEQ	LAB_18BD		; branch if result was = $0, already here
0010B0  1               
0010B0  1               					; print X spaces
0010B0  1               LAB_18BA
0010B0  1  20 D1 10     	JSR	LAB_18E0		; print " "
0010B3  1  CA           	DEX				; decrement count
0010B4  1  D0 FA        	BNE	LAB_18BA		; loop if not all done
0010B6  1               
0010B6  1               					; continue with PRINT processing
0010B6  1               LAB_18BD
0010B6  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0010B9  1  D0 85        	BNE	LAB_1831		; if more to print go do it
0010BB  1               
0010BB  1  60           	RTS
0010BC  1               
0010BC  1               ; print null terminated string from memory
0010BC  1               
0010BC  1               LAB_18C3
0010BC  1  20 2D 19     	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
0010BF  1               
0010BF  1               ; print string from Sutill/Sutilh
0010BF  1               
0010BF  1               LAB_18C6
0010BF  1  20 27 1B     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
0010C2  1               					; space returns with A = length, X=$71=pointer low byte,
0010C2  1               					; Y=$72=pointer high byte
0010C2  1  A0 00        	LDY	#$00			; reset index
0010C4  1  AA           	TAX				; copy length to X
0010C5  1  F0 49        	BEQ	LAB_188C		; exit (RTS) if null string
0010C7  1               
0010C7  1               LAB_18CD
0010C7  1               
0010C7  1  B1 71        	LDA	(ut1_pl),Y		; get next byte
0010C9  1  20 D6 10     	JSR	LAB_PRNA		; go print the character
0010CC  1  C8           	INY				; increment index
0010CD  1  CA           	DEX				; decrement count
0010CE  1  D0 F7        	BNE	LAB_18CD		; loop if not done yet
0010D0  1               
0010D0  1  60           	RTS
0010D1  1               
0010D1  1               					; Print single format character
0010D1  1               ; print " "
0010D1  1               
0010D1  1               LAB_18E0
0010D1  1  A9 20        	LDA	#$20			; load " "
0010D3  1  2C           	.byte	$2C			; change next line to BIT LAB_3FA9
0010D4  1               
0010D4  1               ; print "?" character
0010D4  1               
0010D4  1               LAB_18E3
0010D4  1  A9 3F        	LDA	#$3F			; load "?" character
0010D6  1               
0010D6  1               ; print character in A
0010D6  1               ; now includes the null handler
0010D6  1               ; also includes infinite line length code
0010D6  1               ; note! some routines expect this one to exit with Zb=0
0010D6  1               
0010D6  1               LAB_PRNA
0010D6  1  C9 20        	CMP	#' '			; compare with " "
0010D8  1  90 19        	BCC	LAB_18F9		; branch if less (non printing)
0010DA  1               
0010DA  1               					; else printable character
0010DA  1  48           	PHA				; save the character
0010DB  1               
0010DB  1               ; don't check fit if terminal width byte is zero
0010DB  1               
0010DB  1  A5 0F        	LDA	TWidth		; get terminal width
0010DD  1  D0 0A        	BNE	LAB_18F0		; branch if not zero (not infinite length)
0010DF  1               
0010DF  1               ; is "infinite line" so check TAB position
0010DF  1               
0010DF  1  A5 0E        	LDA	TPos			; get position
0010E1  1  E5 64        	SBC	TabSiz		; subtract TAB size, carry set by CMP #$20 above
0010E3  1  D0 0B        	BNE	LAB_18F7		; skip reset if different
0010E5  1               
0010E5  1  85 0E        	STA	TPos			; else reset position
0010E7  1  F0 07        	BEQ	LAB_18F7		; go print character
0010E9  1               
0010E9  1               LAB_18F0
0010E9  1  C5 0E        	CMP	TPos			; compare with terminal character position
0010EB  1  D0 03        	BNE	LAB_18F7		; branch if not at end of line
0010ED  1               
0010ED  1  20 7B 10     	JSR	LAB_CRLF		; else print CR/LF
0010F0  1               LAB_18F7
0010F0  1  E6 0E        	INC	TPos			; increment terminal position
0010F2  1  68           	PLA				; get character back
0010F3  1               LAB_18F9
0010F3  1  20 36 30     	JSR	V_OUTP		; output byte via output vector
0010F6  1  C9 0D        	CMP	#$0D			; compare with [CR]
0010F8  1  D0 14        	BNE	LAB_188A		; branch if not [CR]
0010FA  1               
0010FA  1               					; else print nullct nulls after the [CR]
0010FA  1  86 78        	STX	TempB			; save buffer index
0010FC  1  A6 0D        	LDX	Nullct		; get null count
0010FE  1  F0 0A        	BEQ	LAB_1886		; branch if no nulls
001100  1               
001100  1  A9 00        	LDA	#$00			; load [NULL]
001102  1               LAB_1880
001102  1  20 D6 10     	JSR	LAB_PRNA		; go print the character
001105  1  CA           	DEX				; decrement count
001106  1  D0 FA        	BNE	LAB_1880		; loop if not all done
001108  1               
001108  1  A9 0D        	LDA	#$0D			; restore the character (and set the flags)
00110A  1               LAB_1886
00110A  1  86 0E        	STX	TPos			; clear terminal position (X always = zero when we get here)
00110C  1  A6 78        	LDX	TempB			; restore buffer index
00110E  1               LAB_188A
00110E  1  29 FF        	AND	#$FF			; set the flags
001110  1               LAB_188C
001110  1  60           	RTS
001111  1               
001111  1               ; handle bad input data
001111  1               
001111  1               LAB_1904
001111  1  A5 62        	LDA	Imode			; get input mode flag, $00=INPUT, $00=READ
001113  1  10 0B        	BPL	LAB_1913		; branch if INPUT (go do redo)
001115  1               
001115  1  A5 8D        	LDA	Dlinel		; get current DATA line low byte
001117  1  A4 8E        	LDY	Dlineh		; get current DATA line high byte
001119  1  85 87        	STA	Clinel		; save current line low byte
00111B  1  84 88        	STY	Clineh		; save current line high byte
00111D  1               LAB_1910
00111D  1  4C EB 13     	JMP	LAB_SNER		; do syntax error then warm start
001120  1               
001120  1               					; mode was INPUT
001120  1               LAB_1913
001120  1  A9 FF        	LDA	#LAB_REDO_LO		; point to redo message (low addr)
001122  1  A0 2F        	LDY	#LAB_REDO_HI		; point to redo message (high addr)
001124  1  20 BC 10     	JSR	LAB_18C3		; print null terminated string from memory
001127  1  A5 8B        	LDA	Cpntrl		; get continue pointer low byte
001129  1  A4 8C        	LDY	Cpntrh		; get continue pointer high byte
00112B  1  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00112D  1  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
00112F  1  60           	RTS
001130  1               
001130  1               ; perform INPUT
001130  1               
001130  1               LAB_INPUT
001130  1  C9 22        	CMP	#$22			; compare next byte with open quote
001132  1  D0 0B        	BNE	LAB_1934		; branch if no prompt string
001134  1               
001134  1  20 A7 13     	JSR	LAB_1BC1		; print "..." string
001137  1  A9 3B        	LDA	#$3B			; load A with ";"
001139  1  20 DA 13     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
00113C  1  20 BF 10     	JSR	LAB_18C6		; print string from Sutill/Sutilh
00113F  1               
00113F  1               					; done with prompt, now get data
00113F  1               LAB_1934
00113F  1  20 53 18     	JSR	LAB_CKRN		; check not Direct, back here if ok
001142  1  20 2B 0A     	JSR	LAB_INLN		; print "? " and get BASIC input
001145  1  A9 00        	LDA	#$00			; set mode = INPUT
001147  1  CD 81 33     	CMP	Ibuffs		; test first byte in buffer
00114A  1  D0 0A        	BNE	LAB_1953		; branch if not null input
00114C  1               
00114C  1  18           	CLC				; was null input so clear carry to exit program
00114D  1  4C 15 0D     	JMP	LAB_1647		; go do BREAK exit
001150  1               
001150  1               ; perform READ
001150  1               
001150  1               LAB_READ
001150  1  A6 8F        	LDX	Dptrl			; get DATA pointer low byte
001152  1  A4 90        	LDY	Dptrh			; get DATA pointer high byte
001154  1  A9 80        	LDA	#$80			; set mode = READ
001156  1               
001156  1               LAB_1953
001156  1  85 62        	STA	Imode			; set input mode flag, $00=INPUT, $80=READ
001158  1  86 91        	STX	Rdptrl		; save READ pointer low byte
00115A  1  84 92        	STY	Rdptrh		; save READ pointer high byte
00115C  1               
00115C  1               					; READ or INPUT next variable from list
00115C  1               LAB_195B
00115C  1  20 93 15     	JSR	LAB_GVAR		; get (var) address
00115F  1  85 97        	STA	Lvarpl		; save address low byte
001161  1  84 98        	STY	Lvarph		; save address high byte
001163  1  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
001165  1  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
001167  1  85 11        	STA	Itempl		; save as temporary integer low byte
001169  1  84 12        	STY	Itemph		; save as temporary integer high byte
00116B  1  A6 91        	LDX	Rdptrl		; get READ pointer low byte
00116D  1  A4 92        	LDY	Rdptrh		; get READ pointer high byte
00116F  1  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
001171  1  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
001173  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
001176  1  D0 11        	BNE	LAB_1988		; branch if not null
001178  1               
001178  1               					; pointer was to null entry
001178  1  24 62        	BIT	Imode			; test input mode flag, $00=INPUT, $80=READ
00117A  1  30 65        	BMI	LAB_19DD		; branch if READ
00117C  1               
00117C  1               					; mode was INPUT
00117C  1  20 D4 10     	JSR	LAB_18E3		; print "?" character (double ? for extended input)
00117F  1  20 2B 0A     	JSR	LAB_INLN		; print "? " and get BASIC input
001182  1  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
001184  1  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
001186  1               LAB_1985
001186  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
001189  1               LAB_1988
001189  1  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
00118B  1  10 24        	BPL	LAB_19B0		; branch if numeric
00118D  1               
00118D  1               					; else get string
00118D  1  85 5B        	STA	Srchc			; save search character
00118F  1  C9 22        	CMP	#$22			; was it " ?
001191  1  F0 07        	BEQ	LAB_1999		; branch if so
001193  1               
001193  1  A9 3A        	LDA	#':'			; else search character is ":"
001195  1  85 5B        	STA	Srchc			; set new search character
001197  1  A9 2C        	LDA	#','			; other search character is ","
001199  1  18           	CLC				; clear carry for add
00119A  1               LAB_1999
00119A  1  85 5C        	STA	Asrch			; set second search character
00119C  1  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00119E  1  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
0011A0  1               
0011A0  1  69 00        	ADC	#$00			; c is =1 if we came via the BEQ LAB_1999, else =0
0011A2  1  90 01        	BCC	LAB_19A4		; branch if no execute pointer low byte rollover
0011A4  1               
0011A4  1  C8           	INY				; else increment high byte
0011A5  1               LAB_19A4
0011A5  1  20 33 19     	JSR	LAB_20B4		; print Srchc or Asrch terminated string to Sutill/Sutilh
0011A8  1  20 B8 1C     	JSR	LAB_23F3		; restore BASIC execute pointer from temp (Btmpl/Btmph)
0011AB  1  20 B9 0F     	JSR	LAB_17D5		; go do string LET
0011AE  1  4C B7 11     	JMP	LAB_19B6		; go check string terminator
0011B1  1               
0011B1  1               					; get numeric INPUT
0011B1  1               LAB_19B0
0011B1  1  20 8F 21     	JSR	LAB_2887		; get FAC1 from string
0011B4  1  20 8C 20     	JSR	LAB_PFAC		; pack FAC1 into (Lvarpl)
0011B7  1               LAB_19B6
0011B7  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
0011BA  1  F0 0A        	BEQ	LAB_19C5		; branch if null (last entry)
0011BC  1               
0011BC  1  C9 2C        	CMP	#','			; else compare with ","
0011BE  1  F0 03        	BEQ	LAB_19C2		; branch if ","
0011C0  1               
0011C0  1  4C 11 11     	JMP	LAB_1904		; else go handle bad input data
0011C3  1               
0011C3  1               					; got good input data
0011C3  1               LAB_19C2
0011C3  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0011C6  1               LAB_19C5
0011C6  1  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte (temp READ/INPUT ptr)
0011C8  1  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte (temp READ/INPUT ptr)
0011CA  1  85 91        	STA	Rdptrl		; save for now
0011CC  1  84 92        	STY	Rdptrh		; save for now
0011CE  1  A5 11        	LDA	Itempl		; get temporary integer low byte (temp BASIC execute ptr)
0011D0  1  A4 12        	LDY	Itemph		; get temporary integer high byte (temp BASIC execute ptr)
0011D2  1  85 C3        	STA	Bpntrl		; set BASIC execute pointer low byte
0011D4  1  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
0011D6  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
0011D9  1  F0 2C        	BEQ	LAB_1A03		; if null go do extra ignored message
0011DB  1               
0011DB  1  20 E7 13     	JSR	LAB_1C01		; else scan for "," , else do syntax error then warm start
0011DE  1  4C 5C 11     	JMP	LAB_195B		; go INPUT next variable from list
0011E1  1               
0011E1  1               					; find next DATA statement or do "Out of DATA" error
0011E1  1               LAB_19DD
0011E1  1  20 86 0E     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
0011E4  1  C8           	INY				; increment index
0011E5  1  AA           	TAX				; copy character ([:] or [EOL])
0011E6  1  D0 12        	BNE	LAB_19F6		; branch if [:]
0011E8  1               
0011E8  1  A2 06        	LDX	#$06			; set for "Out of DATA" error
0011EA  1  C8           	INY				; increment index, now points to next line pointer high byte
0011EB  1  B1 C3        	LDA	(Bpntrl),Y		; get next line pointer high byte
0011ED  1  F0 73        	BEQ	LAB_1A54		; branch if end (eventually does error X)
0011EF  1               
0011EF  1  C8           	INY				; increment index
0011F0  1  B1 C3        	LDA	(Bpntrl),Y		; get next line # low byte
0011F2  1  85 8D        	STA	Dlinel		; save current DATA line low byte
0011F4  1  C8           	INY				; increment index
0011F5  1  B1 C3        	LDA	(Bpntrl),Y		; get next line # high byte
0011F7  1  C8           	INY				; increment index
0011F8  1  85 8E        	STA	Dlineh		; save current DATA line high byte
0011FA  1               LAB_19F6
0011FA  1  B1 C3        	LDA	(Bpntrl),Y		; get byte
0011FC  1  C8           	INY				; increment index
0011FD  1  AA           	TAX				; copy to X
0011FE  1  20 78 0E     	JSR	LAB_170F		; set BASIC execute pointer
001201  1  E0 83        	CPX	#TK_DATA		; compare with "DATA" token
001203  1  F0 81        	BEQ	LAB_1985		; was "DATA" so go do next READ
001205  1               
001205  1  D0 DA        	BNE	LAB_19DD		; go find next statement if not "DATA"
001207  1               
001207  1               ; end of INPUT/READ routine
001207  1               
001207  1               LAB_1A03
001207  1  A5 91        	LDA	Rdptrl		; get temp READ pointer low byte
001209  1  A4 92        	LDY	Rdptrh		; get temp READ pointer high byte
00120B  1  A6 62        	LDX	Imode			; get input mode flag, $00=INPUT, $80=READ
00120D  1  10 03        	BPL	LAB_1A0E		; branch if INPUT
00120F  1               
00120F  1  4C 37 0D     	JMP	LAB_1624		; save AY as DATA pointer and return
001212  1               
001212  1               					; we were getting INPUT
001212  1               LAB_1A0E
001212  1  A0 00        	LDY	#$00			; clear index
001214  1  B1 91        	LDA	(Rdptrl),Y		; get next byte
001216  1  D0 01        	BNE	LAB_1A1B		; error if not end of INPUT
001218  1               
001218  1  60           	RTS
001219  1               
001219  1               					; user typed too much
001219  1               LAB_1A1B
001219  1  A9 EE        	LDA	#LAB_IMSG_LO		; point to extra ignored message (low addr)
00121B  1  A0 2F        	LDY	#LAB_IMSG_HI		; point to extra ignored message (high addr)
00121D  1  4C BC 10     	JMP	LAB_18C3		; print null terminated string from memory and return
001220  1               
001220  1               ; search the stack for FOR activity
001220  1               ; exit with z=1 if FOR else exit with z=0
001220  1               
001220  1               LAB_11A1
001220  1  BA           	TSX				; copy stack pointer
001221  1  E8           	INX				; +1 pass return address
001222  1  E8           	INX				; +2 pass return address
001223  1  E8           	INX				; +3 pass calling routine return address
001224  1  E8           	INX				; +4 pass calling routine return address
001225  1               LAB_11A6
001225  1  BD 01 01     	LDA	LAB_STAK+1,X	; get token byte from stack
001228  1  C9 81        	CMP	#TK_FOR		; is it FOR token
00122A  1  D0 21        	BNE	LAB_11CE		; exit if not FOR token
00122C  1               
00122C  1               					; was FOR token
00122C  1  A5 98        	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
00122E  1  D0 0A        	BNE	LAB_11BB		; branch if not null
001230  1               
001230  1  BD 02 01     	LDA	LAB_STAK+2,X	; get FOR variable pointer low byte
001233  1  85 97        	STA	Frnxtl		; save var pointer for FOR/NEXT low byte
001235  1  BD 03 01     	LDA	LAB_STAK+3,X	; get FOR variable pointer high byte
001238  1  85 98        	STA	Frnxth		; save var pointer for FOR/NEXT high byte
00123A  1               LAB_11BB
00123A  1  DD 03 01     	CMP	LAB_STAK+3,X	; compare var pointer with stacked var pointer (high byte)
00123D  1  D0 07        	BNE	LAB_11C7		; branch if no match
00123F  1               
00123F  1  A5 97        	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
001241  1  DD 02 01     	CMP	LAB_STAK+2,X	; compare var pointer with stacked var pointer (low byte)
001244  1  F0 07        	BEQ	LAB_11CE		; exit if match found
001246  1               
001246  1               LAB_11C7
001246  1  8A           	TXA				; copy index
001247  1  18           	CLC				; clear carry for add
001248  1  69 10        	ADC	#$10			; add FOR stack use size
00124A  1  AA           	TAX				; copy back to index
00124B  1  D0 D8        	BNE	LAB_11A6		; loop if not at start of stack
00124D  1               
00124D  1               LAB_11CE
00124D  1  60           	RTS
00124E  1               
00124E  1               ; perform NEXT
00124E  1               
00124E  1               LAB_NEXT
00124E  1  D0 04        	BNE	LAB_1A46		; branch if NEXT var
001250  1               
001250  1  A0 00        	LDY	#$00			; else clear Y
001252  1  F0 03        	BEQ	LAB_1A49		; branch always (no variable to search for)
001254  1               
001254  1               ; NEXT var
001254  1               
001254  1               LAB_1A46
001254  1  20 93 15     	JSR	LAB_GVAR		; get variable address
001257  1               LAB_1A49
001257  1  85 97        	STA	Frnxtl		; store variable pointer low byte
001259  1  84 98        	STY	Frnxth		; store variable pointer high byte
00125B  1               					; (both cleared if no variable defined)
00125B  1  20 20 12     	JSR	LAB_11A1		; search the stack for FOR activity
00125E  1  F0 04        	BEQ	LAB_1A56		; branch if found
001260  1               
001260  1  A2 00        	LDX	#$00			; else set error $00 ("NEXT without FOR" error)
001262  1               LAB_1A54
001262  1  F0 63        	BEQ	LAB_1ABE		; do error #X, then warm start
001264  1               
001264  1               LAB_1A56
001264  1  9A           	TXS				; set stack pointer, X set by search, dumps return addresses
001265  1               
001265  1  8A           	TXA				; copy stack pointer
001266  1  38           	SEC				; set carry for subtract
001267  1  E9 F7        	SBC	#$F7			; point to TO var
001269  1  85 73        	STA	ut2_pl		; save pointer to TO var for compare
00126B  1  69 FB        	ADC	#$FB			; point to STEP var
00126D  1               
00126D  1  A0 01        	LDY	#LAB_STAK_HI		; point to stack page high byte
00126F  1  20 66 20     	JSR	LAB_UFAC		; unpack memory (STEP value) into FAC1
001272  1  BA           	TSX				; get stack pointer back
001273  1  BD 08 01     	LDA	LAB_STAK+8,X	; get step sign
001276  1  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
001278  1  A5 97        	LDA	Frnxtl		; get FOR variable pointer low byte
00127A  1  A4 98        	LDY	Frnxth		; get FOR variable pointer high byte
00127C  1  20 A7 1D     	JSR	LAB_246C		; add (FOR variable) to FAC1
00127F  1  20 8C 20     	JSR	LAB_PFAC		; pack FAC1 into (FOR variable)
001282  1  A0 01        	LDY	#LAB_STAK_HI		; point to stack page high byte
001284  1  20 02 21     	JSR	LAB_27FA		; compare FAC1 with (Y,ut2_pl) (TO value)
001287  1  BA           	TSX				; get stack pointer back
001288  1  DD 08 01     	CMP	LAB_STAK+8,X	; compare step sign
00128B  1  F0 17        	BEQ	LAB_1A9B		; branch if = (loop complete)
00128D  1               
00128D  1               					; loop back and do it all again
00128D  1  BD 0D 01     	LDA	LAB_STAK+$0D,X	; get FOR line low byte
001290  1  85 87        	STA	Clinel		; save current line low byte
001292  1  BD 0E 01     	LDA	LAB_STAK+$0E,X	; get FOR line high byte
001295  1  85 88        	STA	Clineh		; save current line high byte
001297  1  BD 10 01     	LDA	LAB_STAK+$10,X	; get BASIC execute pointer low byte
00129A  1  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00129C  1  BD 0F 01     	LDA	LAB_STAK+$0F,X	; get BASIC execute pointer high byte
00129F  1  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
0012A1  1               LAB_1A98
0012A1  1  4C A5 0C     	JMP	LAB_15C2		; go do interpreter inner loop
0012A4  1               
0012A4  1               					; loop complete so carry on
0012A4  1               LAB_1A9B
0012A4  1  8A           	TXA				; stack copy to A
0012A5  1  69 0F        	ADC	#$0F			; add $10 ($0F+carry) to dump FOR structure
0012A7  1  AA           	TAX				; copy back to index
0012A8  1  9A           	TXS				; copy to stack pointer
0012A9  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
0012AC  1  C9 2C        	CMP	#','			; compare with ","
0012AE  1  D0 F1        	BNE	LAB_1A98		; branch if not "," (go do interpreter inner loop)
0012B0  1               
0012B0  1               					; was "," so another NEXT variable to do
0012B0  1  20 BC 00     	JSR	LAB_IGBY		; else increment and scan memory
0012B3  1  20 54 12     	JSR	LAB_1A46		; do NEXT (var)
0012B6  1               
0012B6  1               ; evaluate expression and check is numeric, else do type mismatch
0012B6  1               
0012B6  1               LAB_EVNM
0012B6  1  20 CA 12     	JSR	LAB_EVEX		; evaluate expression
0012B9  1               
0012B9  1               ; check if source is numeric, else do type mismatch
0012B9  1               
0012B9  1               LAB_CTNM
0012B9  1  18           	CLC				; destination is numeric
0012BA  1  24           	.byte	$24			; makes next line BIT $38
0012BB  1               
0012BB  1               ; check if source is string, else do type mismatch
0012BB  1               
0012BB  1               LAB_CTST
0012BB  1  38           	SEC				; required type is string
0012BC  1               
0012BC  1               ; type match check, set C for string, clear C for numeric
0012BC  1               
0012BC  1               LAB_CKTM
0012BC  1  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
0012BE  1  30 03        	BMI	LAB_1ABA		; branch if data type is string
0012C0  1               
0012C0  1               					; else data type was numeric
0012C0  1  B0 03        	BCS	LAB_1ABC		; if required type is string do type mismatch error
0012C2  1               LAB_1AB9
0012C2  1  60           	RTS
0012C3  1               
0012C3  1               					; data type was string, now check required type
0012C3  1               LAB_1ABA
0012C3  1  B0 FD        	BCS	LAB_1AB9		; exit if required type is string
0012C5  1               
0012C5  1               					; else do type mismatch error
0012C5  1               LAB_1ABC
0012C5  1  A2 18        	LDX	#$18			; error code $18 ("Type mismatch" error)
0012C7  1               LAB_1ABE
0012C7  1  4C 27 09     	JMP	LAB_XERR		; do error #X, then warm start
0012CA  1               
0012CA  1               ; evaluate expression
0012CA  1               
0012CA  1               LAB_EVEX
0012CA  1  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
0012CC  1  D0 02        	BNE	LAB_1AC7		; skip next if not zero
0012CE  1               
0012CE  1  C6 C4        	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
0012D0  1               LAB_1AC7
0012D0  1  C6 C3        	DEC	Bpntrl		; decrement BASIC execute pointer low byte
0012D2  1               
0012D2  1               LAB_EVEZ
0012D2  1  A9 00        	LDA	#$00			; set null precedence (flag done)
0012D4  1               LAB_1ACC
0012D4  1  48           	PHA				; push precedence byte
0012D5  1  A9 02        	LDA	#$02			; 2 bytes
0012D7  1  20 EE 08     	JSR	LAB_1212		; check room on stack for A bytes
0012DA  1  20 B6 13     	JSR	LAB_GVAL		; get value from line
0012DD  1  A9 00        	LDA	#$00			; clear A
0012DF  1  85 9B        	STA	comp_f		; clear compare function flag
0012E1  1               LAB_1ADB
0012E1  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
0012E4  1               LAB_1ADE
0012E4  1  38           	SEC				; set carry for subtract
0012E5  1  E9 C1        	SBC	#TK_GT		; subtract token for > (lowest comparison function)
0012E7  1  90 17        	BCC	LAB_1AFA		; branch if < TK_GT
0012E9  1               
0012E9  1  C9 03        	CMP	#$03			; compare with ">" to "<" tokens
0012EB  1  B0 13        	BCS	LAB_1AFA		; branch if >= TK_SGN (highest evaluation function +1)
0012ED  1               
0012ED  1               					; was token for > = or < (A = 0, 1 or 2)
0012ED  1  C9 01        	CMP	#$01			; compare with token for =
0012EF  1  2A           	ROL	A			; *2, b0 = carry (=1 if token was = or <)
0012F0  1               					; (A = 0, 3 or 5)
0012F0  1  49 01        	EOR	#$01			; toggle b0
0012F2  1               					; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
0012F2  1  45 9B        	EOR	comp_f		; EOR with compare function flag bits
0012F4  1  C5 9B        	CMP	comp_f		; compare with compare function flag
0012F6  1  90 67        	BCC	LAB_1B53		; if <(comp_f) do syntax error then warm start
0012F8  1               					; was more than one <, = or >)
0012F8  1               
0012F8  1  85 9B        	STA	comp_f		; save new compare function flag
0012FA  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0012FD  1  4C E4 12     	JMP	LAB_1ADE		; go do next character
001300  1               
001300  1               					; token is < ">" or > "<" tokens
001300  1               LAB_1AFA
001300  1  A6 9B        	LDX	comp_f		; get compare function flag
001302  1  D0 2C        	BNE	LAB_1B2A		; branch if compare function
001304  1               
001304  1  B0 79        	BCS	LAB_1B78		; go do functions
001306  1               
001306  1               					; else was <  TK_GT so is operator or lower
001306  1  69 0A        	ADC	#TK_GT-TK_PLUS	; add # of operators (+, -, *, /, ^, AND, OR or EOR)
001308  1  90 75        	BCC	LAB_1B78		; branch if < + operator
00130A  1               
00130A  1               					; carry was set so token was +, -, *, /, ^, AND, OR or EOR
00130A  1  D0 07        	BNE	LAB_1B0B		; branch if not + token
00130C  1               
00130C  1  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
00130E  1  10 03        	BPL	LAB_1B0B		; branch if not string
001310  1               
001310  1               					; will only be $00 if type is string and token was +
001310  1  4C BD 1A     	JMP	LAB_224D		; add strings, string 1 is in descriptor des_pl, string 2
001313  1               					; is in line, and return
001313  1               
001313  1               LAB_1B0B
001313  1  85 71        	STA	ut1_pl		; save it
001315  1  0A           	ASL	A		; *2
001316  1  65 71        	ADC	ut1_pl		; *3
001318  1  A8           	TAY				; copy to index
001319  1               LAB_1B13
001319  1  68           	PLA				; pull previous precedence
00131A  1  D9 CB 2A     	CMP	LAB_OPPT,Y		; compare with precedence byte
00131D  1  B0 65        	BCS	LAB_1B7D		; branch if A >=
00131F  1               
00131F  1  20 B9 12     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
001322  1               LAB_1B1C
001322  1  48           	PHA				; save precedence
001323  1               LAB_1B1D
001323  1  20 4B 13     	JSR	LAB_1B43		; get vector, execute function then continue evaluation
001326  1  68           	PLA				; restore precedence
001327  1  A4 99        	LDY	prstk			; get precedence stacked flag
001329  1  10 19        	BPL	LAB_1B3C		; branch if stacked values
00132B  1               
00132B  1  AA           	TAX				; copy precedence (set flags)
00132C  1  F0 76        	BEQ	LAB_1B9D		; exit if done
00132E  1               
00132E  1  D0 5D        	BNE	LAB_1B86		; else pop FAC2 and return, branch always
001330  1               
001330  1               LAB_1B2A
001330  1  26 5F        	ROL	Dtypef		; shift data type flag into Cb
001332  1  8A           	TXA				; copy compare function flag
001333  1  85 5F        	STA	Dtypef		; clear data type flag, X is 0xxx xxxx
001335  1  2A           	ROL	A			; shift data type into compare function byte b0
001336  1  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
001338  1  D0 02        	BNE	LAB_1B34		; branch if no underflow
00133A  1               
00133A  1  C6 C4        	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
00133C  1               LAB_1B34
00133C  1  C6 C3        	DEC	Bpntrl		; decrement BASIC execute pointer low byte
00133E  1               TK_LT_PLUS	= TK_LT-TK_PLUS
00133E  1  A0 24        	LDY	#TK_LT_PLUS*3	; set offset to last operator entry
001340  1  85 9B        	STA	comp_f		; save new compare function flag
001342  1  D0 D5        	BNE	LAB_1B13		; branch always
001344  1               
001344  1               LAB_1B3C
001344  1  D9 CB 2A     	CMP	LAB_OPPT,Y		;.compare with stacked function precedence
001347  1  B0 44        	BCS	LAB_1B86		; branch if A >=, pop FAC2 and return
001349  1               
001349  1  90 D7        	BCC	LAB_1B1C		; branch always
00134B  1               
00134B  1               ;.get vector, execute function then continue evaluation
00134B  1               
00134B  1               LAB_1B43
00134B  1  B9 CD 2A     	LDA	LAB_OPPT+2,Y	; get function vector high byte
00134E  1  48           	PHA				; onto stack
00134F  1  B9 CC 2A     	LDA	LAB_OPPT+1,Y	; get function vector low byte
001352  1  48           	PHA				; onto stack
001353  1               					; now push sign, round FAC1 and put on stack
001353  1  20 62 13     	JSR	LAB_1B5B		; function will return here, then the next RTS will call
001356  1               					; the function
001356  1  A5 9B        	LDA	comp_f		; get compare function flag
001358  1  48           	PHA				; push compare evaluation byte
001359  1  B9 CB 2A     	LDA	LAB_OPPT,Y		; get precedence byte
00135C  1  4C D4 12     	JMP	LAB_1ACC		; continue evaluating expression
00135F  1               
00135F  1               LAB_1B53
00135F  1  4C EB 13     	JMP	LAB_SNER		; do syntax error then warm start
001362  1               
001362  1               ; push sign, round FAC1 and put on stack
001362  1               
001362  1               LAB_1B5B
001362  1  68           	PLA				; get return addr low byte
001363  1  85 71        	STA	ut1_pl		; save it
001365  1  E6 71        	INC	ut1_pl		; increment it (was ret-1 pushed? yes!)
001367  1               					; note! no check is made on the high byte! if the calling
001367  1               					; routine assembles to a page edge then this all goes
001367  1               					; horribly wrong !!!
001367  1  68           	PLA				; get return addr high byte
001368  1  85 72        	STA	ut1_ph		; save it
00136A  1  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00136C  1  48           	PHA				; push sign
00136D  1               
00136D  1               ; round FAC1 and put on stack
00136D  1               
00136D  1               LAB_1B66
00136D  1  20 C2 20     	JSR	LAB_27BA		; round FAC1
001370  1  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
001372  1  48           	PHA				; push on stack
001373  1  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
001375  1  48           	PHA				; push on stack
001376  1  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
001378  1  48           	PHA				; push on stack
001379  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00137B  1  48           	PHA				; push on stack
00137C  1  6C 71 00     	JMP	(ut1_pl)		; return, sort of
00137F  1               
00137F  1               ; do functions
00137F  1               
00137F  1               LAB_1B78
00137F  1  A0 FF        	LDY	#$FF			; flag function
001381  1  68           	PLA				; pull precedence byte
001382  1               LAB_1B7B
001382  1  F0 20        	BEQ	LAB_1B9D		; exit if done
001384  1               
001384  1               LAB_1B7D
001384  1  C9 64        	CMP	#$64			; compare previous precedence with $64
001386  1  F0 03        	BEQ	LAB_1B84		; branch if was $64 (< function)
001388  1               
001388  1  20 B9 12     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
00138B  1               LAB_1B84
00138B  1  84 99        	STY	prstk			; save precedence stacked flag
00138D  1               
00138D  1               					; pop FAC2 and return
00138D  1               LAB_1B86
00138D  1  68           	PLA				; pop byte
00138E  1  4A           	LSR	A				; shift out comparison evaluation lowest bit
00138F  1  85 63        	STA	Cflag			; save comparison evaluation flag
001391  1  68           	PLA				; pop exponent
001392  1  85 B3        	STA	FAC2_e		; save FAC2 exponent
001394  1  68           	PLA				; pop mantissa1
001395  1  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
001397  1  68           	PLA				; pop mantissa2
001398  1  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
00139A  1  68           	PLA				; pop mantissa3
00139B  1  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
00139D  1  68           	PLA				; pop sign
00139E  1  85 B7        	STA	FAC2_s		; save FAC2 sign (b7)
0013A0  1  45 B0        	EOR	FAC1_s		; EOR FAC1 sign (b7)
0013A2  1  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
0013A4  1               LAB_1B9D
0013A4  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0013A6  1  60           	RTS
0013A7  1               
0013A7  1               ; print "..." string to string util area
0013A7  1               
0013A7  1               LAB_1BC1
0013A7  1  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
0013A9  1  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
0013AB  1  69 00        	ADC	#$00			; add carry to low byte
0013AD  1  90 01        	BCC	LAB_1BCA		; branch if no overflow
0013AF  1               
0013AF  1  C8           	INY				; increment high byte
0013B0  1               LAB_1BCA
0013B0  1  20 2D 19     	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
0013B3  1  4C B8 1C     	JMP	LAB_23F3		; restore BASIC execute pointer from temp and return
0013B6  1               
0013B6  1               ; get value from line
0013B6  1               
0013B6  1               LAB_GVAL
0013B6  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0013B9  1  B0 03        	BCS	LAB_1BAC		; branch if not numeric character
0013BB  1               
0013BB  1               					; else numeric string found (e.g. 123)
0013BB  1               LAB_1BA9
0013BB  1  4C 8F 21     	JMP	LAB_2887		; get FAC1 from string and return
0013BE  1               
0013BE  1               ; get value from line .. continued
0013BE  1               
0013BE  1               					; wasn't a number so ..
0013BE  1               LAB_1BAC
0013BE  1  AA           	TAX				; set the flags
0013BF  1  30 2F        	BMI	LAB_1BD0		; if -ve go test token values
0013C1  1               
0013C1  1               					; else it is either a string, number, variable or (<expr>)
0013C1  1  C9 24        	CMP	#'$'			; compare with "$"
0013C3  1  F0 F6        	BEQ	LAB_1BA9		; branch if "$", hex number
0013C5  1               
0013C5  1  C9 25        	CMP	#'%'			; else compare with "%"
0013C7  1  F0 F2        	BEQ	LAB_1BA9		; branch if "%", binary number
0013C9  1               
0013C9  1  C9 2E        	CMP	#'.'			; compare with "."
0013CB  1  F0 EE        	BEQ	LAB_1BA9		; if so get FAC1 from string and return (e.g. was .123)
0013CD  1               
0013CD  1               					; it wasn't any sort of number so ..
0013CD  1  C9 22        	CMP	#$22			; compare with "
0013CF  1  F0 D6        	BEQ	LAB_1BC1		; branch if open quote
0013D1  1               
0013D1  1               					; wasn't any sort of number so ..
0013D1  1               
0013D1  1               ; evaluate expression within parentheses
0013D1  1               
0013D1  1  C9 28        	CMP	#'('			; compare with "("
0013D3  1  D0 4F        	BNE	LAB_1C18		; if not "(" get (var), return value in FAC1 and $ flag
0013D5  1               
0013D5  1               LAB_1BF7
0013D5  1  20 D2 12     	JSR	LAB_EVEZ		; evaluate expression, no decrement
0013D8  1               
0013D8  1               ; all the 'scan for' routines return the character after the sought character
0013D8  1               
0013D8  1               ; scan for ")" , else do syntax error then warm start
0013D8  1               
0013D8  1               LAB_1BFB
0013D8  1  A9 29        	LDA	#$29			; load A with ")"
0013DA  1               
0013DA  1               ; scan for CHR$(A) , else do syntax error then warm start
0013DA  1               
0013DA  1               LAB_SCCA
0013DA  1  A0 00        	LDY	#$00			; clear index
0013DC  1  D1 C3        	CMP	(Bpntrl),Y		; check next byte is = A
0013DE  1  D0 0B        	BNE	LAB_SNER		; if not do syntax error then warm start
0013E0  1               
0013E0  1  4C BC 00     	JMP	LAB_IGBY		; increment and scan memory then return
0013E3  1               
0013E3  1               ; scan for "(" , else do syntax error then warm start
0013E3  1               
0013E3  1               LAB_1BFE
0013E3  1  A9 28        	LDA	#$28			; load A with "("
0013E5  1  D0 F3        	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
0013E7  1               					; (branch always)
0013E7  1               
0013E7  1               ; scan for "," , else do syntax error then warm start
0013E7  1               
0013E7  1               LAB_1C01
0013E7  1  A9 2C        	LDA	#$2C			; load A with ","
0013E9  1  D0 EF        	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
0013EB  1               					; (branch always)
0013EB  1               
0013EB  1               ; syntax error then warm start
0013EB  1               
0013EB  1               LAB_SNER
0013EB  1  A2 02        	LDX	#$02			; error code $02 ("Syntax" error)
0013ED  1  4C 27 09     	JMP	LAB_XERR		; do error #X, then warm start
0013F0  1               
0013F0  1               ; get value from line .. continued
0013F0  1               ; do tokens
0013F0  1               
0013F0  1               LAB_1BD0
0013F0  1  C9 B8        	CMP	#TK_MINUS		; compare with token for -
0013F2  1  F0 29        	BEQ	LAB_1C11		; branch if - token (do set-up for functions)
0013F4  1               
0013F4  1               					; wasn't -n so ..
0013F4  1  C9 B7        	CMP	#TK_PLUS		; compare with token for +
0013F6  1  F0 BE        	BEQ	LAB_GVAL		; branch if + token (+n = n so ignore leading +)
0013F8  1               
0013F8  1  C9 B2        	CMP	#TK_NOT		; compare with token for NOT
0013FA  1  D0 13        	BNE	LAB_1BE7		; branch if not token for NOT
0013FC  1               
0013FC  1               					; was NOT token
0013FC  1               TK_EQUAL_PLUS	= TK_EQUAL-TK_PLUS
0013FC  1  A0 21        	LDY	#TK_EQUAL_PLUS*3	; offset to NOT function
0013FE  1  D0 1F        	BNE	LAB_1C13		; do set-up for function then execute (branch always)
001400  1               
001400  1               ; do = compare
001400  1               
001400  1               LAB_EQUAL
001400  1  20 8F 16     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
001403  1  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
001405  1  49 FF        	EOR	#$FF			; invert it
001407  1  A8           	TAY				; copy it
001408  1  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00140A  1  49 FF        	EOR	#$FF			; invert it
00140C  1  4C 42 18     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
00140F  1               
00140F  1               ; get value from line .. continued
00140F  1               
00140F  1               					; wasn't +, -, or NOT so ..
00140F  1               LAB_1BE7
00140F  1  C9 AF        	CMP	#TK_FN		; compare with token for FN
001411  1  D0 03        	BNE	LAB_1BEE		; branch if not token for FN
001413  1               
001413  1  4C 9D 18     	JMP	LAB_201E		; go evaluate FNx
001416  1               
001416  1               ; get value from line .. continued
001416  1               
001416  1               					; wasn't +, -, NOT or FN so ..
001416  1               LAB_1BEE
001416  1  E9 C4        	SBC	#TK_SGN		; subtract with token for SGN
001418  1  B0 19        	BCS	LAB_1C27		; if a function token go do it
00141A  1               
00141A  1  4C EB 13     	JMP	LAB_SNER		; else do syntax error
00141D  1               
00141D  1               ; set-up for functions
00141D  1               
00141D  1               LAB_1C11
00141D  1               TK_GT_PLUS	= TK_GT-TK_PLUS
00141D  1  A0 1E        	LDY	#TK_GT_PLUS*3	; set offset from base to > operator
00141F  1               LAB_1C13
00141F  1  68           	PLA				; dump return address low byte
001420  1  68           	PLA				; dump return address high byte
001421  1  4C 23 13     	JMP	LAB_1B1D		; execute function then continue evaluation
001424  1               
001424  1               ; variable name set-up
001424  1               ; get (var), return value in FAC_1 and $ flag
001424  1               
001424  1               LAB_1C18
001424  1  20 93 15     	JSR	LAB_GVAR		; get (var) address
001427  1  85 AE        	STA	FAC1_2		; save address low byte in FAC1 mantissa2
001429  1  84 AF        	STY	FAC1_3		; save address high byte in FAC1 mantissa3
00142B  1  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
00142D  1  30 03        	BMI	LAB_1C25		; if string then return (does RTS)
00142F  1               
00142F  1               LAB_1C24
00142F  1  4C 66 20     	JMP	LAB_UFAC		; unpack memory (AY) into FAC1
001432  1               
001432  1               LAB_1C25
001432  1  60           	RTS
001433  1               
001433  1               ; get value from line .. continued
001433  1               ; only functions left so ..
001433  1               
001433  1               ; set up function references
001433  1               
001433  1               ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
001433  1               ; to process function calls. now the function vector is computed and pushed on the stack
001433  1               ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
001433  1               ; is calculated and the routine called, if not this routine just does RTS. whichever
001433  1               ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
001433  1               ; the function code
001433  1               
001433  1               ; this also removes some less than elegant code that was used to bypass type checking
001433  1               ; for functions that returned strings
001433  1               
001433  1               LAB_1C27
001433  1  0A           	ASL	A			; *2 (2 bytes per function address)
001434  1  A8           	TAY				; copy to index
001435  1               
001435  1  B9 86 2A     	LDA	LAB_FTBM,Y		; get function jump vector high byte
001438  1  48           	PHA				; push functions jump vector high byte
001439  1  B9 85 2A     	LDA	LAB_FTBL,Y		; get function jump vector low byte
00143C  1  48           	PHA				; push functions jump vector low byte
00143D  1               
00143D  1  B9 40 2A     	LDA	LAB_FTPM,Y		; get function pre process vector high byte
001440  1  F0 05        	BEQ	LAB_1C56		; skip pre process if null vector
001442  1               
001442  1  48           	PHA				; push functions pre process vector high byte
001443  1  B9 3F 2A     	LDA	LAB_FTPL,Y		; get function pre process vector low byte
001446  1  48           	PHA				; push functions pre process vector low byte
001447  1               
001447  1               LAB_1C56
001447  1  60           	RTS				; do function, or pre process, call
001448  1               
001448  1               ; process string expression in parenthesis
001448  1               
001448  1               LAB_PPFS
001448  1  20 D5 13     	JSR	LAB_1BF7		; process expression in parenthesis
00144B  1  4C BB 12     	JMP	LAB_CTST		; check if source is string then do function,
00144E  1               					; else do type mismatch
00144E  1               
00144E  1               ; process numeric expression in parenthesis
00144E  1               
00144E  1               LAB_PPFN
00144E  1  20 D5 13     	JSR	LAB_1BF7		; process expression in parenthesis
001451  1  4C B9 12     	JMP	LAB_CTNM		; check if source is numeric then do function,
001454  1               					; else do type mismatch
001454  1               
001454  1               ; set numeric data type and increment BASIC execute pointer
001454  1               
001454  1               LAB_PPBI
001454  1  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
001456  1  4C BC 00     	JMP	LAB_IGBY		; increment and scan memory then do function
001459  1               
001459  1               ; process string for LEFT$, RIGHT$ or MID$
001459  1               
001459  1               LAB_LRMS
001459  1  20 D2 12     	JSR	LAB_EVEZ		; evaluate (should be string) expression
00145C  1  20 E7 13     	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
00145F  1  20 BB 12     	JSR	LAB_CTST		; check if source is string, else do type mismatch
001462  1               
001462  1  68           	PLA				; get function jump vector low byte
001463  1  AA           	TAX				; save functions jump vector low byte
001464  1  68           	PLA				; get function jump vector high byte
001465  1  A8           	TAY				; save functions jump vector high byte
001466  1  A5 AF        	LDA	des_ph		; get descriptor pointer high byte
001468  1  48           	PHA				; push string pointer high byte
001469  1  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
00146B  1  48           	PHA				; push string pointer low byte
00146C  1  98           	TYA				; get function jump vector high byte back
00146D  1  48           	PHA				; save functions jump vector high byte
00146E  1  8A           	TXA				; get function jump vector low byte back
00146F  1  48           	PHA				; save functions jump vector low byte
001470  1  20 75 1C     	JSR	LAB_GTBY		; get byte parameter
001473  1  8A           	TXA				; copy byte parameter to A
001474  1  60           	RTS				; go do function
001475  1               
001475  1               ; process numeric expression(s) for BIN$ or HEX$
001475  1               
001475  1               LAB_BHSS
001475  1  20 D2 12     	JSR	LAB_EVEZ		; process expression
001478  1  20 B9 12     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
00147B  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00147D  1  C9 98        	CMP	#$98			; compare with exponent = 2^24
00147F  1  B0 20        	BCS	LAB_BHER		; branch if n>=2^24 (is too big)
001481  1               
001481  1  20 39 21     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
001484  1  A2 02        	LDX	#$02			; 3 bytes to do
001486  1               LAB_CFAC
001486  1  B5 AD        	LDA	FAC1_1,X		; get byte from FAC1
001488  1  95 11        	STA	nums_1,X		; save byte to temp
00148A  1  CA           	DEX				; decrement index
00148B  1  10 F9        	BPL	LAB_CFAC		; copy FAC1 mantissa to temp
00148D  1               
00148D  1  20 C2 00     	JSR	LAB_GBYT		; get next BASIC byte
001490  1  A2 00        	LDX	#$00			; set default to no leading "0"s
001492  1  C9 29        	CMP	#')'			; compare with close bracket
001494  1  F0 0A        	BEQ	LAB_1C54		; if ")" go do rest of function
001496  1               
001496  1  20 C7 1C     	JSR	LAB_SCGB		; scan for "," and get byte
001499  1  20 C2 00     	JSR	LAB_GBYT		; get last byte back
00149C  1  C9 29        	CMP	#')'			; is next character )
00149E  1  D0 01        	BNE	LAB_BHER		; if not ")" go do error
0014A0  1               
0014A0  1               LAB_1C54
0014A0  1  60           	RTS				; else do function
0014A1  1               
0014A1  1               LAB_BHER
0014A1  1  4C 12 17     	JMP	LAB_FCER		; do function call error then warm start
0014A4  1               
0014A4  1               ; perform EOR
0014A4  1               
0014A4  1               ; added operator format is the same as AND or OR, precedence is the same as OR
0014A4  1               
0014A4  1               ; this bit worked first time but it took a while to sort out the operator table
0014A4  1               ; pointers and offsets afterwards!
0014A4  1               
0014A4  1               LAB_EOR
0014A4  1  20 CB 14     	JSR	GetFirst		; get first integer expression (no sign check)
0014A7  1  45 5B        	EOR	XOAw_l		; EOR with expression 1 low byte
0014A9  1  A8           	TAY				; save in Y
0014AA  1  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
0014AC  1  45 5C        	EOR	XOAw_h		; EOR with expression 1 high byte
0014AE  1  4C 42 18     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
0014B1  1               
0014B1  1               ; perform OR
0014B1  1               
0014B1  1               LAB_OR
0014B1  1  20 CB 14     	JSR	GetFirst		; get first integer expression (no sign check)
0014B4  1  05 5B        	ORA	XOAw_l		; OR with expression 1 low byte
0014B6  1  A8           	TAY				; save in Y
0014B7  1  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
0014B9  1  05 5C        	ORA	XOAw_h		; OR with expression 1 high byte
0014BB  1  4C 42 18     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
0014BE  1               
0014BE  1               ; perform AND
0014BE  1               
0014BE  1               LAB_AND
0014BE  1  20 CB 14     	JSR	GetFirst		; get first integer expression (no sign check)
0014C1  1  25 5B        	AND	XOAw_l		; AND with expression 1 low byte
0014C3  1  A8           	TAY				; save in Y
0014C4  1  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
0014C6  1  25 5C        	AND	XOAw_h		; AND with expression 1 high byte
0014C8  1  4C 42 18     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
0014CB  1               
0014CB  1               ; get first value for OR, AND or EOR
0014CB  1               
0014CB  1               GetFirst
0014CB  1  20 8F 16     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
0014CE  1  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
0014D0  1  85 5C        	STA	XOAw_h		; save it
0014D2  1  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
0014D4  1  85 5B        	STA	XOAw_l		; save it
0014D6  1  20 AC 1D     	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
0014D9  1  20 8F 16     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
0014DC  1  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
0014DE  1               LAB_1C95
0014DE  1  60           	RTS
0014DF  1               
0014DF  1               ; perform comparisons
0014DF  1               
0014DF  1               ; do < compare
0014DF  1               
0014DF  1               LAB_LTHAN
0014DF  1  20 BC 12     	JSR	LAB_CKTM		; type match check, set C for string
0014E2  1  B0 13        	BCS	LAB_1CAE		; branch if string
0014E4  1               
0014E4  1               					; do numeric < compare
0014E4  1  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
0014E6  1  09 7F        	ORA	#$7F			; set all non sign bits
0014E8  1  25 B4        	AND	FAC2_1		; and FAC2 mantissa1 (AND in sign bit)
0014EA  1  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
0014EC  1  A9 B3        	LDA	#FAC2_e_LO		; set pointer low byte to FAC2
0014EE  1  A0 00        	LDY	#FAC2_e_HI		; set pointer high byte to FAC2
0014F0  1  20 00 21     	JSR	LAB_27F8		; compare FAC1 with FAC2 (AY)
0014F3  1  AA           	TAX				; copy result
0014F4  1  4C 28 15     	JMP	LAB_1CE1		; go evaluate result
0014F7  1               
0014F7  1               					; do string < compare
0014F7  1               LAB_1CAE
0014F7  1  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
0014F9  1  C6 9B        	DEC	comp_f		; clear < bit in compare function flag
0014FB  1  20 27 1B     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
0014FE  1               					; space returns with A = length, X=pointer low byte,
0014FE  1               					; Y=pointer high byte
0014FE  1  85 AC        	STA	str_ln		; save length
001500  1  86 AD        	STX	str_pl		; save string pointer low byte
001502  1  84 AE        	STY	str_ph		; save string pointer high byte
001504  1  A5 B5        	LDA	FAC2_2		; get descriptor pointer low byte
001506  1  A4 B6        	LDY	FAC2_3		; get descriptor pointer high byte
001508  1  20 2B 1B     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
00150B  1               					; returns with A = length, X=pointer low byte,
00150B  1               					; Y=pointer high byte
00150B  1  86 B5        	STX	FAC2_2		; save string pointer low byte
00150D  1  84 B6        	STY	FAC2_3		; save string pointer high byte
00150F  1  AA           	TAX				; copy length
001510  1  38           	SEC				; set carry for subtract
001511  1  E5 AC        	SBC	str_ln		; subtract string 1 length
001513  1  F0 08        	BEQ	LAB_1CD6		; branch if str 1 length = string 2 length
001515  1               
001515  1  A9 01        	LDA	#$01			; set str 1 length > string 2 length
001517  1  90 04        	BCC	LAB_1CD6		; branch if so
001519  1               
001519  1  A6 AC        	LDX	str_ln		; get string 1 length
00151B  1  A9 FF        	LDA	#$FF			; set str 1 length < string 2 length
00151D  1               LAB_1CD6
00151D  1  85 B0        	STA	FAC1_s		; save length compare
00151F  1  A0 FF        	LDY	#$FF			; set index
001521  1  E8           	INX				; adjust for loop
001522  1               LAB_1CDB
001522  1  C8           	INY				; increment index
001523  1  CA           	DEX				; decrement count
001524  1  D0 07        	BNE	LAB_1CE6		; branch if still bytes to do
001526  1               
001526  1  A6 B0        	LDX	FAC1_s		; get length compare back
001528  1               LAB_1CE1
001528  1  30 0F        	BMI	LAB_1CF2		; branch if str 1 < str 2
00152A  1               
00152A  1  18           	CLC				; flag str 1 <= str 2
00152B  1  90 0C        	BCC	LAB_1CF2		; go evaluate result
00152D  1               
00152D  1               LAB_1CE6
00152D  1  B1 B5        	LDA	(FAC2_2),Y		; get string 2 byte
00152F  1  D1 AD        	CMP	(FAC1_1),Y		; compare with string 1 byte
001531  1  F0 EF        	BEQ	LAB_1CDB		; loop if bytes =
001533  1               
001533  1  A2 FF        	LDX	#$FF			; set str 1 < string 2
001535  1  B0 02        	BCS	LAB_1CF2		; branch if so
001537  1               
001537  1  A2 01        	LDX	#$01			;  set str 1 > string 2
001539  1               LAB_1CF2
001539  1  E8           	INX				; x = 0, 1 or 2
00153A  1  8A           	TXA				; copy to A
00153B  1  2A           	ROL	A			; *2 (1, 2 or 4)
00153C  1  25 63        	AND	Cflag			; AND with comparison evaluation flag
00153E  1  F0 02        	BEQ	LAB_1CFB		; branch if 0 (compare is false)
001540  1               
001540  1  A9 FF        	LDA	#$FF			; else set result true
001542  1               LAB_1CFB
001542  1  4C E3 20     	JMP	LAB_27DB		; save A as integer byte and return
001545  1               
001545  1               LAB_1CFE
001545  1  20 E7 13     	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
001548  1               
001548  1               ; perform DIM
001548  1               
001548  1               LAB_DIM
001548  1  AA           	TAX				; copy "DIM" flag to X
001549  1  20 98 15     	JSR	LAB_1D10		; search for variable
00154C  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
00154F  1  D0 F4        	BNE	LAB_1CFE		; scan for "," and loop if not null
001551  1               
001551  1  60           	RTS
001552  1               
001552  1               ; perform << (left shift)
001552  1               
001552  1               LAB_LSHIFT
001552  1  20 88 15     	JSR	GetPair		; get integer expression and byte (no sign check)
001555  1  A5 AE        	LDA	FAC1_2		; get expression high byte
001557  1  A6 78        	LDX	TempB			; get shift count
001559  1  F0 22        	BEQ	NoShift		; branch if zero
00155B  1               
00155B  1  E0 10        	CPX	#$10			; compare bit count with 16d
00155D  1  B0 23        	BCS	TooBig		; branch if >=
00155F  1               
00155F  1               Ls_loop
00155F  1  06 AF        	ASL	FAC1_3		; shift low byte
001561  1  2A           	ROL	A			; shift high byte
001562  1  CA           	DEX				; decrement bit count
001563  1  D0 FA        	BNE	Ls_loop		; loop if shift not complete
001565  1               
001565  1  A4 AF        	LDY	FAC1_3		; get expression low byte
001567  1  4C 42 18     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
00156A  1               
00156A  1               ; perform >> (right shift)
00156A  1               
00156A  1               LAB_RSHIFT
00156A  1  20 88 15     	JSR	GetPair		; get integer expression and byte (no sign check)
00156D  1  A5 AE        	LDA	FAC1_2		; get expression high byte
00156F  1  A6 78        	LDX	TempB			; get shift count
001571  1  F0 0A        	BEQ	NoShift		; branch if zero
001573  1               
001573  1  E0 10        	CPX	#$10			; compare bit count with 16d
001575  1  B0 0B        	BCS	TooBig		; branch if >=
001577  1               
001577  1               Rs_loop
001577  1  4A           	LSR	A			; shift high byte
001578  1  66 AF        	ROR	FAC1_3		; shift low byte
00157A  1  CA           	DEX				; decrement bit count
00157B  1  D0 FA        	BNE	Rs_loop		; loop if shift not complete
00157D  1               
00157D  1               NoShift
00157D  1  A4 AF        	LDY	FAC1_3		; get expression low byte
00157F  1  4C 42 18     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
001582  1               
001582  1               TooBig
001582  1  A9 00        	LDA	#$00			; clear high byte
001584  1  A8           	TAY				; copy to low byte
001585  1  4C 42 18     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
001588  1               
001588  1               GetPair
001588  1  20 78 1C     	JSR	LAB_EVBY		; evaluate byte expression, result in X
00158B  1  86 78        	STX	TempB			; save it
00158D  1  20 AC 1D     	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
001590  1  4C 8F 16     	JMP	LAB_EVIR		; evaluate integer expression (no sign check)
001593  1               
001593  1               ; search for variable
001593  1               
001593  1               ; return pointer to variable in Cvaral/Cvarah
001593  1               
001593  1               LAB_GVAR
001593  1  A2 00        	LDX	#$00			; set DIM flag = $00
001595  1  20 C2 00     	JSR	LAB_GBYT		; scan memory (1st character)
001598  1               LAB_1D10
001598  1  86 5E        	STX	Defdim		; save DIM flag
00159A  1               LAB_1D12
00159A  1  85 93        	STA	Varnm1		; save 1st character
00159C  1  29 7F        	AND	#$7F			; clear FN flag bit
00159E  1  20 07 16     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
0015A1  1  B0 03        	BCS	LAB_1D1F		; branch if ok
0015A3  1               
0015A3  1  4C EB 13     	JMP	LAB_SNER		; else syntax error then warm start
0015A6  1               
0015A6  1               					; was variable name so ..
0015A6  1               LAB_1D1F
0015A6  1  A2 00        	LDX	#$00			; clear 2nd character temp
0015A8  1  86 5F        	STX	Dtypef		; clear data type flag, $FF=string, $00=numeric
0015AA  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (2nd character)
0015AD  1  90 05        	BCC	LAB_1D2D		; branch if character = "0"-"9" (ok)
0015AF  1               
0015AF  1               					; 2nd character wasn't "0" to "9" so ..
0015AF  1  20 07 16     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
0015B2  1  90 0B        	BCC	LAB_1D38		; branch if <"A" or >"Z" (go check if string)
0015B4  1               
0015B4  1               LAB_1D2D
0015B4  1  AA           	TAX				; copy 2nd character
0015B5  1               
0015B5  1               					; ignore further (valid) characters in the variable name
0015B5  1               LAB_1D2E
0015B5  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (3rd character)
0015B8  1  90 FB        	BCC	LAB_1D2E		; loop if character = "0"-"9" (ignore)
0015BA  1               
0015BA  1  20 07 16     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
0015BD  1  B0 F6        	BCS	LAB_1D2E		; loop if character = "A"-"Z" (ignore)
0015BF  1               
0015BF  1               					; check if string variable
0015BF  1               LAB_1D38
0015BF  1  C9 24        	CMP	#'$'			; compare with "$"
0015C1  1  D0 0B        	BNE	LAB_1D47		; branch if not string
0015C3  1               
0015C3  1               ; to introduce a new variable type (% suffix for integers say) then this branch
0015C3  1               ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
0015C3  1               
0015C3  1               					; type is string
0015C3  1  A9 FF        	LDA	#$FF			; set data type = string
0015C5  1  85 5F        	STA	Dtypef		; set data type flag, $FF=string, $00=numeric
0015C7  1  8A           	TXA				; get 2nd character back
0015C8  1  09 80        	ORA	#$80			; set top bit (indicate string var)
0015CA  1  AA           	TAX				; copy back to 2nd character temp
0015CB  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0015CE  1               
0015CE  1               ; after we have determined the variable type we need to come back here to determine
0015CE  1               ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
0015CE  1               
0015CE  1               
0015CE  1               LAB_1D47				; gets here with character after var name in A
0015CE  1  86 94        	STX	Varnm2		; save 2nd character
0015D0  1  05 61        	ORA	Sufnxf		; or with subscript/FNX flag (or FN name)
0015D2  1  C9 28        	CMP	#'('			; compare with "("
0015D4  1  D0 03        	BNE	LAB_1D53		; branch if not "("
0015D6  1               
0015D6  1  4C A1 16     	JMP	LAB_1E17		; go find, or make, array
0015D9  1               
0015D9  1               ; either find or create var
0015D9  1               ; var name (1st two characters only!) is in Varnm1,Varnm2
0015D9  1               
0015D9  1               					; variable name wasn't var(... so look for plain var
0015D9  1               LAB_1D53
0015D9  1  A9 00        	LDA	#$00			; clear A
0015DB  1  85 61        	STA	Sufnxf		; clear subscript/FNX flag
0015DD  1  A5 7B        	LDA	Svarl			; get start of vars low byte
0015DF  1  A6 7C        	LDX	Svarh			; get start of vars high byte
0015E1  1  A0 00        	LDY	#$00			; clear index
0015E3  1               LAB_1D5D
0015E3  1  86 AB        	STX	Vrschh		; save search address high byte
0015E5  1               LAB_1D5F
0015E5  1  85 AA        	STA	Vrschl		; save search address low byte
0015E7  1  E4 7E        	CPX	Sarryh		; compare high address with var space end
0015E9  1  D0 04        	BNE	LAB_1D69		; skip next compare if <>
0015EB  1               
0015EB  1               					; high addresses were = so compare low addresses
0015EB  1  C5 7D        	CMP	Sarryl		; compare low address with var space end
0015ED  1  F0 2C        	BEQ	LAB_1D8B		; if not found go make new var
0015EF  1               
0015EF  1               LAB_1D69
0015EF  1  A5 93        	LDA	Varnm1		; get 1st character of var to find
0015F1  1  D1 AA        	CMP	(Vrschl),Y		; compare with variable name 1st character
0015F3  1  D0 08        	BNE	LAB_1D77		; branch if no match
0015F5  1               
0015F5  1               					; 1st characters match so compare 2nd characters
0015F5  1  A5 94        	LDA	Varnm2		; get 2nd character of var to find
0015F7  1  C8           	INY				; index to point to variable name 2nd character
0015F8  1  D1 AA        	CMP	(Vrschl),Y		; compare with variable name 2nd character
0015FA  1  F0 69        	BEQ	LAB_1DD7		; branch if match (found var)
0015FC  1               
0015FC  1  88           	DEY				; else decrement index (now = $00)
0015FD  1               LAB_1D77
0015FD  1  18           	CLC				; clear carry for add
0015FE  1  A5 AA        	LDA	Vrschl		; get search address low byte
001600  1  69 06        	ADC	#$06			; +6 (offset to next var name)
001602  1  90 E1        	BCC	LAB_1D5F		; loop if no overflow to high byte
001604  1               
001604  1  E8           	INX				; else increment high byte
001605  1  D0 DC        	BNE	LAB_1D5D		; loop always (RAM doesn't extend to $FFFF !)
001607  1               
001607  1               ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
001607  1               
001607  1               LAB_CASC
001607  1  C9 61        	CMP	#'a'			; compare with "a"
001609  1  B0 0A        	BCS	LAB_1D83		; go check <"z"+1
00160B  1               
00160B  1               ; check byte, return C=0 if<"A" or >"Z"
00160B  1               
00160B  1               LAB_1D82
00160B  1  C9 41        	CMP	#'A'			; compare with "A"
00160D  1  90 05        	BCC	LAB_1D8A		; exit if less
00160F  1               
00160F  1               					; carry is set
00160F  1  E9 5B        	SBC	#$5B			; subtract "Z"+1
001611  1  38           	SEC				; set carry
001612  1  E9 A5        	SBC	#$A5			; subtract $A5 (restore byte)
001614  1               					; carry clear if byte>$5A
001614  1               LAB_1D8A
001614  1  60           	RTS
001615  1               
001615  1               LAB_1D83
001615  1  E9 7B        	SBC	#$7B			; subtract "z"+1
001617  1  38           	SEC				; set carry
001618  1  E9 85        	SBC	#$85			; subtract $85 (restore byte)
00161A  1               					; carry clear if byte>$7A
00161A  1  60           	RTS
00161B  1               
00161B  1               					; reached end of variable mem without match
00161B  1               					; .. so create new variable
00161B  1               LAB_1D8B
00161B  1  68           	PLA				; pop return address low byte
00161C  1  48           	PHA				; push return address low byte
00161D  1               LAB_1C18p2	= LAB_1C18+2
00161D  1  C9 26        	CMP	#LAB_1C18p2_LO	; compare with expected calling routine return low byte
00161F  1  D0 05        	BNE	LAB_1D98		; if not get (var) go create new var
001621  1               
001621  1               ; This will only drop through if the call was from LAB_1C18 and is only called
001621  1               ; from there if it is searching for a variable from the RHS of a LET a=b statement
001621  1               ; it prevents the creation of variables not assigned a value.
001621  1               
001621  1               ; value returned by this is either numeric zero (exponent byte is $00) or null string
001621  1               ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
001621  1               
001621  1               ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
001621  1               
001621  1               ; this is where you would put the undefined variable error call e.g.
001621  1               
001621  1               ;					; variable doesn't exist so flag error
001621  1               ;	LDX	#$24			; error code $24 ("undefined variable" error)
001621  1               ;	JMP	LAB_XERR		; do error #X then warm start
001621  1               
001621  1               ; the above code has been tested and works a treat! (it replaces the three code lines
001621  1               ; below)
001621  1               
001621  1               					; else return dummy null value
001621  1  A9 C1        	LDA	#LAB_1D96_LO		; low byte point to $00,$00
001623  1               					; (uses part of misc constants table)
001623  1  A0 29        	LDY	#LAB_1D96_HI		; high byte point to $00,$00
001625  1  60           	RTS
001626  1               
001626  1               					; create new numeric variable
001626  1               LAB_1D98
001626  1  A5 7D        	LDA	Sarryl		; get var mem end low byte
001628  1  A4 7E        	LDY	Sarryh		; get var mem end high byte
00162A  1  85 AA        	STA	Ostrtl		; save old block start low byte
00162C  1  84 AB        	STY	Ostrth		; save old block start high byte
00162E  1  A5 7F        	LDA	Earryl		; get array mem end low byte
001630  1  A4 80        	LDY	Earryh		; get array mem end high byte
001632  1  85 A6        	STA	Obendl		; save old block end low byte
001634  1  84 A7        	STY	Obendh		; save old block end high byte
001636  1  18           	CLC				; clear carry for add
001637  1  69 06        	ADC	#$06			; +6 (space for one var)
001639  1  90 01        	BCC	LAB_1DAE		; branch if no overflow to high byte
00163B  1               
00163B  1  C8           	INY				; else increment high byte
00163C  1               LAB_1DAE
00163C  1  85 A4        	STA	Nbendl		; set new block end low byte
00163E  1  84 A5        	STY	Nbendh		; set new block end high byte
001640  1  20 AC 08     	JSR	LAB_11CF		; open up space in memory
001643  1  A5 A4        	LDA	Nbendl		; get new start low byte
001645  1  A4 A5        	LDY	Nbendh		; get new start high byte (-$100)
001647  1  C8           	INY				; correct high byte
001648  1  85 7D        	STA	Sarryl		; save new var mem end low byte
00164A  1  84 7E        	STY	Sarryh		; save new var mem end high byte
00164C  1  A0 00        	LDY	#$00			; clear index
00164E  1  A5 93        	LDA	Varnm1		; get var name 1st character
001650  1  91 AA        	STA	(Vrschl),Y		; save var name 1st character
001652  1  C8           	INY				; increment index
001653  1  A5 94        	LDA	Varnm2		; get var name 2nd character
001655  1  91 AA        	STA	(Vrschl),Y		; save var name 2nd character
001657  1  A9 00        	LDA	#$00			; clear A
001659  1  C8           	INY				; increment index
00165A  1  91 AA        	STA	(Vrschl),Y		; initialise var byte
00165C  1  C8           	INY				; increment index
00165D  1  91 AA        	STA	(Vrschl),Y		; initialise var byte
00165F  1  C8           	INY				; increment index
001660  1  91 AA        	STA	(Vrschl),Y		; initialise var byte
001662  1  C8           	INY				; increment index
001663  1  91 AA        	STA	(Vrschl),Y		; initialise var byte
001665  1               
001665  1               					; found a match for var ((Vrschl) = ptr)
001665  1               LAB_1DD7
001665  1  A5 AA        	LDA	Vrschl		; get var address low byte
001667  1  18           	CLC				; clear carry for add
001668  1  69 02        	ADC	#$02			; +2 (offset past var name bytes)
00166A  1  A4 AB        	LDY	Vrschh		; get var address high byte
00166C  1  90 01        	BCC	LAB_1DE1		; branch if no overflow from add
00166E  1               
00166E  1  C8           	INY				; else increment high byte
00166F  1               LAB_1DE1
00166F  1  85 95        	STA	Cvaral		; save current var address low byte
001671  1  84 96        	STY	Cvarah		; save current var address high byte
001673  1  60           	RTS
001674  1               
001674  1               ; set-up array pointer (Adatal/h) to first element in array
001674  1               ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
001674  1               
001674  1               LAB_1DE6
001674  1  A5 5D        	LDA	Dimcnt		; get # of dimensions (1, 2 or 3)
001676  1  0A           	ASL	A			; *2 (also clears the carry !)
001677  1  69 05        	ADC	#$05			; +5 (result is 7, 9 or 11 here)
001679  1  65 AA        	ADC	Astrtl		; add array start pointer low byte
00167B  1  A4 AB        	LDY	Astrth		; get array pointer high byte
00167D  1  90 01        	BCC	LAB_1DF2		; branch if no overflow
00167F  1               
00167F  1  C8           	INY				; else increment high byte
001680  1               LAB_1DF2
001680  1  85 A4        	STA	Adatal		; save array data pointer low byte
001682  1  84 A5        	STY	Adatah		; save array data pointer high byte
001684  1  60           	RTS
001685  1               
001685  1               ; evaluate integer expression
001685  1               
001685  1               LAB_EVIN
001685  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
001688  1  20 B6 12     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
00168B  1               					; else do type mismatch
00168B  1               
00168B  1               ; evaluate integer expression (no check)
00168B  1               
00168B  1               LAB_EVPI
00168B  1  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00168D  1  30 0D        	BMI	LAB_1E12		; do function call error if -ve
00168F  1               
00168F  1               ; evaluate integer expression (no sign check)
00168F  1               
00168F  1               LAB_EVIR
00168F  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
001691  1  C9 90        	CMP	#$90			; compare with exponent = 2^16 (n>2^15)
001693  1  90 09        	BCC	LAB_1E14		; branch if n<2^16 (is ok)
001695  1               
001695  1  A9 C8        	LDA	#LAB_1DF7_LO		; set pointer low byte to -32768
001697  1  A0 29        	LDY	#LAB_1DF7_HI		; set pointer high byte to -32768
001699  1  20 00 21     	JSR	LAB_27F8		; compare FAC1 with (AY)
00169C  1               LAB_1E12
00169C  1  D0 74        	BNE	LAB_FCER		; if <> do function call error then warm start
00169E  1               
00169E  1               LAB_1E14
00169E  1  4C 39 21     	JMP	LAB_2831		; convert FAC1 floating-to-fixed and return
0016A1  1               
0016A1  1               ; find or make array
0016A1  1               
0016A1  1               LAB_1E17
0016A1  1  A5 5E        	LDA	Defdim		; get DIM flag
0016A3  1  48           	PHA				; push it
0016A4  1  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
0016A6  1  48           	PHA				; push it
0016A7  1  A0 00        	LDY	#$00			; clear dimensions count
0016A9  1               
0016A9  1               ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
0016A9  1               
0016A9  1               LAB_1E1F
0016A9  1  98           	TYA				; copy dimensions count
0016AA  1  48           	PHA				; save it
0016AB  1  A5 94        	LDA	Varnm2		; get array name 2nd byte
0016AD  1  48           	PHA				; save it
0016AE  1  A5 93        	LDA	Varnm1		; get array name 1st byte
0016B0  1  48           	PHA				; save it
0016B1  1  20 85 16     	JSR	LAB_EVIN		; evaluate integer expression
0016B4  1  68           	PLA				; pull array name 1st byte
0016B5  1  85 93        	STA	Varnm1		; restore array name 1st byte
0016B7  1  68           	PLA				; pull array name 2nd byte
0016B8  1  85 94        	STA	Varnm2		; restore array name 2nd byte
0016BA  1  68           	PLA				; pull dimensions count
0016BB  1  A8           	TAY				; restore it
0016BC  1  BA           	TSX				; copy stack pointer
0016BD  1  BD 02 01     	LDA	LAB_STAK+2,X	; get DIM flag
0016C0  1  48           	PHA				; push it
0016C1  1  BD 01 01     	LDA	LAB_STAK+1,X	; get data type flag
0016C4  1  48           	PHA				; push it
0016C5  1  A5 AE        	LDA	FAC1_2		; get this dimension size high byte
0016C7  1  9D 02 01     	STA	LAB_STAK+2,X	; stack before flag bytes
0016CA  1  A5 AF        	LDA	FAC1_3		; get this dimension size low byte
0016CC  1  9D 01 01     	STA	LAB_STAK+1,X	; stack before flag bytes
0016CF  1  C8           	INY				; increment dimensions count
0016D0  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
0016D3  1  C9 2C        	CMP	#','			; compare with ","
0016D5  1  F0 D2        	BEQ	LAB_1E1F		; if found go do next dimension
0016D7  1               
0016D7  1  84 5D        	STY	Dimcnt		; store dimensions count
0016D9  1  20 D8 13     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
0016DC  1  68           	PLA				; pull data type flag
0016DD  1  85 5F        	STA	Dtypef		; restore data type flag, $FF=string, $00=numeric
0016DF  1  68           	PLA				; pull DIM flag
0016E0  1  85 5E        	STA	Defdim		; restore DIM flag
0016E2  1  A6 7D        	LDX	Sarryl		; get array mem start low byte
0016E4  1  A5 7E        	LDA	Sarryh		; get array mem start high byte
0016E6  1               
0016E6  1               ; now check to see if we are at the end of array memory (we would be if there were
0016E6  1               ; no arrays).
0016E6  1               
0016E6  1               LAB_1E5C
0016E6  1  86 AA        	STX	Astrtl		; save as array start pointer low byte
0016E8  1  85 AB        	STA	Astrth		; save as array start pointer high byte
0016EA  1  C5 80        	CMP	Earryh		; compare with array mem end high byte
0016EC  1  D0 04        	BNE	LAB_1E68		; branch if not reached array mem end
0016EE  1               
0016EE  1  E4 7F        	CPX	Earryl		; else compare with array mem end low byte
0016F0  1  F0 39        	BEQ	LAB_1EA1		; go build array if not found
0016F2  1               
0016F2  1               					; search for array
0016F2  1               LAB_1E68
0016F2  1  A0 00        	LDY	#$00			; clear index
0016F4  1  B1 AA        	LDA	(Astrtl),Y		; get array name first byte
0016F6  1  C8           	INY				; increment index to second name byte
0016F7  1  C5 93        	CMP	Varnm1		; compare with this array name first byte
0016F9  1  D0 06        	BNE	LAB_1E77		; branch if no match
0016FB  1               
0016FB  1  A5 94        	LDA	Varnm2		; else get this array name second byte
0016FD  1  D1 AA        	CMP	(Astrtl),Y		; compare with array name second byte
0016FF  1  F0 16        	BEQ	LAB_1E8D		; array found so branch
001701  1               
001701  1               					; no match
001701  1               LAB_1E77
001701  1  C8           	INY				; increment index
001702  1  B1 AA        	LDA	(Astrtl),Y		; get array size low byte
001704  1  18           	CLC				; clear carry for add
001705  1  65 AA        	ADC	Astrtl		; add array start pointer low byte
001707  1  AA           	TAX				; copy low byte to X
001708  1  C8           	INY				; increment index
001709  1  B1 AA        	LDA	(Astrtl),Y		; get array size high byte
00170B  1  65 AB        	ADC	Astrth		; add array mem pointer high byte
00170D  1  90 D7        	BCC	LAB_1E5C		; if no overflow go check next array
00170F  1               
00170F  1               ; do array bounds error
00170F  1               
00170F  1               LAB_1E85
00170F  1  A2 10        	LDX	#$10			; error code $10 ("Array bounds" error)
001711  1  2C           	.byte	$2C			; makes next bit BIT LAB_08A2
001712  1               
001712  1               ; do function call error
001712  1               
001712  1               LAB_FCER
001712  1  A2 08        	LDX	#$08			; error code $08 ("Function call" error)
001714  1               LAB_1E8A
001714  1  4C 27 09     	JMP	LAB_XERR		; do error #X, then warm start
001717  1               
001717  1               					; found array, are we trying to dimension it?
001717  1               LAB_1E8D
001717  1  A2 12        	LDX	#$12			; set error $12 ("Double dimension" error)
001719  1  A5 5E        	LDA	Defdim		; get DIM flag
00171B  1  D0 F7        	BNE	LAB_1E8A		; if we are trying to dimension it do error #X, then warm
00171D  1               					; start
00171D  1               
00171D  1               ; found the array and we're not dimensioning it so we must find an element in it
00171D  1               
00171D  1  20 74 16     	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
001720  1               					; (Astrtl,Astrth points to start of array)
001720  1  A5 5D        	LDA	Dimcnt		; get dimensions count
001722  1  A0 04        	LDY	#$04			; set index to array's # of dimensions
001724  1  D1 AA        	CMP	(Astrtl),Y		; compare with no of dimensions
001726  1  D0 E7        	BNE	LAB_1E85		; if wrong do array bounds error, could do "Wrong
001728  1               					; dimensions" error here .. if we want a different
001728  1               					; error message
001728  1               
001728  1  4C AE 17     	JMP	LAB_1F28		; found array so go get element
00172B  1               					; (could jump to LAB_1F28 as all LAB_1F24 does is take
00172B  1               					; Dimcnt and save it at (Astrtl),Y which is already the
00172B  1               					; same or we would have taken the BNE)
00172B  1               
00172B  1               					; array not found, so build it
00172B  1               LAB_1EA1
00172B  1  20 74 16     	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
00172E  1               					; (Astrtl,Astrth points to start of array)
00172E  1  20 F6 08     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
001731  1               					; addr to check is in AY (low/high)
001731  1  A0 00        	LDY	#$00			; clear Y (don't need to clear A)
001733  1  84 BB        	STY	Aspth			; clear array data size high byte
001735  1  A5 93        	LDA	Varnm1		; get variable name 1st byte
001737  1  91 AA        	STA	(Astrtl),Y		; save array name 1st byte
001739  1  C8           	INY				; increment index
00173A  1  A5 94        	LDA	Varnm2		; get variable name 2nd byte
00173C  1  91 AA        	STA	(Astrtl),Y		; save array name 2nd byte
00173E  1  A5 5D        	LDA	Dimcnt		; get dimensions count
001740  1  A0 04        	LDY	#$04			; index to dimension count
001742  1  84 BA        	STY	Asptl			; set array data size low byte (four bytes per element)
001744  1  91 AA        	STA	(Astrtl),Y		; set array's dimensions count
001746  1               
001746  1               					; now calculate the size of the data space for the array
001746  1  18           	CLC				; clear carry for add (clear on subsequent loops)
001747  1               LAB_1EC0
001747  1  A2 0B        	LDX	#$0B			; set default dimension value low byte
001749  1  A9 00        	LDA	#$00			; set default dimension value high byte
00174B  1  24 5E        	BIT	Defdim		; test default DIM flag
00174D  1  50 07        	BVC	LAB_1ED0		; branch if b6 of Defdim is clear
00174F  1               
00174F  1  68           	PLA				; else pull dimension value low byte
001750  1  69 01        	ADC	#$01			; +1 (allow for zeroeth element)
001752  1  AA           	TAX				; copy low byte to X
001753  1  68           	PLA				; pull dimension value high byte
001754  1  69 00        	ADC	#$00			; add carry from low byte
001756  1               
001756  1               LAB_1ED0
001756  1  C8           	INY				; index to dimension value high byte
001757  1  91 AA        	STA	(Astrtl),Y		; save dimension value high byte
001759  1  C8           	INY				; index to dimension value high byte
00175A  1  8A           	TXA				; get dimension value low byte
00175B  1  91 AA        	STA	(Astrtl),Y		; save dimension value low byte
00175D  1  20 FD 17     	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
001760  1  86 BA        	STX	Asptl			; save array data size low byte
001762  1  85 BB        	STA	Aspth			; save array data size high byte
001764  1  A4 71        	LDY	ut1_pl		; restore index (saved by subroutine)
001766  1  C6 5D        	DEC	Dimcnt		; decrement dimensions count
001768  1  D0 DD        	BNE	LAB_1EC0		; loop while not = 0
00176A  1               
00176A  1  65 A5        	ADC	Adatah		; add size high byte to first element high byte
00176C  1               					; (carry is always clear here)
00176C  1  B0 5D        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
00176E  1               
00176E  1  85 A5        	STA	Adatah		; save end of array high byte
001770  1  A8           	TAY				; copy end high byte to Y
001771  1  8A           	TXA				; get array size low byte
001772  1  65 A4        	ADC	Adatal		; add array start low byte
001774  1  90 03        	BCC	LAB_1EF3		; branch if no carry
001776  1               
001776  1  C8           	INY				; else increment end of array high byte
001777  1  F0 52        	BEQ	LAB_1F45		; if overflow go do "Out of memory" error
001779  1               
001779  1               					; set-up mostly complete, now zero the array
001779  1               LAB_1EF3
001779  1  20 F6 08     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
00177C  1               					; addr to check is in AY (low/high)
00177C  1  85 7F        	STA	Earryl		; save array mem end low byte
00177E  1  84 80        	STY	Earryh		; save array mem end high byte
001780  1  A9 00        	LDA	#$00			; clear byte for array clear
001782  1  E6 BB        	INC	Aspth			; increment array size high byte (now block count)
001784  1  A4 BA        	LDY	Asptl			; get array size low byte (now index to block)
001786  1  F0 05        	BEQ	LAB_1F07		; branch if low byte = $00
001788  1               
001788  1               LAB_1F02
001788  1  88           	DEY				; decrement index (do 0 to n-1)
001789  1  91 A4        	STA	(Adatal),Y		; zero byte
00178B  1  D0 FB        	BNE	LAB_1F02		; loop until this block done
00178D  1               
00178D  1               LAB_1F07
00178D  1  C6 A5        	DEC	Adatah		; decrement array pointer high byte
00178F  1  C6 BB        	DEC	Aspth			; decrement block count high byte
001791  1  D0 F5        	BNE	LAB_1F02		; loop until all blocks done
001793  1               
001793  1  E6 A5        	INC	Adatah		; correct for last loop
001795  1  38           	SEC				; set carry for subtract
001796  1  A0 02        	LDY	#$02			; index to array size low byte
001798  1  A5 7F        	LDA	Earryl		; get array mem end low byte
00179A  1  E5 AA        	SBC	Astrtl		; subtract array start low byte
00179C  1  91 AA        	STA	(Astrtl),Y		; save array size low byte
00179E  1  C8           	INY				; index to array size high byte
00179F  1  A5 80        	LDA	Earryh		; get array mem end high byte
0017A1  1  E5 AB        	SBC	Astrth		; subtract array start high byte
0017A3  1  91 AA        	STA	(Astrtl),Y		; save array size high byte
0017A5  1  A5 5E        	LDA	Defdim		; get default DIM flag
0017A7  1  D0 53        	BNE	LAB_1F7B		; exit (RET) if this was a DIM command
0017A9  1               
0017A9  1               					; else, find element
0017A9  1  C8           	INY				; index to # of dimensions
0017AA  1               
0017AA  1               LAB_1F24
0017AA  1  B1 AA        	LDA	(Astrtl),Y		; get array's dimension count
0017AC  1  85 5D        	STA	Dimcnt		; save it
0017AE  1               
0017AE  1               ; we have found, or built, the array. now we need to find the element
0017AE  1               
0017AE  1               LAB_1F28
0017AE  1  A9 00        	LDA	#$00			; clear byte
0017B0  1  85 BA        	STA	Asptl			; clear array data pointer low byte
0017B2  1               LAB_1F2C
0017B2  1  85 BB        	STA	Aspth			; save array data pointer high byte
0017B4  1  C8           	INY				; increment index (point to array bound high byte)
0017B5  1  68           	PLA				; pull array index low byte
0017B6  1  AA           	TAX				; copy to X
0017B7  1  85 AE        	STA	FAC1_2		; save index low byte to FAC1 mantissa2
0017B9  1  68           	PLA				; pull array index high byte
0017BA  1  85 AF        	STA	FAC1_3		; save index high byte to FAC1 mantissa3
0017BC  1  D1 AA        	CMP	(Astrtl),Y		; compare with array bound high byte
0017BE  1  90 0E        	BCC	LAB_1F48		; branch if within bounds
0017C0  1               
0017C0  1  D0 06        	BNE	LAB_1F42		; if outside bounds do array bounds error
0017C2  1               
0017C2  1               					; else high byte was = so test low bytes
0017C2  1  C8           	INY				; index to array bound low byte
0017C3  1  8A           	TXA				; get array index low byte
0017C4  1  D1 AA        	CMP	(Astrtl),Y		; compare with array bound low byte
0017C6  1  90 07        	BCC	LAB_1F49		; branch if within bounds
0017C8  1               
0017C8  1               LAB_1F42
0017C8  1  4C 0F 17     	JMP	LAB_1E85		; else do array bounds error
0017CB  1               
0017CB  1               LAB_1F45
0017CB  1  4C 25 09     	JMP	LAB_OMER		; do "Out of memory" error then warm start
0017CE  1               
0017CE  1               LAB_1F48
0017CE  1  C8           	INY				; index to array bound low byte
0017CF  1               LAB_1F49
0017CF  1  A5 BB        	LDA	Aspth			; get array data pointer high byte
0017D1  1  05 BA        	ORA	Asptl			; OR with array data pointer low byte
0017D3  1  F0 0A        	BEQ	LAB_1F5A		; branch if array data pointer = null (skip multiply)
0017D5  1               
0017D5  1  20 FD 17     	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
0017D8  1  8A           	TXA				; get result low byte
0017D9  1  65 AE        	ADC	FAC1_2		; add index low byte from FAC1 mantissa2
0017DB  1  AA           	TAX				; save result low byte
0017DC  1  98           	TYA				; get result high byte
0017DD  1  A4 71        	LDY	ut1_pl		; restore index
0017DF  1               LAB_1F5A
0017DF  1  65 AF        	ADC	FAC1_3		; add index high byte from FAC1 mantissa3
0017E1  1  86 BA        	STX	Asptl			; save array data pointer low byte
0017E3  1  C6 5D        	DEC	Dimcnt		; decrement dimensions count
0017E5  1  D0 CB        	BNE	LAB_1F2C		; loop if dimensions still to do
0017E7  1               
0017E7  1  06 BA        	ASL	Asptl			; array data pointer low byte * 2
0017E9  1  2A           	ROL	A			; array data pointer high byte * 2
0017EA  1  06 BA        	ASL	Asptl			; array data pointer low byte * 4
0017EC  1  2A           	ROL	A			; array data pointer high byte * 4
0017ED  1  A8           	TAY				; copy high byte
0017EE  1  A5 BA        	LDA	Asptl			; get low byte
0017F0  1  65 A4        	ADC	Adatal		; add array data start pointer low byte
0017F2  1  85 95        	STA	Cvaral		; save as current var address low byte
0017F4  1  98           	TYA				; get high byte back
0017F5  1  65 A5        	ADC	Adatah		; add array data start pointer high byte
0017F7  1  85 96        	STA	Cvarah		; save as current var address high byte
0017F9  1  A8           	TAY				; copy high byte to Y
0017FA  1  A5 95        	LDA	Cvaral		; get current var address low byte
0017FC  1               LAB_1F7B
0017FC  1  60           	RTS
0017FD  1               
0017FD  1               ; does XY = (Astrtl),Y * (Asptl)
0017FD  1               
0017FD  1               LAB_1F7C
0017FD  1  84 71        	STY	ut1_pl		; save index
0017FF  1  B1 AA        	LDA	(Astrtl),Y		; get dimension size low byte
001801  1  85 76        	STA	dims_l		; save dimension size low byte
001803  1  88           	DEY				; decrement index
001804  1  B1 AA        	LDA	(Astrtl),Y		; get dimension size high byte
001806  1  85 77        	STA	dims_h		; save dimension size high byte
001808  1               
001808  1  A9 10        	LDA	#$10			; count = $10 (16 bit multiply)
00180A  1  85 A8        	STA	numbit		; save bit count
00180C  1  A2 00        	LDX	#$00			; clear result low byte
00180E  1  A0 00        	LDY	#$00			; clear result high byte
001810  1               LAB_1F8F
001810  1  8A           	TXA				; get result low byte
001811  1  0A           	ASL	A			; *2
001812  1  AA           	TAX				; save result low byte
001813  1  98           	TYA				; get result high byte
001814  1  2A           	ROL	A			; *2
001815  1  A8           	TAY				; save result high byte
001816  1  B0 B3        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
001818  1               
001818  1  06 BA        	ASL	Asptl			; shift multiplier low byte
00181A  1  26 BB        	ROL	Aspth			; shift multiplier high byte
00181C  1  90 0B        	BCC	LAB_1FA8		; skip add if no carry
00181E  1               
00181E  1  18           	CLC				; else clear carry for add
00181F  1  8A           	TXA				; get result low byte
001820  1  65 76        	ADC	dims_l		; add dimension size low byte
001822  1  AA           	TAX				; save result low byte
001823  1  98           	TYA				; get result high byte
001824  1  65 77        	ADC	dims_h		; add dimension size high byte
001826  1  A8           	TAY				; save result high byte
001827  1  B0 A2        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
001829  1               
001829  1               LAB_1FA8
001829  1  C6 A8        	DEC	numbit		; decrement bit count
00182B  1  D0 E3        	BNE	LAB_1F8F		; loop until all done
00182D  1               
00182D  1  60           	RTS
00182E  1               
00182E  1               ; perform FRE()
00182E  1               
00182E  1               LAB_FRE
00182E  1  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
001830  1  10 03        	BPL	LAB_1FB4		; branch if numeric
001832  1               
001832  1  20 27 1B     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
001835  1               					; space returns with A = length, X=$71=pointer low byte,
001835  1               					; Y=$72=pointer high byte
001835  1               
001835  1               					; FRE(n) was numeric so do this
001835  1               LAB_1FB4
001835  1  20 C8 19     	JSR	LAB_GARB		; go do garbage collection
001838  1  38           	SEC				; set carry for subtract
001839  1  A5 81        	LDA	Sstorl		; get bottom of string space low byte
00183B  1  E5 7F        	SBC	Earryl		; subtract array mem end low byte
00183D  1  A8           	TAY				; copy result to Y
00183E  1  A5 82        	LDA	Sstorh		; get bottom of string space high byte
001840  1  E5 80        	SBC	Earryh		; subtract array mem end high byte
001842  1               
001842  1               ; save and convert integer AY to FAC1
001842  1               
001842  1               LAB_AYFC
001842  1  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
001844  1  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
001846  1  84 AE        	STY	FAC1_2		; save FAC1 mantissa2
001848  1  A2 90        	LDX	#$90			; set exponent=2^16 (integer)
00184A  1  4C EB 20     	JMP	LAB_27E3		; set exp=X, clear FAC1_3, normalise and return
00184D  1               
00184D  1               ; perform POS()
00184D  1               
00184D  1               LAB_POS
00184D  1  A4 0E        	LDY	TPos			; get terminal position
00184F  1               
00184F  1               ; convert Y to byte in FAC1
00184F  1               
00184F  1               LAB_1FD0
00184F  1  A9 00        	LDA	#$00			; clear high byte
001851  1  F0 EF        	BEQ	LAB_AYFC		; always save and convert integer AY to FAC1 and return
001853  1               
001853  1               ; check not Direct (used by DEF and INPUT)
001853  1               
001853  1               LAB_CKRN
001853  1  A6 88        	LDX	Clineh		; get current line high byte
001855  1  E8           	INX				; increment it
001856  1  D0 A4        	BNE	LAB_1F7B		; return if can continue not direct mode
001858  1               
001858  1               					; else do illegal direct error
001858  1               LAB_1FD9
001858  1  A2 16        	LDX	#$16			; error code $16 ("Illegal direct" error)
00185A  1               LAB_1FDB
00185A  1  4C 27 09     	JMP	LAB_XERR		; go do error #X, then warm start
00185D  1               
00185D  1               ; perform DEF
00185D  1               
00185D  1               LAB_DEF
00185D  1  20 8E 18     	JSR	LAB_200B		; check FNx syntax
001860  1  85 9C        	STA	func_l		; save function pointer low byte
001862  1  84 9D        	STY	func_h		; save function pointer high byte
001864  1  20 53 18     	JSR	LAB_CKRN		; check not Direct (back here if ok)
001867  1  20 E3 13     	JSR	LAB_1BFE		; scan for "(" , else do syntax error then warm start
00186A  1  A9 80        	LDA	#$80			; set flag for FNx
00186C  1  85 61        	STA	Sufnxf		; save subscript/FNx flag
00186E  1  20 93 15     	JSR	LAB_GVAR		; get (var) address
001871  1  20 B9 12     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
001874  1  20 D8 13     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
001877  1  A9 C2        	LDA	#TK_EQUAL		; get = token
001879  1  20 DA 13     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
00187C  1  A5 96        	LDA	Cvarah		; get current var address high byte
00187E  1  48           	PHA				; push it
00187F  1  A5 95        	LDA	Cvaral		; get current var address low byte
001881  1  48           	PHA				; push it
001882  1  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
001884  1  48           	PHA				; push it
001885  1  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
001887  1  48           	PHA				; push it
001888  1  20 75 0E     	JSR	LAB_DATA		; go perform DATA
00188B  1  4C FD 18     	JMP	LAB_207A		; put execute pointer and variable pointer into function
00188E  1               					; and return
00188E  1               
00188E  1               ; check FNx syntax
00188E  1               
00188E  1               LAB_200B
00188E  1  A9 AF        	LDA	#TK_FN		; get FN" token
001890  1  20 DA 13     	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
001893  1               					; return character after A
001893  1  09 80        	ORA	#$80			; set FN flag bit
001895  1  85 61        	STA	Sufnxf		; save FN flag so array variable test fails
001897  1  20 9A 15     	JSR	LAB_1D12		; search for FN variable
00189A  1  4C B9 12     	JMP	LAB_CTNM		; check if source is numeric and return, else do type
00189D  1               					; mismatch
00189D  1               
00189D  1               					; Evaluate FNx
00189D  1               LAB_201E
00189D  1  20 8E 18     	JSR	LAB_200B		; check FNx syntax
0018A0  1  48           	PHA				; push function pointer low byte
0018A1  1  98           	TYA				; copy function pointer high byte
0018A2  1  48           	PHA				; push function pointer high byte
0018A3  1  20 E3 13     	JSR	LAB_1BFE		; scan for "(", else do syntax error then warm start
0018A6  1  20 CA 12     	JSR	LAB_EVEX		; evaluate expression
0018A9  1  20 D8 13     	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
0018AC  1  20 B9 12     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
0018AF  1  68           	PLA				; pop function pointer high byte
0018B0  1  85 9D        	STA	func_h		; restore it
0018B2  1  68           	PLA				; pop function pointer low byte
0018B3  1  85 9C        	STA	func_l		; restore it
0018B5  1  A2 20        	LDX	#$20			; error code $20 ("Undefined function" error)
0018B7  1  A0 03        	LDY	#$03			; index to variable pointer high byte
0018B9  1  B1 9C        	LDA	(func_l),Y		; get variable pointer high byte
0018BB  1  F0 9D        	BEQ	LAB_1FDB		; if zero go do undefined function error
0018BD  1               
0018BD  1  85 96        	STA	Cvarah		; save variable address high byte
0018BF  1  88           	DEY				; index to variable address low byte
0018C0  1  B1 9C        	LDA	(func_l),Y		; get variable address low byte
0018C2  1  85 95        	STA	Cvaral		; save variable address low byte
0018C4  1  AA           	TAX				; copy address low byte
0018C5  1               
0018C5  1               					; now stack the function variable value before use
0018C5  1  C8           	INY				; index to mantissa_3
0018C6  1               LAB_2043
0018C6  1  B1 95        	LDA	(Cvaral),Y		; get byte from variable
0018C8  1  48           	PHA				; stack it
0018C9  1  88           	DEY				; decrement index
0018CA  1  10 FA        	BPL	LAB_2043		; loop until variable stacked
0018CC  1               
0018CC  1  A4 96        	LDY	Cvarah		; get variable address high byte
0018CE  1  20 90 20     	JSR	LAB_2778		; pack FAC1 (function expression value) into (XY)
0018D1  1               					; (function variable), return Y=0, always
0018D1  1  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
0018D3  1  48           	PHA				; push it
0018D4  1  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
0018D6  1  48           	PHA				; push it
0018D7  1  B1 9C        	LDA	(func_l),Y		; get function execute pointer low byte
0018D9  1  85 C3        	STA	Bpntrl		; save as BASIC execute pointer low byte
0018DB  1  C8           	INY				; index to high byte
0018DC  1  B1 9C        	LDA	(func_l),Y		; get function execute pointer high byte
0018DE  1  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
0018E0  1  A5 96        	LDA	Cvarah		; get variable address high byte
0018E2  1  48           	PHA				; push it
0018E3  1  A5 95        	LDA	Cvaral		; get variable address low byte
0018E5  1  48           	PHA				; push it
0018E6  1  20 B6 12     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
0018E9  1               					; else do type mismatch
0018E9  1  68           	PLA				; pull variable address low byte
0018EA  1  85 9C        	STA	func_l		; save variable address low byte
0018EC  1  68           	PLA				; pull variable address high byte
0018ED  1  85 9D        	STA	func_h		; save variable address high byte
0018EF  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
0018F2  1  F0 03        	BEQ	LAB_2074		; branch if null (should be [EOL] marker)
0018F4  1               
0018F4  1  4C EB 13     	JMP	LAB_SNER		; else syntax error then warm start
0018F7  1               
0018F7  1               ; restore Bpntrl,Bpntrh and function variable from stack
0018F7  1               
0018F7  1               LAB_2074
0018F7  1  68           	PLA				; pull BASIC execute pointer low byte
0018F8  1  85 C3        	STA	Bpntrl		; restore BASIC execute pointer low byte
0018FA  1  68           	PLA				; pull BASIC execute pointer high byte
0018FB  1  85 C4        	STA	Bpntrh		; restore BASIC execute pointer high byte
0018FD  1               
0018FD  1               ; put execute pointer and variable pointer into function
0018FD  1               
0018FD  1               LAB_207A
0018FD  1  A0 00        	LDY	#$00			; clear index
0018FF  1  68           	PLA				; pull BASIC execute pointer low byte
001900  1  91 9C        	STA	(func_l),Y		; save to function
001902  1  C8           	INY				; increment index
001903  1  68           	PLA				; pull BASIC execute pointer high byte
001904  1  91 9C        	STA	(func_l),Y		; save to function
001906  1  C8           	INY				; increment index
001907  1  68           	PLA				; pull current var address low byte
001908  1  91 9C        	STA	(func_l),Y		; save to function
00190A  1  C8           	INY				; increment index
00190B  1  68           	PLA				; pull current var address high byte
00190C  1  91 9C        	STA	(func_l),Y		; save to function
00190E  1  60           	RTS
00190F  1               
00190F  1               ; perform STR$()
00190F  1               
00190F  1               LAB_STRS
00190F  1  20 B9 12     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
001912  1  20 81 22     	JSR	LAB_296E		; convert FAC1 to string
001915  1  A9 F0        	LDA	#Decssp1_LO		; set result string low pointer
001917  1  A0 00        	LDY	#Decssp1_HI		; set result string high pointer
001919  1  F0 12        	BEQ	LAB_20AE		; print null terminated string to Sutill/Sutilh
00191B  1               
00191B  1               ; Do string vector
00191B  1               ; copy des_pl/h to des_2l/h and make string space A bytes long
00191B  1               
00191B  1               LAB_209C
00191B  1  A6 AE        	LDX	des_pl		; get descriptor pointer low byte
00191D  1  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
00191F  1  86 9E        	STX	des_2l		; save descriptor pointer low byte
001921  1  84 9F        	STY	des_2h		; save descriptor pointer high byte
001923  1               
001923  1               ; make string space A bytes long
001923  1               ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
001923  1               
001923  1               LAB_MSSP
001923  1  20 96 19     	JSR	LAB_2115		; make space in string memory for string A long
001926  1               					; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
001926  1  86 AD        	STX	str_pl		; save string pointer low byte
001928  1  84 AE        	STY	str_ph		; save string pointer high byte
00192A  1  85 AC        	STA	str_ln		; save length
00192C  1  60           	RTS
00192D  1               
00192D  1               ; Scan, set up string
00192D  1               ; print " terminated string to Sutill/Sutilh
00192D  1               
00192D  1               LAB_20AE
00192D  1  A2 22        	LDX	#$22			; set terminator to "
00192F  1  86 5B        	STX	Srchc			; set search character (terminator 1)
001931  1  86 5C        	STX	Asrch			; set terminator 2
001933  1               
001933  1               ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
001933  1               ; source is AY
001933  1               
001933  1               LAB_20B4
001933  1  85 B8        	STA	ssptr_l		; store string start low byte
001935  1  84 B9        	STY	ssptr_h		; store string start high byte
001937  1  85 AD        	STA	str_pl		; save string pointer low byte
001939  1  84 AE        	STY	str_ph		; save string pointer high byte
00193B  1  A0 FF        	LDY	#$FF			; set length to -1
00193D  1               LAB_20BE
00193D  1  C8           	INY				; increment length
00193E  1  B1 B8        	LDA	(ssptr_l),Y		; get byte from string
001940  1  F0 0C        	BEQ	LAB_20CF		; exit loop if null byte [EOS]
001942  1               
001942  1  C5 5B        	CMP	Srchc			; compare with search character (terminator 1)
001944  1  F0 04        	BEQ	LAB_20CB		; branch if terminator
001946  1               
001946  1  C5 5C        	CMP	Asrch			; compare with terminator 2
001948  1  D0 F3        	BNE	LAB_20BE		; loop if not terminator 2
00194A  1               
00194A  1               LAB_20CB
00194A  1  C9 22        	CMP	#$22			; compare with "
00194C  1  F0 01        	BEQ	LAB_20D0		; branch if " (carry set if = !)
00194E  1               
00194E  1               LAB_20CF
00194E  1  18           	CLC				; clear carry for add (only if [EOL] terminated string)
00194F  1               LAB_20D0
00194F  1  84 AC        	STY	str_ln		; save length in FAC1 exponent
001951  1  98           	TYA				; copy length to A
001952  1  65 B8        	ADC	ssptr_l		; add string start low byte
001954  1  85 BA        	STA	Sendl			; save string end low byte
001956  1  A6 B9        	LDX	ssptr_h		; get string start high byte
001958  1  90 01        	BCC	LAB_20DC		; branch if no low byte overflow
00195A  1               
00195A  1  E8           	INX				; else increment high byte
00195B  1               LAB_20DC
00195B  1  86 BB        	STX	Sendh			; save string end high byte
00195D  1  A5 B9        	LDA	ssptr_h		; get string start high byte
00195F  1  C9 08        	CMP	#((BASICBEGIN & $FF00) >>8)  ; compare with BASICBEGIN, FORMERLY (Ram_base_HI) start of program memory
001961  1  B0 0B        	BCS	LAB_RTST		; branch if not in utility area
001963  1               
001963  1               					; string in utility area, move to string memory
001963  1  98           	TYA				; copy length to A
001964  1  20 1B 19     	JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
001967  1               					; long
001967  1  A6 B8        	LDX	ssptr_l		; get string start low byte
001969  1  A4 B9        	LDY	ssptr_h		; get string start high byte
00196B  1  20 08 1B     	JSR	LAB_2298		; store string A bytes long from XY to (Sutill)
00196E  1               
00196E  1               ; check for space on descriptor stack then ..
00196E  1               ; put string address and length on descriptor stack and update stack pointers
00196E  1               
00196E  1               LAB_RTST
00196E  1  A6 65        	LDX	next_s		; get string stack pointer
001970  1  E0 71        	CPX	#des_sk+$09		; compare with max+1
001972  1  D0 05        	BNE	LAB_20F8		; branch if space on string stack
001974  1               
001974  1               					; else do string too complex error
001974  1  A2 1C        	LDX	#$1C			; error code $1C ("String too complex" error)
001976  1               LAB_20F5
001976  1  4C 27 09     	JMP	LAB_XERR		; do error #X, then warm start
001979  1               
001979  1               ; put string address and length on descriptor stack and update stack pointers
001979  1               
001979  1               LAB_20F8
001979  1  A5 AC        	LDA	str_ln		; get string length
00197B  1  95 00        	STA	PLUS_0,X		; put on string stack
00197D  1  A5 AD        	LDA	str_pl		; get string pointer low byte
00197F  1  95 01        	STA	PLUS_1,X		; put on string stack
001981  1  A5 AE        	LDA	str_ph		; get string pointer high byte
001983  1  95 02        	STA	PLUS_2,X		; put on string stack
001985  1  A0 00        	LDY	#$00			; clear Y
001987  1  86 AE        	STX	des_pl		; save string descriptor pointer low byte
001989  1  84 AF        	STY	des_ph		; save string descriptor pointer high byte (always $00)
00198B  1  88           	DEY				; Y = $FF
00198C  1  84 5F        	STY	Dtypef		; save data type flag, $FF=string
00198E  1  86 66        	STX	last_sl		; save old stack pointer (current top item)
001990  1  E8           	INX				; update stack pointer
001991  1  E8           	INX				; update stack pointer
001992  1  E8           	INX				; update stack pointer
001993  1  86 65        	STX	next_s		; save new top item value
001995  1  60           	RTS
001996  1               
001996  1               ; Build descriptor
001996  1               ; make space in string memory for string A long
001996  1               ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
001996  1               
001996  1               LAB_2115
001996  1  46 60        	LSR	Gclctd		; clear garbage collected flag (b7)
001998  1               
001998  1               					; make space for string A long
001998  1               LAB_2117
001998  1  48           	PHA				; save string length
001999  1  49 FF        	EOR	#$FF			; complement it
00199B  1  38           	SEC				; set carry for subtract (twos comp add)
00199C  1  65 81        	ADC	Sstorl		; add bottom of string space low byte (subtract length)
00199E  1  A4 82        	LDY	Sstorh		; get bottom of string space high byte
0019A0  1  B0 01        	BCS	LAB_2122		; skip decrement if no underflow
0019A2  1               
0019A2  1  88           	DEY				; decrement bottom of string space high byte
0019A3  1               LAB_2122
0019A3  1  C4 80        	CPY	Earryh		; compare with array mem end high byte
0019A5  1  90 11        	BCC	LAB_2137		; do out of memory error if less
0019A7  1               
0019A7  1  D0 04        	BNE	LAB_212C		; if not = skip next test
0019A9  1               
0019A9  1  C5 7F        	CMP	Earryl		; compare with array mem end low byte
0019AB  1  90 0B        	BCC	LAB_2137		; do out of memory error if less
0019AD  1               
0019AD  1               LAB_212C
0019AD  1  85 81        	STA	Sstorl		; save bottom of string space low byte
0019AF  1  84 82        	STY	Sstorh		; save bottom of string space high byte
0019B1  1  85 83        	STA	Sutill		; save string utility ptr low byte
0019B3  1  84 84        	STY	Sutilh		; save string utility ptr high byte
0019B5  1  AA           	TAX				; copy low byte to X
0019B6  1  68           	PLA				; get string length back
0019B7  1  60           	RTS
0019B8  1               
0019B8  1               LAB_2137
0019B8  1  A2 0C        	LDX	#$0C			; error code $0C ("Out of memory" error)
0019BA  1  A5 60        	LDA	Gclctd		; get garbage collected flag
0019BC  1  30 B8        	BMI	LAB_20F5		; if set then do error code X
0019BE  1               
0019BE  1  20 C8 19     	JSR	LAB_GARB		; else go do garbage collection
0019C1  1  A9 80        	LDA	#$80			; flag for garbage collected
0019C3  1  85 60        	STA	Gclctd		; set garbage collected flag
0019C5  1  68           	PLA				; pull length
0019C6  1  D0 D0        	BNE	LAB_2117		; go try again (loop always, length should never be = $00)
0019C8  1               
0019C8  1               ; garbage collection routine
0019C8  1               
0019C8  1               LAB_GARB
0019C8  1  A6 85        	LDX	Ememl			; get end of mem low byte
0019CA  1  A5 86        	LDA	Ememh			; get end of mem high byte
0019CC  1               
0019CC  1               ; re-run routine from last ending
0019CC  1               
0019CC  1               LAB_214B
0019CC  1  86 81        	STX	Sstorl		; set string storage low byte
0019CE  1  85 82        	STA	Sstorh		; set string storage high byte
0019D0  1  A0 00        	LDY	#$00			; clear index
0019D2  1  84 9D        	STY	garb_h		; clear working pointer high byte (flag no strings to move)
0019D4  1  A5 7F        	LDA	Earryl		; get array mem end low byte
0019D6  1  A6 80        	LDX	Earryh		; get array mem end high byte
0019D8  1  85 AA        	STA	Histrl		; save as highest string low byte
0019DA  1  86 AB        	STX	Histrh		; save as highest string high byte
0019DC  1  A9 68        	LDA	#des_sk		; set descriptor stack pointer
0019DE  1  85 71        	STA	ut1_pl		; save descriptor stack pointer low byte
0019E0  1  84 72        	STY	ut1_ph		; save descriptor stack pointer high byte ($00)
0019E2  1               LAB_2161
0019E2  1  C5 65        	CMP	next_s		; compare with descriptor stack pointer
0019E4  1  F0 05        	BEQ	LAB_216A		; branch if =
0019E6  1               
0019E6  1  20 4C 1A     	JSR	LAB_21D7		; go garbage collect descriptor stack
0019E9  1  F0 F7        	BEQ	LAB_2161		; loop always
0019EB  1               
0019EB  1               					; done stacked strings, now do string vars
0019EB  1               LAB_216A
0019EB  1  06 A0        	ASL	g_step		; set step size = $06
0019ED  1  A5 7B        	LDA	Svarl			; get start of vars low byte
0019EF  1  A6 7C        	LDX	Svarh			; get start of vars high byte
0019F1  1  85 71        	STA	ut1_pl		; save as pointer low byte
0019F3  1  86 72        	STX	ut1_ph		; save as pointer high byte
0019F5  1               LAB_2176
0019F5  1  E4 7E        	CPX	Sarryh		; compare start of arrays high byte
0019F7  1  D0 04        	BNE	LAB_217E		; branch if no high byte match
0019F9  1               
0019F9  1  C5 7D        	CMP	Sarryl		; else compare start of arrays low byte
0019FB  1  F0 05        	BEQ	LAB_2183		; branch if = var mem end
0019FD  1               
0019FD  1               LAB_217E
0019FD  1  20 46 1A     	JSR	LAB_21D1		; go garbage collect strings
001A00  1  F0 F3        	BEQ	LAB_2176		; loop always
001A02  1               
001A02  1               					; done string vars, now do string arrays
001A02  1               LAB_2183
001A02  1  85 A4        	STA	Nbendl		; save start of arrays low byte as working pointer
001A04  1  86 A5        	STX	Nbendh		; save start of arrays high byte as working pointer
001A06  1  A9 04        	LDA	#$04			; set step size
001A08  1  85 A0        	STA	g_step		; save step size
001A0A  1               LAB_218B
001A0A  1  A5 A4        	LDA	Nbendl		; get pointer low byte
001A0C  1  A6 A5        	LDX	Nbendh		; get pointer high byte
001A0E  1               LAB_218F
001A0E  1  E4 80        	CPX	Earryh		; compare with array mem end high byte
001A10  1  D0 04        	BNE	LAB_219A		; branch if not at end
001A12  1               
001A12  1  C5 7F        	CMP	Earryl		; else compare with array mem end low byte
001A14  1  F0 75        	BEQ	LAB_2216		; tidy up and exit if at end
001A16  1               
001A16  1               LAB_219A
001A16  1  85 71        	STA	ut1_pl		; save pointer low byte
001A18  1  86 72        	STX	ut1_ph		; save pointer high byte
001A1A  1  A0 02        	LDY	#$02			; set index
001A1C  1  B1 71        	LDA	(ut1_pl),Y		; get array size low byte
001A1E  1  65 A4        	ADC	Nbendl		; add start of this array low byte
001A20  1  85 A4        	STA	Nbendl		; save start of next array low byte
001A22  1  C8           	INY				; increment index
001A23  1  B1 71        	LDA	(ut1_pl),Y		; get array size high byte
001A25  1  65 A5        	ADC	Nbendh		; add start of this array high byte
001A27  1  85 A5        	STA	Nbendh		; save start of next array high byte
001A29  1  A0 01        	LDY	#$01			; set index
001A2B  1  B1 71        	LDA	(ut1_pl),Y		; get name second byte
001A2D  1  10 DB        	BPL	LAB_218B		; skip if not string array
001A2F  1               
001A2F  1               ; was string array so ..
001A2F  1               
001A2F  1  A0 04        	LDY	#$04			; set index
001A31  1  B1 71        	LDA	(ut1_pl),Y		; get # of dimensions
001A33  1  0A           	ASL	A			; *2
001A34  1  69 05        	ADC	#$05			; +5 (array header size)
001A36  1  20 7E 1A     	JSR	LAB_2208		; go set up for first element
001A39  1               LAB_21C4
001A39  1  E4 A5        	CPX	Nbendh		; compare with start of next array high byte
001A3B  1  D0 04        	BNE	LAB_21CC		; branch if <> (go do this array)
001A3D  1               
001A3D  1  C5 A4        	CMP	Nbendl		; else compare element pointer low byte with next array
001A3F  1               					; low byte
001A3F  1  F0 CD        	BEQ	LAB_218F		; if equal then go do next array
001A41  1               
001A41  1               LAB_21CC
001A41  1  20 4C 1A     	JSR	LAB_21D7		; go defrag array strings
001A44  1  F0 F3        	BEQ	LAB_21C4		; go do next array string (loop always)
001A46  1               
001A46  1               ; defrag string variables
001A46  1               ; enter with XA = variable pointer
001A46  1               ; return with XA = next variable pointer
001A46  1               
001A46  1               LAB_21D1
001A46  1  C8           	INY				; increment index (Y was $00)
001A47  1  B1 71        	LDA	(ut1_pl),Y		; get var name byte 2
001A49  1  10 30        	BPL	LAB_2206		; if not string, step pointer to next var and return
001A4B  1               
001A4B  1  C8           	INY				; else increment index
001A4C  1               LAB_21D7
001A4C  1  B1 71        	LDA	(ut1_pl),Y		; get string length
001A4E  1  F0 2B        	BEQ	LAB_2206		; if null, step pointer to next string and return
001A50  1               
001A50  1  C8           	INY				; else increment index
001A51  1  B1 71        	LDA	(ut1_pl),Y		; get string pointer low byte
001A53  1  AA           	TAX				; copy to X
001A54  1  C8           	INY				; increment index
001A55  1  B1 71        	LDA	(ut1_pl),Y		; get string pointer high byte
001A57  1  C5 82        	CMP	Sstorh		; compare bottom of string space high byte
001A59  1  90 06        	BCC	LAB_21EC		; branch if less
001A5B  1               
001A5B  1  D0 1E        	BNE	LAB_2206		; if greater, step pointer to next string and return
001A5D  1               
001A5D  1               					; high bytes were = so compare low bytes
001A5D  1  E4 81        	CPX	Sstorl		; compare bottom of string space low byte
001A5F  1  B0 1A        	BCS	LAB_2206		; if >=, step pointer to next string and return
001A61  1               
001A61  1               					; string pointer is < string storage pointer (pos in mem)
001A61  1               LAB_21EC
001A61  1  C5 AB        	CMP	Histrh		; compare to highest string high byte
001A63  1  90 17        	BCC	LAB_2207		; if <, step pointer to next string and return
001A65  1               
001A65  1  D0 04        	BNE	LAB_21F6		; if > update pointers, step to next and return
001A67  1               
001A67  1               					; high bytes were = so compare low bytes
001A67  1  E4 AA        	CPX	Histrl		; compare to highest string low byte
001A69  1  90 11        	BCC	LAB_2207		; if <, step pointer to next string and return
001A6B  1               
001A6B  1               					; string is in string memory space
001A6B  1               LAB_21F6
001A6B  1  86 AA        	STX	Histrl		; save as new highest string low byte
001A6D  1  85 AB        	STA	Histrh		; save as new highest string high byte
001A6F  1  A5 71        	LDA	ut1_pl		; get start of vars(descriptors) low byte
001A71  1  A6 72        	LDX	ut1_ph		; get start of vars(descriptors) high byte
001A73  1  85 9C        	STA	garb_l		; save as working pointer low byte
001A75  1  86 9D        	STX	garb_h		; save as working pointer high byte
001A77  1  88           	DEY				; decrement index DIFFERS
001A78  1  88           	DEY				; decrement index (should point to descriptor start)
001A79  1  84 A2        	STY	g_indx		; save index pointer
001A7B  1               
001A7B  1               					; step pointer to next string
001A7B  1               LAB_2206
001A7B  1  18           	CLC				; clear carry for add
001A7C  1               LAB_2207
001A7C  1  A5 A0        	LDA	g_step		; get step size
001A7E  1               LAB_2208
001A7E  1  65 71        	ADC	ut1_pl		; add pointer low byte
001A80  1  85 71        	STA	ut1_pl		; save pointer low byte
001A82  1  90 02        	BCC	LAB_2211		; branch if no overflow
001A84  1               
001A84  1  E6 72        	INC	ut1_ph		; else increment high byte
001A86  1               LAB_2211
001A86  1  A6 72        	LDX	ut1_ph		; get pointer high byte
001A88  1  A0 00        	LDY	#$00			; clear Y
001A8A  1  60           	RTS
001A8B  1               
001A8B  1               ; search complete, now either exit or set-up and move string
001A8B  1               
001A8B  1               LAB_2216
001A8B  1  C6 A0        	DEC	g_step		; decrement step size (now $03 for descriptor stack)
001A8D  1  A6 9D        	LDX	garb_h		; get string to move high byte
001A8F  1  F0 F5        	BEQ	LAB_2211		; exit if nothing to move
001A91  1               
001A91  1  A4 A2        	LDY	g_indx		; get index byte back (points to descriptor)
001A93  1  18           	CLC				; clear carry for add
001A94  1  B1 9C        	LDA	(garb_l),Y		; get string length
001A96  1  65 AA        	ADC	Histrl		; add highest string low byte
001A98  1  85 A6        	STA	Obendl		; save old block end low pointer
001A9A  1  A5 AB        	LDA	Histrh		; get highest string high byte
001A9C  1  69 00        	ADC	#$00			; add any carry
001A9E  1  85 A7        	STA	Obendh		; save old block end high byte
001AA0  1  A5 81        	LDA	Sstorl		; get bottom of string space low byte
001AA2  1  A6 82        	LDX	Sstorh		; get bottom of string space high byte
001AA4  1  85 A4        	STA	Nbendl		; save new block end low byte
001AA6  1  86 A5        	STX	Nbendh		; save new block end high byte
001AA8  1  20 B3 08     	JSR	LAB_11D6		; open up space in memory, don't set array end
001AAB  1  A4 A2        	LDY	g_indx		; get index byte
001AAD  1  C8           	INY				; point to descriptor low byte
001AAE  1  A5 A4        	LDA	Nbendl		; get string pointer low byte
001AB0  1  91 9C        	STA	(garb_l),Y		; save new string pointer low byte
001AB2  1  AA           	TAX				; copy string pointer low byte
001AB3  1  E6 A5        	INC	Nbendh		; correct high byte (move sets high byte -1)
001AB5  1  A5 A5        	LDA	Nbendh		; get new string pointer high byte
001AB7  1  C8           	INY				; point to descriptor high byte
001AB8  1  91 9C        	STA	(garb_l),Y		; save new string pointer high byte
001ABA  1  4C CC 19     	JMP	LAB_214B		; re-run routine from last ending
001ABD  1               					; (but don't collect this string)
001ABD  1               
001ABD  1               ; concatenate
001ABD  1               ; add strings, string 1 is in descriptor des_pl, string 2 is in line
001ABD  1               
001ABD  1               LAB_224D
001ABD  1  A5 AF        	LDA	des_ph		; get descriptor pointer high byte
001ABF  1  48           	PHA				; put on stack
001AC0  1  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
001AC2  1  48           	PHA				; put on stack
001AC3  1  20 B6 13     	JSR	LAB_GVAL		; get value from line
001AC6  1  20 BB 12     	JSR	LAB_CTST		; check if source is string, else do type mismatch
001AC9  1  68           	PLA				; get descriptor pointer low byte back
001ACA  1  85 B8        	STA	ssptr_l		; set pointer low byte
001ACC  1  68           	PLA				; get descriptor pointer high byte back
001ACD  1  85 B9        	STA	ssptr_h		; set pointer high byte
001ACF  1  A0 00        	LDY	#$00			; clear index
001AD1  1  B1 B8        	LDA	(ssptr_l),Y		; get length_1 from descriptor
001AD3  1  18           	CLC				; clear carry for add
001AD4  1  71 AE        	ADC	(des_pl),Y		; add length_2
001AD6  1  90 05        	BCC	LAB_226D		; branch if no overflow
001AD8  1               
001AD8  1  A2 1A        	LDX	#$1A			; else set error code $1A ("String too long" error)
001ADA  1  4C 27 09     	JMP	LAB_XERR		; do error #X, then warm start
001ADD  1               
001ADD  1               LAB_226D
001ADD  1  20 1B 19     	JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
001AE0  1               					; long
001AE0  1  20 FA 1A     	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
001AE3  1  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
001AE5  1  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
001AE7  1  20 2B 1B     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
001AEA  1               					; returns with A = length, ut1_pl = pointer low byte,
001AEA  1               					; ut1_ph = pointer high byte
001AEA  1  20 0C 1B     	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
001AED  1  A5 B8        	LDA	ssptr_l		;.set descriptor pointer low byte
001AEF  1  A4 B9        	LDY	ssptr_h		;.set descriptor pointer high byte
001AF1  1  20 2B 1B     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
001AF4  1               					; returns with A = length, X=ut1_pl=pointer low byte,
001AF4  1               					; Y=ut1_ph=pointer high byte
001AF4  1  20 6E 19     	JSR	LAB_RTST		; check for space on descriptor stack then put string
001AF7  1               					; address and length on descriptor stack and update stack
001AF7  1               					; pointers
001AF7  1  4C E1 12     	JMP	LAB_1ADB		;.continue evaluation
001AFA  1               
001AFA  1               ; copy string from descriptor (sdescr) to (Sutill)
001AFA  1               
001AFA  1               LAB_228A
001AFA  1  A0 00        	LDY	#$00			; clear index
001AFC  1  B1 B8        	LDA	(sdescr),Y		; get string length
001AFE  1  48           	PHA				; save on stack
001AFF  1  C8           	INY				; increment index
001B00  1  B1 B8        	LDA	(sdescr),Y		; get source string pointer low byte
001B02  1  AA           	TAX				; copy to X
001B03  1  C8           	INY				; increment index
001B04  1  B1 B8        	LDA	(sdescr),Y		; get source string pointer high byte
001B06  1  A8           	TAY				; copy to Y
001B07  1  68           	PLA				; get length back
001B08  1               
001B08  1               ; store string A bytes long from YX to (Sutill)
001B08  1               
001B08  1               LAB_2298
001B08  1  86 71        	STX	ut1_pl		; save source string pointer low byte
001B0A  1  84 72        	STY	ut1_ph		; save source string pointer high byte
001B0C  1               
001B0C  1               ; store string A bytes long from (ut1_pl) to (Sutill)
001B0C  1               
001B0C  1               LAB_229C
001B0C  1  AA           	TAX				; copy length to index (don't count with Y)
001B0D  1  F0 14        	BEQ	LAB_22B2		; branch if = $0 (null string) no need to add zero length
001B0F  1               
001B0F  1  A0 00        	LDY	#$00			; zero pointer (copy forward)
001B11  1               LAB_22A0
001B11  1  B1 71        	LDA	(ut1_pl),Y		; get source byte
001B13  1  91 83        	STA	(Sutill),Y		; save destination byte
001B15  1               
001B15  1  C8           	INY				; increment index
001B16  1  CA           	DEX				; decrement counter
001B17  1  D0 F8        	BNE	LAB_22A0		; loop while <> 0
001B19  1               
001B19  1  98           	TYA				; restore length from Y
001B1A  1               LAB_22A9
001B1A  1  18           	CLC				; clear carry for add
001B1B  1  65 83        	ADC	Sutill		; add string utility ptr low byte
001B1D  1  85 83        	STA	Sutill		; save string utility ptr low byte
001B1F  1  90 02        	BCC	LAB_22B2		; branch if no carry
001B21  1               
001B21  1  E6 84        	INC	Sutilh		; else increment string utility ptr high byte
001B23  1               LAB_22B2
001B23  1  60           	RTS
001B24  1               
001B24  1               ; evaluate string
001B24  1               
001B24  1               LAB_EVST
001B24  1  20 BB 12     	JSR	LAB_CTST		; check if source is string, else do type mismatch
001B27  1               
001B27  1               ; pop string off descriptor stack, or from top of string space
001B27  1               ; returns with A = length, X=pointer low byte, Y=pointer high byte
001B27  1               
001B27  1               LAB_22B6
001B27  1  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
001B29  1  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
001B2B  1               
001B2B  1               ; pop (YA) descriptor off stack or from top of string space
001B2B  1               ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
001B2B  1               
001B2B  1               LAB_22BA
001B2B  1  85 71        	STA	ut1_pl		; save descriptor pointer low byte
001B2D  1  84 72        	STY	ut1_ph		; save descriptor pointer high byte
001B2F  1  20 5C 1B     	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
001B32  1  08           	PHP				; save status flags
001B33  1  A0 00        	LDY	#$00			; clear index
001B35  1  B1 71        	LDA	(ut1_pl),Y		; get length from string descriptor
001B37  1  48           	PHA				; put on stack
001B38  1  C8           	INY				; increment index
001B39  1  B1 71        	LDA	(ut1_pl),Y		; get string pointer low byte from descriptor
001B3B  1  AA           	TAX				; copy to X
001B3C  1  C8           	INY				; increment index
001B3D  1  B1 71        	LDA	(ut1_pl),Y		; get string pointer high byte from descriptor
001B3F  1  A8           	TAY				; copy to Y
001B40  1  68           	PLA				; get string length back
001B41  1  28           	PLP				; restore status
001B42  1  D0 13        	BNE	LAB_22E6		; branch if pointer <> last_sl,last_sh
001B44  1               
001B44  1  C4 82        	CPY	Sstorh		; compare bottom of string space high byte
001B46  1  D0 0F        	BNE	LAB_22E6		; branch if <>
001B48  1               
001B48  1  E4 81        	CPX	Sstorl		; else compare bottom of string space low byte
001B4A  1  D0 0B        	BNE	LAB_22E6		; branch if <>
001B4C  1               
001B4C  1  48           	PHA				; save string length
001B4D  1  18           	CLC				; clear carry for add
001B4E  1  65 81        	ADC	Sstorl		; add bottom of string space low byte
001B50  1  85 81        	STA	Sstorl		; save bottom of string space low byte
001B52  1  90 02        	BCC	LAB_22E5		; skip increment if no overflow
001B54  1               
001B54  1  E6 82        	INC	Sstorh		; increment bottom of string space high byte
001B56  1               LAB_22E5
001B56  1  68           	PLA				; restore string length
001B57  1               LAB_22E6
001B57  1  86 71        	STX	ut1_pl		; save string pointer low byte
001B59  1  84 72        	STY	ut1_ph		; save string pointer high byte
001B5B  1  60           	RTS
001B5C  1               
001B5C  1               ; clean descriptor stack, YA = pointer
001B5C  1               ; checks if AY is on the descriptor stack, if so does a stack discard
001B5C  1               
001B5C  1               LAB_22EB
001B5C  1  C4 67        	CPY	last_sh		; compare pointer high byte
001B5E  1  D0 0C        	BNE	LAB_22FB		; exit if <>
001B60  1               
001B60  1  C5 66        	CMP	last_sl		; compare pointer low byte
001B62  1  D0 08        	BNE	LAB_22FB		; exit if <>
001B64  1               
001B64  1  85 65        	STA	next_s		; save descriptor stack pointer
001B66  1  E9 03        	SBC	#$03			; -3
001B68  1  85 66        	STA	last_sl		; save low byte -3
001B6A  1  A0 00        	LDY	#$00			; clear high byte
001B6C  1               LAB_22FB
001B6C  1  60           	RTS
001B6D  1               
001B6D  1               ; perform CHR$()
001B6D  1               
001B6D  1               LAB_CHRS
001B6D  1  20 78 1C     	JSR	LAB_EVBY		; evaluate byte expression, result in X
001B70  1  8A           	TXA				; copy to A
001B71  1  48           	PHA				; save character
001B72  1  A9 01        	LDA	#$01			; string is single byte
001B74  1  20 23 19     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
001B77  1               					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
001B77  1  68           	PLA				; get character back
001B78  1  A0 00        	LDY	#$00			; clear index
001B7A  1  91 AD        	STA	(str_pl),Y		; save byte in string (byte IS string!)
001B7C  1  4C 6E 19     	JMP	LAB_RTST		; check for space on descriptor stack then put string
001B7F  1               					; address and length on descriptor stack and update stack
001B7F  1               					; pointers
001B7F  1               
001B7F  1               ; perform LEFT$()
001B7F  1               
001B7F  1               LAB_LEFT
001B7F  1  48           	PHA				; push byte parameter
001B80  1  20 E0 1B     	JSR	LAB_236F		; pull string data and byte parameter from stack
001B83  1               					; return pointer in des_2l/h, byte in A (and X), Y=0
001B83  1  D1 9E        	CMP	(des_2l),Y		; compare byte parameter with string length
001B85  1  98           	TYA				; clear A
001B86  1  F0 09        	BEQ	LAB_2316		; go do string copy (branch always)
001B88  1               
001B88  1               ; perform RIGHT$()
001B88  1               
001B88  1               LAB_RIGHT
001B88  1  48           	PHA				; push byte parameter
001B89  1  20 E0 1B     	JSR	LAB_236F		; pull string data and byte parameter from stack
001B8C  1               					; return pointer in des_2l/h, byte in A (and X), Y=0
001B8C  1  18           	CLC				; clear carry for add-1
001B8D  1  F1 9E        	SBC	(des_2l),Y		; subtract string length
001B8F  1  49 FF        	EOR	#$FF			; invert it (A=LEN(expression$)-l)
001B91  1               
001B91  1               LAB_2316
001B91  1  90 04        	BCC	LAB_231C		; branch if string length > byte parameter
001B93  1               
001B93  1  B1 9E        	LDA	(des_2l),Y		; else make parameter = length
001B95  1  AA           	TAX				; copy to byte parameter copy
001B96  1  98           	TYA				; clear string start offset
001B97  1               LAB_231C
001B97  1  48           	PHA				; save string start offset
001B98  1               LAB_231D
001B98  1  8A           	TXA				; copy byte parameter (or string length if <)
001B99  1               LAB_231E
001B99  1  48           	PHA				; save string length
001B9A  1  20 23 19     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
001B9D  1               					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
001B9D  1  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
001B9F  1  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
001BA1  1  20 2B 1B     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
001BA4  1               					; returns with A = length, X=ut1_pl=pointer low byte,
001BA4  1               					; Y=ut1_ph=pointer high byte
001BA4  1  68           	PLA				; get string length back
001BA5  1  A8           	TAY				; copy length to Y
001BA6  1  68           	PLA				; get string start offset back
001BA7  1  18           	CLC				; clear carry for add
001BA8  1  65 71        	ADC	ut1_pl		; add start offset to string start pointer low byte
001BAA  1  85 71        	STA	ut1_pl		; save string start pointer low byte
001BAC  1  90 02        	BCC	LAB_2335		; branch if no overflow
001BAE  1               
001BAE  1  E6 72        	INC	ut1_ph		; else increment string start pointer high byte
001BB0  1               LAB_2335
001BB0  1  98           	TYA				; copy length to A
001BB1  1  20 0C 1B     	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
001BB4  1  4C 6E 19     	JMP	LAB_RTST		; check for space on descriptor stack then put string
001BB7  1               					; address and length on descriptor stack and update stack
001BB7  1               					; pointers
001BB7  1               
001BB7  1               ; perform MID$()
001BB7  1               
001BB7  1               LAB_MIDS
001BB7  1  48           	PHA				; push byte parameter
001BB8  1  A9 FF        	LDA	#$FF			; set default length = 255
001BBA  1  85 AF        	STA	mids_l		; save default length
001BBC  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
001BBF  1  C9 29        	CMP	#')'			; compare with ")"
001BC1  1  F0 06        	BEQ	LAB_2358		; branch if = ")" (skip second byte get)
001BC3  1               
001BC3  1  20 E7 13     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
001BC6  1  20 75 1C     	JSR	LAB_GTBY		; get byte parameter (use copy in mids_l)
001BC9  1               LAB_2358
001BC9  1  20 E0 1B     	JSR	LAB_236F		; pull string data and byte parameter from stack
001BCC  1               					; return pointer in des_2l/h, byte in A (and X), Y=0
001BCC  1  CA           	DEX				; decrement start index
001BCD  1  8A           	TXA				; copy to A
001BCE  1  48           	PHA				; save string start offset
001BCF  1  18           	CLC				; clear carry for sub-1
001BD0  1  A2 00        	LDX	#$00			; clear output string length
001BD2  1  F1 9E        	SBC	(des_2l),Y		; subtract string length
001BD4  1  B0 C2        	BCS	LAB_231D		; if start>string length go do null string
001BD6  1               
001BD6  1  49 FF        	EOR	#$FF			; complement -length
001BD8  1  C5 AF        	CMP	mids_l		; compare byte parameter
001BDA  1  90 BD        	BCC	LAB_231E		; if length>remaining string go do RIGHT$
001BDC  1               
001BDC  1  A5 AF        	LDA	mids_l		; get length byte
001BDE  1  B0 B9        	BCS	LAB_231E		; go do string copy (branch always)
001BE0  1               
001BE0  1               ; pull string data and byte parameter from stack
001BE0  1               ; return pointer in des_2l/h, byte in A (and X), Y=0
001BE0  1               
001BE0  1               LAB_236F
001BE0  1  20 D8 13     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
001BE3  1  68           	PLA				; pull return address low byte (return address)
001BE4  1  85 A2        	STA	Fnxjpl		; save functions jump vector low byte
001BE6  1  68           	PLA				; pull return address high byte (return address)
001BE7  1  85 A3        	STA	Fnxjph		; save functions jump vector high byte
001BE9  1  68           	PLA				; pull byte parameter
001BEA  1  AA           	TAX				; copy byte parameter to X
001BEB  1  68           	PLA				; pull string pointer low byte
001BEC  1  85 9E        	STA	des_2l		; save it
001BEE  1  68           	PLA				; pull string pointer high byte
001BEF  1  85 9F        	STA	des_2h		; save it
001BF1  1  A0 00        	LDY	#$00			; clear index
001BF3  1  8A           	TXA				; copy byte parameter
001BF4  1  F0 79        	BEQ	LAB_23A8		; if null do function call error then warm start
001BF6  1               
001BF6  1  E6 A2        	INC	Fnxjpl		; increment function jump vector low byte
001BF8  1               					; (JSR pushes return addr-1. this is all very nice
001BF8  1               					; but will go tits up if either call is on a page
001BF8  1               					; boundary!)
001BF8  1  6C A2 00     	JMP	(Fnxjpl)		; in effect, RTS
001BFB  1               
001BFB  1               ; perform LCASE$()
001BFB  1               
001BFB  1               LAB_LCASE
001BFB  1  20 24 1B     	JSR	LAB_EVST		; evaluate string
001BFE  1  85 AC        	STA	str_ln		; set string length
001C00  1  A8           	TAY				; copy length to Y
001C01  1  F0 38        	BEQ	NoString		; branch if null string
001C03  1               
001C03  1  20 23 19     	JSR	LAB_MSSP		; make string space A bytes long A=length,
001C06  1               					; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
001C06  1  86 AD        	STX	str_pl		; save string pointer low byte
001C08  1  84 AE        	STY	str_ph		; save string pointer high byte
001C0A  1  A8           	TAY				; get string length back
001C0B  1               
001C0B  1               LC_loop
001C0B  1  88           	DEY				; decrement index
001C0C  1  B1 71        	LDA	(ut1_pl),Y		; get byte from string
001C0E  1  20 0B 16     	JSR	LAB_1D82		; is character "A" to "Z"
001C11  1  90 02        	BCC	NoUcase		; branch if not upper case alpha
001C13  1               
001C13  1  09 20        	ORA	#$20			; convert upper to lower case
001C15  1               NoUcase
001C15  1  91 83        	STA	(Sutill),Y		; save byte back to string
001C17  1  98           	TYA				; test index
001C18  1  D0 F1        	BNE	LC_loop		; loop if not all done
001C1A  1               
001C1A  1  F0 1F        	BEQ	NoString		; tidy up and exit, branch always
001C1C  1               
001C1C  1               ; perform UCASE$()
001C1C  1               
001C1C  1               LAB_UCASE
001C1C  1  20 24 1B     	JSR	LAB_EVST		; evaluate string
001C1F  1  85 AC        	STA	str_ln		; set string length
001C21  1  A8           	TAY				; copy length to Y
001C22  1  F0 17        	BEQ	NoString		; branch if null string
001C24  1               
001C24  1  20 23 19     	JSR	LAB_MSSP		; make string space A bytes long A=length,
001C27  1               					; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
001C27  1  86 AD        	STX	str_pl		; save string pointer low byte
001C29  1  84 AE        	STY	str_ph		; save string pointer high byte
001C2B  1  A8           	TAY				; get string length back
001C2C  1               
001C2C  1               UC_loop
001C2C  1  88           	DEY				; decrement index
001C2D  1  B1 71        	LDA	(ut1_pl),Y		; get byte from string
001C2F  1  20 07 16     	JSR	LAB_CASC		; is character "a" to "z" (or "A" to "Z")
001C32  1  90 02        	BCC	NoLcase		; branch if not alpha
001C34  1               
001C34  1  29 DF        	AND	#$DF			; convert lower to upper case
001C36  1               NoLcase
001C36  1  91 83        	STA	(Sutill),Y		; save byte back to string
001C38  1  98           	TYA				; test index
001C39  1  D0 F1        	BNE	UC_loop		; loop if not all done
001C3B  1               
001C3B  1               NoString
001C3B  1  4C 6E 19     	JMP	LAB_RTST		; check for space on descriptor stack then put string
001C3E  1               					; address and length on descriptor stack and update stack
001C3E  1               					; pointers
001C3E  1               
001C3E  1               ; perform SADD()
001C3E  1               
001C3E  1               LAB_SADD
001C3E  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
001C41  1  20 93 15     	JSR	LAB_GVAR		; get var address
001C44  1               
001C44  1  20 D8 13     	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
001C47  1  20 BB 12     	JSR	LAB_CTST		; check if source is string, else do type mismatch
001C4A  1               
001C4A  1  A0 02        	LDY	#$02			; index to string pointer high byte
001C4C  1  B1 95        	LDA	(Cvaral),Y		; get string pointer high byte
001C4E  1  AA           	TAX				; copy string pointer high byte to X
001C4F  1  88           	DEY				; index to string pointer low byte
001C50  1  B1 95        	LDA	(Cvaral),Y		; get string pointer low byte
001C52  1  A8           	TAY				; copy string pointer low byte to Y
001C53  1  8A           	TXA				; copy string pointer high byte to A
001C54  1  4C 42 18     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
001C57  1               
001C57  1               ; perform LEN()
001C57  1               
001C57  1               LAB_LENS
001C57  1  20 5D 1C     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
001C5A  1  4C 4F 18     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
001C5D  1               
001C5D  1               ; evaluate string, get length in Y
001C5D  1               
001C5D  1               LAB_ESGL
001C5D  1  20 24 1B     	JSR	LAB_EVST		; evaluate string
001C60  1  A8           	TAY				; copy length to Y
001C61  1  60           	RTS
001C62  1               
001C62  1               ; perform ASC()
001C62  1               
001C62  1               LAB_ASC
001C62  1  20 5D 1C     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
001C65  1  F0 08        	BEQ	LAB_23A8		; if null do function call error then warm start
001C67  1               
001C67  1  A0 00        	LDY	#$00			; set index to first character
001C69  1  B1 71        	LDA	(ut1_pl),Y		; get byte
001C6B  1  A8           	TAY				; copy to Y
001C6C  1  4C 4F 18     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
001C6F  1               
001C6F  1               ; do function call error then warm start
001C6F  1               
001C6F  1               LAB_23A8
001C6F  1  4C 12 17     	JMP	LAB_FCER		; do function call error then warm start
001C72  1               
001C72  1               ; scan and get byte parameter
001C72  1               
001C72  1               LAB_SGBY
001C72  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
001C75  1               
001C75  1               ; get byte parameter
001C75  1               
001C75  1               LAB_GTBY
001C75  1  20 B6 12     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
001C78  1               					; else do type mismatch
001C78  1               
001C78  1               ; evaluate byte expression, result in X
001C78  1               
001C78  1               LAB_EVBY
001C78  1  20 8B 16     	JSR	LAB_EVPI		; evaluate integer expression (no check)
001C7B  1               
001C7B  1  A4 AE        	LDY	FAC1_2		; get FAC1 mantissa2
001C7D  1  D0 F0        	BNE	LAB_23A8		; if top byte <> 0 do function call error then warm start
001C7F  1               
001C7F  1  A6 AF        	LDX	FAC1_3		; get FAC1 mantissa3
001C81  1  4C C2 00     	JMP	LAB_GBYT		; scan memory and return
001C84  1               
001C84  1               ; perform VAL()
001C84  1               
001C84  1               LAB_VAL
001C84  1  20 5D 1C     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
001C87  1  D0 03        	BNE	LAB_23C5		; branch if not null string
001C89  1               
001C89  1               					; string was null so set result = $00
001C89  1  4C 39 1E     	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
001C8C  1               
001C8C  1               LAB_23C5
001C8C  1  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
001C8E  1  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
001C90  1  86 BA        	STX	Btmpl			; save BASIC execute pointer low byte
001C92  1  84 BB        	STY	Btmph			; save BASIC execute pointer high byte
001C94  1  A6 71        	LDX	ut1_pl		; get string pointer low byte
001C96  1  86 C3        	STX	Bpntrl		; save as BASIC execute pointer low byte
001C98  1  18           	CLC				; clear carry
001C99  1  65 71        	ADC	ut1_pl		; add string length
001C9B  1  85 73        	STA	ut2_pl		; save string end low byte
001C9D  1  A5 72        	LDA	ut1_ph		; get string pointer high byte
001C9F  1  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
001CA1  1  69 00        	ADC	#$00			; add carry to high byte
001CA3  1  85 74        	STA	ut2_ph		; save string end high byte
001CA5  1  A0 00        	LDY	#$00			; set index to $00
001CA7  1  B1 73        	LDA	(ut2_pl),Y		; get string end +1 byte
001CA9  1  48           	PHA				; push it
001CAA  1  98           	TYA				; clear A
001CAB  1  91 73        	STA	(ut2_pl),Y		; terminate string with $00
001CAD  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
001CB0  1  20 8F 21     	JSR	LAB_2887		; get FAC1 from string
001CB3  1  68           	PLA				; restore string end +1 byte
001CB4  1  A0 00        	LDY	#$00			; set index to zero
001CB6  1  91 73        	STA	(ut2_pl),Y		; put string end byte back
001CB8  1               
001CB8  1               ; restore BASIC execute pointer from temp (Btmpl/Btmph)
001CB8  1               
001CB8  1               LAB_23F3
001CB8  1  A6 BA        	LDX	Btmpl			; get BASIC execute pointer low byte back
001CBA  1  A4 BB        	LDY	Btmph			; get BASIC execute pointer high byte back
001CBC  1  86 C3        	STX	Bpntrl		; save BASIC execute pointer low byte
001CBE  1  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
001CC0  1  60           	RTS
001CC1  1               
001CC1  1               ; get two parameters for POKE or WAIT
001CC1  1               
001CC1  1               LAB_GADB
001CC1  1  20 B6 12     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
001CC4  1               					; else do type mismatch
001CC4  1  20 DA 1C     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
001CC7  1               
001CC7  1               ; scan for "," and get byte, else do Syntax error then warm start
001CC7  1               
001CC7  1               LAB_SCGB
001CC7  1  20 E7 13     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
001CCA  1  A5 12        	LDA	Itemph		; save temporary integer high byte
001CCC  1  48           	PHA				; on stack
001CCD  1  A5 11        	LDA	Itempl		; save temporary integer low byte
001CCF  1  48           	PHA				; on stack
001CD0  1  20 75 1C     	JSR	LAB_GTBY		; get byte parameter
001CD3  1  68           	PLA				; pull low byte
001CD4  1  85 11        	STA	Itempl		; restore temporary integer low byte
001CD6  1  68           	PLA				; pull high byte
001CD7  1  85 12        	STA	Itemph		; restore temporary integer high byte
001CD9  1  60           	RTS
001CDA  1               
001CDA  1               ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
001CDA  1               ; -ve and converts it into a right truncated integer in Itempl and Itemph
001CDA  1               
001CDA  1               ; save unsigned 16 bit integer part of FAC1 in temporary integer
001CDA  1               
001CDA  1               LAB_F2FX
001CDA  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
001CDC  1  C9 98        	CMP	#$98			; compare with exponent = 2^24
001CDE  1  B0 8F        	BCS	LAB_23A8		; if >= do function call error then warm start
001CE0  1               
001CE0  1               LAB_F2FU
001CE0  1  20 39 21     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
001CE3  1  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
001CE5  1  A4 AF        	LDY	FAC1_3		; get FAC1 mantissa3
001CE7  1  84 11        	STY	Itempl		; save temporary integer low byte
001CE9  1  85 12        	STA	Itemph		; save temporary integer high byte
001CEB  1  60           	RTS
001CEC  1               
001CEC  1               ; perform PEEK()
001CEC  1               
001CEC  1               LAB_PEEK
001CEC  1  20 DA 1C     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
001CEF  1  A2 00        	LDX	#$00			; clear index
001CF1  1  A1 11        	LDA	(Itempl,X)		; get byte via temporary integer (addr)
001CF3  1  A8           	TAY				; copy byte to Y
001CF4  1  4C 4F 18     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
001CF7  1               
001CF7  1               ; perform POKE
001CF7  1               
001CF7  1               LAB_POKE
001CF7  1  20 C1 1C     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
001CFA  1  8A           	TXA				; copy byte argument to A
001CFB  1  A2 00        	LDX	#$00			; clear index
001CFD  1  81 11        	STA	(Itempl,X)		; save byte via temporary integer (addr)
001CFF  1  60           	RTS
001D00  1               
001D00  1               ; perform DEEK()
001D00  1               
001D00  1               LAB_DEEK
001D00  1  20 DA 1C     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
001D03  1  A2 00        	LDX	#$00			; clear index
001D05  1  A1 11        	LDA	(Itempl,X)		; PEEK low byte
001D07  1  A8           	TAY				; copy to Y
001D08  1  E6 11        	INC	Itempl		; increment pointer low byte
001D0A  1  D0 02        	BNE	Deekh			; skip high increment if no rollover
001D0C  1               
001D0C  1  E6 12        	INC	Itemph		; increment pointer high byte
001D0E  1               Deekh
001D0E  1  A1 11        	LDA	(Itempl,X)		; PEEK high byte
001D10  1  4C 42 18     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
001D13  1               
001D13  1               ; perform DOKE
001D13  1               
001D13  1               LAB_DOKE
001D13  1  20 B6 12     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
001D16  1               					; else do type mismatch
001D16  1  20 DA 1C     	JSR	LAB_F2FX		; convert floating-to-fixed
001D19  1               
001D19  1  84 97        	STY	Frnxtl		; save pointer low byte (float to fixed returns word in AY)
001D1B  1  85 98        	STA	Frnxth		; save pointer high byte
001D1D  1               
001D1D  1  20 E7 13     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
001D20  1  20 B6 12     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
001D23  1               					; else do type mismatch
001D23  1  20 DA 1C     	JSR	LAB_F2FX		; convert floating-to-fixed
001D26  1               
001D26  1  98           	TYA				; copy value low byte (float to fixed returns word in AY)
001D27  1  A2 00        	LDX	#$00			; clear index
001D29  1  81 97        	STA	(Frnxtl,X)		; POKE low byte
001D2B  1  E6 97        	INC	Frnxtl		; increment pointer low byte
001D2D  1  D0 02        	BNE	Dokeh			; skip high increment if no rollover
001D2F  1               
001D2F  1  E6 98        	INC	Frnxth		; increment pointer high byte
001D31  1               Dokeh
001D31  1  A5 12        	LDA	Itemph		; get value high byte
001D33  1  81 97        	STA	(Frnxtl,X)		; POKE high byte
001D35  1  4C C2 00     	JMP	LAB_GBYT		; scan memory and return
001D38  1               
001D38  1               ; perform SWAP
001D38  1               
001D38  1               LAB_SWAP
001D38  1  20 93 15     	JSR	LAB_GVAR		; get var1 address
001D3B  1  85 97        	STA	Lvarpl		; save var1 address low byte
001D3D  1  84 98        	STY	Lvarph		; save var1 address high byte
001D3F  1  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
001D41  1  48           	PHA				; save data type flag
001D42  1               
001D42  1  20 E7 13     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
001D45  1  20 93 15     	JSR	LAB_GVAR		; get var2 address (pointer in Cvaral/h)
001D48  1  68           	PLA				; pull var1 data type flag
001D49  1  45 5F        	EOR	Dtypef		; compare with var2 data type
001D4B  1  10 10        	BPL	SwapErr		; exit if not both the same type
001D4D  1               
001D4D  1  A0 03        	LDY	#$03			; four bytes to swap (either value or descriptor+1)
001D4F  1               SwapLp
001D4F  1  B1 97        	LDA	(Lvarpl),Y		; get byte from var1
001D51  1  AA           	TAX				; save var1 byte
001D52  1  B1 95        	LDA	(Cvaral),Y		; get byte from var2
001D54  1  91 97        	STA	(Lvarpl),Y		; save byte to var1
001D56  1  8A           	TXA				; restore var1 byte
001D57  1  91 95        	STA	(Cvaral),Y		; save byte to var2
001D59  1  88           	DEY				; decrement index
001D5A  1  10 F3        	BPL	SwapLp		; loop until done
001D5C  1               
001D5C  1  60           	RTS
001D5D  1               
001D5D  1               SwapErr
001D5D  1  4C C5 12     	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
001D60  1               
001D60  1               ; perform CALL
001D60  1               
001D60  1               LAB_CALL
001D60  1  20 B6 12     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
001D63  1               					; else do type mismatch
001D63  1  20 DA 1C     	JSR	LAB_F2FX		; convert floating-to-fixed
001D66  1  A9 1D        	LDA	#CallExit_HI		; set return address high byte
001D68  1  48           	PHA				; put on stack
001D69  1  A9 6E        	LDA	#CallExit_LO-1	; set return address low byte
001D6B  1  48           	PHA				; put on stack
001D6C  1  6C 11 00     	JMP	(Itempl)		; do indirect jump to user routine
001D6F  1               
001D6F  1               ; if the called routine exits correctly then it will return to here. this will then get
001D6F  1               ; the next byte for the interpreter and return
001D6F  1               
001D6F  1               CallExit
001D6F  1  4C C2 00     	JMP	LAB_GBYT		; scan memory and return
001D72  1               
001D72  1               ; perform WAIT
001D72  1               
001D72  1               LAB_WAIT
001D72  1  20 C1 1C     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
001D75  1  86 97        	STX	Frnxtl		; save byte
001D77  1  A2 00        	LDX	#$00			; clear mask
001D79  1  20 C2 00     	JSR	LAB_GBYT		; scan memory
001D7C  1  F0 03        	BEQ	LAB_2441		; skip if no third argument
001D7E  1               
001D7E  1  20 C7 1C     	JSR	LAB_SCGB		; scan for "," and get byte, else SN error then warm start
001D81  1               LAB_2441
001D81  1  86 98        	STX	Frnxth		; save EOR argument
001D83  1               LAB_2445
001D83  1  B1 11        	LDA	(Itempl),Y		; get byte via temporary integer (addr)
001D85  1  45 98        	EOR	Frnxth		; EOR with second argument (mask)
001D87  1  25 97        	AND	Frnxtl		; AND with first argument (byte)
001D89  1  F0 F8        	BEQ	LAB_2445		; loop if result is zero
001D8B  1               
001D8B  1               LAB_244D
001D8B  1  60           	RTS
001D8C  1               
001D8C  1               ; perform subtraction, FAC1 from (AY)
001D8C  1               
001D8C  1               LAB_2455
001D8C  1  20 74 1F     	JSR	LAB_264D		; unpack memory (AY) into FAC2
001D8F  1               
001D8F  1               ; perform subtraction, FAC1 from FAC2
001D8F  1               
001D8F  1               LAB_SUBTRACT
001D8F  1  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
001D91  1  49 FF        	EOR	#$FF			; complement it
001D93  1  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
001D95  1  45 B7        	EOR	FAC2_s		; EOR with FAC2 sign (b7)
001D97  1  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
001D99  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
001D9B  1  4C AA 1D     	JMP	LAB_ADD		; go add FAC2 to FAC1
001D9E  1               
001D9E  1               ; perform addition
001D9E  1               
001D9E  1               LAB_2467
001D9E  1  20 C3 1E     	JSR	LAB_257B		; shift FACX A times right (>8 shifts)
001DA1  1  90 4D        	BCC	LAB_24A8		;.go subtract mantissas
001DA3  1               
001DA3  1               ; add 0.5 to FAC1
001DA3  1               
001DA3  1               LAB_244E
001DA3  1  A9 C9        	LDA	#LAB_2A96_LO		; set 0.5 pointer low byte
001DA5  1  A0 29        	LDY	#LAB_2A96_HI		; set 0.5 pointer high byte
001DA7  1               
001DA7  1               ; add (AY) to FAC1
001DA7  1               
001DA7  1               LAB_246C
001DA7  1  20 74 1F     	JSR	LAB_264D		; unpack memory (AY) into FAC2
001DAA  1               
001DAA  1               ; add FAC2 to FAC1
001DAA  1               
001DAA  1               LAB_ADD
001DAA  1  D0 10        	BNE	LAB_2474		; branch if FAC1 was not zero
001DAC  1               
001DAC  1               ; copy FAC2 to FAC1
001DAC  1               
001DAC  1               LAB_279B
001DAC  1  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
001DAE  1               
001DAE  1               ; save FAC1 sign and copy ABS(FAC2) to FAC1
001DAE  1               
001DAE  1               LAB_279D
001DAE  1  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
001DB0  1  A2 04        	LDX	#$04			; 4 bytes to copy
001DB2  1               LAB_27A1
001DB2  1  B5 B2        	LDA	FAC1_o,X		; get byte from FAC2,X
001DB4  1  95 AB        	STA	FAC1_e-1,X		; save byte at FAC1,X
001DB6  1  CA           	DEX				; decrement count
001DB7  1  D0 F9        	BNE	LAB_27A1		; loop if not all done
001DB9  1               
001DB9  1  86 B9        	STX	FAC1_r		; clear FAC1 rounding byte
001DBB  1  60           	RTS
001DBC  1               
001DBC  1               					; FAC1 is non zero
001DBC  1               LAB_2474
001DBC  1  A6 B9        	LDX	FAC1_r		; get FAC1 rounding byte
001DBE  1  86 A3        	STX	FAC2_r		; save as FAC2 rounding byte
001DC0  1  A2 B3        	LDX	#FAC2_e		; set index to FAC2 exponent addr
001DC2  1  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
001DC4  1               LAB_247C
001DC4  1  A8           	TAY				; copy exponent
001DC5  1  F0 C4        	BEQ	LAB_244D		; exit if zero
001DC7  1               
001DC7  1  38           	SEC				; set carry for subtract
001DC8  1  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent
001DCA  1  F0 24        	BEQ	LAB_24A8		; branch if = (go add mantissa)
001DCC  1               
001DCC  1  90 12        	BCC	LAB_2498		; branch if <
001DCE  1               
001DCE  1               					; FAC2>FAC1
001DCE  1  84 AC        	STY	FAC1_e		; save FAC1 exponent
001DD0  1  A4 B7        	LDY	FAC2_s		; get FAC2 sign (b7)
001DD2  1  84 B0        	STY	FAC1_s		; save FAC1 sign (b7)
001DD4  1  49 FF        	EOR	#$FF			; complement A
001DD6  1  69 00        	ADC	#$00			; +1 (twos complement, carry is set)
001DD8  1  A0 00        	LDY	#$00			; clear Y
001DDA  1  84 A3        	STY	FAC2_r		; clear FAC2 rounding byte
001DDC  1  A2 AC        	LDX	#FAC1_e		; set index to FAC1 exponent addr
001DDE  1  D0 04        	BNE	LAB_249C		; branch always
001DE0  1               
001DE0  1               LAB_2498
001DE0  1  A0 00        	LDY	#$00			; clear Y
001DE2  1  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
001DE4  1               LAB_249C
001DE4  1  C9 F9        	CMP	#$F9			; compare exponent diff with $F9
001DE6  1  30 B6        	BMI	LAB_2467		; branch if range $79-$F8
001DE8  1               
001DE8  1  A8           	TAY				; copy exponent difference to Y
001DE9  1  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
001DEB  1  56 01        	LSR	PLUS_1,X		; shift FAC? mantissa1
001DED  1  20 DA 1E     	JSR	LAB_2592		; shift FACX Y times right
001DF0  1               
001DF0  1               					; exponents are equal now do mantissa subtract
001DF0  1               LAB_24A8
001DF0  1  24 B8        	BIT	FAC_sc		; test sign compare (FAC1 EOR FAC2)
001DF2  1  10 4C        	BPL	LAB_24F8		; if = add FAC2 mantissa to FAC1 mantissa and return
001DF4  1               
001DF4  1  A0 AC        	LDY	#FAC1_e		; set index to FAC1 exponent addr
001DF6  1  E0 B3        	CPX	#FAC2_e		; compare X to FAC2 exponent addr
001DF8  1  F0 02        	BEQ	LAB_24B4		; branch if =
001DFA  1               
001DFA  1  A0 B3        	LDY	#FAC2_e		; else set index to FAC2 exponent addr
001DFC  1               
001DFC  1               					; subtract smaller from bigger (take sign of bigger)
001DFC  1               LAB_24B4
001DFC  1  38           	SEC				; set carry for subtract
001DFD  1  49 FF        	EOR	#$FF			; ones complement A
001DFF  1  65 A3        	ADC	FAC2_r		; add FAC2 rounding byte
001E01  1  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
001E03  1  B9 03 00     	LDA	PLUS_3,Y		; get FACY mantissa3
001E06  1  F5 03        	SBC	PLUS_3,X		; subtract FACX mantissa3
001E08  1  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
001E0A  1  B9 02 00     	LDA	PLUS_2,Y		; get FACY mantissa2
001E0D  1  F5 02        	SBC	PLUS_2,X		; subtract FACX mantissa2
001E0F  1  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
001E11  1  B9 01 00     	LDA	PLUS_1,Y		; get FACY mantissa1
001E14  1  F5 01        	SBC	PLUS_1,X		; subtract FACX mantissa1
001E16  1  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
001E18  1               
001E18  1               ; do ABS and normalise FAC1
001E18  1               
001E18  1               LAB_24D0
001E18  1  B0 03        	BCS	LAB_24D5		; branch if number is +ve
001E1A  1               
001E1A  1  20 7F 1E     	JSR	LAB_2537		; negate FAC1
001E1D  1               
001E1D  1               ; normalise FAC1
001E1D  1               
001E1D  1               LAB_24D5
001E1D  1  A0 00        	LDY	#$00			; clear Y
001E1F  1  98           	TYA				; clear A
001E20  1  18           	CLC				; clear carry for add
001E21  1               LAB_24D9
001E21  1  A6 AD        	LDX	FAC1_1		; get FAC1 mantissa1
001E23  1  D0 3E        	BNE	LAB_251B		; if not zero normalise FAC1
001E25  1               
001E25  1  A6 AE        	LDX	FAC1_2		; get FAC1 mantissa2
001E27  1  86 AD        	STX	FAC1_1		; save FAC1 mantissa1
001E29  1  A6 AF        	LDX	FAC1_3		; get FAC1 mantissa3
001E2B  1  86 AE        	STX	FAC1_2		; save FAC1 mantissa2
001E2D  1  A6 B9        	LDX	FAC1_r		; get FAC1 rounding byte
001E2F  1  86 AF        	STX	FAC1_3		; save FAC1 mantissa3
001E31  1  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
001E33  1  69 08        	ADC	#$08			; add x to exponent offset
001E35  1  C9 18        	CMP	#$18			; compare with $18 (max offset, all bits would be =0)
001E37  1  D0 E8        	BNE	LAB_24D9		; loop if not max
001E39  1               
001E39  1               ; clear FAC1 exponent and sign
001E39  1               
001E39  1               LAB_24F1
001E39  1  A9 00        	LDA	#$00			; clear A
001E3B  1               LAB_24F3
001E3B  1  85 AC        	STA	FAC1_e		; set FAC1 exponent
001E3D  1               
001E3D  1               ; save FAC1 sign
001E3D  1               
001E3D  1               LAB_24F5
001E3D  1  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
001E3F  1  60           	RTS
001E40  1               
001E40  1               ; add FAC2 mantissa to FAC1 mantissa
001E40  1               
001E40  1               LAB_24F8
001E40  1  65 A3        	ADC	FAC2_r		; add FAC2 rounding byte
001E42  1  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
001E44  1  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
001E46  1  65 B6        	ADC	FAC2_3		; add FAC2 mantissa3
001E48  1  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
001E4A  1  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
001E4C  1  65 B5        	ADC	FAC2_2		; add FAC2 mantissa2
001E4E  1  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
001E50  1  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
001E52  1  65 B4        	ADC	FAC2_1		; add FAC2 mantissa1
001E54  1  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
001E56  1  B0 1A        	BCS	LAB_252A		; if carry then normalise FAC1 for C=1
001E58  1               
001E58  1  60           	RTS				; else just exit
001E59  1               
001E59  1               LAB_2511
001E59  1  69 01        	ADC	#$01			; add 1 to exponent offset
001E5B  1  06 B9        	ASL	FAC1_r		; shift FAC1 rounding byte
001E5D  1  26 AF        	ROL	FAC1_3		; shift FAC1 mantissa3
001E5F  1  26 AE        	ROL	FAC1_2		; shift FAC1 mantissa2
001E61  1  26 AD        	ROL	FAC1_1		; shift FAC1 mantissa1
001E63  1               
001E63  1               ; normalise FAC1
001E63  1               
001E63  1               LAB_251B
001E63  1  10 F4        	BPL	LAB_2511		; loop if not normalised
001E65  1               
001E65  1  38           	SEC				; set carry for subtract
001E66  1  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent
001E68  1  B0 CF        	BCS	LAB_24F1		; branch if underflow (set result = $0)
001E6A  1               
001E6A  1  49 FF        	EOR	#$FF			; complement exponent
001E6C  1  69 01        	ADC	#$01			; +1 (twos complement)
001E6E  1  85 AC        	STA	FAC1_e		; save FAC1 exponent
001E70  1               
001E70  1               ; test and normalise FAC1 for C=0/1
001E70  1               
001E70  1               LAB_2528
001E70  1  90 0C        	BCC	LAB_2536		; exit if no overflow
001E72  1               
001E72  1               ; normalise FAC1 for C=1
001E72  1               
001E72  1               LAB_252A
001E72  1  E6 AC        	INC	FAC1_e		; increment FAC1 exponent
001E74  1  F0 36        	BEQ	LAB_2564		; if zero do overflow error and warm start
001E76  1               
001E76  1  66 AD        	ROR	FAC1_1		; shift FAC1 mantissa1
001E78  1  66 AE        	ROR	FAC1_2		; shift FAC1 mantissa2
001E7A  1  66 AF        	ROR	FAC1_3		; shift FAC1 mantissa3
001E7C  1  66 B9        	ROR	FAC1_r		; shift FAC1 rounding byte
001E7E  1               LAB_2536
001E7E  1  60           	RTS
001E7F  1               
001E7F  1               ; negate FAC1
001E7F  1               
001E7F  1               LAB_2537
001E7F  1  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
001E81  1  49 FF        	EOR	#$FF			; complement it
001E83  1  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
001E85  1               
001E85  1               ; twos complement FAC1 mantissa
001E85  1               
001E85  1               LAB_253D
001E85  1  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
001E87  1  49 FF        	EOR	#$FF			; complement it
001E89  1  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
001E8B  1  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
001E8D  1  49 FF        	EOR	#$FF			; complement it
001E8F  1  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
001E91  1  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
001E93  1  49 FF        	EOR	#$FF			; complement it
001E95  1  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
001E97  1  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
001E99  1  49 FF        	EOR	#$FF			; complement it
001E9B  1  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
001E9D  1  E6 B9        	INC	FAC1_r		; increment FAC1 rounding byte
001E9F  1  D0 0A        	BNE	LAB_2563		; exit if no overflow
001EA1  1               
001EA1  1               ; increment FAC1 mantissa
001EA1  1               
001EA1  1               LAB_2559
001EA1  1  E6 AF        	INC	FAC1_3		; increment FAC1 mantissa3
001EA3  1  D0 06        	BNE	LAB_2563		; finished if no rollover
001EA5  1               
001EA5  1  E6 AE        	INC	FAC1_2		; increment FAC1 mantissa2
001EA7  1  D0 02        	BNE	LAB_2563		; finished if no rollover
001EA9  1               
001EA9  1  E6 AD        	INC	FAC1_1		; increment FAC1 mantissa1
001EAB  1               LAB_2563
001EAB  1  60           	RTS
001EAC  1               
001EAC  1               ; do overflow error (overflow exit)
001EAC  1               
001EAC  1               LAB_2564
001EAC  1  A2 0A        	LDX	#$0A			; error code $0A ("Overflow" error)
001EAE  1  4C 27 09     	JMP	LAB_XERR		; do error #X, then warm start
001EB1  1               
001EB1  1               ; shift FCAtemp << A+8 times
001EB1  1               
001EB1  1               LAB_2569
001EB1  1  A2 74        	LDX	#FACt_1-1		; set offset to FACtemp
001EB3  1               LAB_256B
001EB3  1  B4 03        	LDY	PLUS_3,X		; get FACX mantissa3
001EB5  1  84 B9        	STY	FAC1_r		; save as FAC1 rounding byte
001EB7  1  B4 02        	LDY	PLUS_2,X		; get FACX mantissa2
001EB9  1  94 03        	STY	PLUS_3,X		; save FACX mantissa3
001EBB  1  B4 01        	LDY	PLUS_1,X		; get FACX mantissa1
001EBD  1  94 02        	STY	PLUS_2,X		; save FACX mantissa2
001EBF  1  A4 B2        	LDY	FAC1_o		; get FAC1 overflow byte
001EC1  1  94 01        	STY	PLUS_1,X		; save FACX mantissa1
001EC3  1               
001EC3  1               ; shift FACX -A times right (> 8 shifts)
001EC3  1               
001EC3  1               LAB_257B
001EC3  1  69 08        	ADC	#$08			; add 8 to shift count
001EC5  1  30 EC        	BMI	LAB_256B		; go do 8 shift if still -ve
001EC7  1               
001EC7  1  F0 EA        	BEQ	LAB_256B		; go do 8 shift if zero
001EC9  1               
001EC9  1  E9 08        	SBC	#$08			; else subtract 8 again
001ECB  1  A8           	TAY				; save count to Y
001ECC  1  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
001ECE  1  B0 12        	BCS	LAB_259A		;.
001ED0  1               
001ED0  1               LAB_2588
001ED0  1  16 01        	ASL	PLUS_1,X		; shift FACX mantissa1
001ED2  1  90 02        	BCC	LAB_258E		; branch if +ve
001ED4  1               
001ED4  1  F6 01        	INC	PLUS_1,X		; this sets b7 eventually
001ED6  1               LAB_258E
001ED6  1  76 01        	ROR	PLUS_1,X		; shift FACX mantissa1 (correct for ASL)
001ED8  1  76 01        	ROR	PLUS_1,X		; shift FACX mantissa1 (put carry in b7)
001EDA  1               
001EDA  1               ; shift FACX Y times right
001EDA  1               
001EDA  1               LAB_2592
001EDA  1  76 02        	ROR	PLUS_2,X		; shift FACX mantissa2
001EDC  1  76 03        	ROR	PLUS_3,X		; shift FACX mantissa3
001EDE  1  6A           	ROR	A			; shift FACX rounding byte
001EDF  1  C8           	INY				; increment exponent diff
001EE0  1  D0 EE        	BNE	LAB_2588		; branch if range adjust not complete
001EE2  1               
001EE2  1               LAB_259A
001EE2  1  18           	CLC				; just clear it
001EE3  1  60           	RTS
001EE4  1               
001EE4  1               ; perform LOG()
001EE4  1               
001EE4  1               LAB_LOG
001EE4  1  20 D2 20     	JSR	LAB_27CA		; test sign and zero
001EE7  1  F0 02        	BEQ	LAB_25C4		; if zero do function call error then warm start
001EE9  1               
001EE9  1  10 03        	BPL	LAB_25C7		; skip error if +ve
001EEB  1               
001EEB  1               LAB_25C4
001EEB  1  4C 12 17     	JMP	LAB_FCER		; do function call error then warm start (-ve)
001EEE  1               
001EEE  1               LAB_25C7
001EEE  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
001EF0  1  E9 7F        	SBC	#$7F			; normalise it
001EF2  1  48           	PHA				; save it
001EF3  1  A9 80        	LDA	#$80			; set exponent to zero
001EF5  1  85 AC        	STA	FAC1_e		; save FAC1 exponent
001EF7  1  A9 49        	LDA	#LAB_25AD_LO		; set 1/root2 pointer low byte
001EF9  1  A0 29        	LDY	#LAB_25AD_HI		; set 1/root2 pointer high byte
001EFB  1  20 A7 1D     	JSR	LAB_246C		; add (AY) to FAC1 (1/root2)
001EFE  1  A9 4D        	LDA	#LAB_25B1_LO		; set root2 pointer low byte
001F00  1  A0 29        	LDY	#LAB_25B1_HI		; set root2 pointer high byte
001F02  1  20 EA 1F     	JSR	LAB_26CA		; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
001F05  1  A9 C0        	LDA	#LAB_259C_LO		; set 1 pointer low byte
001F07  1  A0 29        	LDY	#LAB_259C_HI		; set 1 pointer high byte
001F09  1  20 8C 1D     	JSR	LAB_2455		; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
001F0C  1  A9 3C        	LDA	#LAB_25A0_LO		; set pointer low byte to counter
001F0E  1  A0 29        	LDY	#LAB_25A0_HI		; set pointer high byte to counter
001F10  1  20 3D 24     	JSR	LAB_2B6E		; ^2 then series evaluation
001F13  1  A9 51        	LDA	#LAB_25B5_LO		; set -0.5 pointer low byte
001F15  1  A0 29        	LDY	#LAB_25B5_HI		; set -0.5 pointer high byte
001F17  1  20 A7 1D     	JSR	LAB_246C		; add (AY) to FAC1
001F1A  1  68           	PLA				; restore FAC1 exponent
001F1B  1  20 31 22     	JSR	LAB_2912		; evaluate new ASCII digit
001F1E  1  A9 55        	LDA	#LAB_25B9_LO		; set LOG(2) pointer low byte
001F20  1  A0 29        	LDY	#LAB_25B9_HI		; set LOG(2) pointer high byte
001F22  1               
001F22  1               ; do convert AY, FCA1*(AY)
001F22  1               
001F22  1               LAB_25FB
001F22  1  20 74 1F     	JSR	LAB_264D		; unpack memory (AY) into FAC2
001F25  1               LAB_MULTIPLY
001F25  1  F0 4C        	BEQ	LAB_264C		; exit if zero
001F27  1               
001F27  1  20 9A 1F     	JSR	LAB_2673		; test and adjust accumulators
001F2A  1  A9 00        	LDA	#$00			; clear A
001F2C  1  85 75        	STA	FACt_1		; clear temp mantissa1
001F2E  1  85 76        	STA	FACt_2		; clear temp mantissa2
001F30  1  85 77        	STA	FACt_3		; clear temp mantissa3
001F32  1  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
001F34  1  20 49 1F     	JSR	LAB_2622		; go do shift/add FAC2
001F37  1  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
001F39  1  20 49 1F     	JSR	LAB_2622		; go do shift/add FAC2
001F3C  1  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
001F3E  1  20 49 1F     	JSR	LAB_2622		; go do shift/add FAC2
001F41  1  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
001F43  1  20 4E 1F     	JSR	LAB_2627		; go do shift/add FAC2
001F46  1  4C 57 20     	JMP	LAB_273C		; copy temp to FAC1, normalise and return
001F49  1               
001F49  1               LAB_2622
001F49  1  D0 03        	BNE	LAB_2627		; branch if byte <> zero
001F4B  1               
001F4B  1  4C B1 1E     	JMP	LAB_2569		; shift FCAtemp << A+8 times
001F4E  1               
001F4E  1               					; else do shift and add
001F4E  1               LAB_2627
001F4E  1  4A           	LSR	A			; shift byte
001F4F  1  09 80        	ORA	#$80			; set top bit (mark for 8 times)
001F51  1               LAB_262A
001F51  1  A8           	TAY				; copy result
001F52  1  90 13        	BCC	LAB_2640		; skip next if bit was zero
001F54  1               
001F54  1  18           	CLC				; clear carry for add
001F55  1  A5 77        	LDA	FACt_3		; get temp mantissa3
001F57  1  65 B6        	ADC	FAC2_3		; add FAC2 mantissa3
001F59  1  85 77        	STA	FACt_3		; save temp mantissa3
001F5B  1  A5 76        	LDA	FACt_2		; get temp mantissa2
001F5D  1  65 B5        	ADC	FAC2_2		; add FAC2 mantissa2
001F5F  1  85 76        	STA	FACt_2		; save temp mantissa2
001F61  1  A5 75        	LDA	FACt_1		; get temp mantissa1
001F63  1  65 B4        	ADC	FAC2_1		; add FAC2 mantissa1
001F65  1  85 75        	STA	FACt_1		; save temp mantissa1
001F67  1               LAB_2640
001F67  1  66 75        	ROR	FACt_1		; shift temp mantissa1
001F69  1  66 76        	ROR	FACt_2		; shift temp mantissa2
001F6B  1  66 77        	ROR	FACt_3		; shift temp mantissa3
001F6D  1  66 B9        	ROR	FAC1_r		; shift temp rounding byte
001F6F  1  98           	TYA				; get byte back
001F70  1  4A           	LSR	A			; shift byte
001F71  1  D0 DE        	BNE	LAB_262A		; loop if all bits not done
001F73  1               
001F73  1               LAB_264C
001F73  1  60           	RTS
001F74  1               
001F74  1               ; unpack memory (AY) into FAC2
001F74  1               
001F74  1               LAB_264D
001F74  1  85 71        	STA	ut1_pl		; save pointer low byte
001F76  1  84 72        	STY	ut1_ph		; save pointer high byte
001F78  1  A0 03        	LDY	#$03			; 4 bytes to get (0-3)
001F7A  1  B1 71        	LDA	(ut1_pl),Y		; get mantissa3
001F7C  1  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
001F7E  1  88           	DEY				; decrement index
001F7F  1  B1 71        	LDA	(ut1_pl),Y		; get mantissa2
001F81  1  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
001F83  1  88           	DEY				; decrement index
001F84  1  B1 71        	LDA	(ut1_pl),Y		; get mantissa1+sign
001F86  1  85 B7        	STA	FAC2_s		; save FAC2 sign (b7)
001F88  1  45 B0        	EOR	FAC1_s		; EOR with FAC1 sign (b7)
001F8A  1  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
001F8C  1  A5 B7        	LDA	FAC2_s		; recover FAC2 sign (b7)
001F8E  1  09 80        	ORA	#$80			; set 1xxx xxx (set normal bit)
001F90  1  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
001F92  1  88           	DEY				; decrement index
001F93  1  B1 71        	LDA	(ut1_pl),Y		; get exponent byte
001F95  1  85 B3        	STA	FAC2_e		; save FAC2 exponent
001F97  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
001F99  1  60           	RTS
001F9A  1               
001F9A  1               ; test and adjust accumulators
001F9A  1               
001F9A  1               LAB_2673
001F9A  1  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
001F9C  1               LAB_2675
001F9C  1  F0 1D        	BEQ	LAB_2696		; branch if FAC2 = $00 (handle underflow)
001F9E  1               
001F9E  1  18           	CLC				; clear carry for add
001F9F  1  65 AC        	ADC	FAC1_e		; add FAC1 exponent
001FA1  1  90 04        	BCC	LAB_2680		; branch if sum of exponents <$0100
001FA3  1               
001FA3  1  30 31        	BMI	LAB_269B		; do overflow error
001FA5  1               
001FA5  1  18           	CLC				; clear carry for the add
001FA6  1  2C           	.byte	$2C			; makes next line BIT $1410
001FA7  1               LAB_2680
001FA7  1  10 12        	BPL	LAB_2696		; if +ve go handle underflow
001FA9  1               
001FA9  1  69 80        	ADC	#$80			; adjust exponent
001FAB  1  85 AC        	STA	FAC1_e		; save FAC1 exponent
001FAD  1  D0 03        	BNE	LAB_268B		; branch if not zero
001FAF  1               
001FAF  1  4C 3D 1E     	JMP	LAB_24F5		; save FAC1 sign and return
001FB2  1               
001FB2  1               LAB_268B
001FB2  1  A5 B8        	LDA	FAC_sc		; get sign compare (FAC1 EOR FAC2)
001FB4  1  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
001FB6  1               LAB_268F
001FB6  1  60           	RTS
001FB7  1               
001FB7  1               ; handle overflow and underflow
001FB7  1               
001FB7  1               LAB_2690
001FB7  1  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
001FB9  1  10 1B        	BPL	LAB_269B		; do overflow error
001FBB  1               
001FBB  1               					; handle underflow
001FBB  1               LAB_2696
001FBB  1  68           	PLA				; pop return address low byte
001FBC  1  68           	PLA				; pop return address high byte
001FBD  1  4C 39 1E     	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
001FC0  1               
001FC0  1               ; multiply by 10
001FC0  1               
001FC0  1               LAB_269E
001FC0  1  20 B3 20     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
001FC3  1  AA           	TAX				; copy exponent (set the flags)
001FC4  1  F0 F0        	BEQ	LAB_268F		; exit if zero
001FC6  1               
001FC6  1  18           	CLC				; clear carry for add
001FC7  1  69 02        	ADC	#$02			; add two to exponent (*4)
001FC9  1  B0 0B        	BCS	LAB_269B		; do overflow error if > $FF
001FCB  1               
001FCB  1  A2 00        	LDX	#$00			; clear byte
001FCD  1  86 B8        	STX	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
001FCF  1  20 C4 1D     	JSR	LAB_247C		; add FAC2 to FAC1 (*5)
001FD2  1  E6 AC        	INC	FAC1_e		; increment FAC1 exponent (*10)
001FD4  1  D0 E0        	BNE	LAB_268F		; if non zero just do RTS
001FD6  1               
001FD6  1               LAB_269B
001FD6  1  4C AC 1E     	JMP	LAB_2564		; do overflow error and warm start
001FD9  1               
001FD9  1               ; divide by 10
001FD9  1               
001FD9  1               LAB_26B9
001FD9  1  20 B3 20     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
001FDC  1  A9 D1        	LDA	#LAB_26B5_LO		; set pointer to 10d low addr
001FDE  1  A0 29        	LDY	#LAB_26B5_HI		; set pointer to 10d high addr
001FE0  1  A2 00        	LDX	#$00			; clear sign
001FE2  1               
001FE2  1               ; divide by (AY) (X=sign)
001FE2  1               
001FE2  1               LAB_26C2
001FE2  1  86 B8        	STX	FAC_sc		; save sign compare (FAC1 EOR FAC2)
001FE4  1  20 66 20     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
001FE7  1  4C ED 1F     	JMP	LAB_DIVIDE		; do FAC2/FAC1
001FEA  1               
001FEA  1               					; Perform divide-by
001FEA  1               ; convert AY and do (AY)/FAC1
001FEA  1               
001FEA  1               LAB_26CA
001FEA  1  20 74 1F     	JSR	LAB_264D		; unpack memory (AY) into FAC2
001FED  1               
001FED  1               					; Perform divide-into
001FED  1               LAB_DIVIDE
001FED  1  F0 63        	BEQ	LAB_2737		; if zero go do /0 error
001FEF  1               
001FEF  1  20 C2 20     	JSR	LAB_27BA		; round FAC1
001FF2  1  A9 00        	LDA	#$00			; clear A
001FF4  1  38           	SEC				; set carry for subtract
001FF5  1  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent (2s complement)
001FF7  1  85 AC        	STA	FAC1_e		; save FAC1 exponent
001FF9  1  20 9A 1F     	JSR	LAB_2673		; test and adjust accumulators
001FFC  1  E6 AC        	INC	FAC1_e		; increment FAC1 exponent
001FFE  1  F0 D6        	BEQ	LAB_269B		; if zero do overflow error
002000  1               
002000  1  A2 FF        	LDX	#$FF			; set index for pre increment
002002  1  A9 01        	LDA	#$01			; set bit to flag byte save
002004  1               LAB_26E4
002004  1  A4 B4        	LDY	FAC2_1		; get FAC2 mantissa1
002006  1  C4 AD        	CPY	FAC1_1		; compare FAC1 mantissa1
002008  1  D0 0A        	BNE	LAB_26F4		; branch if <>
00200A  1               
00200A  1  A4 B5        	LDY	FAC2_2		; get FAC2 mantissa2
00200C  1  C4 AE        	CPY	FAC1_2		; compare FAC1 mantissa2
00200E  1  D0 04        	BNE	LAB_26F4		; branch if <>
002010  1               
002010  1  A4 B6        	LDY	FAC2_3		; get FAC2 mantissa3
002012  1  C4 AF        	CPY	FAC1_3		; compare FAC1 mantissa3
002014  1               LAB_26F4
002014  1  08           	PHP				; save FAC2-FAC1 compare status
002015  1  2A           	ROL	A			; shift the result byte
002016  1  90 0E        	BCC	LAB_2702		; if no carry skip the byte save
002018  1               
002018  1  A0 01        	LDY	#$01			; set bit to flag byte save
00201A  1  E8           	INX				; else increment the index to FACt
00201B  1  E0 02        	CPX	#$02			; compare with the index to FACt_3
00201D  1  30 04        	BMI	LAB_2701		; if not last byte just go save it
00201F  1               
00201F  1  D0 28        	BNE	LAB_272B		; if all done go save FAC1 rounding byte, normalise and
002021  1               					; return
002021  1               
002021  1  A0 40        	LDY	#$40			; set bit to flag byte save for the rounding byte
002023  1               LAB_2701
002023  1  95 75        	STA	FACt_1,X		; write result byte to FACt_1 + index
002025  1  98           	TYA				; copy the next save byte flag
002026  1               LAB_2702
002026  1  28           	PLP				; restore FAC2-FAC1 compare status
002027  1  90 14        	BCC	LAB_2704		; if FAC2 < FAC1 then skip the subtract
002029  1               
002029  1  A8           	TAY				; save FAC2-FAC1 compare status
00202A  1  A5 B6        	LDA	FAC2_3		; get FAC2 mantissa3
00202C  1  E5 AF        	SBC	FAC1_3		; subtract FAC1 mantissa3
00202E  1  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
002030  1  A5 B5        	LDA	FAC2_2		; get FAC2 mantissa2
002032  1  E5 AE        	SBC	FAC1_2		; subtract FAC1 mantissa2
002034  1  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
002036  1  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
002038  1  E5 AD        	SBC	FAC1_1		; subtract FAC1 mantissa1
00203A  1  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
00203C  1  98           	TYA				; restore FAC2-FAC1 compare status
00203D  1               
00203D  1               					; FAC2 = FAC2*2
00203D  1               LAB_2704
00203D  1  06 B6        	ASL	FAC2_3		; shift FAC2 mantissa3
00203F  1  26 B5        	ROL	FAC2_2		; shift FAC2 mantissa2
002041  1  26 B4        	ROL	FAC2_1		; shift FAC2 mantissa1
002043  1  B0 CF        	BCS	LAB_26F4		; loop with no compare
002045  1               
002045  1  30 BD        	BMI	LAB_26E4		; loop with compare
002047  1               
002047  1  10 CB        	BPL	LAB_26F4		; loop always with no compare
002049  1               
002049  1               ; do A<<6, save as FAC1 rounding byte, normalise and return
002049  1               
002049  1               LAB_272B
002049  1  4A           	LSR	A			; shift b1 - b0 ..
00204A  1  6A           	ROR	A				; ..
00204B  1  6A           	ROR	A			; .. to b7 - b6
00204C  1  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
00204E  1  28           	PLP				; dump FAC2-FAC1 compare status
00204F  1  4C 57 20     	JMP	LAB_273C		; copy temp to FAC1, normalise and return
002052  1               
002052  1               ; do "Divide by zero" error
002052  1               
002052  1               LAB_2737
002052  1  A2 14        	LDX	#$14			; error code $14 ("Divide by zero" error)
002054  1  4C 27 09     	JMP	LAB_XERR		; do error #X, then warm start
002057  1               
002057  1               ; copy temp to FAC1 and normalise
002057  1               
002057  1               LAB_273C
002057  1  A5 75        	LDA	FACt_1		; get temp mantissa1
002059  1  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00205B  1  A5 76        	LDA	FACt_2		; get temp mantissa2
00205D  1  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
00205F  1  A5 77        	LDA	FACt_3		; get temp mantissa3
002061  1  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
002063  1  4C 1D 1E     	JMP	LAB_24D5		; normalise FAC1 and return
002066  1               
002066  1               ; unpack memory (AY) into FAC1
002066  1               
002066  1               LAB_UFAC
002066  1  85 71        	STA	ut1_pl		; save pointer low byte
002068  1  84 72        	STY	ut1_ph		; save pointer high byte
00206A  1  A0 03        	LDY	#$03			; 4 bytes to do
00206C  1  B1 71        	LDA	(ut1_pl),Y		; get last byte
00206E  1  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
002070  1  88           	DEY				; decrement index
002071  1  B1 71        	LDA	(ut1_pl),Y		; get last-1 byte
002073  1  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
002075  1  88           	DEY				; decrement index
002076  1  B1 71        	LDA	(ut1_pl),Y		; get second byte
002078  1  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00207A  1  09 80        	ORA	#$80			; set 1xxx xxxx (add normal bit)
00207C  1  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00207E  1  88           	DEY				; decrement index
00207F  1  B1 71        	LDA	(ut1_pl),Y		; get first byte (exponent)
002081  1  85 AC        	STA	FAC1_e		; save FAC1 exponent
002083  1  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
002085  1  60           	RTS
002086  1               
002086  1               ; pack FAC1 into Adatal
002086  1               
002086  1               LAB_276E
002086  1  A2 A4        	LDX	#Adatal_LO		; set pointer low byte
002088  1               LAB_2770
002088  1  A0 00        	LDY	#Adatal_HI		; set pointer high byte
00208A  1  F0 04        	BEQ	LAB_2778		; pack FAC1 into (XY) and return
00208C  1               
00208C  1               ; pack FAC1 into (Lvarpl)
00208C  1               
00208C  1               LAB_PFAC
00208C  1  A6 97        	LDX	Lvarpl		; get destination pointer low byte
00208E  1  A4 98        	LDY	Lvarph		; get destination pointer high byte
002090  1               
002090  1               ; pack FAC1 into (XY)
002090  1               
002090  1               LAB_2778
002090  1  20 C2 20     	JSR	LAB_27BA		; round FAC1
002093  1  86 71        	STX	ut1_pl		; save pointer low byte
002095  1  84 72        	STY	ut1_ph		; save pointer high byte
002097  1  A0 03        	LDY	#$03			; set index
002099  1  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00209B  1  91 71        	STA	(ut1_pl),Y		; store in destination
00209D  1  88           	DEY				; decrement index
00209E  1  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
0020A0  1  91 71        	STA	(ut1_pl),Y		; store in destination
0020A2  1  88           	DEY				; decrement index
0020A3  1  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
0020A5  1  09 7F        	ORA	#$7F			; set bits x111 1111
0020A7  1  25 AD        	AND	FAC1_1		; AND in FAC1 mantissa1
0020A9  1  91 71        	STA	(ut1_pl),Y		; store in destination
0020AB  1  88           	DEY				; decrement index
0020AC  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0020AE  1  91 71        	STA	(ut1_pl),Y		; store in destination
0020B0  1  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
0020B2  1  60           	RTS
0020B3  1               
0020B3  1               ; round and copy FAC1 to FAC2
0020B3  1               
0020B3  1               LAB_27AB
0020B3  1  20 C2 20     	JSR	LAB_27BA		; round FAC1
0020B6  1               
0020B6  1               ; copy FAC1 to FAC2
0020B6  1               
0020B6  1               LAB_27AE
0020B6  1  A2 05        	LDX	#$05			; 5 bytes to copy
0020B8  1               LAB_27B0
0020B8  1  B5 AB        	LDA	FAC1_e-1,X		; get byte from FAC1,X
0020BA  1  95 B2        	STA	FAC1_o,X		; save byte at FAC2,X
0020BC  1  CA           	DEX				; decrement count
0020BD  1  D0 F9        	BNE	LAB_27B0		; loop if not all done
0020BF  1               
0020BF  1  86 B9        	STX	FAC1_r		; clear FAC1 rounding byte
0020C1  1               LAB_27B9
0020C1  1  60           	RTS
0020C2  1               
0020C2  1               ; round FAC1
0020C2  1               
0020C2  1               LAB_27BA
0020C2  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0020C4  1  F0 FB        	BEQ	LAB_27B9		; exit if zero
0020C6  1               
0020C6  1  06 B9        	ASL	FAC1_r		; shift FAC1 rounding byte
0020C8  1  90 F7        	BCC	LAB_27B9		; exit if no overflow
0020CA  1               
0020CA  1               ; round FAC1 (no check)
0020CA  1               
0020CA  1               LAB_27C2
0020CA  1  20 A1 1E     	JSR	LAB_2559		; increment FAC1 mantissa
0020CD  1  D0 F2        	BNE	LAB_27B9		; branch if no overflow
0020CF  1               
0020CF  1  4C 72 1E     	JMP	LAB_252A		; normalise FAC1 for C=1 and return
0020D2  1               
0020D2  1               ; get FAC1 sign
0020D2  1               ; return A=FF,C=1/-ve A=01,C=0/+ve
0020D2  1               
0020D2  1               LAB_27CA
0020D2  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0020D4  1  F0 09        	BEQ	LAB_27D7		; exit if zero (already correct SGN(0)=0)
0020D6  1               
0020D6  1               ; return A=FF,C=1/-ve A=01,C=0/+ve
0020D6  1               ; no = 0 check
0020D6  1               
0020D6  1               LAB_27CE
0020D6  1  A5 B0        	LDA	FAC1_s		; else get FAC1 sign (b7)
0020D8  1               
0020D8  1               ; return A=FF,C=1/-ve A=01,C=0/+ve
0020D8  1               ; no = 0 check, sign in A
0020D8  1               
0020D8  1               LAB_27D0
0020D8  1  2A           	ROL	A			; move sign bit to carry
0020D9  1  A9 FF        	LDA	#$FF			; set byte for -ve result
0020DB  1  B0 02        	BCS	LAB_27D7		; return if sign was set (-ve)
0020DD  1               
0020DD  1  A9 01        	LDA	#$01			; else set byte for +ve result
0020DF  1               LAB_27D7
0020DF  1  60           	RTS
0020E0  1               
0020E0  1               ; perform SGN()
0020E0  1               
0020E0  1               LAB_SGN
0020E0  1  20 D2 20     	JSR	LAB_27CA		; get FAC1 sign
0020E3  1               					; return A=$FF/-ve A=$01/+ve
0020E3  1               ; save A as integer byte
0020E3  1               
0020E3  1               LAB_27DB
0020E3  1  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
0020E5  1  A9 00        	LDA	#$00			; clear A
0020E7  1  85 AE        	STA	FAC1_2		; clear FAC1 mantissa2
0020E9  1  A2 88        	LDX	#$88			; set exponent
0020EB  1               
0020EB  1               ; set exp=X, clearFAC1 mantissa3 and normalise
0020EB  1               
0020EB  1               LAB_27E3
0020EB  1  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
0020ED  1  49 FF        	EOR	#$FF			; complement it
0020EF  1  2A           	ROL	A			; sign bit into carry
0020F0  1               
0020F0  1               ; set exp=X, clearFAC1 mantissa3 and normalise
0020F0  1               
0020F0  1               LAB_STFA
0020F0  1  A9 00        	LDA	#$00			; clear A
0020F2  1  85 AF        	STA	FAC1_3		; clear FAC1 mantissa3
0020F4  1  86 AC        	STX	FAC1_e		; set FAC1 exponent
0020F6  1  85 B9        	STA	FAC1_r		; clear FAC1 rounding byte
0020F8  1  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
0020FA  1  4C 18 1E     	JMP	LAB_24D0		; do ABS and normalise FAC1
0020FD  1               
0020FD  1               ; perform ABS()
0020FD  1               
0020FD  1               LAB_ABS
0020FD  1  46 B0        	LSR	FAC1_s		; clear FAC1 sign (put zero in b7)
0020FF  1  60           	RTS
002100  1               
002100  1               ; compare FAC1 with (AY)
002100  1               ; returns A=$00 if FAC1 = (AY)
002100  1               ; returns A=$01 if FAC1 > (AY)
002100  1               ; returns A=$FF if FAC1 < (AY)
002100  1               
002100  1               LAB_27F8
002100  1  85 73        	STA	ut2_pl		; save pointer low byte
002102  1               LAB_27FA
002102  1  84 74        	STY	ut2_ph		; save pointer high byte
002104  1  A0 00        	LDY	#$00			; clear index
002106  1  B1 73        	LDA	(ut2_pl),Y		; get exponent
002108  1  C8           	INY				; increment index
002109  1  AA           	TAX				; copy (AY) exponent to X
00210A  1  F0 C6        	BEQ	LAB_27CA		; branch if (AY) exponent=0 and get FAC1 sign
00210C  1               					; A=FF,C=1/-ve A=01,C=0/+ve
00210C  1               
00210C  1  B1 73        	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
00210E  1  45 B0        	EOR	FAC1_s		; EOR FAC1 sign (b7)
002110  1  30 C4        	BMI	LAB_27CE		; if signs <> do return A=FF,C=1/-ve
002112  1               					; A=01,C=0/+ve and return
002112  1               
002112  1  E4 AC        	CPX	FAC1_e		; compare (AY) exponent with FAC1 exponent
002114  1  D0 1A        	BNE	LAB_2828		; branch if different
002116  1               
002116  1  B1 73        	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
002118  1  09 80        	ORA	#$80			; normalise top bit
00211A  1  C5 AD        	CMP	FAC1_1		; compare with FAC1 mantissa1
00211C  1  D0 12        	BNE	LAB_2828		; branch if different
00211E  1               
00211E  1  C8           	INY				; increment index
00211F  1  B1 73        	LDA	(ut2_pl),Y		; get mantissa2
002121  1  C5 AE        	CMP	FAC1_2		; compare with FAC1 mantissa2
002123  1  D0 0B        	BNE	LAB_2828		; branch if different
002125  1               
002125  1  C8           	INY				; increment index
002126  1  A9 7F        	LDA	#$7F			; set for 1/2 value rounding byte
002128  1  C5 B9        	CMP	FAC1_r		; compare with FAC1 rounding byte (set carry)
00212A  1  B1 73        	LDA	(ut2_pl),Y		; get mantissa3
00212C  1  E5 AF        	SBC	FAC1_3		; subtract FAC1 mantissa3
00212E  1  F0 28        	BEQ	LAB_2850		; exit if mantissa3 equal
002130  1               
002130  1               ; gets here if number <> FAC1
002130  1               
002130  1               LAB_2828
002130  1  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
002132  1  90 02        	BCC	LAB_282E		; branch if FAC1 > (AY)
002134  1               
002134  1  49 FF        	EOR	#$FF			; else toggle FAC1 sign
002136  1               LAB_282E
002136  1  4C D8 20     	JMP	LAB_27D0		; return A=FF,C=1/-ve A=01,C=0/+ve
002139  1               
002139  1               ; convert FAC1 floating-to-fixed
002139  1               
002139  1               LAB_2831
002139  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00213B  1  F0 4A        	BEQ	LAB_287F		; if zero go clear FAC1 and return
00213D  1               
00213D  1  38           	SEC				; set carry for subtract
00213E  1  E9 98        	SBC	#$98			; subtract maximum integer range exponent
002140  1  24 B0        	BIT	FAC1_s		; test FAC1 sign (b7)
002142  1  10 09        	BPL	LAB_2845		; branch if FAC1 +ve
002144  1               
002144  1               					; FAC1 was -ve
002144  1  AA           	TAX				; copy subtracted exponent
002145  1  A9 FF        	LDA	#$FF			; overflow for -ve number
002147  1  85 B2        	STA	FAC1_o		; set FAC1 overflow byte
002149  1  20 85 1E     	JSR	LAB_253D		; twos complement FAC1 mantissa
00214C  1  8A           	TXA				; restore subtracted exponent
00214D  1               LAB_2845
00214D  1  A2 AC        	LDX	#FAC1_e		; set index to FAC1
00214F  1  C9 F9        	CMP	#$F9			; compare exponent result
002151  1  10 06        	BPL	LAB_2851		; if < 8 shifts shift FAC1 A times right and return
002153  1               
002153  1  20 C3 1E     	JSR	LAB_257B		; shift FAC1 A times right (> 8 shifts)
002156  1  84 B2        	STY	FAC1_o		; clear FAC1 overflow byte
002158  1               LAB_2850
002158  1  60           	RTS
002159  1               
002159  1               ; shift FAC1 A times right
002159  1               
002159  1               LAB_2851
002159  1  A8           	TAY				; copy shift count
00215A  1  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00215C  1  29 80        	AND	#$80			; mask sign bit only (x000 0000)
00215E  1  46 AD        	LSR	FAC1_1		; shift FAC1 mantissa1
002160  1  05 AD        	ORA	FAC1_1		; OR sign in b7 FAC1 mantissa1
002162  1  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
002164  1  20 DA 1E     	JSR	LAB_2592		; shift FAC1 Y times right
002167  1  84 B2        	STY	FAC1_o		; clear FAC1 overflow byte
002169  1  60           	RTS
00216A  1               
00216A  1               ; perform INT()
00216A  1               
00216A  1               LAB_INT
00216A  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00216C  1  C9 98        	CMP	#$98			; compare with max int
00216E  1  B0 1E        	BCS	LAB_2886		; exit if >= (already int, too big for fractional part!)
002170  1               
002170  1  20 39 21     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
002173  1  84 B9        	STY	FAC1_r		; save FAC1 rounding byte
002175  1  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
002177  1  84 B0        	STY	FAC1_s		; save FAC1 sign (b7)
002179  1  49 80        	EOR	#$80			; toggle FAC1 sign
00217B  1  2A           	ROL	A			; shift into carry
00217C  1  A9 98        	LDA	#$98			; set new exponent
00217E  1  85 AC        	STA	FAC1_e		; save FAC1 exponent
002180  1  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
002182  1  85 5B        	STA	Temp3			; save for EXP() function
002184  1  4C 18 1E     	JMP	LAB_24D0		; do ABS and normalise FAC1
002187  1               
002187  1               ; clear FAC1 and return
002187  1               
002187  1               LAB_287F
002187  1  85 AD        	STA	FAC1_1		; clear FAC1 mantissa1
002189  1  85 AE        	STA	FAC1_2		; clear FAC1 mantissa2
00218B  1  85 AF        	STA	FAC1_3		; clear FAC1 mantissa3
00218D  1  A8           	TAY				; clear Y
00218E  1               LAB_2886
00218E  1  60           	RTS
00218F  1               
00218F  1               ; get FAC1 from string
00218F  1               ; this routine now handles hex and binary values from strings
00218F  1               ; starting with "$" and "%" respectively
00218F  1               
00218F  1               LAB_2887
00218F  1  A0 00        	LDY	#$00			; clear Y
002191  1  84 5F        	STY	Dtypef		; clear data type flag, $FF=string, $00=numeric
002193  1  A2 09        	LDX	#$09			; set index
002195  1               LAB_288B
002195  1  94 A8        	STY	numexp,X		; clear byte
002197  1  CA           	DEX				; decrement index
002198  1  10 FB        	BPL	LAB_288B		; loop until numexp to negnum (and FAC1) = $00
00219A  1               
00219A  1  B0 03        	BCS	LAB_s28FE		; branch if 1st NOT character numeric
00219C  1  4C 1E 22     	JMP	LAB_28FE		; branch if 1st character numeric
00219F  1               LAB_s28FE:
00219F  1               
00219F  1               ; get FAC1 from string .. first character wasn't numeric
00219F  1               
00219F  1  C9 2D        	CMP	#'-'			; else compare with "-"
0021A1  1  D0 04        	BNE	LAB_289A		; branch if not "-"
0021A3  1               
0021A3  1  86 B1        	STX	negnum		; set flag for -ve number (X = $FF)
0021A5  1  F0 04        	BEQ	LAB_289C		; branch always (go scan and check for hex/bin)
0021A7  1               
0021A7  1               ; get FAC1 from string .. first character wasn't numeric or -
0021A7  1               
0021A7  1               LAB_289A
0021A7  1  C9 2B        	CMP	#'+'			; else compare with "+"
0021A9  1  D0 05        	BNE	LAB_289D		; branch if not "+" (go check for hex/bin)
0021AB  1               
0021AB  1               ; was "+" or "-" to start, so get next character
0021AB  1               
0021AB  1               LAB_289C
0021AB  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0021AE  1  90 6E        	BCC	LAB_28FE		; branch if numeric character
0021B0  1               
0021B0  1               ; code here for hex and binary numbers
0021B0  1               
0021B0  1               LAB_289D
0021B0  1  C9 24        	CMP	#'$'			; else compare with "$"
0021B2  1  D0 03        	BNE	LAB_NHEX		; branch if not "$"
0021B4  1               
0021B4  1  4C 5A 26     	JMP	LAB_CHEX		; branch if "$"
0021B7  1               
0021B7  1               LAB_NHEX
0021B7  1  C9 25        	CMP	#'%'			; else compare with "%"
0021B9  1  D0 08        	BNE	LAB_28A3		; branch if not "%" (continue original code)
0021BB  1               
0021BB  1  4C 88 26     	JMP	LAB_CBIN		; branch if "%"
0021BE  1               
0021BE  1               LAB_289E
0021BE  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (ignore + or get next number)
0021C1  1               LAB_28A1
0021C1  1  90 5B        	BCC	LAB_28FE		; branch if numeric character
0021C3  1               
0021C3  1               ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
0021C3  1               
0021C3  1               LAB_28A3
0021C3  1  C9 2E        	CMP	#'.'			; else compare with "."
0021C5  1  F0 2E        	BEQ	LAB_28D5		; branch if "."
0021C7  1               
0021C7  1               ; get FAC1 from string .. character wasn't numeric, -, + or .
0021C7  1               
0021C7  1  C9 45        	CMP	#'E'			; else compare with "E"
0021C9  1  D0 30        	BNE	LAB_28DB		; branch if not "E"
0021CB  1               
0021CB  1               					; was "E" so evaluate exponential part
0021CB  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0021CE  1  90 17        	BCC	LAB_28C7		; branch if numeric character
0021D0  1               
0021D0  1  C9 B8        	CMP	#TK_MINUS		; else compare with token for -
0021D2  1  F0 0E        	BEQ	LAB_28C2		; branch if token for -
0021D4  1               
0021D4  1  C9 2D        	CMP	#'-'			; else compare with "-"
0021D6  1  F0 0A        	BEQ	LAB_28C2		; branch if "-"
0021D8  1               
0021D8  1  C9 B7        	CMP	#TK_PLUS		; else compare with token for +
0021DA  1  F0 08        	BEQ	LAB_28C4		; branch if token for +
0021DC  1               
0021DC  1  C9 2B        	CMP	#'+'			; else compare with "+"
0021DE  1  F0 04        	BEQ	LAB_28C4		; branch if "+"
0021E0  1               
0021E0  1  D0 07        	BNE	LAB_28C9		; branch always
0021E2  1               
0021E2  1               LAB_28C2
0021E2  1  66 AB        	ROR	expneg		; set exponent -ve flag (C, which=1, into b7)
0021E4  1               LAB_28C4
0021E4  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0021E7  1               LAB_28C7
0021E7  1  90 5B        	BCC	LAB_2925		; branch if numeric character
0021E9  1               
0021E9  1               LAB_28C9
0021E9  1  24 AB        	BIT	expneg		; test exponent -ve flag
0021EB  1  10 0E        	BPL	LAB_28DB		; if +ve go evaluate exponent
0021ED  1               
0021ED  1               					; else do exponent = -exponent
0021ED  1  A9 00        	LDA	#$00			; clear result
0021EF  1  38           	SEC				; set carry for subtract
0021F0  1  E5 A9        	SBC	expcnt		; subtract exponent byte
0021F2  1  4C FD 21     	JMP	LAB_28DD		; go evaluate exponent
0021F5  1               
0021F5  1               LAB_28D5
0021F5  1  66 AA        	ROR	numdpf		; set decimal point flag
0021F7  1  24 AA        	BIT	numdpf		; test decimal point flag
0021F9  1  50 C3        	BVC	LAB_289E		; branch if only one decimal point so far
0021FB  1               
0021FB  1               					; evaluate exponent
0021FB  1               LAB_28DB
0021FB  1  A5 A9        	LDA	expcnt		; get exponent count byte
0021FD  1               LAB_28DD
0021FD  1  38           	SEC				; set carry for subtract
0021FE  1  E5 A8        	SBC	numexp		; subtract numerator exponent
002200  1  85 A9        	STA	expcnt		; save exponent count byte
002202  1  F0 12        	BEQ	LAB_28F6		; branch if no adjustment
002204  1               
002204  1  10 09        	BPL	LAB_28EF		; else if +ve go do FAC1*10^expcnt
002206  1               
002206  1               					; else go do FAC1/10^(0-expcnt)
002206  1               LAB_28E6
002206  1  20 D9 1F     	JSR	LAB_26B9		; divide by 10
002209  1  E6 A9        	INC	expcnt		; increment exponent count byte
00220B  1  D0 F9        	BNE	LAB_28E6		; loop until all done
00220D  1               
00220D  1  F0 07        	BEQ	LAB_28F6		; branch always
00220F  1               
00220F  1               LAB_28EF
00220F  1  20 C0 1F     	JSR	LAB_269E		; multiply by 10
002212  1  C6 A9        	DEC	expcnt		; decrement exponent count byte
002214  1  D0 F9        	BNE	LAB_28EF		; loop until all done
002216  1               
002216  1               LAB_28F6
002216  1  A5 B1        	LDA	negnum		; get -ve flag
002218  1  30 01        	BMI	LAB_28FB		; if -ve do - FAC1 and return
00221A  1               
00221A  1  60           	RTS
00221B  1               
00221B  1               ; do - FAC1 and return
00221B  1               
00221B  1               LAB_28FB
00221B  1  4C E0 23     	JMP	LAB_GTHAN		; do - FAC1 and return
00221E  1               
00221E  1               ; do unsigned FAC1*10+number
00221E  1               
00221E  1               LAB_28FE
00221E  1  48           	PHA				; save character
00221F  1  24 AA        	BIT	numdpf		; test decimal point flag
002221  1  10 02        	BPL	LAB_2905		; skip exponent increment if not set
002223  1               
002223  1  E6 A8        	INC	numexp		; else increment number exponent
002225  1               LAB_2905
002225  1  20 C0 1F     	JSR	LAB_269E		; multiply FAC1 by 10
002228  1  68           	PLA				; restore character
002229  1  29 0F        	AND	#$0F			; convert to binary
00222B  1  20 31 22     	JSR	LAB_2912		; evaluate new ASCII digit
00222E  1  4C BE 21     	JMP	LAB_289E		; go do next character
002231  1               
002231  1               ; evaluate new ASCII digit
002231  1               
002231  1               LAB_2912
002231  1  48           	PHA				; save digit
002232  1  20 B3 20     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
002235  1  68           	PLA				; restore digit
002236  1  20 E3 20     	JSR	LAB_27DB		; save A as integer byte
002239  1  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
00223B  1  45 B0        	EOR	FAC1_s		; toggle with FAC1 sign (b7)
00223D  1  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
00223F  1  A6 AC        	LDX	FAC1_e		; get FAC1 exponent
002241  1  4C AA 1D     	JMP	LAB_ADD		; add FAC2 to FAC1 and return
002244  1               
002244  1               ; evaluate next character of exponential part of number
002244  1               
002244  1               LAB_2925
002244  1  A5 A9        	LDA	expcnt		; get exponent count byte
002246  1  C9 0A        	CMP	#$0A			; compare with 10 decimal
002248  1  90 09        	BCC	LAB_2934		; branch if less
00224A  1               
00224A  1  A9 64        	LDA	#$64			; make all -ve exponents = -100 decimal (causes underflow)
00224C  1  24 AB        	BIT	expneg		; test exponent -ve flag
00224E  1  30 0E        	BMI	LAB_2942		; branch if -ve
002250  1               
002250  1  4C AC 1E     	JMP	LAB_2564		; else do overflow error
002253  1               
002253  1               LAB_2934
002253  1  0A           	ASL	A			; * 2
002254  1  0A           	ASL	A			; * 4
002255  1  65 A9        	ADC	expcnt		; * 5
002257  1  0A           	ASL	A			; * 10
002258  1  A0 00        	LDY	#$00			; set index
00225A  1  71 C3        	ADC	(Bpntrl),Y		; add character (will be $30 too much!)
00225C  1  E9 2F        	SBC	#'0'-1		; convert character to binary
00225E  1               LAB_2942
00225E  1  85 A9        	STA	expcnt		; save exponent count byte
002260  1  4C E4 21     	JMP	LAB_28C4		; go get next character
002263  1               
002263  1               ; print " in line [LINE #]"
002263  1               
002263  1               LAB_2953
002263  1  A9 DA        	LDA	#LAB_LMSG_LO		; point to " in line " message low byte
002265  1  A0 2F        	LDY	#LAB_LMSG_HI		; point to " in line " message high byte
002267  1  20 BC 10     	JSR	LAB_18C3		; print null terminated string from memory
00226A  1               
00226A  1               					; print Basic line #
00226A  1  A5 88        	LDA	Clineh		; get current line high byte
00226C  1  A6 87        	LDX	Clinel		; get current line low byte
00226E  1               
00226E  1               ; print XA as unsigned integer
00226E  1               
00226E  1               LAB_295E
00226E  1  85 AD        	STA	FAC1_1		; save low byte as FAC1 mantissa1
002270  1  86 AE        	STX	FAC1_2		; save high byte as FAC1 mantissa2
002272  1  A2 90        	LDX	#$90			; set exponent to 16d bits
002274  1  38           	SEC				; set integer is +ve flag
002275  1  20 F0 20     	JSR	LAB_STFA		; set exp=X, clearFAC1 mantissa3 and normalise
002278  1  A0 00        	LDY	#$00			; clear index
00227A  1  98           	TYA				; clear A
00227B  1  20 8E 22     	JSR	LAB_297B		; convert FAC1 to string, skip sign character save
00227E  1  4C BC 10     	JMP	LAB_18C3		; print null terminated string from memory and return
002281  1               
002281  1               ; convert FAC1 to ASCII string result in (AY)
002281  1               ; not any more, moved scratchpad to page 0
002281  1               
002281  1               LAB_296E
002281  1  A0 01        	LDY	#$01			; set index = 1
002283  1  A9 20        	LDA	#$20			; character = " " (assume +ve)
002285  1  24 B0        	BIT	FAC1_s		; test FAC1 sign (b7)
002287  1  10 02        	BPL	LAB_2978		; branch if +ve
002289  1               
002289  1  A9 2D        	LDA	#$2D			; else character = "-"
00228B  1               LAB_2978
00228B  1  99 EF 00     	STA	Decss,Y		; save leading character (" " or "-")
00228E  1               LAB_297B
00228E  1  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
002290  1  84 BA        	STY	Sendl			; save index
002292  1  C8           	INY				; increment index
002293  1  A6 AC        	LDX	FAC1_e		; get FAC1 exponent
002295  1  D0 05        	BNE	LAB_2989		; branch if FAC1<>0
002297  1               
002297  1               					; exponent was $00 so FAC1 is 0
002297  1  A9 30        	LDA	#'0'			; set character = "0"
002299  1  4C 9A 23     	JMP	LAB_2A89		; save last character, [EOT] and exit
00229C  1               
00229C  1               					; FAC1 is some non zero value
00229C  1               LAB_2989
00229C  1  A9 00        	LDA	#$00			; clear (number exponent count)
00229E  1  E0 81        	CPX	#$81			; compare FAC1 exponent with $81 (>1.00000)
0022A0  1               
0022A0  1  B0 09        	BCS	LAB_299A		; branch if FAC1=>1
0022A2  1               
0022A2  1               					; FAC1<1
0022A2  1  A9 61        	LDA	#LAB_294F_LO		; set pointer low byte to 1,000,000
0022A4  1  A0 29        	LDY	#LAB_294F_HI		; set pointer high byte to 1,000,000
0022A6  1  20 22 1F     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
0022A9  1  A9 FA        	LDA	#$FA			; set number exponent count (-6)
0022AB  1               LAB_299A
0022AB  1  85 A8        	STA	numexp		; save number exponent count
0022AD  1               LAB_299C
0022AD  1  A9 5D        	LDA	#LAB_294B_LO		; set pointer low byte to 999999.4375 (max before sci note)
0022AF  1  A0 29        	LDY	#LAB_294B_HI		; set pointer high byte to 999999.4375
0022B1  1  20 00 21     	JSR	LAB_27F8		; compare FAC1 with (AY)
0022B4  1  F0 1E        	BEQ	LAB_29C3		; exit if FAC1 = (AY)
0022B6  1               
0022B6  1  10 12        	BPL	LAB_29B9		; go do /10 if FAC1 > (AY)
0022B8  1               
0022B8  1               					; FAC1 < (AY)
0022B8  1               LAB_29A7
0022B8  1  A9 59        	LDA	#LAB_2947_LO		; set pointer low byte to 99999.9375
0022BA  1  A0 29        	LDY	#LAB_2947_HI		; set pointer high byte to 99999.9375
0022BC  1  20 00 21     	JSR	LAB_27F8		; compare FAC1 with (AY)
0022BF  1  F0 02        	BEQ	LAB_29B2		; branch if FAC1 = (AY) (allow decimal places)
0022C1  1               
0022C1  1  10 0E        	BPL	LAB_29C0		; branch if FAC1 > (AY) (no decimal places)
0022C3  1               
0022C3  1               					; FAC1 <= (AY)
0022C3  1               LAB_29B2
0022C3  1  20 C0 1F     	JSR	LAB_269E		; multiply by 10
0022C6  1  C6 A8        	DEC	numexp		; decrement number exponent count
0022C8  1  D0 EE        	BNE	LAB_29A7		; go test again (branch always)
0022CA  1               
0022CA  1               LAB_29B9
0022CA  1  20 D9 1F     	JSR	LAB_26B9		; divide by 10
0022CD  1  E6 A8        	INC	numexp		; increment number exponent count
0022CF  1  D0 DC        	BNE	LAB_299C		; go test again (branch always)
0022D1  1               
0022D1  1               ; now we have just the digits to do
0022D1  1               
0022D1  1               LAB_29C0
0022D1  1  20 A3 1D     	JSR	LAB_244E		; add 0.5 to FAC1 (round FAC1)
0022D4  1               LAB_29C3
0022D4  1  20 39 21     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
0022D7  1  A2 01        	LDX	#$01			; set default digits before dp = 1
0022D9  1  A5 A8        	LDA	numexp		; get number exponent count
0022DB  1  18           	CLC				; clear carry for add
0022DC  1  69 07        	ADC	#$07			; up to 6 digits before point
0022DE  1  30 09        	BMI	LAB_29D8		; if -ve then 1 digit before dp
0022E0  1               
0022E0  1  C9 08        	CMP	#$08			; A>=8 if n>=1E6
0022E2  1  B0 06        	BCS	LAB_29D9		; branch if >= $08
0022E4  1               
0022E4  1               					; carry is clear
0022E4  1  69 FF        	ADC	#$FF			; take 1 from digit count
0022E6  1  AA           	TAX				; copy to A
0022E7  1  A9 02        	LDA	#$02			;.set exponent adjust
0022E9  1               LAB_29D8
0022E9  1  38           	SEC				; set carry for subtract
0022EA  1               LAB_29D9
0022EA  1  E9 02        	SBC	#$02			; -2
0022EC  1  85 A9        	STA	expcnt		;.save exponent adjust
0022EE  1  86 A8        	STX	numexp		; save digits before dp count
0022F0  1  8A           	TXA				; copy to A
0022F1  1  F0 02        	BEQ	LAB_29E4		; branch if no digits before dp
0022F3  1               
0022F3  1  10 13        	BPL	LAB_29F7		; branch if digits before dp
0022F5  1               
0022F5  1               LAB_29E4
0022F5  1  A4 BA        	LDY	Sendl			; get output string index
0022F7  1  A9 2E        	LDA	#$2E			; character "."
0022F9  1  C8           	INY				; increment index
0022FA  1  99 EF 00     	STA	Decss,Y		; save to output string
0022FD  1  8A           	TXA				;.
0022FE  1  F0 06        	BEQ	LAB_29F5		;.
002300  1               
002300  1  A9 30        	LDA	#'0'			; character "0"
002302  1  C8           	INY				; increment index
002303  1  99 EF 00     	STA	Decss,Y		; save to output string
002306  1               LAB_29F5
002306  1  84 BA        	STY	Sendl			; save output string index
002308  1               LAB_29F7
002308  1  A0 00        	LDY	#$00			; clear index (point to 100,000)
00230A  1  A2 80        	LDX	#$80			;
00230C  1               LAB_29FB
00230C  1  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00230E  1  18           	CLC				; clear carry for add
00230F  1  79 D7 29     	ADC	LAB_2A9C,Y		; add -ve LSB
002312  1  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
002314  1  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
002316  1  79 D6 29     	ADC	LAB_2A9B,Y		; add -ve NMSB
002319  1  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
00231B  1  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
00231D  1  79 D5 29     	ADC	LAB_2A9A,Y		; add -ve MSB
002320  1  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
002322  1  E8           	INX				;
002323  1  B0 04        	BCS	LAB_2A18		;
002325  1               
002325  1  10 E5        	BPL	LAB_29FB		; not -ve so try again
002327  1               
002327  1  30 02        	BMI	LAB_2A1A		;
002329  1               
002329  1               LAB_2A18
002329  1  30 E1        	BMI	LAB_29FB		;
00232B  1               
00232B  1               LAB_2A1A
00232B  1  8A           	TXA				;
00232C  1  90 04        	BCC	LAB_2A21		;
00232E  1               
00232E  1  49 FF        	EOR	#$FF			;
002330  1  69 0A        	ADC	#$0A			;
002332  1               LAB_2A21
002332  1  69 2F        	ADC	#'0'-1		; add "0"-1 to result
002334  1  C8           	INY				; increment index ..
002335  1  C8           	INY				; .. to next less ..
002336  1  C8           	INY				; .. power of ten
002337  1  84 95        	STY	Cvaral		; save as current var address low byte
002339  1  A4 BA        	LDY	Sendl			; get output string index
00233B  1  C8           	INY				; increment output string index
00233C  1  AA           	TAX				; copy character to X
00233D  1  29 7F        	AND	#$7F			; mask out top bit
00233F  1  99 EF 00     	STA	Decss,Y		; save to output string
002342  1  C6 A8        	DEC	numexp		; decrement # of characters before the dp
002344  1  D0 06        	BNE	LAB_2A3B		; branch if still characters to do
002346  1               
002346  1               					; else output the point
002346  1  A9 2E        	LDA	#$2E			; character "."
002348  1  C8           	INY				; increment output string index
002349  1  99 EF 00     	STA	Decss,Y		; save to output string
00234C  1               LAB_2A3B
00234C  1  84 BA        	STY	Sendl			; save output string index
00234E  1  A4 95        	LDY	Cvaral		; get current var address low byte
002350  1  8A           	TXA				; get character back
002351  1  49 FF        	EOR	#$FF			;
002353  1  29 80        	AND	#$80			;
002355  1  AA           	TAX				;
002356  1  C0 12        	CPY	#$12			; compare index with max
002358  1  D0 B2        	BNE	LAB_29FB		; loop if not max
00235A  1               
00235A  1               					; now remove trailing zeroes
00235A  1  A4 BA        	LDY	Sendl			; get output string index
00235C  1               LAB_2A4B
00235C  1  B9 EF 00     	LDA	Decss,Y		; get character from output string
00235F  1  88           	DEY				; decrement output string index
002360  1  C9 30        	CMP	#'0'			; compare with "0"
002362  1  F0 F8        	BEQ	LAB_2A4B		; loop until non "0" character found
002364  1               
002364  1  C9 2E        	CMP	#'.'			; compare with "."
002366  1  F0 01        	BEQ	LAB_2A58		; branch if was dp
002368  1               
002368  1               					; restore last character
002368  1  C8           	INY				; increment output string index
002369  1               LAB_2A58
002369  1  A9 2B        	LDA	#$2B			; character "+"
00236B  1  A6 A9        	LDX	expcnt		; get exponent count
00236D  1  F0 2E        	BEQ	LAB_2A8C		; if zero go set null terminator and exit
00236F  1               
00236F  1               					; exponent isn't zero so write exponent
00236F  1  10 08        	BPL	LAB_2A68		; branch if exponent count +ve
002371  1               
002371  1  A9 00        	LDA	#$00			; clear A
002373  1  38           	SEC				; set carry for subtract
002374  1  E5 A9        	SBC	expcnt		; subtract exponent count adjust (convert -ve to +ve)
002376  1  AA           	TAX				; copy exponent count to X
002377  1  A9 2D        	LDA	#'-'			; character "-"
002379  1               LAB_2A68
002379  1  99 F1 00     	STA	Decss+2,Y		; save to output string
00237C  1  A9 45        	LDA	#$45			; character "E"
00237E  1  99 F0 00     	STA	Decss+1,Y		; save exponent sign to output string
002381  1  8A           	TXA				; get exponent count back
002382  1  A2 2F        	LDX	#'0'-1		; one less than "0" character
002384  1  38           	SEC				; set carry for subtract
002385  1               LAB_2A74
002385  1  E8           	INX				; increment 10's character
002386  1  E9 0A        	SBC	#$0A			;.subtract 10 from exponent count
002388  1  B0 FB        	BCS	LAB_2A74		; loop while still >= 0
00238A  1               
00238A  1  69 3A        	ADC	#':'			; add character ":" ($30+$0A, result is 10 less that value)
00238C  1  99 F3 00     	STA	Decss+4,Y		; save to output string
00238F  1  8A           	TXA				; copy 10's character
002390  1  99 F2 00     	STA	Decss+3,Y		; save to output string
002393  1  A9 00        	LDA	#$00			; set null terminator
002395  1  99 F4 00     	STA	Decss+5,Y		; save to output string
002398  1  F0 08        	BEQ	LAB_2A91		; go set string pointer (AY) and exit (branch always)
00239A  1               
00239A  1               					; save last character, [EOT] and exit
00239A  1               LAB_2A89
00239A  1  99 EF 00     	STA	Decss,Y		; save last character to output string
00239D  1               
00239D  1               					; set null terminator and exit
00239D  1               LAB_2A8C
00239D  1  A9 00        	LDA	#$00			; set null terminator
00239F  1  99 F0 00     	STA	Decss+1,Y		; save after last character
0023A2  1               
0023A2  1               					; set string pointer (AY) and exit
0023A2  1               LAB_2A91
0023A2  1  A9 F0        	LDA	#Decssp1_LO		; set result string low pointer
0023A4  1  A0 00        	LDY	#Decssp1_HI		; set result string high pointer
0023A6  1  60           	RTS
0023A7  1               
0023A7  1               ; perform power function
0023A7  1               
0023A7  1               LAB_POWER
0023A7  1  F0 42        	BEQ	LAB_EXP		; go do  EXP()
0023A9  1               
0023A9  1  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
0023AB  1  D0 03        	BNE	LAB_2ABF		; branch if FAC2<>0
0023AD  1               
0023AD  1  4C 3B 1E     	JMP	LAB_24F3		; clear FAC1 exponent and sign and return
0023B0  1               
0023B0  1               LAB_2ABF
0023B0  1  A2 9C        	LDX	#func_l_LO		; set destination pointer low byte
0023B2  1  A0 00        	LDY	#func_l_HI		; set destination pointer high byte
0023B4  1  20 90 20     	JSR	LAB_2778		; pack FAC1 into (XY)
0023B7  1  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
0023B9  1  10 0F        	BPL	LAB_2AD9		; branch if FAC2>0
0023BB  1               
0023BB  1               					; else FAC2 is -ve and can only be raised to an
0023BB  1               					; integer power which gives an x +j0 result
0023BB  1  20 6A 21     	JSR	LAB_INT		; perform INT
0023BE  1  A9 9C        	LDA	#func_l_LO		; set source pointer low byte
0023C0  1  A0 00        	LDY	#func_l_HI		; set source pointer high byte
0023C2  1  20 00 21     	JSR	LAB_27F8		; compare FAC1 with (AY)
0023C5  1  D0 03        	BNE	LAB_2AD9		; branch if FAC1 <> (AY) to allow Function Call error
0023C7  1               					; this will leave FAC1 -ve and cause a Function Call
0023C7  1               					; error when LOG() is called
0023C7  1               
0023C7  1  98           	TYA				; clear sign b7
0023C8  1  A4 5B        	LDY	Temp3			; save mantissa 3 from INT() function as sign in Y
0023CA  1               					; for possible later negation, b0
0023CA  1               LAB_2AD9
0023CA  1  20 AE 1D     	JSR	LAB_279D		; save FAC1 sign and copy ABS(FAC2) to FAC1
0023CD  1  98           	TYA				; copy sign back ..
0023CE  1  48           	PHA				; .. and save it
0023CF  1  20 E4 1E     	JSR	LAB_LOG		; do LOG(n)
0023D2  1  A9 9C        	LDA	#garb_l_LO		; set pointer low byte
0023D4  1  A0 00        	LDY	#garb_l_HI		; set pointer high byte
0023D6  1  20 22 1F     	JSR	LAB_25FB		; do convert AY, FCA1*(AY) (square the value)
0023D9  1  20 EB 23     	JSR	LAB_EXP		; go do EXP(n)
0023DC  1  68           	PLA				; pull sign from stack
0023DD  1  4A           	LSR	A			; b0 is to be tested, shift to Cb
0023DE  1  90 0A        	BCC	LAB_2AF9		; if no bit then exit
0023E0  1               
0023E0  1               					; Perform negation
0023E0  1               ; do - FAC1
0023E0  1               
0023E0  1               LAB_GTHAN
0023E0  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0023E2  1  F0 06        	BEQ	LAB_2AF9		; exit if FAC1_e = $00
0023E4  1               
0023E4  1  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
0023E6  1  49 FF        	EOR	#$FF			; complement it
0023E8  1  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
0023EA  1               LAB_2AF9
0023EA  1  60           	RTS
0023EB  1               
0023EB  1               ; perform EXP()	(x^e)
0023EB  1               
0023EB  1               LAB_EXP
0023EB  1  A9 65        	LDA	#LAB_2AFA_LO		; set 1.443 pointer low byte
0023ED  1  A0 29        	LDY	#LAB_2AFA_HI		; set 1.443 pointer high byte
0023EF  1  20 22 1F     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
0023F2  1  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
0023F4  1  69 50        	ADC	#$50			; +$50/$100
0023F6  1  90 03        	BCC	LAB_2B2B		; skip rounding if no carry
0023F8  1               
0023F8  1  20 CA 20     	JSR	LAB_27C2		; round FAC1 (no check)
0023FB  1               LAB_2B2B
0023FB  1  85 A3        	STA	FAC2_r		; save FAC2 rounding byte
0023FD  1  20 B6 20     	JSR	LAB_27AE		; copy FAC1 to FAC2
002400  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
002402  1  C9 88        	CMP	#$88			; compare with EXP limit (256d)
002404  1  90 03        	BCC	LAB_2B39		; branch if less
002406  1               
002406  1               LAB_2B36
002406  1  20 B7 1F     	JSR	LAB_2690		; handle overflow and underflow
002409  1               LAB_2B39
002409  1  20 6A 21     	JSR	LAB_INT		; perform INT
00240C  1  A5 5B        	LDA	Temp3			; get mantissa 3 from INT() function
00240E  1  18           	CLC				; clear carry for add
00240F  1  69 81        	ADC	#$81			; normalise +1
002411  1  F0 F3        	BEQ	LAB_2B36		; if $00 go handle overflow
002413  1               
002413  1  38           	SEC				; set carry for subtract
002414  1  E9 01        	SBC	#$01			; now correct for exponent
002416  1  48           	PHA				; save FAC2 exponent
002417  1               
002417  1               					; swap FAC1 and FAC2
002417  1  A2 04        	LDX	#$04			; 4 bytes to do
002419  1               LAB_2B49
002419  1  B5 B3        	LDA	FAC2_e,X		; get FAC2,X
00241B  1  B4 AC        	LDY	FAC1_e,X		; get FAC1,X
00241D  1  95 AC        	STA	FAC1_e,X		; save FAC1,X
00241F  1  94 B3        	STY	FAC2_e,X		; save FAC2,X
002421  1  CA           	DEX				; decrement count/index
002422  1  10 F5        	BPL	LAB_2B49		; loop if not all done
002424  1               
002424  1  A5 A3        	LDA	FAC2_r		; get FAC2 rounding byte
002426  1  85 B9        	STA	FAC1_r		; save as FAC1 rounding byte
002428  1  20 8F 1D     	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
00242B  1  20 E0 23     	JSR	LAB_GTHAN		; do - FAC1
00242E  1  A9 69        	LDA	#LAB_2AFE_LO		; set counter pointer low byte
002430  1  A0 29        	LDY	#LAB_2AFE_HI		; set counter pointer high byte
002432  1  20 53 24     	JSR	LAB_2B84		; go do series evaluation
002435  1  A9 00        	LDA	#$00			; clear A
002437  1  85 B8        	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
002439  1  68           	PLA				;.get saved FAC2 exponent
00243A  1  4C 9C 1F     	JMP	LAB_2675		; test and adjust accumulators and return
00243D  1               
00243D  1               ; ^2 then series evaluation
00243D  1               
00243D  1               LAB_2B6E
00243D  1  85 BA        	STA	Cptrl			; save count pointer low byte
00243F  1  84 BB        	STY	Cptrh			; save count pointer high byte
002441  1  20 86 20     	JSR	LAB_276E		; pack FAC1 into Adatal
002444  1  A9 A4        	LDA	#Adatal_LO		; set pointer low byte (Y already $00)
002446  1  20 22 1F     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
002449  1  20 57 24     	JSR	LAB_2B88		; go do series evaluation
00244C  1  A9 A4        	LDA	#Adatal_LO		; pointer to original # low byte
00244E  1  A0 00        	LDY	#Adatal_HI		; pointer to original # high byte
002450  1  4C 22 1F     	JMP	LAB_25FB		; do convert AY, FCA1*(AY) and return
002453  1               
002453  1               ; series evaluation
002453  1               
002453  1               LAB_2B84
002453  1  85 BA        	STA	Cptrl			; save count pointer low byte
002455  1  84 BB        	STY	Cptrh			; save count pointer high byte
002457  1               LAB_2B88
002457  1  A2 A8        	LDX	#numexp_LO		; set pointer low byte
002459  1  20 88 20     	JSR	LAB_2770		; set pointer high byte and pack FAC1 into numexp
00245C  1  B1 BA        	LDA	(Cptrl),Y		; get constants count
00245E  1  85 B1        	STA	numcon		; save constants count
002460  1  A4 BA        	LDY	Cptrl			; get count pointer low byte
002462  1  C8           	INY				; increment it (now constants pointer)
002463  1  98           	TYA				; copy it
002464  1  D0 02        	BNE	LAB_2B97		; skip next if no overflow
002466  1               
002466  1  E6 BB        	INC	Cptrh			; else increment high byte
002468  1               LAB_2B97
002468  1  85 BA        	STA	Cptrl			; save low byte
00246A  1  A4 BB        	LDY	Cptrh			; get high byte
00246C  1               LAB_2B9B
00246C  1  20 22 1F     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
00246F  1  A5 BA        	LDA	Cptrl			; get constants pointer low byte
002471  1  A4 BB        	LDY	Cptrh			; get constants pointer high byte
002473  1  18           	CLC				; clear carry for add
002474  1  69 04        	ADC	#$04			; +4 to  low pointer (4 bytes per constant)
002476  1  90 01        	BCC	LAB_2BA8		; skip next if no overflow
002478  1               
002478  1  C8           	INY				; increment high byte
002479  1               LAB_2BA8
002479  1  85 BA        	STA	Cptrl			; save pointer low byte
00247B  1  84 BB        	STY	Cptrh			; save pointer high byte
00247D  1  20 A7 1D     	JSR	LAB_246C		; add (AY) to FAC1
002480  1  A9 A8        	LDA	#numexp_LO		; set pointer low byte to partial @ numexp
002482  1  A0 00        	LDY	#numexp_HI		; set pointer high byte to partial @ numexp
002484  1  C6 B1        	DEC	numcon		; decrement constants count
002486  1  D0 E4        	BNE	LAB_2B9B		; loop until all done
002488  1               
002488  1  60           	RTS
002489  1               
002489  1               ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
002489  1               ; to get 19th next number in sequence after seed n. This version of the PRNG uses
002489  1               ; the Galois method and a sample of 65536 bytes produced gives the following values.
002489  1               
002489  1               ; Entropy = 7.997442 bits per byte
002489  1               ; Optimum compression would reduce these 65536 bytes by 0 percent
002489  1               
002489  1               ; Chi square distribution for 65536 samples is 232.01, and
002489  1               ; randomly would exceed this value 75.00 percent of the time
002489  1               
002489  1               ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
002489  1               ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
002489  1               ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
002489  1               
002489  1               LAB_RND
002489  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00248B  1  F0 07        	BEQ	NextPRN		; do next random # if zero
00248D  1               
00248D  1               					; else get seed into random number store
00248D  1  A2 D8        	LDX	#Rbyte4		; set PRNG pointer low byte
00248F  1  A0 00        	LDY	#$00			; set PRNG pointer high byte
002491  1  20 90 20     	JSR	LAB_2778		; pack FAC1 into (XY)
002494  1               NextPRN
002494  1  A2 AF        	LDX	#$AF			; set EOR byte
002496  1  A0 13        	LDY	#$13			; do this nineteen times
002498  1               LoopPRN
002498  1  06 D9        	ASL	Rbyte1		; shift PRNG most significant byte
00249A  1  26 DA        	ROL	Rbyte2		; shift PRNG middle byte
00249C  1  26 DB        	ROL	Rbyte3		; shift PRNG least significant byte
00249E  1  26 D8        	ROL	Rbyte4		; shift PRNG extra byte
0024A0  1  90 05        	BCC	Ninc1			; branch if bit 32 clear
0024A2  1               
0024A2  1  8A           	TXA				; set EOR byte
0024A3  1  45 D9        	EOR	Rbyte1		; EOR PRNG extra byte
0024A5  1  85 D9        	STA	Rbyte1		; save new PRNG extra byte
0024A7  1               Ninc1
0024A7  1  88           	DEY				; decrement loop count
0024A8  1  D0 EE        	BNE	LoopPRN		; loop if not all done
0024AA  1               
0024AA  1  A2 02        	LDX	#$02			; three bytes to copy
0024AC  1               CopyPRNG
0024AC  1  B5 D9        	LDA	Rbyte1,X		; get PRNG byte
0024AE  1  95 AD        	STA	FAC1_1,X		; save FAC1 byte
0024B0  1  CA           	DEX
0024B1  1  10 F9        	BPL	CopyPRNG		; loop if not complete
0024B3  1               
0024B3  1  A9 80        	LDA	#$80			; set the exponent
0024B5  1  85 AC        	STA	FAC1_e		; save FAC1 exponent
0024B7  1               
0024B7  1  0A           	ASL	A			; clear A
0024B8  1  85 B0        	STA	FAC1_s		; save FAC1 sign
0024BA  1               
0024BA  1  4C 1D 1E     	JMP	LAB_24D5		; normalise FAC1 and return
0024BD  1               
0024BD  1               ; perform COS()
0024BD  1               
0024BD  1               LAB_COS
0024BD  1  A9 86        	LDA	#LAB_2C78_LO		; set (pi/2) pointer low byte
0024BF  1  A0 29        	LDY	#LAB_2C78_HI		; set (pi/2) pointer high byte
0024C1  1  20 A7 1D     	JSR	LAB_246C		; add (AY) to FAC1
0024C4  1               
0024C4  1               ; perform SIN()
0024C4  1               
0024C4  1               LAB_SIN
0024C4  1  20 B3 20     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
0024C7  1  A9 9B        	LDA	#LAB_2C7C_LO		; set (2*pi) pointer low byte
0024C9  1  A0 29        	LDY	#LAB_2C7C_HI		; set (2*pi) pointer high byte
0024CB  1  A6 B7        	LDX	FAC2_s		; get FAC2 sign (b7)
0024CD  1  20 E2 1F     	JSR	LAB_26C2		; divide by (AY) (X=sign)
0024D0  1  20 B3 20     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
0024D3  1  20 6A 21     	JSR	LAB_INT		; perform INT
0024D6  1  A9 00        	LDA	#$00			; clear byte
0024D8  1  85 B8        	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
0024DA  1  20 8F 1D     	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
0024DD  1  A9 CD        	LDA	#LAB_2C80_LO		; set 0.25 pointer low byte
0024DF  1  A0 29        	LDY	#LAB_2C80_HI		; set 0.25 pointer high byte
0024E1  1  20 8C 1D     	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
0024E4  1  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
0024E6  1  48           	PHA				; save FAC1 sign
0024E7  1  10 0D        	BPL	LAB_2C35		; branch if +ve
0024E9  1               
0024E9  1               					; FAC1 sign was -ve
0024E9  1  20 A3 1D     	JSR	LAB_244E		; add 0.5 to FAC1
0024EC  1  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
0024EE  1  30 09        	BMI	LAB_2C38		; branch if -ve
0024F0  1               
0024F0  1  A5 63        	LDA	Cflag			; get comparison evaluation flag
0024F2  1  49 FF        	EOR	#$FF			; toggle flag
0024F4  1  85 63        	STA	Cflag			; save comparison evaluation flag
0024F6  1               LAB_2C35
0024F6  1  20 E0 23     	JSR	LAB_GTHAN		; do - FAC1
0024F9  1               LAB_2C38
0024F9  1  A9 CD        	LDA	#LAB_2C80_LO		; set 0.25 pointer low byte
0024FB  1  A0 29        	LDY	#LAB_2C80_HI		; set 0.25 pointer high byte
0024FD  1  20 A7 1D     	JSR	LAB_246C		; add (AY) to FAC1
002500  1  68           	PLA				; restore FAC1 sign
002501  1  10 03        	BPL	LAB_2C45		; branch if was +ve
002503  1               
002503  1               					; else correct FAC1
002503  1  20 E0 23     	JSR	LAB_GTHAN		; do - FAC1
002506  1               LAB_2C45
002506  1  A9 8A        	LDA	#LAB_2C84_LO		; set pointer low byte to counter
002508  1  A0 29        	LDY	#LAB_2C84_HI		; set pointer high byte to counter
00250A  1  4C 3D 24     	JMP	LAB_2B6E		; ^2 then series evaluation and return
00250D  1               
00250D  1               ; perform TAN()
00250D  1               
00250D  1               LAB_TAN
00250D  1  20 86 20     	JSR	LAB_276E		; pack FAC1 into Adatal
002510  1  A9 00        	LDA	#$00			; clear byte
002512  1  85 63        	STA	Cflag			; clear comparison evaluation flag
002514  1  20 C4 24     	JSR	LAB_SIN		; go do SIN(n)
002517  1  A2 9C        	LDX	#func_l_LO		; set sin(n) pointer low byte
002519  1  A0 00        	LDY	#func_l_HI		; set sin(n) pointer high byte
00251B  1  20 90 20     	JSR	LAB_2778		; pack FAC1 into (XY)
00251E  1  A9 A4        	LDA	#Adatal_LO		; set n pointer low addr
002520  1  A0 00        	LDY	#Adatal_HI		; set n pointer high addr
002522  1  20 66 20     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
002525  1  A9 00        	LDA	#$00			; clear byte
002527  1  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
002529  1  A5 63        	LDA	Cflag			; get comparison evaluation flag
00252B  1  20 35 25     	JSR	LAB_2C74		; save flag and go do series evaluation
00252E  1               
00252E  1  A9 9C        	LDA	#func_l_LO		; set sin(n) pointer low byte
002530  1  A0 00        	LDY	#func_l_HI		; set sin(n) pointer high byte
002532  1  4C EA 1F     	JMP	LAB_26CA		; convert AY and do (AY)/FAC1
002535  1               
002535  1               LAB_2C74
002535  1  48           	PHA				; save comparison evaluation flag
002536  1  4C F6 24     	JMP	LAB_2C35		; go do series evaluation
002539  1               
002539  1               ; perform USR()
002539  1               
002539  1               LAB_USR
002539  1  20 0A 00     	JSR	Usrjmp		; call user code
00253C  1  4C D8 13     	JMP	LAB_1BFB		; scan for ")", else do syntax error then warm start
00253F  1               
00253F  1               ; perform ATN()
00253F  1               
00253F  1               LAB_ATN
00253F  1  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
002541  1  48           	PHA				; save sign
002542  1  10 03        	BPL	LAB_2CA1		; branch if +ve
002544  1               
002544  1  20 E0 23     	JSR	LAB_GTHAN		; else do - FAC1
002547  1               LAB_2CA1
002547  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
002549  1  48           	PHA				; push exponent
00254A  1  C9 81        	CMP	#$81			; compare with 1
00254C  1  90 07        	BCC	LAB_2CAF		; branch if FAC1<1
00254E  1               
00254E  1  A9 C0        	LDA	#LAB_259C_LO		; set 1 pointer low byte
002550  1  A0 29        	LDY	#LAB_259C_HI		; set 1 pointer high byte
002552  1  20 EA 1F     	JSR	LAB_26CA		; convert AY and do (AY)/FAC1
002555  1               LAB_2CAF
002555  1  A9 9F        	LDA	#LAB_2CC9_LO		; set pointer low byte to counter
002557  1  A0 29        	LDY	#LAB_2CC9_HI		; set pointer high byte to counter
002559  1  20 3D 24     	JSR	LAB_2B6E		; ^2 then series evaluation
00255C  1  68           	PLA				; restore old FAC1 exponent
00255D  1  C9 81        	CMP	#$81			; compare with 1
00255F  1  90 07        	BCC	LAB_2CC2		; branch if FAC1<1
002561  1               
002561  1  A9 86        	LDA	#LAB_2C78_LO		; set (pi/2) pointer low byte
002563  1  A0 29        	LDY	#LAB_2C78_HI		; set (pi/2) pointer high byte
002565  1  20 8C 1D     	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
002568  1               LAB_2CC2
002568  1  68           	PLA				; restore FAC1 sign
002569  1  10 16        	BPL	LAB_2D04		; exit if was +ve
00256B  1               
00256B  1  4C E0 23     	JMP	LAB_GTHAN		; else do - FAC1 and return
00256E  1               
00256E  1               ; perform BITSET
00256E  1               
00256E  1               LAB_BITSET
00256E  1  20 C1 1C     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
002571  1  E0 08        	CPX	#$08			; only 0 to 7 are allowed
002573  1  B0 20        	BCS	FCError		; branch if > 7
002575  1               
002575  1  A9 00        	LDA	#$00			; clear A
002577  1  38           	SEC				; set the carry
002578  1               S_Bits
002578  1  2A           	ROL	A			; shift bit
002579  1  CA           	DEX				; decrement bit number
00257A  1  10 FC        	BPL	S_Bits		; loop if still +ve
00257C  1               
00257C  1  E8           	INX				; make X = $00
00257D  1  01 11        	ORA	(Itempl,X)		; or with byte via temporary integer (addr)
00257F  1  81 11        	STA	(Itempl,X)		; save byte via temporary integer (addr)
002581  1               LAB_2D04
002581  1  60           	RTS
002582  1               
002582  1               ; perform BITCLR
002582  1               
002582  1               LAB_BITCLR
002582  1  20 C1 1C     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
002585  1  E0 08        	CPX	#$08			; only 0 to 7 are allowed
002587  1  B0 0C        	BCS	FCError		; branch if > 7
002589  1               
002589  1  A9 FF        	LDA	#$FF			; set A
00258B  1               S_Bitc
00258B  1  2A           	ROL	A			; shift bit
00258C  1  CA           	DEX				; decrement bit number
00258D  1  10 FC        	BPL	S_Bitc		; loop if still +ve
00258F  1               
00258F  1  E8           	INX				; make X = $00
002590  1  21 11        	AND	(Itempl,X)		; and with byte via temporary integer (addr)
002592  1  81 11        	STA	(Itempl,X)		; save byte via temporary integer (addr)
002594  1  60           	RTS
002595  1               
002595  1               FCError
002595  1  4C 12 17     	JMP	LAB_FCER		; do function call error then warm start
002598  1               
002598  1               ; perform BITTST()
002598  1               
002598  1               LAB_BTST
002598  1  20 BC 00     	JSR	LAB_IGBY		; increment BASIC pointer
00259B  1  20 C1 1C     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
00259E  1  E0 08        	CPX	#$08			; only 0 to 7 are allowed
0025A0  1  B0 F3        	BCS	FCError		; branch if > 7
0025A2  1               
0025A2  1  20 C2 00     	JSR	LAB_GBYT		; get next BASIC byte
0025A5  1  C9 29        	CMP	#')'			; is next character ")"
0025A7  1  F0 03        	BEQ	TST_OK		; if ")" go do rest of function
0025A9  1               
0025A9  1  4C EB 13     	JMP	LAB_SNER		; do syntax error then warm start
0025AC  1               
0025AC  1               TST_OK
0025AC  1  20 BC 00     	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
0025AF  1  A9 00        	LDA	#$00			; clear A
0025B1  1  38           	SEC				; set the carry
0025B2  1               T_Bits
0025B2  1  2A           	ROL	A			; shift bit
0025B3  1  CA           	DEX				; decrement bit number
0025B4  1  10 FC        	BPL	T_Bits		; loop if still +ve
0025B6  1               
0025B6  1  E8           	INX				; make X = $00
0025B7  1  21 11        	AND	(Itempl,X)		; AND with byte via temporary integer (addr)
0025B9  1  F0 02        	BEQ	LAB_NOTT		; branch if zero (already correct)
0025BB  1               
0025BB  1  A9 FF        	LDA	#$FF			; set for -1 result
0025BD  1               LAB_NOTT
0025BD  1  4C E3 20     	JMP	LAB_27DB		; go do SGN tail
0025C0  1               
0025C0  1               ; perform BIN$()
0025C0  1               
0025C0  1               LAB_BINS
0025C0  1  E0 19        	CPX	#$19			; max + 1
0025C2  1  B0 48        	BCS	BinFErr		; exit if too big ( > or = )
0025C4  1               
0025C4  1  86 78        	STX	TempB			; save # of characters ($00 = leading zero remove)
0025C6  1  A9 18        	LDA	#$18			; need A byte long space
0025C8  1  20 23 19     	JSR	LAB_MSSP		; make string space A bytes long
0025CB  1  A0 17        	LDY	#$17			; set index
0025CD  1  A2 18        	LDX	#$18			; character count
0025CF  1               NextB1
0025CF  1  46 11        	LSR	nums_1		; shift highest byte
0025D1  1  66 12        	ROR	nums_2		; shift middle byte
0025D3  1  66 13        	ROR	nums_3		; shift lowest byte bit 0 to carry
0025D5  1  8A           	TXA				; load with "0"/2
0025D6  1  2A           	ROL	A			; shift in carry
0025D7  1  91 AD        	STA	(str_pl),Y		; save to temp string + index
0025D9  1  88           	DEY				; decrement index
0025DA  1  10 F3        	BPL	NextB1		; loop if not done
0025DC  1               
0025DC  1  A5 78        	LDA	TempB			; get # of characters
0025DE  1  F0 0A        	BEQ	EndBHS		; branch if truncate
0025E0  1               
0025E0  1  AA           	TAX				; copy length to X
0025E1  1  38           	SEC				; set carry for add !
0025E2  1  49 FF        	EOR	#$FF			; 1's complement
0025E4  1  69 18        	ADC	#$18			; add 24d
0025E6  1  F0 1C        	BEQ	GoPr2			; if zero print whole string
0025E8  1               
0025E8  1  D0 0F        	BNE	GoPr1			; else go make output string
0025EA  1               
0025EA  1               ; this is the exit code and is also used by HEX$()
0025EA  1               ; truncate string to remove leading "0"s
0025EA  1               
0025EA  1               EndBHS
0025EA  1  A8           	TAY				; clear index (A=0, X=length here)
0025EB  1               NextB2
0025EB  1  B1 AD        	LDA	(str_pl),Y		; get character from string
0025ED  1  C9 30        	CMP	#'0'			; compare with "0"
0025EF  1  D0 07        	BNE	GoPr			; if not "0" then go print string from here
0025F1  1               
0025F1  1  CA           	DEX				; decrement character count
0025F2  1  F0 03        	BEQ	GoPr3			; if zero then end of string so go print it
0025F4  1               
0025F4  1  C8           	INY				; else increment index
0025F5  1  10 F4        	BPL	NextB2		; loop always
0025F7  1               
0025F7  1               ; make fixed length output string - ignore overflows!
0025F7  1               
0025F7  1               GoPr3
0025F7  1  E8           	INX				; need at least 1 character
0025F8  1               GoPr
0025F8  1  98           	TYA				; copy result
0025F9  1               GoPr1
0025F9  1  18           	CLC				; clear carry for add
0025FA  1  65 AD        	ADC	str_pl		; add low address
0025FC  1  85 AD        	STA	str_pl		; save low address
0025FE  1  A9 00        	LDA	#$00			; do high byte
002600  1  65 AE        	ADC	str_ph		; add high address
002602  1  85 AE        	STA	str_ph		; save high address
002604  1               GoPr2
002604  1  86 AC        	STX	str_ln		; X holds string length
002606  1  20 BC 00     	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
002609  1  4C 6E 19     	JMP	LAB_RTST		; check for space on descriptor stack then put address
00260C  1               					; and length on descriptor stack and update stack pointers
00260C  1               
00260C  1               BinFErr
00260C  1  4C 12 17     	JMP	LAB_FCER		; do function call error then warm start
00260F  1               
00260F  1               ; perform HEX$()
00260F  1               
00260F  1               LAB_HEXS
00260F  1  E0 07        	CPX	#$07			; max + 1
002611  1  B0 F9        	BCS	BinFErr		; exit if too big ( > or = )
002613  1               
002613  1  86 78        	STX	TempB			; save # of characters
002615  1               
002615  1  A9 06        	LDA	#$06			; need 6 bytes for string
002617  1  20 23 19     	JSR	LAB_MSSP		; make string space A bytes long
00261A  1  A0 05        	LDY	#$05			; set string index
00261C  1               
00261C  1  F8           	SED				; need decimal mode for nibble convert
00261D  1  A5 13        	LDA	nums_3		; get lowest byte
00261F  1  20 3D 26     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
002622  1  A5 12        	LDA	nums_2		; get middle byte
002624  1  20 3D 26     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
002627  1  A5 11        	LDA	nums_1		; get highest byte
002629  1  20 3D 26     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
00262C  1  D8           	CLD				; back to binary
00262D  1               
00262D  1  A2 06        	LDX	#$06			; character count
00262F  1  A5 78        	LDA	TempB			; get # of characters
002631  1  F0 B7        	BEQ	EndBHS		; branch if truncate
002633  1               
002633  1  AA           	TAX				; copy length to X
002634  1  38           	SEC				; set carry for add !
002635  1  49 FF        	EOR	#$FF			; 1's complement
002637  1  69 06        	ADC	#$06			; add 6d
002639  1  F0 C9        	BEQ	GoPr2			; if zero print whole string
00263B  1               
00263B  1  D0 BC        	BNE	GoPr1			; else go make output string (branch always)
00263D  1               
00263D  1               ; convert A to ASCII hex byte and output .. note set decimal mode before calling
00263D  1               
00263D  1               LAB_A2HX
00263D  1  AA           	TAX				; save byte
00263E  1  29 0F        	AND	#$0F			; mask off top bits
002640  1  20 48 26     	JSR	LAB_AL2X		; convert low nibble to ASCII and output
002643  1  8A           	TXA				; get byte back
002644  1  4A           	LSR	A			; /2	shift high nibble to low nibble
002645  1  4A           	LSR	A			; /4
002646  1  4A           	LSR	A			; /8
002647  1  4A           	LSR	A			; /16
002648  1               LAB_AL2X
002648  1  C9 0A        	CMP	#$0A			; set carry for +1 if >9
00264A  1  69 30        	ADC	#'0'			; add ASCII "0"
00264C  1  91 AD        	STA	(str_pl),Y		; save to temp string
00264E  1  88           	DEY				; decrement counter
00264F  1  60           	RTS
002650  1               
002650  1               LAB_NLTO
002650  1  85 AC        	STA	FAC1_e		; save FAC1 exponent
002652  1  A9 00        	LDA	#$00			; clear sign compare
002654  1               LAB_MLTE
002654  1  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
002656  1  8A           	TXA				; restore character
002657  1  20 31 22     	JSR	LAB_2912		; evaluate new ASCII digit
00265A  1               
00265A  1               ; gets here if the first character was "$" for hex
00265A  1               ; get hex number
00265A  1               
00265A  1               LAB_CHEX
00265A  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00265D  1  90 0A        	BCC	LAB_ISHN		; branch if numeric character
00265F  1               
00265F  1  09 20        	ORA	#$20			; case convert, allow "A" to "F" and "a" to "f"
002661  1  E9 61        	SBC	#'a'			; subtract "a" (carry set here)
002663  1  C9 06        	CMP	#$06			; compare normalised with $06 (max+1)
002665  1  B0 2A        	BCS	LAB_EXCH		; exit if >"f" or <"0"
002667  1               
002667  1  69 0A        	ADC	#$0A			; convert to nibble
002669  1               LAB_ISHN
002669  1  29 0F        	AND	#$0F			; convert to binary
00266B  1  AA           	TAX				; save nibble
00266C  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00266E  1  F0 E4        	BEQ	LAB_MLTE		; skip multiply if zero
002670  1               
002670  1  69 04        	ADC	#$04			; add four to exponent (*16 - carry clear here)
002672  1  90 DC        	BCC	LAB_NLTO		; if no overflow do evaluate digit
002674  1               
002674  1               LAB_MLTO
002674  1  4C AC 1E     	JMP	LAB_2564		; do overflow error and warm start
002677  1               
002677  1               LAB_NXCH
002677  1  AA           	TAX				; save bit
002678  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00267A  1  F0 06        	BEQ	LAB_MLBT		; skip multiply if zero
00267C  1               
00267C  1  E6 AC        	INC	FAC1_e		; increment FAC1 exponent (*2)
00267E  1  F0 F4        	BEQ	LAB_MLTO		; do overflow error if = $00
002680  1               
002680  1  A9 00        	LDA	#$00			; clear sign compare
002682  1               LAB_MLBT
002682  1  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
002684  1  8A           	TXA				; restore bit
002685  1  20 31 22     	JSR	LAB_2912		; evaluate new ASCII digit
002688  1               
002688  1               ; gets here if the first character was  "%" for binary
002688  1               ; get binary number
002688  1               
002688  1               LAB_CBIN
002688  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00268B  1  49 30        	EOR	#'0'			; convert "0" to 0 etc.
00268D  1  C9 02        	CMP	#$02			; compare with max+1
00268F  1  90 E6        	BCC	LAB_NXCH		; branch exit if < 2
002691  1               
002691  1               LAB_EXCH
002691  1  4C 16 22     	JMP	LAB_28F6		; evaluate -ve flag and return
002694  1               
002694  1               ; ctrl-c check routine. includes limited "life" byte save for INGET routine
002694  1               ; now also the code that checks to see if an interrupt has occurred
002694  1               
002694  1               CTRLC
002694  1  AD 00 02     	LDA	ccflag		; get [CTRL-C] check flag
002697  1  D0 18        	BNE	LAB_FBA2		; exit if inhibited
002699  1               
002699  1  20 12 30     	JSR	V_INPT		; scan input device
00269C  1  90 0B        	BCC	LAB_FBA0		; exit if buffer empty
00269E  1               
00269E  1  8D 01 02     	STA	ccbyte		; save received byte
0026A1  1  A2 20        	LDX	#$20			; "life" timer for bytes
0026A3  1  8E 02 02     	STX	ccnull		; set countdown
0026A6  1  4C 00 0D     	JMP	LAB_1636		; return to BASIC
0026A9  1               
0026A9  1               LAB_FBA0
0026A9  1  AE 02 02     	LDX	ccnull		; get countdown byte
0026AC  1  F0 03        	BEQ	LAB_FBA2		; exit if finished
0026AE  1               
0026AE  1  CE 02 02     	DEC	ccnull		; else decrement countdown
0026B1  1               LAB_FBA2
0026B1  1  A2 DC        	LDX	#NmiBase		; set pointer to NMI values
0026B3  1  20 BC 26     	JSR	LAB_CKIN		; go check interrupt
0026B6  1  A2 DF        	LDX	#IrqBase		; set pointer to IRQ values
0026B8  1  20 BC 26     	JSR	LAB_CKIN		; go check interrupt
0026BB  1               LAB_CRTS
0026BB  1  60           	RTS
0026BC  1               
0026BC  1               ; check whichever interrupt is indexed by X
0026BC  1               
0026BC  1               LAB_CKIN
0026BC  1  B5 00        	LDA	PLUS_0,X		; get interrupt flag byte
0026BE  1  10 FB        	BPL	LAB_CRTS		; branch if interrupt not enabled
0026C0  1               
0026C0  1               ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
0026C0  1               ; automatically enable the interrupt when we exit
0026C0  1               
0026C0  1  0A           	ASL	A			; move happened bit to setup bit
0026C1  1  29 40        	AND	#$40			; mask happened bits
0026C3  1  F0 F6        	BEQ	LAB_CRTS		; if no interrupt then exit
0026C5  1               
0026C5  1  95 00        	STA	PLUS_0,X		; save interrupt flag byte
0026C7  1               
0026C7  1  8A           	TXA				; copy index ..
0026C8  1  A8           	TAY				; .. to Y
0026C9  1               
0026C9  1  68           	PLA				; dump return address low byte, call from CTRL-C
0026CA  1  68           	PLA				; dump return address high byte
0026CB  1               
0026CB  1  A9 05        	LDA	#$05			; need 5 bytes for GOSUB
0026CD  1  20 EE 08     	JSR	LAB_1212		; check room on stack for A bytes
0026D0  1  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
0026D2  1  48           	PHA				; push on stack
0026D3  1  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
0026D5  1  48           	PHA				; push on stack
0026D6  1  A5 88        	LDA	Clineh		; get current line high byte
0026D8  1  48           	PHA				; push on stack
0026D9  1  A5 87        	LDA	Clinel		; get current line low byte
0026DB  1  48           	PHA				; push on stack
0026DC  1  A9 8D        	LDA	#TK_GOSUB		; token for GOSUB
0026DE  1  48           	PHA				; push on stack
0026DF  1               
0026DF  1  B9 01 00     	LDA	PLUS_1,Y		; get interrupt code pointer low byte
0026E2  1  85 C3        	STA	Bpntrl		; save as BASIC execute pointer low byte
0026E4  1  B9 02 00     	LDA	PLUS_2,Y		; get interrupt code pointer high byte
0026E7  1  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
0026E9  1               
0026E9  1  4C A5 0C     	JMP	LAB_15C2		; go do interpreter inner loop
0026EC  1               					; can't RTS, we used the stack! the RTS from the ctrl-c
0026EC  1               					; check will be taken when the RETIRQ/RETNMI/RETURN is
0026EC  1               					; executed at the end of the subroutine
0026EC  1               
0026EC  1               ; get byte from input device, no waiting
0026EC  1               ; returns with carry set if byte in A
0026EC  1               
0026EC  1               INGET
0026EC  1  20 12 30     	JSR	V_INPT		; call scan input device
0026EF  1  B0 09        	BCS	LAB_FB95		; if byte go reset timer
0026F1  1               
0026F1  1  AD 02 02     	LDA	ccnull		; get countdown
0026F4  1  F0 09        	BEQ	LAB_FB96		; exit if empty
0026F6  1               
0026F6  1  AD 01 02     	LDA	ccbyte		; get last received byte
0026F9  1  38           	SEC				; flag we got a byte
0026FA  1               LAB_FB95
0026FA  1  A2 00        	LDX	#$00			; clear X
0026FC  1  8E 02 02     	STX	ccnull		; clear timer because we got a byte
0026FF  1               LAB_FB96
0026FF  1  60           	RTS
002700  1               
002700  1               ; these routines only enable the interrupts if the set-up flag is set
002700  1               ; if not they have no effect
002700  1               
002700  1               ; perform IRQ {ON|OFF|CLEAR}
002700  1               
002700  1               LAB_IRQ
002700  1  A2 DF        	LDX	#IrqBase		; set pointer to IRQ values
002702  1  2C           	.byte	$2C			; make next line BIT abs.
002703  1               
002703  1               ; perform NMI {ON|OFF|CLEAR}
002703  1               
002703  1               LAB_NMI
002703  1  A2 DC        	LDX	#NmiBase		; set pointer to NMI values
002705  1  C9 93        	CMP	#TK_ON		; compare with token for ON
002707  1  F0 11        	BEQ	LAB_INON		; go turn on interrupt
002709  1               
002709  1  C9 B6        	CMP	#TK_OFF		; compare with token for OFF
00270B  1  F0 07        	BEQ	LAB_IOFF		; go turn off interrupt
00270D  1               
00270D  1  49 A2        	EOR	#TK_CLEAR		; compare with token for CLEAR, A = $00 if = TK_CLEAR
00270F  1  F0 0E        	BEQ	LAB_INEX		; go clear interrupt flags and return
002711  1               
002711  1  4C EB 13     	JMP	LAB_SNER		; do syntax error then warm start
002714  1               
002714  1               LAB_IOFF
002714  1  A9 7F        	LDA	#$7F			; clear A
002716  1  35 00        	AND	PLUS_0,X		; AND with interrupt setup flag
002718  1  10 05        	BPL	LAB_INEX		; go clear interrupt enabled flag and return
00271A  1               
00271A  1               LAB_INON
00271A  1  B5 00        	LDA	PLUS_0,X		; get interrupt setup flag
00271C  1  0A           	ASL	A			; Shift bit to enabled flag
00271D  1  15 00        	ORA	PLUS_0,X		; OR with flag byte
00271F  1               LAB_INEX
00271F  1  95 00        	STA	PLUS_0,X		; save interrupt flag byte
002721  1  4C BC 00     	JMP	LAB_IGBY		; update BASIC execute pointer and return
002724  1               
002724  1               ; these routines set up the pointers and flags for the interrupt routines
002724  1               ; note that the interrupts are also enabled by these commands
002724  1               
002724  1               ; perform ON IRQ
002724  1               
002724  1               LAB_SIRQ
002724  1  58           	CLI				; enable interrupts
002725  1  A2 DF        	LDX	#IrqBase		; set pointer to IRQ values
002727  1  2C           	.byte	$2C			; make next line BIT abs.
002728  1               
002728  1               ; perform ON NMI
002728  1               
002728  1               LAB_SNMI
002728  1  A2 DC        	LDX	#NmiBase		; set pointer to NMI values
00272A  1               
00272A  1  86 78        	STX	TempB			; save interrupt pointer
00272C  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (past token)
00272F  1  20 3E 0F     	JSR	LAB_GFPN		; get fixed-point number into temp integer
002732  1  A5 79        	LDA	Smeml			; get start of mem low byte
002734  1  A6 7A        	LDX	Smemh			; get start of mem high byte
002736  1  20 11 0B     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
002739  1  B0 03        	BCS	LAB_LFND		; if carry set go set-up interrupt
00273B  1               
00273B  1  4C 5B 0E     	JMP	LAB_16F7		; else go do "Undefined statement" error and warm start
00273E  1               
00273E  1               LAB_LFND
00273E  1  A6 78        	LDX	TempB			; get interrupt pointer
002740  1  A5 AA        	LDA	Baslnl		; get pointer low byte
002742  1  E9 01        	SBC	#$01			; -1 (carry already set for subtract)
002744  1  95 01        	STA	PLUS_1,X		; save as interrupt pointer low byte
002746  1  A5 AB        	LDA	Baslnh		; get pointer high byte
002748  1  E9 00        	SBC	#$00			; subtract carry
00274A  1  95 02        	STA	PLUS_2,X		; save as interrupt pointer high byte
00274C  1               
00274C  1  A9 C0        	LDA	#$C0			; set interrupt enabled/setup bits
00274E  1  95 00        	STA	PLUS_0,X		; set interrupt flags
002750  1               LAB_IRTS
002750  1  60           	RTS
002751  1               
002751  1               ; return from IRQ service, restores the enabled flag.
002751  1               
002751  1               ; perform RETIRQ
002751  1               
002751  1               LAB_RETIRQ
002751  1  D0 FD        	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
002753  1               
002753  1  A5 DF        	LDA	IrqBase		; get interrupt flags
002755  1  0A           	ASL	A			; copy setup to enabled (b7)
002756  1  05 DF        	ORA	IrqBase		; OR in setup flag
002758  1  85 DF        	STA	IrqBase		; save enabled flag
00275A  1  4C 62 0E     	JMP	LAB_16E8		; go do rest of RETURN
00275D  1               
00275D  1               ; return from NMI service, restores the enabled flag.
00275D  1               
00275D  1               ; perform RETNMI
00275D  1               
00275D  1               LAB_RETNMI
00275D  1  D0 F1        	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
00275F  1               
00275F  1  A5 DC        	LDA	NmiBase		; get set-up flag
002761  1  0A           	ASL	A			; copy setup to enabled (b7)
002762  1  05 DC        	ORA	NmiBase		; OR in setup flag
002764  1  85 DC        	STA	NmiBase		; save enabled flag
002766  1  4C 62 0E     	JMP	LAB_16E8		; go do rest of RETURN
002769  1               
002769  1               ; MAX() MIN() pre process
002769  1               
002769  1               LAB_MMPP
002769  1  20 D2 12     	JSR	LAB_EVEZ		; process expression
00276C  1  4C B9 12     	JMP	LAB_CTNM		; check if source is numeric, else do type mismatch
00276F  1               
00276F  1               ; perform MAX()
00276F  1               
00276F  1               LAB_MAX
00276F  1  20 9D 27     	JSR	LAB_PHFA		; push FAC1, evaluate expression,
002772  1               					; pull FAC2 and compare with FAC1
002772  1  10 FB        	BPL	LAB_MAX		; branch if no swap to do
002774  1               
002774  1  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
002776  1  09 80        	ORA	#$80			; set top bit (clear sign from compare)
002778  1  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
00277A  1  20 AC 1D     	JSR	LAB_279B		; copy FAC2 to FAC1
00277D  1  F0 F0        	BEQ	LAB_MAX		; go do next (branch always)
00277F  1               
00277F  1               ; perform MIN()
00277F  1               
00277F  1               LAB_MIN
00277F  1  20 9D 27     	JSR	LAB_PHFA		; push FAC1, evaluate expression,
002782  1               					; pull FAC2 and compare with FAC1
002782  1  30 FB        	BMI	LAB_MIN		; branch if no swap to do
002784  1               
002784  1  F0 F9        	BEQ	LAB_MIN		; branch if no swap to do
002786  1               
002786  1  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
002788  1  09 80        	ORA	#$80			; set top bit (clear sign from compare)
00278A  1  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
00278C  1  20 AC 1D     	JSR	LAB_279B		; copy FAC2 to FAC1
00278F  1  F0 EE        	BEQ	LAB_MIN		; go do next (branch always)
002791  1               
002791  1               ; exit routine. don't bother returning to the loop code
002791  1               ; check for correct exit, else so syntax error
002791  1               
002791  1               LAB_MMEC
002791  1  C9 29        	CMP	#')'			; is it end of function?
002793  1  D0 05        	BNE	LAB_MMSE		; if not do MAX MIN syntax error
002795  1               
002795  1  68           	PLA				; dump return address low byte
002796  1  68           	PLA				; dump return address high byte
002797  1  4C BC 00     	JMP	LAB_IGBY		; update BASIC execute pointer (to chr past ")")
00279A  1               
00279A  1               LAB_MMSE
00279A  1  4C EB 13     	JMP	LAB_SNER		; do syntax error then warm start
00279D  1               
00279D  1               ; check for next, evaluate and return or exit
00279D  1               ; this is the routine that does most of the work
00279D  1               
00279D  1               LAB_PHFA
00279D  1  20 C2 00     	JSR	LAB_GBYT		; get next BASIC byte
0027A0  1  C9 2C        	CMP	#','			; is there more ?
0027A2  1  D0 ED        	BNE	LAB_MMEC		; if not go do end check
0027A4  1               
0027A4  1               					; push FAC1
0027A4  1  20 C2 20     	JSR	LAB_27BA		; round FAC1
0027A7  1  A5 B0        	LDA	FAC1_s		; get FAC1 sign
0027A9  1  09 7F        	ORA	#$7F			; set all non sign bits
0027AB  1  25 AD        	AND	FAC1_1		; AND FAC1 mantissa1 (AND in sign bit)
0027AD  1  48           	PHA				; push on stack
0027AE  1  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
0027B0  1  48           	PHA				; push on stack
0027B1  1  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
0027B3  1  48           	PHA				; push on stack
0027B4  1  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0027B6  1  48           	PHA				; push on stack
0027B7  1               
0027B7  1  20 BC 00     	JSR	LAB_IGBY		; scan and get next BASIC byte (after ",")
0027BA  1  20 B6 12     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
0027BD  1               					; else do type mismatch
0027BD  1               
0027BD  1               					; pop FAC2 (MAX/MIN expression so far)
0027BD  1  68           	PLA				; pop exponent
0027BE  1  85 B3        	STA	FAC2_e		; save FAC2 exponent
0027C0  1  68           	PLA				; pop mantissa3
0027C1  1  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
0027C3  1  68           	PLA				; pop mantissa1
0027C4  1  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
0027C6  1  68           	PLA				; pop sign/mantissa1
0027C7  1  85 B4        	STA	FAC2_1		; save FAC2 sign/mantissa1
0027C9  1  85 B7        	STA	FAC2_s		; save FAC2 sign
0027CB  1               
0027CB  1               					; compare FAC1 with (packed) FAC2
0027CB  1  A9 B3        	LDA	#FAC2_e_LO		; set pointer low byte to FAC2
0027CD  1  A0 00        	LDY	#FAC2_e_HI		; set pointer high byte to FAC2
0027CF  1  4C 00 21     	JMP	LAB_27F8		; compare FAC1 with FAC2 (AY) and return
0027D2  1               					; returns A=$00 if FAC1 = (AY)
0027D2  1               					; returns A=$01 if FAC1 > (AY)
0027D2  1               					; returns A=$FF if FAC1 < (AY)
0027D2  1               
0027D2  1               ; perform WIDTH
0027D2  1               
0027D2  1               LAB_WDTH
0027D2  1  C9 2C        	CMP	#','			; is next byte ","
0027D4  1  F0 1B        	BEQ	LAB_TBSZ		; if so do tab size
0027D6  1               
0027D6  1  20 75 1C     	JSR	LAB_GTBY		; get byte parameter
0027D9  1  8A           	TXA				; copy width to A
0027DA  1  F0 0A        	BEQ	LAB_NSTT		; branch if set for infinite line
0027DC  1               
0027DC  1  E0 10        	CPX	#$10			; else make min width = 16d
0027DE  1  90 45        	BCC	TabErr		; if less do function call error and exit
0027E0  1               
0027E0  1               ; this next compare ensures that we can't exit WIDTH via an error leaving the
0027E0  1               ; tab size greater than the line length.
0027E0  1               
0027E0  1  E4 64        	CPX	TabSiz		; compare with tab size
0027E2  1  B0 02        	BCS	LAB_NSTT		; branch if >= tab size
0027E4  1               
0027E4  1  86 64        	STX	TabSiz		; else make tab size = terminal width
0027E6  1               LAB_NSTT
0027E6  1  86 0F        	STX	TWidth		; set the terminal width
0027E8  1  20 C2 00     	JSR	LAB_GBYT		; get BASIC byte back
0027EB  1  F0 1A        	BEQ	WExit			; exit if no following
0027ED  1               
0027ED  1  C9 2C        	CMP	#','			; else is it ","
0027EF  1  D0 A9        	BNE	LAB_MMSE		; if not do syntax error
0027F1  1               
0027F1  1               LAB_TBSZ
0027F1  1  20 72 1C     	JSR	LAB_SGBY		; scan and get byte parameter
0027F4  1  8A           	TXA				; copy TAB size
0027F5  1  30 2E        	BMI	TabErr		; if >127 do function call error and exit
0027F7  1               
0027F7  1  E0 01        	CPX	#$01			; compare with min-1
0027F9  1  90 2A        	BCC	TabErr		; if <=1 do function call error and exit
0027FB  1               
0027FB  1  A5 0F        	LDA	TWidth		; set flags for width
0027FD  1  F0 06        	BEQ	LAB_SVTB		; skip check if infinite line
0027FF  1               
0027FF  1  E4 0F        	CPX	TWidth		; compare TAB with width
002801  1  F0 02        	BEQ	LAB_SVTB		; ok if =
002803  1               
002803  1  B0 20        	BCS	TabErr		; branch if too big
002805  1               
002805  1               LAB_SVTB
002805  1  86 64        	STX	TabSiz		; save TAB size
002807  1               
002807  1               ; calculate tab column limit from TAB size. The Iclim is set to the last tab
002807  1               ; position on a line that still has at least one whole tab width between it
002807  1               ; and the end of the line.
002807  1               
002807  1               WExit
002807  1  A5 0F        	LDA	TWidth		; get width
002809  1  F0 06        	BEQ	LAB_SULP		; branch if infinite line
00280B  1               
00280B  1  C5 64        	CMP	TabSiz		; compare with tab size
00280D  1  B0 03        	BCS	LAB_WDLP		; branch if >= tab size
00280F  1               
00280F  1  85 64        	STA	TabSiz		; else make tab size = terminal width
002811  1               LAB_SULP
002811  1  38           	SEC				; set carry for subtract
002812  1               LAB_WDLP
002812  1  E5 64        	SBC	TabSiz		; subtract tab size
002814  1  B0 FC        	BCS	LAB_WDLP		; loop while no borrow
002816  1               
002816  1  65 64        	ADC	TabSiz		; add tab size back
002818  1  18           	CLC				; clear carry for add
002819  1  65 64        	ADC	TabSiz		; add tab size back again
00281B  1  85 10        	STA	Iclim			; save for now
00281D  1  A5 0F        	LDA	TWidth		; get width back
00281F  1  38           	SEC				; set carry for subtract
002820  1  E5 10        	SBC	Iclim			; subtract remainder
002822  1  85 10        	STA	Iclim			; save tab column limit
002824  1               LAB_NOSQ
002824  1  60           	RTS
002825  1               
002825  1               TabErr
002825  1  4C 12 17     	JMP	LAB_FCER		; do function call error then warm start
002828  1               
002828  1               ; perform SQR()
002828  1               
002828  1               LAB_SQR
002828  1  A5 B0        	LDA	FAC1_s		; get FAC1 sign
00282A  1  30 F9        	BMI	TabErr		; if -ve do function call error
00282C  1               
00282C  1  A5 AC        	LDA	FAC1_e		; get exponent
00282E  1  F0 F4        	BEQ	LAB_NOSQ		; if zero just return
002830  1               
002830  1               					; else do root
002830  1  20 B3 20     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
002833  1  A9 00        	LDA	#$00			; clear A
002835  1               
002835  1  85 77        	STA	FACt_3		; clear remainder
002837  1  85 76        	STA	FACt_2		; ..
002839  1  85 75        	STA	FACt_1		; ..
00283B  1  85 78        	STA	TempB			; ..
00283D  1               
00283D  1  85 AF        	STA	FAC1_3		; clear root
00283F  1  85 AE        	STA	FAC1_2		; ..
002841  1  85 AD        	STA	FAC1_1		; ..
002843  1               
002843  1  A2 18        	LDX	#$18			; 24 pairs of bits to do
002845  1  A5 B3        	LDA	FAC2_e		; get exponent
002847  1  4A           	LSR	A			; check odd/even
002848  1  B0 0E        	BCS	LAB_SQE2		; if odd only 1 shift first time
00284A  1               
00284A  1               LAB_SQE1
00284A  1  06 B6        	ASL	FAC2_3		; shift highest bit of number ..
00284C  1  26 B5        	ROL	FAC2_2		; ..
00284E  1  26 B4        	ROL	FAC2_1		; ..
002850  1  26 77        	ROL	FACt_3		; .. into remainder
002852  1  26 76        	ROL	FACt_2		; ..
002854  1  26 75        	ROL	FACt_1		; ..
002856  1  26 78        	ROL	TempB			; .. never overflows
002858  1               LAB_SQE2
002858  1  06 B6        	ASL	FAC2_3		; shift highest bit of number ..
00285A  1  26 B5        	ROL	FAC2_2		; ..
00285C  1  26 B4        	ROL	FAC2_1		; ..
00285E  1  26 77        	ROL	FACt_3		; .. into remainder
002860  1  26 76        	ROL	FACt_2		; ..
002862  1  26 75        	ROL	FACt_1		; ..
002864  1  26 78        	ROL	TempB			; .. never overflows
002866  1               
002866  1  06 AF        	ASL	FAC1_3		; root = root * 2
002868  1  26 AE        	ROL	FAC1_2		; ..
00286A  1  26 AD        	ROL	FAC1_1		; .. never overflows
00286C  1               
00286C  1  A5 AF        	LDA	FAC1_3		; get root low byte
00286E  1  2A           	ROL	A		; *2
00286F  1  85 5B        	STA	Temp3			; save partial low byte
002871  1  A5 AE        	LDA	FAC1_2		; get root low mid byte
002873  1  2A           	ROL	A			; *2
002874  1  85 5C        	STA	Temp3+1		; save partial low mid byte
002876  1  A5 AD        	LDA	FAC1_1		; get root high mid byte
002878  1  2A           	ROL	A			; *2
002879  1  85 5D        	STA	Temp3+2		; save partial high mid byte
00287B  1  A9 00        	LDA	#$00			; get root high byte (always $00)
00287D  1  2A           	ROL	A			; *2
00287E  1  85 5E        	STA	Temp3+3		; save partial high byte
002880  1               
002880  1               					; carry clear for subtract +1
002880  1  A5 77        	LDA	FACt_3		; get remainder low byte
002882  1  E5 5B        	SBC	Temp3			; subtract partial low byte
002884  1  85 5B        	STA	Temp3			; save partial low byte
002886  1               
002886  1  A5 76        	LDA	FACt_2		; get remainder low mid byte
002888  1  E5 5C        	SBC	Temp3+1		; subtract partial low mid byte
00288A  1  85 5C        	STA	Temp3+1		; save partial low mid byte
00288C  1               
00288C  1  A5 75        	LDA	FACt_1		; get remainder high mid byte
00288E  1  E5 5D        	SBC	Temp3+2		; subtract partial high mid byte
002890  1  A8           	TAY				; copy partial high mid byte
002891  1               
002891  1  A5 78        	LDA	TempB			; get remainder high byte
002893  1  E5 5E        	SBC	Temp3+3		; subtract partial high byte
002895  1  90 0E        	BCC	LAB_SQNS		; skip sub if remainder smaller
002897  1               
002897  1  85 78        	STA	TempB			; save remainder high byte
002899  1               
002899  1  84 75        	STY	FACt_1		; save remainder high mid byte
00289B  1               
00289B  1  A5 5C        	LDA	Temp3+1		; get remainder low mid byte
00289D  1  85 76        	STA	FACt_2		; save remainder low mid byte
00289F  1               
00289F  1  A5 5B        	LDA	Temp3			; get partial low byte
0028A1  1  85 77        	STA	FACt_3		; save remainder low byte
0028A3  1               
0028A3  1  E6 AF        	INC	FAC1_3		; increment root low byte (never any rollover)
0028A5  1               LAB_SQNS
0028A5  1  CA           	DEX				; decrement bit pair count
0028A6  1  D0 A2        	BNE	LAB_SQE1		; loop if not all done
0028A8  1               
0028A8  1  38           	SEC				; set carry for subtract
0028A9  1  A5 B3        	LDA	FAC2_e		; get exponent
0028AB  1  E9 80        	SBC	#$80			; normalise
0028AD  1  6A           	ROR	A			; /2 and re-bias to $80
0028AE  1  69 00        	ADC	#$00			; add bit zero back in (allow for half shift)
0028B0  1  85 AC        	STA	FAC1_e		; save it
0028B2  1  4C 1D 1E     	JMP	LAB_24D5		; normalise FAC1 and return
0028B5  1               
0028B5  1               ; perform VARPTR()
0028B5  1               
0028B5  1               LAB_VARPTR
0028B5  1  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0028B8  1  20 93 15     	JSR	LAB_GVAR		; get var address
0028BB  1  20 D8 13     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
0028BE  1  A4 95        	LDY	Cvaral		; get var address low byte
0028C0  1  A5 96        	LDA	Cvarah		; get var address high byte
0028C2  1  4C 42 18     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
0028C5  1               
0028C5  1               ; perform PI
0028C5  1               
0028C5  1               LAB_PI
0028C5  1  A9 9B        	LDA	#LAB_2C7C_LO		; set (2*pi) pointer low byte
0028C7  1  A0 29        	LDY	#LAB_2C7C_HI		; set (2*pi) pointer high byte
0028C9  1  20 66 20     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
0028CC  1  C6 AC        	DEC	FAC1_e		; make result = PI
0028CE  1  60           	RTS
0028CF  1               
0028CF  1               ; perform TWOPI
0028CF  1               
0028CF  1               LAB_TWOPI
0028CF  1  A9 9B        	LDA	#LAB_2C7C_LO		; set (2*pi) pointer low byte
0028D1  1  A0 29        	LDY	#LAB_2C7C_HI		; set (2*pi) pointer high byte
0028D3  1  4C 66 20     	JMP	LAB_UFAC		; unpack memory (AY) into FAC1 and return
0028D6  1               
0028D6  1               
0028D6  1               ; The rest are tables messages and code for RAM
0028D6  1               
0028D6  1               ; the rest of the code is tables and BASIC start-up code
0028D6  1               
0028D6  1               PG2_TABS
0028D6  1  00           	.byte	$00			; ctrl-c flag		-	$00 = enabled
0028D7  1  00           	.byte	$00			; ctrl-c byte		-	GET needs this
0028D8  1  00           	.byte	$00			; ctrl-c byte timeout	-	GET needs this
0028D9  1  94 26        	.word	CTRLC			; ctrl c check vector
0028DB  1               ;	.word	xxxx			; non halting key input	-	monitor to set this
0028DB  1               ;	.word	xxxx			; output vector		-	monitor to set this
0028DB  1               ;	.word	xxxx			; load vector		-	monitor to set this
0028DB  1               ;	.word	xxxx			; save vector		-	monitor to set this
0028DB  1               PG2_TABE
0028DB  1               
0028DB  1               ; character get subroutine for zero page
0028DB  1               
0028DB  1               ; For a 1.8432MHz 6502 including the JSR and RTS
0028DB  1               ; fastest (>=":")	=  29 cycles =  15.7uS
0028DB  1               ; slowest (<":")	=  40 cycles =  21.7uS
0028DB  1               ; space skip	= +21 cycles = +11.4uS
0028DB  1               ; inc across page	=  +4 cycles =  +2.2uS
0028DB  1               
0028DB  1               ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
0028DB  1               ; block is copied to it's destination, any non zero page address will do at assembly
0028DB  1               ; time, to assemble a three byte instruction.
0028DB  1               
0028DB  1               ; page 0 initialisation table from $BC
0028DB  1               ; increment and scan memory
0028DB  1               
0028DB  1               LAB_2CEE
0028DB  1  E6 C3        	INC	Bpntrl		; increment BASIC execute pointer low byte
0028DD  1  D0 02        	BNE	LAB_2CF4		; branch if no carry
0028DF  1               					; else
0028DF  1  E6 C4        	INC	Bpntrh		; increment BASIC execute pointer high byte
0028E1  1               
0028E1  1               ; page 0 initialisation table from $C2
0028E1  1               ; scan memory
0028E1  1               
0028E1  1               LAB_2CF4
0028E1  1  AD FF FF     	LDA	$FFFF			; get byte to scan (addr set by call routine)
0028E4  1  C9 AD        	CMP	#TK_ELSE		; compare with the token for ELSE
0028E6  1  F0 0E        	BEQ	LAB_2D05		; exit if ELSE, not numeric, carry set
0028E8  1               
0028E8  1  C9 3A        	CMP	#':'			; compare with ":"
0028EA  1  B0 0A        	BCS	LAB_2D05		; exit if >= ":", not numeric, carry set
0028EC  1               
0028EC  1  C9 20        	CMP	#' '			; compare with " "
0028EE  1  F0 EB        	BEQ	LAB_2CEE		; if " " go do next
0028F0  1               
0028F0  1  38           	SEC				; set carry for SBC
0028F1  1  E9 30        	SBC	#'0'			; subtract "0"
0028F3  1  38           	SEC				; set carry for SBC
0028F4  1  E9 D0        	SBC	#$D0			; subtract -"0"
0028F6  1               					; clear carry if byte = "0"-"9"
0028F6  1               LAB_2D05
0028F6  1  60           	RTS
0028F7  1               
0028F7  1               ; page zero initialisation table $00-$12 inclusive
0028F7  1               
0028F7  1               StrTab
0028F7  1  4C           	.byte	$4C			; JMP opcode
0028F8  1  0C 08        	.word LAB_COLD		; initial warm start vector (cold start)
0028FA  1               
0028FA  1  00           	.byte	$00			; these bytes are not used by BASIC
0028FB  1  00 00        	.word	$0000			;
0028FD  1  00 00        	.word	$0000			;
0028FF  1  00 00        	.word	$0000			;
002901  1               
002901  1  4C           	.byte	$4C			; JMP opcode
002902  1  12 17        	.word	LAB_FCER		; initial user function vector ("Function call" error)
002904  1  00           	.byte	$00			; default NULL count
002905  1  00           	.byte	$00			; clear terminal position
002906  1  00           	.byte	$00			; default terminal width byte
002907  1  F2           	.byte	$F2			; default limit for TAB = 14
002908  1  00 34        	.word	Ram_base		; start of user RAM
00290A  1               EndTab
00290A  1               
00290A  1               LAB_MSZM
00290A  1  0D 0A 4D 65  	.byte	$0D,$0A,"Memory size ",$00
00290E  1  6D 6F 72 79  
002912  1  20 73 69 7A  
002919  1               
002919  1               LAB_SMSG
002919  1  20 42 79 74  	.byte	" Bytes free",$0D,$0A,$0A
00291D  1  65 73 20 66  
002921  1  72 65 65 0D  
002927  1  45 6E 68 61  	.byte	"Enhanced BASIC 2.22",$0A,$00
00292B  1  6E 63 65 64  
00292F  1  20 42 41 53  
00293C  1               
00293C  1               ; numeric constants and series
00293C  1               
00293C  1               					; constants and series for LOG(n)
00293C  1               LAB_25A0
00293C  1  02           	.byte	$02			; counter
00293D  1  80 19 56 62  	.byte	$80,$19,$56,$62	; 0.59898
002941  1  80 76 22 F3  	.byte	$80,$76,$22,$F3	; 0.96147
002945  1               ;##	.byte	$80,$76,$22,$F1	; 0.96147
002945  1  82 38 AA 40  	.byte	$82,$38,$AA,$40	; 2.88539
002949  1               ;##	.byte	$82,$38,$AA,$45	; 2.88539
002949  1               
002949  1               LAB_25AD
002949  1  80 35 04 F3  	.byte	$80,$35,$04,$F3	; 0.70711	1/root 2
00294D  1               LAB_25B1
00294D  1  81 35 04 F3  	.byte	$81,$35,$04,$F3	; 1.41421	root 2
002951  1               LAB_25B5
002951  1  80 80 00 00  	.byte	$80,$80,$00,$00	; -0.5
002955  1               LAB_25B9
002955  1  80 31 72 18  	.byte	$80,$31,$72,$18	; 0.69315	LOG(2)
002959  1               
002959  1               					; numeric PRINT constants
002959  1               LAB_2947
002959  1  91 43 4F F8  	.byte	$91,$43,$4F,$F8	; 99999.9375 (max value with at least one decimal)
00295D  1               LAB_294B
00295D  1  94 74 23 F7  	.byte	$94,$74,$23,$F7	; 999999.4375 (max value before scientific notation)
002961  1               LAB_294F
002961  1  94 74 24 00  	.byte	$94,$74,$24,$00	; 1000000
002965  1               
002965  1               					; EXP(n) constants and series
002965  1               LAB_2AFA
002965  1  81 38 AA 3B  	.byte	$81,$38,$AA,$3B	; 1.4427	(1/LOG base 2 e)
002969  1               LAB_2AFE
002969  1  06           	.byte	$06			; counter
00296A  1  74 63 90 8C  	.byte	$74,$63,$90,$8C	; 2.17023e-4
00296E  1  77 23 0C AB  	.byte	$77,$23,$0C,$AB	; 0.00124
002972  1  7A 1E 94 00  	.byte	$7A,$1E,$94,$00	; 0.00968
002976  1  7C 63 42 80  	.byte	$7C,$63,$42,$80	; 0.05548
00297A  1  7E 75 FE D0  	.byte	$7E,$75,$FE,$D0	; 0.24023
00297E  1  80 31 72 15  	.byte	$80,$31,$72,$15	; 0.69315
002982  1  81 00 00 00  	.byte	$81,$00,$00,$00	; 1.00000
002986  1               
002986  1               ;##	.byte	$07			; counter
002986  1               ;##	.byte	$74,$94,$2E,$40	; -1/7! (-1/5040)
002986  1               ;##	.byte	$77,$2E,$4F,$70	;  1/6! ( 1/720)
002986  1               ;##	.byte	$7A,$88,$02,$6E	; -1/5! (-1/120)
002986  1               ;##	.byte	$7C,$2A,$A0,$E6	;  1/4! ( 1/24)
002986  1               ;##	.byte	$7E,$AA,$AA,$50	; -1/3! (-1/6)
002986  1               ;##	.byte	$7F,$7F,$FF,$FF	;  1/2! ( 1/2)
002986  1               ;##	.byte	$81,$80,$00,$00	; -1/1! (-1/1)
002986  1               ;##	.byte	$81,$00,$00,$00	;  1/0! ( 1/1)
002986  1               
002986  1               					; trigonometric constants and series
002986  1               LAB_2C78
002986  1  81 49 0F DB  	.byte	$81,$49,$0F,$DB	; 1.570796371 (pi/2) as floating #
00298A  1               LAB_2C84
00298A  1  04           	.byte	$04			; counter
00298B  1  86 1E D7 FB  	.byte	$86,$1E,$D7,$FB	; 39.7109
00298F  1               ;##	.byte	$86,$1E,$D7,$BA	; 39.7109
00298F  1  87 99 26 65  	.byte	$87,$99,$26,$65	;-76.575
002993  1               ;##	.byte	$87,$99,$26,$64	;-76.575
002993  1  87 23 34 58  	.byte	$87,$23,$34,$58	; 81.6022
002997  1  86 A5 5D E1  	.byte	$86,$A5,$5D,$E1	;-41.3417
00299B  1               ;##	.byte	$86,$A5,$5D,$E0	;-41.3417
00299B  1               LAB_2C7C
00299B  1  83 49 0F DB  	.byte	$83,$49,$0F,$DB	; 6.28319 (2*pi) as floating #
00299F  1               ;##	.byte	$83,$49,$0F,$DA	; 6.28319 (2*pi) as floating #
00299F  1               
00299F  1               LAB_2CC9
00299F  1  08           	.byte	$08			; counter
0029A0  1  78 3A C5 37  	.byte	$78,$3A,$C5,$37	; 0.00285
0029A4  1  7B 83 A2 5C  	.byte	$7B,$83,$A2,$5C	;-0.0160686
0029A8  1  7C 2E DD 4D  	.byte	$7C,$2E,$DD,$4D	; 0.0426915
0029AC  1  7D 99 B0 1E  	.byte	$7D,$99,$B0,$1E	;-0.0750429
0029B0  1  7D 59 ED 24  	.byte	$7D,$59,$ED,$24	; 0.106409
0029B4  1  7E 91 72 00  	.byte	$7E,$91,$72,$00	;-0.142036
0029B8  1  7E 4C B9 73  	.byte	$7E,$4C,$B9,$73	; 0.199926
0029BC  1  7F AA AA 53  	.byte	$7F,$AA,$AA,$53	;-0.333331
0029C0  1               
0029C0  1               ;##	.byte	$08			; counter
0029C0  1               ;##	.byte	$78,$3B,$D7,$4A	; 1/17
0029C0  1               ;##	.byte	$7B,$84,$6E,$02	;-1/15
0029C0  1               ;##	.byte	$7C,$2F,$C1,$FE	; 1/13
0029C0  1               ;##	.byte	$7D,$9A,$31,$74	;-1/11
0029C0  1               ;##	.byte	$7D,$5A,$3D,$84	; 1/9
0029C0  1               ;##	.byte	$7E,$91,$7F,$C8	;-1/7
0029C0  1               ;##	.byte	$7E,$4C,$BB,$E4	; 1/5
0029C0  1               ;##	.byte	$7F,$AA,$AA,$6C	;-1/3
0029C0  1               
0029C0  1               LAB_1D96	= *+1			; $00,$00 used for undefined variables
0029C0  1               LAB_259C
0029C0  1  81 00 00 00  	.byte	$81,$00,$00,$00	; 1.000000, used for INC
0029C4  1               LAB_2AFD
0029C4  1  81 80 00 00  	.byte	$81,$80,$00,$00	; -1.00000, used for DEC. must be on the same page as +1.00
0029C8  1               
0029C8  1               					; misc constants
0029C8  1               LAB_1DF7
0029C8  1  90           	.byte	$90			;-32768 (uses first three bytes from 0.5)
0029C9  1               LAB_2A96
0029C9  1  80 00 00 00  	.byte	$80,$00,$00,$00	; 0.5
0029CD  1               LAB_2C80
0029CD  1  7F 00 00 00  	.byte	$7F,$00,$00,$00	; 0.25
0029D1  1               LAB_26B5
0029D1  1  84 20 00 00  	.byte	$84,$20,$00,$00	; 10.0000 divide by 10 constant
0029D5  1               
0029D5  1               ; This table is used in converting numbers to ASCII.
0029D5  1               
0029D5  1               LAB_2A9A
0029D5  1               LAB_2A9B = LAB_2A9A+1
0029D5  1               LAB_2A9C = LAB_2A9B+1
0029D5  1  FE 79 60     	.byte	$FE,$79,$60		; -100000
0029D8  1  00 27 10     	.byte	$00,$27,$10		; 10000
0029DB  1  FF FC 18     	.byte	$FF,$FC,$18		; -1000
0029DE  1  00 00 64     	.byte	$00,$00,$64		; 100
0029E1  1  FF FF F6     	.byte	$FF,$FF,$F6		; -10
0029E4  1  00 00 01     	.byte	$00,$00,$01		; 1
0029E7  1               
0029E7  1               LAB_CTBL
0029E7  1  03 0D        	.word	LAB_END-1		; END
0029E9  1  40 0C        	.word	LAB_FOR-1		; FOR
0029EB  1  4D 12        	.word	LAB_NEXT-1		; NEXT
0029ED  1  74 0E        	.word	LAB_DATA-1		; DATA
0029EF  1  2F 11        	.word	LAB_INPUT-1		; INPUT
0029F1  1  47 15        	.word	LAB_DIM-1		; DIM
0029F3  1  4F 11        	.word	LAB_READ-1		; READ
0029F5  1  9C 0F        	.word	LAB_LET-1		; LET
0029F7  1  6E 0F        	.word	LAB_DEC-1		; DEC			new command
0029F9  1  D3 0D        	.word	LAB_GOTO-1		; GOTO
0029FB  1  92 0D        	.word	LAB_RUN-1		; RUN
0029FD  1  A2 0E        	.word	LAB_IF-1		; IF
0029FF  1  2A 0D        	.word	LAB_RESTORE-1	; RESTORE		modified command
002A01  1  B6 0D        	.word	LAB_GOSUB-1		; GOSUB
002A03  1  50 27        	.word	LAB_RETIRQ-1	; RETIRQ		new command
002A05  1  5C 27        	.word	LAB_RETNMI-1	; RETNMI		new command
002A07  1  5F 0E        	.word	LAB_RETURN-1	; RETURN
002A09  1  06 0F        	.word	LAB_REM-1		; REM
002A0B  1  01 0D        	.word	LAB_STOP-1		; STOP
002A0D  1  0F 0F        	.word	LAB_ON-1		; ON			modified command
002A0F  1  68 0D        	.word	LAB_NULL-1		; NULL		modified command
002A11  1  71 0F        	.word	LAB_INC-1		; INC			new command
002A13  1  71 1D        	.word	LAB_WAIT-1		; WAIT
002A15  1  1D 31        	.word	V_LOAD-1		; LOAD
002A17  1  58 30        	.word	V_SAVE-1		; SAVE
002A19  1  5C 18        	.word	LAB_DEF-1		; DEF
002A1B  1  F6 1C        	.word	LAB_POKE-1		; POKE
002A1D  1  12 1D        	.word	LAB_DOKE-1		; DOKE		new command
002A1F  1  5F 1D        	.word	LAB_CALL-1		; CALL		new command
002A21  1  9C 0D        	.word	LAB_DO-1		; DO			new command
002A23  1  05 0E        	.word	LAB_LOOP-1		; LOOP		new command
002A25  1  3D 10        	.word	LAB_PRINT-1		; PRINT
002A27  1  6E 0D        	.word	LAB_CONT-1		; CONT
002A29  1  8B 0B        	.word	LAB_LIST-1		; LIST
002A2B  1  88 0B        	.word	LAB_CLEAR-1		; CLEAR
002A2D  1  36 0B        	.word	LAB_NEW-1		; NEW
002A2F  1  D1 27        	.word	LAB_WDTH-1		; WIDTH		new command
002A31  1  0C 10        	.word	LAB_GET-1		; GET			new command
002A33  1  37 1D        	.word	LAB_SWAP-1		; SWAP		new command
002A35  1  6D 25        	.word	LAB_BITSET-1	; BITSET		new command
002A37  1  81 25        	.word	LAB_BITCLR-1	; BITCLR		new command
002A39  1  FF 26        	.word	LAB_IRQ-1		; IRQ			new command
002A3B  1  02 27        	.word	LAB_NMI-1		; NMI			new command
002A3D  1  55 30        	.word	LAB_KILL-1		; KILL			new command
002A3F  1               
002A3F  1               ; function pre process routine table
002A3F  1               
002A3F  1               LAB_FTPL
002A3F  1               LAB_FTPM	= LAB_FTPL+$01
002A3F  1  4D 14        	.word	LAB_PPFN-1		; SGN(n)	process numeric expression in ()
002A41  1  4D 14        	.word	LAB_PPFN-1		; INT(n)		"
002A43  1  4D 14        	.word	LAB_PPFN-1		; ABS(n)		"
002A45  1  D1 12        	.word	LAB_EVEZ-1		; USR(x)	process any expression
002A47  1  D4 13        	.word	LAB_1BF7-1		; FRE(x)		"
002A49  1  D4 13        	.word	LAB_1BF7-1		; POS(x)		"
002A4B  1  4D 14        	.word	LAB_PPFN-1		; SQR(n)	process numeric expression in ()
002A4D  1  4D 14        	.word	LAB_PPFN-1		; RND(n)		"
002A4F  1  4D 14        	.word	LAB_PPFN-1		; LOG(n)		"
002A51  1  4D 14        	.word	LAB_PPFN-1		; EXP(n)		"
002A53  1  4D 14        	.word	LAB_PPFN-1		; COS(n)		"
002A55  1  4D 14        	.word	LAB_PPFN-1		; SIN(n)		"
002A57  1  4D 14        	.word	LAB_PPFN-1		; TAN(n)		"
002A59  1  4D 14        	.word	LAB_PPFN-1		; ATN(n)		"
002A5B  1  4D 14        	.word	LAB_PPFN-1		; PEEK(n)		"
002A5D  1  4D 14        	.word	LAB_PPFN-1		; DEEK(n)		"
002A5F  1  00 00        	.word	$0000			; SADD()	none
002A61  1  47 14        	.word	LAB_PPFS-1		; LEN($)	process string expression in ()
002A63  1  4D 14        	.word	LAB_PPFN-1		; STR$(n)	process numeric expression in ()
002A65  1  47 14        	.word	LAB_PPFS-1		; VAL($)	process string expression in ()
002A67  1  47 14        	.word	LAB_PPFS-1		; ASC($)		"
002A69  1  47 14        	.word	LAB_PPFS-1		; UCASE$($)		"
002A6B  1  47 14        	.word	LAB_PPFS-1		; LCASE$($)		"
002A6D  1  4D 14        	.word	LAB_PPFN-1		; CHR$(n)	process numeric expression in ()
002A6F  1  74 14        	.word	LAB_BHSS-1		; HEX$(n)		"
002A71  1  74 14        	.word	LAB_BHSS-1		; BIN$(n)		"
002A73  1  00 00        	.word	$0000			; BITTST()	none
002A75  1  68 27        	.word	LAB_MMPP-1		; MAX()	process numeric expression
002A77  1  68 27        	.word	LAB_MMPP-1		; MIN()		"
002A79  1  53 14        	.word	LAB_PPBI-1		; PI		advance pointer
002A7B  1  53 14        	.word	LAB_PPBI-1		; TWOPI		"
002A7D  1  00 00        	.word	$0000			; VARPTR()	none
002A7F  1  58 14        	.word	LAB_LRMS-1		; LEFT$()	process string expression
002A81  1  58 14        	.word	LAB_LRMS-1		; RIGHT$()		"
002A83  1  58 14        	.word	LAB_LRMS-1		; MID$()		"
002A85  1               
002A85  1               ; action addresses for functions
002A85  1               
002A85  1               LAB_FTBL
002A85  1               LAB_FTBM	= LAB_FTBL+$01
002A85  1  DF 20        	.word	LAB_SGN-1		; SGN()
002A87  1  69 21        	.word	LAB_INT-1		; INT()
002A89  1  FC 20        	.word	LAB_ABS-1		; ABS()
002A8B  1  38 25        	.word	LAB_USR-1		; USR()
002A8D  1  2D 18        	.word	LAB_FRE-1		; FRE()
002A8F  1  4C 18        	.word	LAB_POS-1		; POS()
002A91  1  27 28        	.word	LAB_SQR-1		; SQR()
002A93  1  88 24        	.word	LAB_RND-1		; RND()		modified function
002A95  1  E3 1E        	.word	LAB_LOG-1		; LOG()
002A97  1  EA 23        	.word	LAB_EXP-1		; EXP()
002A99  1  BC 24        	.word	LAB_COS-1		; COS()
002A9B  1  C3 24        	.word	LAB_SIN-1		; SIN()
002A9D  1  0C 25        	.word	LAB_TAN-1		; TAN()
002A9F  1  3E 25        	.word	LAB_ATN-1		; ATN()
002AA1  1  EB 1C        	.word	LAB_PEEK-1		; PEEK()
002AA3  1  FF 1C        	.word	LAB_DEEK-1		; DEEK()		new function
002AA5  1  3D 1C        	.word	LAB_SADD-1		; SADD()		new function
002AA7  1  56 1C        	.word	LAB_LENS-1		; LEN()
002AA9  1  0E 19        	.word	LAB_STRS-1		; STR$()
002AAB  1  83 1C        	.word	LAB_VAL-1		; VAL()
002AAD  1  61 1C        	.word	LAB_ASC-1		; ASC()
002AAF  1  1B 1C        	.word	LAB_UCASE-1		; UCASE$()		new function
002AB1  1  FA 1B        	.word	LAB_LCASE-1		; LCASE$()		new function
002AB3  1  6C 1B        	.word	LAB_CHRS-1		; CHR$()
002AB5  1  0E 26        	.word	LAB_HEXS-1		; HEX$()		new function
002AB7  1  BF 25        	.word	LAB_BINS-1		; BIN$()		new function
002AB9  1  97 25        	.word	LAB_BTST-1		; BITTST()		new function
002ABB  1  6E 27        	.word	LAB_MAX-1		; MAX()		new function
002ABD  1  7E 27        	.word	LAB_MIN-1		; MIN()		new function
002ABF  1  C4 28        	.word	LAB_PI-1		; PI			new function
002AC1  1  CE 28        	.word	LAB_TWOPI-1		; TWOPI		new function
002AC3  1  B4 28        	.word	LAB_VARPTR-1	; VARPTR()		new function
002AC5  1  7E 1B        	.word	LAB_LEFT-1		; LEFT$()
002AC7  1  87 1B        	.word	LAB_RIGHT-1		; RIGHT$()
002AC9  1  B6 1B        	.word	LAB_MIDS-1		; MID$()
002ACB  1               
002ACB  1               ; hierarchy and action addresses for operator
002ACB  1               
002ACB  1               LAB_OPPT
002ACB  1  79           	.byte	$79			; +
002ACC  1  A9 1D        	.word	LAB_ADD-1
002ACE  1  79           	.byte	$79			; -
002ACF  1  8E 1D        	.word	LAB_SUBTRACT-1
002AD1  1  7B           	.byte	$7B			; *
002AD2  1  24 1F        	.word	LAB_MULTIPLY-1
002AD4  1  7B           	.byte	$7B			; /
002AD5  1  EC 1F        	.word	LAB_DIVIDE-1
002AD7  1  7F           	.byte	$7F			; ^
002AD8  1  A6 23        	.word	LAB_POWER-1
002ADA  1  50           	.byte	$50			; AND
002ADB  1  BD 14        	.word	LAB_AND-1
002ADD  1  46           	.byte	$46			; EOR			new operator
002ADE  1  A3 14        	.word	LAB_EOR-1
002AE0  1  46           	.byte	$46			; OR
002AE1  1  B0 14        	.word	LAB_OR-1
002AE3  1  56           	.byte	$56			; >>			new operator
002AE4  1  69 15        	.word	LAB_RSHIFT-1
002AE6  1  56           	.byte	$56			; <<			new operator
002AE7  1  51 15        	.word	LAB_LSHIFT-1
002AE9  1  7D           	.byte	$7D			; >
002AEA  1  DF 23        	.word	LAB_GTHAN-1
002AEC  1  5A           	.byte	$5A			; =
002AED  1  FF 13        	.word	LAB_EQUAL-1
002AEF  1  64           	.byte	$64			; <
002AF0  1  DE 14        	.word	LAB_LTHAN-1
002AF2  1               
002AF2  1               ; keywords start with ..
002AF2  1               ; this is the first character table and must be in alphabetic order
002AF2  1               
002AF2  1               TAB_1STC
002AF2  1  2A           	.byte	"*"
002AF3  1  2B           	.byte	"+"
002AF4  1  2D           	.byte	"-"
002AF5  1  2F           	.byte	"/"
002AF6  1  3C           	.byte	"<"
002AF7  1  3D           	.byte	"="
002AF8  1  3E           	.byte	">"
002AF9  1  3F           	.byte	"?"
002AFA  1  41           	.byte	"A"
002AFB  1  42           	.byte	"B"
002AFC  1  43           	.byte	"C"
002AFD  1  44           	.byte	"D"
002AFE  1  45           	.byte	"E"
002AFF  1  46           	.byte	"F"
002B00  1  47           	.byte	"G"
002B01  1  48           	.byte	"H"
002B02  1  49           	.byte	"I"
002B03  1  4B           	.byte	"K"
002B04  1  4C           	.byte	"L"
002B05  1  4D           	.byte	"M"
002B06  1  4E           	.byte	"N"
002B07  1  4F           	.byte	"O"
002B08  1  50           	.byte	"P"
002B09  1  52           	.byte	"R"
002B0A  1  53           	.byte	"S"
002B0B  1  54           	.byte	"T"
002B0C  1  55           	.byte	"U"
002B0D  1  56           	.byte	"V"
002B0E  1  57           	.byte	"W"
002B0F  1  5E           	.byte	"^"
002B10  1  00           	.byte	$00			; table terminator
002B11  1               
002B11  1               ; pointers to keyword tables
002B11  1               
002B11  1               TAB_CHRT
002B11  1  4D 2B        	.word	TAB_STAR		; table for "*"
002B13  1  4F 2B        	.word	TAB_PLUS		; table for "+"
002B15  1  51 2B        	.word	TAB_MNUS		; table for "-"
002B17  1  53 2B        	.word	TAB_SLAS		; table for "/"
002B19  1  55 2B        	.word	TAB_LESS		; table for "<"
002B1B  1  59 2B        	.word	TAB_EQUL		; table for "="
002B1D  1  5B 2B        	.word	TAB_MORE		; table for ">"
002B1F  1  5F 2B        	.word	TAB_QEST		; table for "?"
002B21  1  61 2B        	.word	TAB_ASCA		; table for "A"
002B23  1  71 2B        	.word	TAB_ASCB		; table for "B"
002B25  1  8A 2B        	.word	TAB_ASCC		; table for "C"
002B27  1  A1 2B        	.word	TAB_ASCD		; table for "D"
002B29  1  BA 2B        	.word	TAB_ASCE		; table for "E"
002B2B  1  C9 2B        	.word	TAB_ASCF		; table for "F"
002B2D  1  D3 2B        	.word	TAB_ASCG		; table for "G"
002B2F  1  E0 2B        	.word	TAB_ASCH		; table for "H"
002B31  1  E6 2B        	.word	TAB_ASCI		; table for "I"
002B33  1  F8 2B        	.word	TAB_ASCK		; table for "K"
002B35  1  FC 2B        	.word	TAB_ASCL		; table for "L"
002B37  1  21 2C        	.word	TAB_ASCM		; table for "M"
002B39  1  2F 2C        	.word	TAB_ASCN		; table for "N"
002B3B  1  41 2C        	.word	TAB_ASCO		; table for "O"
002B3D  1  49 2C        	.word	TAB_ASCP		; table for "P"
002B3F  1  5E 2C        	.word	TAB_ASCR		; table for "R"
002B41  1  8D 2C        	.word	TAB_ASCS		; table for "S"
002B43  1  B8 2C        	.word	TAB_ASCT		; table for "T"
002B45  1  CC 2C        	.word	TAB_ASCU		; table for "U"
002B47  1  DD 2C        	.word	TAB_ASCV		; table for "V"
002B49  1  E9 2C        	.word	TAB_ASCW		; table for "W"
002B4B  1  F8 2C        	.word	TAB_POWR		; table for "^"
002B4D  1               
002B4D  1               ; tables for each start character, note if a longer keyword with the same start
002B4D  1               ; letters as a shorter one exists then it must come first, else the list is in
002B4D  1               ; alphabetical order as follows ..
002B4D  1               
002B4D  1               ; [keyword,token
002B4D  1               ; [keyword,token]]
002B4D  1               ; end marker (#$00)
002B4D  1               
002B4D  1               TAB_STAR
002B4D  1  B9 00        	.byte TK_MUL,$00		; *
002B4F  1               TAB_PLUS
002B4F  1  B7 00        	.byte TK_PLUS,$00		; +
002B51  1               TAB_MNUS
002B51  1  B8 00        	.byte TK_MINUS,$00	; -
002B53  1               TAB_SLAS
002B53  1  BA 00        	.byte TK_DIV,$00		; /
002B55  1               TAB_LESS
002B55  1               LBB_LSHIFT
002B55  1  3C C0        	.byte	"<",TK_LSHIFT	; <<	note - "<<" must come before "<"
002B57  1  C3           	.byte TK_LT			; <
002B58  1  00           	.byte	$00
002B59  1               TAB_EQUL
002B59  1  C2 00        	.byte TK_EQUAL,$00	; =
002B5B  1               TAB_MORE
002B5B  1               LBB_RSHIFT
002B5B  1  3E BF        	.byte	">",TK_RSHIFT	; >>	note - ">>" must come before ">"
002B5D  1  C1           	.byte TK_GT			; >
002B5E  1  00           	.byte	$00
002B5F  1               TAB_QEST
002B5F  1  9F 00        	.byte TK_PRINT,$00	; ?
002B61  1               TAB_ASCA
002B61  1               LBB_ABS
002B61  1  42 53 28 C6  	.byte	"BS(",TK_ABS	; ABS(
002B65  1               LBB_AND
002B65  1  4E 44 BC     	.byte	"ND",TK_AND		; AND
002B68  1               LBB_ASC
002B68  1  53 43 28 D8  	.byte	"SC(",TK_ASC	; ASC(
002B6C  1               LBB_ATN
002B6C  1  54 4E 28 D1  	.byte	"TN(",TK_ATN	; ATN(
002B70  1  00           	.byte	$00
002B71  1               TAB_ASCB
002B71  1               LBB_BINS
002B71  1  49 4E 24 28  	.byte	"IN$(",TK_BINS	; BIN$(
002B75  1  DD           
002B76  1               LBB_BITCLR
002B76  1  49 54 43 4C  	.byte	"ITCLR",TK_BITCLR	; BITCLR
002B7A  1  52 A8        
002B7C  1               LBB_BITSET
002B7C  1  49 54 53 45  	.byte	"ITSET",TK_BITSET	; BITSET
002B80  1  54 A7        
002B82  1               LBB_BITTST
002B82  1  49 54 54 53  	.byte	"ITTST(",TK_BITTST
002B86  1  54 28 DE     
002B89  1               					; BITTST(
002B89  1  00           	.byte	$00
002B8A  1               TAB_ASCC
002B8A  1               LBB_CALL
002B8A  1  41 4C 4C 9C  	.byte	"ALL",TK_CALL	; CALL
002B8E  1               LBB_CHRS
002B8E  1  48 52 24 28  	.byte	"HR$(",TK_CHRS	; CHR$(
002B92  1  DB           
002B93  1               LBB_CLEAR
002B93  1  4C 45 41 52  	.byte	"LEAR",TK_CLEAR	; CLEAR
002B97  1  A2           
002B98  1               LBB_CONT
002B98  1  4F 4E 54 A0  	.byte	"ONT",TK_CONT	; CONT
002B9C  1               LBB_COS
002B9C  1  4F 53 28 CE  	.byte	"OS(",TK_COS	; COS(
002BA0  1  00           	.byte	$00
002BA1  1               TAB_ASCD
002BA1  1               LBB_DATA
002BA1  1  41 54 41 83  	.byte	"ATA",TK_DATA	; DATA
002BA5  1               LBB_DEC
002BA5  1  45 43 88     	.byte	"EC",TK_DEC		; DEC
002BA8  1               LBB_DEEK
002BA8  1  45 45 4B 28  	.byte	"EEK(",TK_DEEK	; DEEK(
002BAC  1  D3           
002BAD  1               LBB_DEF
002BAD  1  45 46 99     	.byte	"EF",TK_DEF		; DEF
002BB0  1               LBB_DIM
002BB0  1  49 4D 85     	.byte	"IM",TK_DIM		; DIM
002BB3  1               LBB_DOKE
002BB3  1  4F 4B 45 9B  	.byte	"OKE",TK_DOKE	; DOKE note - "DOKE" must come before "DO"
002BB7  1               LBB_DO
002BB7  1  4F 9D        	.byte	"O",TK_DO		; DO
002BB9  1  00           	.byte	$00
002BBA  1               TAB_ASCE
002BBA  1               LBB_ELSE
002BBA  1  4C 53 45 AD  	.byte	"LSE",TK_ELSE	; ELSE
002BBE  1               LBB_END
002BBE  1  4E 44 80     	.byte	"ND",TK_END		; END
002BC1  1               LBB_EOR
002BC1  1  4F 52 BD     	.byte	"OR",TK_EOR		; EOR
002BC4  1               LBB_EXP
002BC4  1  58 50 28 CD  	.byte	"XP(",TK_EXP	; EXP(
002BC8  1  00           	.byte	$00
002BC9  1               TAB_ASCF
002BC9  1               LBB_FN
002BC9  1  4E AF        	.byte	"N",TK_FN		; FN
002BCB  1               LBB_FOR
002BCB  1  4F 52 81     	.byte	"OR",TK_FOR		; FOR
002BCE  1               LBB_FRE
002BCE  1  52 45 28 C8  	.byte	"RE(",TK_FRE	; FRE(
002BD2  1  00           	.byte	$00
002BD3  1               TAB_ASCG
002BD3  1               LBB_GET
002BD3  1  45 54 A5     	.byte	"ET",TK_GET		; GET
002BD6  1               LBB_GOSUB
002BD6  1  4F 53 55 42  	.byte	"OSUB",TK_GOSUB	; GOSUB
002BDA  1  8D           
002BDB  1               LBB_GOTO
002BDB  1  4F 54 4F 89  	.byte	"OTO",TK_GOTO	; GOTO
002BDF  1  00           	.byte	$00
002BE0  1               TAB_ASCH
002BE0  1               LBB_HEXS
002BE0  1  45 58 24 28  	.byte	"EX$(",TK_HEXS	; HEX$(
002BE4  1  DC           
002BE5  1  00           	.byte	$00
002BE6  1               TAB_ASCI
002BE6  1               LBB_IF
002BE6  1  46 8B        	.byte	"F",TK_IF		; IF
002BE8  1               LBB_INC
002BE8  1  4E 43 95     	.byte	"NC",TK_INC		; INC
002BEB  1               LBB_INPUT
002BEB  1  4E 50 55 54  	.byte	"NPUT",TK_INPUT	; INPUT
002BEF  1  84           
002BF0  1               LBB_INT
002BF0  1  4E 54 28 C5  	.byte	"NT(",TK_INT	; INT(
002BF4  1               LBB_IRQ
002BF4  1  52 51 A9     	.byte	"RQ",TK_IRQ		; IRQ
002BF7  1  00           	.byte	$00
002BF8  1               TAB_ASCK
002BF8  1               LBB_KILL
002BF8  1  49 4C 4C AB  	.byte	"ILL",TK_KILL	; KILL
002BFC  1               TAB_ASCL
002BFC  1               LBB_LCASES
002BFC  1  43 41 53 45  	.byte	"CASE$(",TK_LCASES
002C00  1  24 28 DA     
002C03  1               					; LCASE$(
002C03  1               LBB_LEFTS
002C03  1  45 46 54 24  	.byte	"EFT$(",TK_LEFTS	; LEFT$(
002C07  1  28 E4        
002C09  1               LBB_LEN
002C09  1  45 4E 28 D5  	.byte	"EN(",TK_LEN	; LEN(
002C0D  1               LBB_LET
002C0D  1  45 54 87     	.byte	"ET",TK_LET		; LET
002C10  1               LBB_LIST
002C10  1  49 53 54 A1  	.byte	"IST",TK_LIST	; LIST
002C14  1               LBB_LOAD
002C14  1  4F 41 44 97  	.byte	"OAD",TK_LOAD	; LOAD
002C18  1               LBB_LOG
002C18  1  4F 47 28 CC  	.byte	"OG(",TK_LOG	; LOG(
002C1C  1               LBB_LOOP
002C1C  1  4F 4F 50 9E  	.byte	"OOP",TK_LOOP	; LOOP
002C20  1  00           	.byte	$00
002C21  1               TAB_ASCM
002C21  1               LBB_MAX
002C21  1  41 58 28 DF  	.byte	"AX(",TK_MAX	; MAX(
002C25  1               LBB_MIDS
002C25  1  49 44 24 28  	.byte	"ID$(",TK_MIDS	; MID$(
002C29  1  E6           
002C2A  1               LBB_MIN
002C2A  1  49 4E 28 E0  	.byte	"IN(",TK_MIN	; MIN(
002C2E  1  00           	.byte	$00
002C2F  1               TAB_ASCN
002C2F  1               LBB_NEW
002C2F  1  45 57 A3     	.byte	"EW",TK_NEW		; NEW
002C32  1               LBB_NEXT
002C32  1  45 58 54 82  	.byte	"EXT",TK_NEXT	; NEXT
002C36  1               LBB_NMI
002C36  1  4D 49 AA     	.byte	"MI",TK_NMI		; NMI
002C39  1               LBB_NOT
002C39  1  4F 54 B2     	.byte	"OT",TK_NOT		; NOT
002C3C  1               LBB_NULL
002C3C  1  55 4C 4C 94  	.byte	"ULL",TK_NULL	; NULL
002C40  1  00           	.byte	$00
002C41  1               TAB_ASCO
002C41  1               LBB_OFF
002C41  1  46 46 B6     	.byte	"FF",TK_OFF		; OFF
002C44  1               LBB_ON
002C44  1  4E 93        	.byte	"N",TK_ON		; ON
002C46  1               LBB_OR
002C46  1  52 BE        	.byte	"R",TK_OR		; OR
002C48  1  00           	.byte	$00
002C49  1               TAB_ASCP
002C49  1               LBB_PEEK
002C49  1  45 45 4B 28  	.byte	"EEK(",TK_PEEK	; PEEK(
002C4D  1  D2           
002C4E  1               LBB_PI
002C4E  1  49 E1        	.byte	"I",TK_PI		; PI
002C50  1               LBB_POKE
002C50  1  4F 4B 45 9A  	.byte	"OKE",TK_POKE	; POKE
002C54  1               LBB_POS
002C54  1  4F 53 28 C9  	.byte	"OS(",TK_POS	; POS(
002C58  1               LBB_PRINT
002C58  1  52 49 4E 54  	.byte	"RINT",TK_PRINT	; PRINT
002C5C  1  9F           
002C5D  1  00           	.byte	$00
002C5E  1               TAB_ASCR
002C5E  1               LBB_READ
002C5E  1  45 41 44 86  	.byte	"EAD",TK_READ	; READ
002C62  1               LBB_REM
002C62  1  45 4D 91     	.byte	"EM",TK_REM		; REM
002C65  1               LBB_RESTORE
002C65  1  45 53 54 4F  	.byte	"ESTORE",TK_RESTORE
002C69  1  52 45 8C     
002C6C  1               					; RESTORE
002C6C  1               LBB_RETIRQ
002C6C  1  45 54 49 52  	.byte	"ETIRQ",TK_RETIRQ	; RETIRQ
002C70  1  51 8E        
002C72  1               LBB_RETNMI
002C72  1  45 54 4E 4D  	.byte	"ETNMI",TK_RETNMI	; RETNMI
002C76  1  49 8F        
002C78  1               LBB_RETURN
002C78  1  45 54 55 52  	.byte	"ETURN",TK_RETURN	; RETURN
002C7C  1  4E 90        
002C7E  1               LBB_RIGHTS
002C7E  1  49 47 48 54  	.byte	"IGHT$(",TK_RIGHTS
002C82  1  24 28 E5     
002C85  1               					; RIGHT$(
002C85  1               LBB_RND
002C85  1  4E 44 28 CB  	.byte	"ND(",TK_RND	; RND(
002C89  1               LBB_RUN
002C89  1  55 4E 8A     	.byte	"UN",TK_RUN		; RUN
002C8C  1  00           	.byte	$00
002C8D  1               TAB_ASCS
002C8D  1               LBB_SADD
002C8D  1  41 44 44 28  	.byte	"ADD(",TK_SADD	; SADD(
002C91  1  D4           
002C92  1               LBB_SAVE
002C92  1  41 56 45 98  	.byte	"AVE",TK_SAVE	; SAVE
002C96  1               LBB_SGN
002C96  1  47 4E 28 C4  	.byte	"GN(",TK_SGN	; SGN(
002C9A  1               LBB_SIN
002C9A  1  49 4E 28 CF  	.byte	"IN(",TK_SIN	; SIN(
002C9E  1               LBB_SPC
002C9E  1  50 43 28 B0  	.byte	"PC(",TK_SPC	; SPC(
002CA2  1               LBB_SQR
002CA2  1  51 52 28 CA  	.byte	"QR(",TK_SQR	; SQR(
002CA6  1               LBB_STEP
002CA6  1  54 45 50 B3  	.byte	"TEP",TK_STEP	; STEP
002CAA  1               LBB_STOP
002CAA  1  54 4F 50 92  	.byte	"TOP",TK_STOP	; STOP
002CAE  1               LBB_STRS
002CAE  1  54 52 24 28  	.byte	"TR$(",TK_STRS	; STR$(
002CB2  1  D6           
002CB3  1               LBB_SWAP
002CB3  1  57 41 50 A6  	.byte	"WAP",TK_SWAP	; SWAP
002CB7  1  00           	.byte	$00
002CB8  1               TAB_ASCT
002CB8  1               LBB_TAB
002CB8  1  41 42 28 AC  	.byte	"AB(",TK_TAB	; TAB(
002CBC  1               LBB_TAN
002CBC  1  41 4E 28 D0  	.byte	"AN(",TK_TAN	; TAN(
002CC0  1               LBB_THEN
002CC0  1  48 45 4E B1  	.byte	"HEN",TK_THEN	; THEN
002CC4  1               LBB_TO
002CC4  1  4F AE        	.byte	"O",TK_TO		; TO
002CC6  1               LBB_TWOPI
002CC6  1  57 4F 50 49  	.byte	"WOPI",TK_TWOPI	; TWOPI
002CCA  1  E2           
002CCB  1  00           	.byte	$00
002CCC  1               TAB_ASCU
002CCC  1               LBB_UCASES
002CCC  1  43 41 53 45  	.byte	"CASE$(",TK_UCASES
002CD0  1  24 28 D9     
002CD3  1               					; UCASE$(
002CD3  1               LBB_UNTIL
002CD3  1  4E 54 49 4C  	.byte	"NTIL",TK_UNTIL	; UNTIL
002CD7  1  B4           
002CD8  1               LBB_USR
002CD8  1  53 52 28 C7  	.byte	"SR(",TK_USR	; USR(
002CDC  1  00           	.byte	$00
002CDD  1               TAB_ASCV
002CDD  1               LBB_VAL
002CDD  1  41 4C 28 D7  	.byte	"AL(",TK_VAL	; VAL(
002CE1  1               LBB_VPTR
002CE1  1  41 52 50 54  	.byte	"ARPTR(",TK_VPTR	; VARPTR(
002CE5  1  52 28 E3     
002CE8  1  00           	.byte	$00
002CE9  1               TAB_ASCW
002CE9  1               LBB_WAIT
002CE9  1  41 49 54 96  	.byte	"AIT",TK_WAIT	; WAIT
002CED  1               LBB_WHILE
002CED  1  48 49 4C 45  	.byte	"HILE",TK_WHILE	; WHILE
002CF1  1  B5           
002CF2  1               LBB_WIDTH
002CF2  1  49 44 54 48  	.byte	"IDTH",TK_WIDTH	; WIDTH
002CF6  1  A4           
002CF7  1  00           	.byte	$00
002CF8  1               TAB_POWR
002CF8  1  BB 00        	.byte	TK_POWER,$00	; ^
002CFA  1               
002CFA  1               ; new decode table for LIST
002CFA  1               ; Table is ..
002CFA  1               ; byte - keyword length, keyword first character
002CFA  1               ; word - pointer to rest of keyword from dictionary
002CFA  1               
002CFA  1               ; note if length is 1 then the pointer is ignored
002CFA  1               
002CFA  1               LAB_KEYT
002CFA  1  03 45        	.byte	3,'E'
002CFC  1  BE 2B        	.word	LBB_END		; END
002CFE  1  03 46        	.byte	3,'F'
002D00  1  CB 2B        	.word	LBB_FOR		; FOR
002D02  1  04 4E        	.byte	4,'N'
002D04  1  32 2C        	.word	LBB_NEXT		; NEXT
002D06  1  04 44        	.byte	4,'D'
002D08  1  A1 2B        	.word	LBB_DATA		; DATA
002D0A  1  05 49        	.byte	5,'I'
002D0C  1  EB 2B        	.word	LBB_INPUT		; INPUT
002D0E  1  03 44        	.byte	3,'D'
002D10  1  B0 2B        	.word	LBB_DIM		; DIM
002D12  1  04 52        	.byte	4,'R'
002D14  1  5E 2C        	.word	LBB_READ		; READ
002D16  1  03 4C        	.byte	3,'L'
002D18  1  0D 2C        	.word	LBB_LET		; LET
002D1A  1  03 44        	.byte	3,'D'
002D1C  1  A5 2B        	.word	LBB_DEC		; DEC
002D1E  1  04 47        	.byte	4,'G'
002D20  1  DB 2B        	.word	LBB_GOTO		; GOTO
002D22  1  03 52        	.byte	3,'R'
002D24  1  89 2C        	.word	LBB_RUN		; RUN
002D26  1  02 49        	.byte	2,'I'
002D28  1  E6 2B        	.word	LBB_IF		; IF
002D2A  1  07 52        	.byte	7,'R'
002D2C  1  65 2C        	.word	LBB_RESTORE		; RESTORE
002D2E  1  05 47        	.byte	5,'G'
002D30  1  D6 2B        	.word	LBB_GOSUB		; GOSUB
002D32  1  06 52        	.byte	6,'R'
002D34  1  6C 2C        	.word	LBB_RETIRQ		; RETIRQ
002D36  1  06 52        	.byte	6,'R'
002D38  1  72 2C        	.word	LBB_RETNMI		; RETNMI
002D3A  1  06 52        	.byte	6,'R'
002D3C  1  78 2C        	.word	LBB_RETURN		; RETURN
002D3E  1  03 52        	.byte	3,'R'
002D40  1  62 2C        	.word	LBB_REM		; REM
002D42  1  04 53        	.byte	4,'S'
002D44  1  AA 2C        	.word	LBB_STOP		; STOP
002D46  1  02 4F        	.byte	2,'O'
002D48  1  44 2C        	.word	LBB_ON		; ON
002D4A  1  04 4E        	.byte	4,'N'
002D4C  1  3C 2C        	.word	LBB_NULL		; NULL
002D4E  1  03 49        	.byte	3,'I'
002D50  1  E8 2B        	.word	LBB_INC		; INC
002D52  1  04 57        	.byte	4,'W'
002D54  1  E9 2C        	.word	LBB_WAIT		; WAIT
002D56  1  04 4C        	.byte	4,'L'
002D58  1  14 2C        	.word	LBB_LOAD		; LOAD
002D5A  1  04 53        	.byte	4,'S'
002D5C  1  92 2C        	.word	LBB_SAVE		; SAVE
002D5E  1  03 44        	.byte	3,'D'
002D60  1  AD 2B        	.word	LBB_DEF		; DEF
002D62  1  04 50        	.byte	4,'P'
002D64  1  50 2C        	.word	LBB_POKE		; POKE
002D66  1  04 44        	.byte	4,'D'
002D68  1  B3 2B        	.word	LBB_DOKE		; DOKE
002D6A  1  04 43        	.byte	4,'C'
002D6C  1  8A 2B        	.word	LBB_CALL		; CALL
002D6E  1  02 44        	.byte	2,'D'
002D70  1  B7 2B        	.word	LBB_DO		; DO
002D72  1  04 4C        	.byte	4,'L'
002D74  1  1C 2C        	.word	LBB_LOOP		; LOOP
002D76  1  05 50        	.byte	5,'P'
002D78  1  58 2C        	.word	LBB_PRINT		; PRINT
002D7A  1  04 43        	.byte	4,'C'
002D7C  1  98 2B        	.word	LBB_CONT		; CONT
002D7E  1  04 4C        	.byte	4,'L'
002D80  1  10 2C        	.word	LBB_LIST		; LIST
002D82  1  05 43        	.byte	5,'C'
002D84  1  93 2B        	.word	LBB_CLEAR		; CLEAR
002D86  1  03 4E        	.byte	3,'N'
002D88  1  2F 2C        	.word	LBB_NEW		; NEW
002D8A  1  05 57        	.byte	5,'W'
002D8C  1  F2 2C        	.word	LBB_WIDTH		; WIDTH
002D8E  1  03 47        	.byte	3,'G'
002D90  1  D3 2B        	.word	LBB_GET		; GET
002D92  1  04 53        	.byte	4,'S'
002D94  1  B3 2C        	.word	LBB_SWAP		; SWAP
002D96  1  06 42        	.byte	6,'B'
002D98  1  7C 2B        	.word	LBB_BITSET		; BITSET
002D9A  1  06 42        	.byte	6,'B'
002D9C  1  76 2B        	.word	LBB_BITCLR		; BITCLR
002D9E  1  03 49        	.byte	3,'I'
002DA0  1  F4 2B        	.word	LBB_IRQ		; IRQ
002DA2  1  03 4E        	.byte	3,'N'
002DA4  1  36 2C        	.word	LBB_NMI		; NMI
002DA6  1  04 4B        	.byte	4,'K'
002DA8  1  F8 2B        	.word	LBB_KILL		; KILL
002DAA  1               
002DAA  1               
002DAA  1               ; secondary commands (can't start a statement)
002DAA  1               
002DAA  1  04 54        	.byte	4,'T'
002DAC  1  B8 2C        	.word	LBB_TAB		; TAB
002DAE  1  04 45        	.byte	4,'E'
002DB0  1  BA 2B        	.word	LBB_ELSE		; ELSE
002DB2  1  02 54        	.byte	2,'T'
002DB4  1  C4 2C        	.word	LBB_TO		; TO
002DB6  1  02 46        	.byte	2,'F'
002DB8  1  C9 2B        	.word	LBB_FN		; FN
002DBA  1  04 53        	.byte	4,'S'
002DBC  1  9E 2C        	.word	LBB_SPC		; SPC
002DBE  1  04 54        	.byte	4,'T'
002DC0  1  C0 2C        	.word	LBB_THEN		; THEN
002DC2  1  03 4E        	.byte	3,'N'
002DC4  1  39 2C        	.word	LBB_NOT		; NOT
002DC6  1  04 53        	.byte	4,'S'
002DC8  1  A6 2C        	.word	LBB_STEP		; STEP
002DCA  1  05 55        	.byte	5,'U'
002DCC  1  D3 2C        	.word	LBB_UNTIL		; UNTIL
002DCE  1  05 57        	.byte	5,'W'
002DD0  1  ED 2C        	.word	LBB_WHILE		; WHILE
002DD2  1  03 4F        	.byte	3,'O'
002DD4  1  41 2C        	.word	LBB_OFF		; OFF
002DD6  1               
002DD6  1               ; opperators
002DD6  1               
002DD6  1  01 2B        	.byte	1,'+'
002DD8  1  00 00        	.word	$0000			; +
002DDA  1  01 2D        	.byte	1,'-'
002DDC  1  00 00        	.word	$0000			; -
002DDE  1  01 2A        	.byte	1,'*'
002DE0  1  00 00        	.word	$0000			; *
002DE2  1  01 2F        	.byte	1,'/'
002DE4  1  00 00        	.word	$0000			; /
002DE6  1  01 5E        	.byte	1,'^'
002DE8  1  00 00        	.word	$0000			; ^
002DEA  1  03 41        	.byte	3,'A'
002DEC  1  65 2B        	.word	LBB_AND		; AND
002DEE  1  03 45        	.byte	3,'E'
002DF0  1  C1 2B        	.word	LBB_EOR		; EOR
002DF2  1  02 4F        	.byte	2,'O'
002DF4  1  46 2C        	.word	LBB_OR		; OR
002DF6  1  02 3E        	.byte	2,'>'
002DF8  1  5B 2B        	.word	LBB_RSHIFT		; >>
002DFA  1  02 3C        	.byte	2,'<'
002DFC  1  55 2B        	.word	LBB_LSHIFT		; <<
002DFE  1  01 3E        	.byte	1,'>'
002E00  1  00 00        	.word	$0000			; >
002E02  1  01 3D        	.byte	1,'='
002E04  1  00 00        	.word	$0000			; =
002E06  1  01 3C        	.byte	1,'<'
002E08  1  00 00        	.word	$0000			; <
002E0A  1               
002E0A  1               ; functions
002E0A  1               
002E0A  1  04 53        	.byte	4,'S'			;
002E0C  1  96 2C        	.word	LBB_SGN		; SGN
002E0E  1  04 49        	.byte	4,'I'			;
002E10  1  F0 2B        	.word	LBB_INT		; INT
002E12  1  04 41        	.byte	4,'A'			;
002E14  1  61 2B        	.word	LBB_ABS		; ABS
002E16  1  04 55        	.byte	4,'U'			;
002E18  1  D8 2C        	.word	LBB_USR		; USR
002E1A  1  04 46        	.byte	4,'F'			;
002E1C  1  CE 2B        	.word	LBB_FRE		; FRE
002E1E  1  04 50        	.byte	4,'P'			;
002E20  1  54 2C        	.word	LBB_POS		; POS
002E22  1  04 53        	.byte	4,'S'			;
002E24  1  A2 2C        	.word	LBB_SQR		; SQR
002E26  1  04 52        	.byte	4,'R'			;
002E28  1  85 2C        	.word	LBB_RND		; RND
002E2A  1  04 4C        	.byte	4,'L'			;
002E2C  1  18 2C        	.word	LBB_LOG		; LOG
002E2E  1  04 45        	.byte	4,'E'			;
002E30  1  C4 2B        	.word	LBB_EXP		; EXP
002E32  1  04 43        	.byte	4,'C'			;
002E34  1  9C 2B        	.word	LBB_COS		; COS
002E36  1  04 53        	.byte	4,'S'			;
002E38  1  9A 2C        	.word	LBB_SIN		; SIN
002E3A  1  04 54        	.byte	4,'T'			;
002E3C  1  BC 2C        	.word	LBB_TAN		; TAN
002E3E  1  04 41        	.byte	4,'A'			;
002E40  1  6C 2B        	.word	LBB_ATN		; ATN
002E42  1  05 50        	.byte	5,'P'			;
002E44  1  49 2C        	.word	LBB_PEEK		; PEEK
002E46  1  05 44        	.byte	5,'D'			;
002E48  1  A8 2B        	.word	LBB_DEEK		; DEEK
002E4A  1  05 53        	.byte	5,'S'			;
002E4C  1  8D 2C        	.word	LBB_SADD		; SADD
002E4E  1  04 4C        	.byte	4,'L'			;
002E50  1  09 2C        	.word	LBB_LEN		; LEN
002E52  1  05 53        	.byte	5,'S'			;
002E54  1  AE 2C        	.word	LBB_STRS		; STR$
002E56  1  04 56        	.byte	4,'V'			;
002E58  1  DD 2C        	.word	LBB_VAL		; VAL
002E5A  1  04 41        	.byte	4,'A'			;
002E5C  1  68 2B        	.word	LBB_ASC		; ASC
002E5E  1  07 55        	.byte	7,'U'			;
002E60  1  CC 2C        	.word	LBB_UCASES		; UCASE$
002E62  1  07 4C        	.byte	7,'L'			;
002E64  1  FC 2B        	.word	LBB_LCASES		; LCASE$
002E66  1  05 43        	.byte	5,'C'			;
002E68  1  8E 2B        	.word	LBB_CHRS		; CHR$
002E6A  1  05 48        	.byte	5,'H'			;
002E6C  1  E0 2B        	.word	LBB_HEXS		; HEX$
002E6E  1  05 42        	.byte	5,'B'			;
002E70  1  71 2B        	.word	LBB_BINS		; BIN$
002E72  1  07 42        	.byte	7,'B'			;
002E74  1  82 2B        	.word	LBB_BITTST		; BITTST
002E76  1  04 4D        	.byte	4,'M'			;
002E78  1  21 2C        	.word	LBB_MAX		; MAX
002E7A  1  04 4D        	.byte	4,'M'			;
002E7C  1  2A 2C        	.word	LBB_MIN		; MIN
002E7E  1  02 50        	.byte	2,'P'			;
002E80  1  4E 2C        	.word	LBB_PI		; PI
002E82  1  05 54        	.byte	5,'T'			;
002E84  1  C6 2C        	.word	LBB_TWOPI		; TWOPI
002E86  1  07 56        	.byte	7,'V'			;
002E88  1  E1 2C        	.word	LBB_VPTR		; VARPTR
002E8A  1  06 4C        	.byte	6,'L'			;
002E8C  1  03 2C        	.word	LBB_LEFTS		; LEFT$
002E8E  1  07 52        	.byte	7,'R'			;
002E90  1  7E 2C        	.word	LBB_RIGHTS		; RIGHT$
002E92  1  05 4D        	.byte	5,'M'			;
002E94  1  25 2C        	.word	LBB_MIDS		; MID$
002E96  1               
002E96  1               ; BASIC messages, mostly error messages
002E96  1               
002E96  1               LAB_BAER
002E96  1  BA 2E        	.word	ERR_NF		;$00 NEXT without FOR
002E98  1  CB 2E        	.word	ERR_SN		;$02 syntax
002E9A  1  D2 2E        	.word	ERR_RG		;$04 RETURN without GOSUB
002E9C  1  E7 2E        	.word	ERR_OD		;$06 out of data
002E9E  1  F3 2E        	.word	ERR_FC		;$08 function call
002EA0  1  01 2F        	.word	ERR_OV		;$0A overflow
002EA2  1  0A 2F        	.word	ERR_OM		;$0C out of memory
002EA4  1  18 2F        	.word	ERR_US		;$0E undefined statement
002EA6  1  2C 2F        	.word	ERR_BS		;$10 array bounds
002EA8  1  39 2F        	.word	ERR_DD		;$12 double dimension array
002EAA  1  4A 2F        	.word	ERR_D0		;$14 divide by 0
002EAC  1  59 2F        	.word	ERR_ID		;$16 illegal direct
002EAE  1  68 2F        	.word	ERR_TM		;$18 type mismatch
002EB0  1  76 2F        	.word	ERR_LS		;$1A long string
002EB2  1  86 2F        	.word	ERR_ST		;$1C string too complex
002EB4  1  99 2F        	.word	ERR_CN		;$1E continue error
002EB6  1  A8 2F        	.word	ERR_UF		;$20 undefined function
002EB8  1  BB 2F        	.word ERR_LD		;$22 LOOP without DO
002EBA  1               
002EBA  1               ; I may implement these two errors to force definition of variables and
002EBA  1               ; dimensioning of arrays before use.
002EBA  1               
002EBA  1               ;	.word ERR_UV		;$24 undefined variable
002EBA  1               
002EBA  1               ; the above error has been tested and works (see code and comments below LAB_1D8B)
002EBA  1               
002EBA  1               ;	.word ERR_UA		;$26 undimensioned array
002EBA  1               
002EBA  1  4E 45 58 54  ERR_NF	.byte	"NEXT without FOR",$00
002EBE  1  20 77 69 74  
002EC2  1  68 6F 75 74  
002ECB  1  53 79 6E 74  ERR_SN	.byte	"Syntax",$00
002ECF  1  61 78 00     
002ED2  1  52 45 54 55  ERR_RG	.byte	"RETURN without GOSUB",$00
002ED6  1  52 4E 20 77  
002EDA  1  69 74 68 6F  
002EE7  1  4F 75 74 20  ERR_OD	.byte	"Out of DATA",$00
002EEB  1  6F 66 20 44  
002EEF  1  41 54 41 00  
002EF3  1  46 75 6E 63  ERR_FC	.byte	"Function call",$00
002EF7  1  74 69 6F 6E  
002EFB  1  20 63 61 6C  
002F01  1  4F 76 65 72  ERR_OV	.byte	"Overflow",$00
002F05  1  66 6C 6F 77  
002F09  1  00           
002F0A  1  4F 75 74 20  ERR_OM	.byte	"Out of memory",$00
002F0E  1  6F 66 20 6D  
002F12  1  65 6D 6F 72  
002F18  1  55 6E 64 65  ERR_US	.byte	"Undefined statement",$00
002F1C  1  66 69 6E 65  
002F20  1  64 20 73 74  
002F2C  1  41 72 72 61  ERR_BS	.byte	"Array bounds",$00
002F30  1  79 20 62 6F  
002F34  1  75 6E 64 73  
002F39  1  44 6F 75 62  ERR_DD	.byte	"Double dimension",$00
002F3D  1  6C 65 20 64  
002F41  1  69 6D 65 6E  
002F4A  1  44 69 76 69  ERR_D0	.byte	"Divide by zero",$00
002F4E  1  64 65 20 62  
002F52  1  79 20 7A 65  
002F59  1  49 6C 6C 65  ERR_ID	.byte	"Illegal direct",$00
002F5D  1  67 61 6C 20  
002F61  1  64 69 72 65  
002F68  1  54 79 70 65  ERR_TM	.byte	"Type mismatch",$00
002F6C  1  20 6D 69 73  
002F70  1  6D 61 74 63  
002F76  1  53 74 72 69  ERR_LS	.byte	"String too long",$00
002F7A  1  6E 67 20 74  
002F7E  1  6F 6F 20 6C  
002F86  1  53 74 72 69  ERR_ST	.byte	"String too complex",$00
002F8A  1  6E 67 20 74  
002F8E  1  6F 6F 20 63  
002F99  1  43 61 6E 27  ERR_CN	.byte	"Can't continue",$00
002F9D  1  74 20 63 6F  
002FA1  1  6E 74 69 6E  
002FA8  1  55 6E 64 65  ERR_UF	.byte	"Undefined function",$00
002FAC  1  66 69 6E 65  
002FB0  1  64 20 66 75  
002FBB  1  4C 4F 4F 50  ERR_LD	.byte	"LOOP without DO",$00
002FBF  1  20 77 69 74  
002FC3  1  68 6F 75 74  
002FCB  1               
002FCB  1               ;ERR_UV	.byte	"Undefined variable",$00
002FCB  1               
002FCB  1               ; the above error has been tested and works (see code and comments below LAB_1D8B)
002FCB  1               
002FCB  1               ;ERR_UA	.byte	"Undimensioned array",$00
002FCB  1               
002FCB  1  0D 0A 42 72  LAB_BMSG	.byte	$0D,$0A,"Break",$00
002FCF  1  65 61 6B 00  
002FD3  1  20 45 72 72  LAB_EMSG	.byte	" Error",$00
002FD7  1  6F 72 00     
002FDA  1  20 69 6E 20  LAB_LMSG	.byte	" in line ",$00
002FDE  1  6C 69 6E 65  
002FE2  1  20 00        
002FE4  1  0D 0A 52 65  LAB_RMSG	.byte	$0D,$0A,"Ready",$0D,$0A,$00
002FE8  1  61 64 79 0D  
002FEC  1  0A 00        
002FEE  1               
002FEE  1  20 45 78 74  LAB_IMSG	.byte	" Extra ignored",$0D,$0A,$00
002FF2  1  72 61 20 69  
002FF6  1  67 6E 6F 72  
002FFF  1  20 52 65 64  LAB_REDO	.byte	" Redo from start",$0D,$0A,$00
003003  1  6F 20 66 72  
003007  1  6F 6D 20 73  
003012  1               
003012  1               AA_end_basic
003012  1               
003012  1               
003012  1               
003012  1               ; system dependant i/o vectors
003012  1               ; these are in RAM and are set by the monitor at start-up
003012  1               
003012  1               V_INPT:					; non halting scan input device
003012  1               BYTEIN:
003012  1  8C 51 30     	STY	DBGY			;
003015  1  8E 50 30     	STX	DBGX			;
003018  1  A2 0B        	LDX	#11			;
00301A  1  20 53 30     	JSR	PEM			;
00301D  1  C9 00        	CMP	#$00			;
00301F  1  F0 0D        	BEQ	LAB_nobyw		; branch if no byte waiting
003021  1  A2 06        	LDX	#6			;
003023  1  20 53 30     	JSR	PEM			;
003026  1  AC 51 30     	LDY	DBGY
003029  1  AE 50 30     	LDX	DBGX
00302C  1  38           	SEC				; flag byte received
00302D  1  60           	RTS
00302E  1               LAB_nobyw
00302E  1  AC 51 30     	LDY	DBGY
003031  1  AE 50 30     	LDX	DBGX
003034  1  18           	CLC				; flag no byte received
003035  1  60           	RTS				;
003036  1               
003036  1               V_OUTP:					; send byte to output device
003036  1               BYTEOUT:
003036  1  8D 52 30     	STA	DBGA
003039  1  8C 51 30     	STY	DBGY
00303C  1  8E 50 30     	STX	DBGX
00303F  1  A2 02        	LDX	#2			;
003041  1  20 53 30     	JSR	PEM			;
003044  1  AD 52 30     	LDA	DBGA
003047  1  AC 51 30     	LDY	DBGY
00304A  1  AE 50 30     	LDX	DBGX
00304D  1  60           	RTS
00304E  1               
00304E  1               
00304E  1  00 00        PEMVEC		.word	$0000
003050  1               
003050  1  00           DBGX		.byte 0
003051  1  00           DBGY		.byte 0
003052  1  00           DBGA		.byte 0
003053  1               
003053  1               
003053  1               
003053  1               PEM:
003053  1  6C 4E 30     	JMP	(PEMVEC)
003056  1               
003056  1               
003056  1               LAB_KILL:
003056  1               RETURN_TO_OS:
003056  1  4C 00 01     	JMP $0100
003059  1               
003059  1               
003059  1               
003059  1               V_SAVE:					; save BASIC program
003059  1               DOS65SAVE:
003059  1  20 B4 31     	JSR	DOS65FCBPREP		; parse parameters into FCB
00305C  1  B0 29        	BCS	DOS65SAVE_ERR1		; Error?, if so abort
00305E  1  A2 0D        	LDX	#13			;
003060  1  20 53 30     	JSR	PEM			;
003063  1  A9 74        	LDA	#(FCB & $FF)		; CREATE File
003065  1  A0 32        	LDY	#((FCB /$100)& $FF)	;
003067  1  A2 16        	LDX	#22			;
003069  1  20 53 30     	JSR	PEM			;
00306C  1  A9 00        	LDA	#0			; clear
00306E  1  8D 94 32     	STA	FCB+32			; record number
003071  1  A9 74        	LDA	#(FCB & $FF)		; Open File
003073  1  A0 32        	LDY	#((FCB /$100)& $FF)	;
003075  1  A2 0F        	LDX	#15			;
003077  1  20 53 30     	JSR	PEM			;
00307A  1  C9 FF        	CMP	#$FF			; error?, if NOT, continue
00307C  1  D0 0C        	BNE	DOS65SAVE_1		;
00307E  1               DOS65SAVE_ERR:
00307E  1  A9 4F        	LDA	#(FILEERROR2 & $FF)	; NO, ERROR OUT
003080  1  A0 32        	LDY	#((FILEERROR2 /$100)& $FF)
003082  1  A2 09        	LDX	#9			; Print error message
003084  1  20 53 30     	JSR	PEM			;
003087  1               DOS65SAVE_ERR1:
003087  1  4C 07 0F     	JMP	LAB_REM			; comment out the remainder of the line (if any)
00308A  1               DOS65SAVE_1:
00308A  1  A9 95        	LDA	#(FCBBUFFER & $FF)			; SETUP BUFFER
00308C  1  85 E2        	STA	FCBPTR			; STORE DEST BUFFER IN FCBPTR
00308E  1  A0 32        	LDY	#((FCBBUFFER /$100)& $FF)			;
003090  1  84 E3        	STY	FCBPTR+1		;
003092  1  A2 1A        	LDX	#26			; Setup Buffer
003094  1  20 53 30     	JSR	PEM			;
003097  1  20 FE 30     	JSR	DOS65SAVE_CONTROL	;
00309A  1               DOS65SAVE_2:
00309A  1  A9 00        	LDA	#(Ram_base & $FF)	; All is well, file opened and continue
00309C  1  85 E4        	STA	FCBPTR+2		; point to base of RAM
00309E  1  A9 34        	LDA	#((Ram_base /$100)& $FF);
0030A0  1  85 E5        	STA	FCBPTR+3		;
0030A2  1  A2 00        	LDX	#$00			; x=0 (null counter)
0030A4  1               DOS65SAVE_2A:
0030A4  1  A0 00        	LDY	#$00			; y=0 (Loop Index)
0030A6  1               DOS65SAVE_3:
0030A6  1  B1 E4        	LDA	(FCBPTR+2),Y		; load from RAM
0030A8  1  91 E2        	STA	(FCBPTR),Y		; save to Buffer
0030AA  1  C9 00        	CMP	#$00			; is Zero?
0030AC  1  D0 10        	BNE	DOS65SAVE_3A		; No, continue
0030AE  1  E8           	INX				; yes, bump Null Counter
0030AF  1  E0 03        	CPX	#$03			; Three nulls in a row?
0030B1  1  D0 0D        	BNE	DOS65SAVE_3B		; no, continue
0030B3  1  A9 90        	LDA	#$90			; yes, signal end
0030B5  1  85 E4        	STA	FCBPTR+2		;
0030B7  1  A9 B7        	LDA	#((Ram_top /$100)& $FF)-1	; yes, signal end
0030B9  1  85 E5        	STA	FCBPTR+3		;
0030BB  1  4C C5 30     	JMP	DOS65SAVE_3C
0030BE  1               DOS65SAVE_3A:				;
0030BE  1  A2 00        	LDX	#$00			; prior char not null, reset null counter
0030C0  1               DOS65SAVE_3B:				;
0030C0  1  C8           	INY				; bump index
0030C1  1  C0 80        	CPY	#$80			; end of buffer?
0030C3  1  D0 E1        	BNE	DOS65SAVE_3		; no, loop
0030C5  1               DOS65SAVE_3C:
0030C5  1  A9 74        	LDA	#(FCB & $FF)		; Write record in buffer to disk file
0030C7  1  A0 32        	LDY	#((FCB /$100)& $FF)	;
0030C9  1  A2 15        	LDX	#21			;
0030CB  1  20 53 30     	JSR	PEM			;
0030CE  1  29 FE        	AND	#$FE			; strip out extension
0030D0  1  C9 00        	CMP	#$00			; is error
0030D2  1  D0 AA        	BNE	DOS65SAVE_ERR		; ERROR, do error handling
0030D4  1  18           	CLC				;
0030D5  1  A5 E4        	LDA	FCBPTR+2		; add $80 to base counter
0030D7  1  69 80        	ADC	#$80			;
0030D9  1  85 E4        	STA	FCBPTR+2		;
0030DB  1  90 C7        	BCC	DOS65SAVE_2A		; is carry?, no loop
0030DD  1  18           	CLC				; yes, carry, inc high byte
0030DE  1  A5 E5        	LDA	FCBPTR+3		;
0030E0  1  69 01        	ADC	#$01			;
0030E2  1  85 E5        	STA	FCBPTR+3		;
0030E4  1  C9 B8        	CMP	#((Ram_top /$100)& $FF)			; are we at the end of RAM?
0030E6  1  F0 03        	BEQ	DOS65SAVE_4
0030E8  1  4C A4 30     	JMP	DOS65SAVE_2A
0030EB  1               DOS65SAVE_4:
0030EB  1  A9 74        	LDA	#(FCB & $FF)		;
0030ED  1  A0 32        	LDY	#((FCB /$100)& $FF)	;
0030EF  1  A2 10        	LDX	#16			;
0030F1  1  20 53 30     	JSR	PEM			;
0030F4  1  C9 FF        	CMP	#$FF			;
0030F6  1  D0 03        	BNE	DOS65SAVE_5		;
0030F8  1  4C 7E 30     	JMP	DOS65SAVE_ERR		; ERROR, DISPLAY IT
0030FB  1               DOS65SAVE_5
0030FB  1  4C 07 0F     	JMP	LAB_REM			;
0030FE  1               
0030FE  1               
0030FE  1               
0030FE  1               DOS65SAVE_CONTROL:
0030FE  1  A9 60        	LDA	#$60			; SAVE 80H OF CONTROL DATA
003100  1  85 E4        	STA	FCBPTR+2		;
003102  1  A9 00        	LDA	#$00			;
003104  1  85 E5        	STA	FCBPTR+3		;
003106  1  A0 00        	LDY	#$00			; y=0 (Loop Index)
003108  1  A2 00        	LDX	#$00			; x=0 (null counter)
00310A  1               DOS65SAVE_CONTROL1:
00310A  1  B1 E4        	LDA	(FCBPTR+2),Y		; load from RAM
00310C  1  91 E2        	STA	(FCBPTR),Y		; save to Buffer
00310E  1  C8           	INY
00310F  1  98           	TYA
003110  1  C9 80        	CMP	#$80			; is END?
003112  1  D0 F6        	BNE	DOS65SAVE_CONTROL1	; No, continue
003114  1  A9 74        	LDA	#(FCB & $FF)		; Write record in buffer to disk file
003116  1  A0 32        	LDY	#((FCB /$100)& $FF)	;
003118  1  A2 15        	LDX	#21			;
00311A  1  20 53 30     	JSR	PEM			;
00311D  1  60           	RTS
00311E  1               
00311E  1               
00311E  1               V_LOAD:					; load BASIC program
00311E  1               DOS65LOAD:
00311E  1  20 B4 31     	JSR	DOS65FCBPREP		; parse parameters into FCB
003121  1  B0 20        	BCS	DOS65LOAD_ERR1		; Error?, if so abort
003123  1  A2 0D        	LDX	#13			;
003125  1  20 53 30     	JSR	PEM			;
003128  1  A9 00        	LDA	#0			; clear
00312A  1  8D 94 32     	STA	FCB+32			; record number
00312D  1  A9 74        	LDA	#(FCB & $FF)		; Open File
00312F  1  A0 32        	LDY	#((FCB /$100)& $FF)	;
003131  1  A2 0F        	LDX	#15			;
003133  1  20 53 30     	JSR	PEM			;
003136  1  C9 FF        	CMP	#$FF			; error?, if NOT, continue
003138  1  D0 0C        	BNE	DOS65LOAD_1		;
00313A  1               DOS65LOAD_ERR:
00313A  1  A9 4F        	LDA	#(FILEERROR2 & $FF)	; NO, ERROR OUT
00313C  1  A0 32        	LDY	#((FILEERROR2 /$100)& $FF)
00313E  1  A2 09        	LDX	#9			; Print error message
003140  1  20 53 30     	JSR	PEM			;
003143  1               DOS65LOAD_ERR1:
003143  1  4C 07 0F     	JMP	LAB_REM			; comment out the remainder of the line (if any)
003146  1               DOS65LOAD_1:
003146  1  A9 95        	LDA	#(FCBBUFFER & $FF)			; SETUP BUFFER
003148  1  85 E2        	STA	FCBPTR			; STORE DEST BUFFER IN FCBPTR
00314A  1  A0 32        	LDY	#((FCBBUFFER /$100)& $FF)			;
00314C  1  A2 1A        	LDX	#26			; Setup Buffer
00314E  1  20 53 30     	JSR	PEM			;
003151  1  20 99 31     	JSR	DOS65LOAD_CONTROL	;
003154  1               DOS65LOAD_2:
003154  1  A9 00        	LDA	#(Ram_base & $FF)	; All is well, file opened and continue
003156  1  85 E4        	STA	FCBPTR+2		; point to base of RAM
003158  1  A9 34        	LDA	#((Ram_base /$100)& $FF);
00315A  1  85 E5        	STA	FCBPTR+3		;
00315C  1  4C 7C 31     	JMP	DOS65LOAD_3C
00315F  1               DOS65LOAD_3:
00315F  1  B1 E2        	LDA	(FCBPTR),Y		; load from BUFFER
003161  1  91 E4        	STA	(FCBPTR+2),Y		; save to RAM
003163  1  C8           	INY				; bump index
003164  1  C0 80        	CPY	#$80			; end of buffer?
003166  1  D0 F7        	BNE	DOS65LOAD_3		; no, loop
003168  1               
003168  1  18           	CLC				;
003169  1  A5 E4        	LDA	FCBPTR+2		; add $80 to base counter
00316B  1  69 80        	ADC	#$80			;
00316D  1  85 E4        	STA	FCBPTR+2		;
00316F  1  90 0B        	BCC	DOS65LOAD_3C		; is carry?, no SKIP
003171  1  18           	CLC				; yes, carry, inc high byte
003172  1  A5 E5        	LDA	FCBPTR+3		;
003174  1  69 01        	ADC	#$01			;
003176  1  85 E5        	STA	FCBPTR+3		;
003178  1  C9 B8        	CMP	#((Ram_top /$100)& $FF)		; are we at the end of RAM?
00317A  1  F0 11        	BEQ	DOS65LOAD_4
00317C  1               
00317C  1               DOS65LOAD_3C:
00317C  1  A9 74        	LDA	#(FCB & $FF)		; READ record buffer from disk file
00317E  1  A0 32        	LDY	#((FCB /$100)& $FF)	;
003180  1  20 07 32     	JSR	RDERCR		;
003183  1  A0 00        	LDY	#$00			; RESET INDEX
003185  1  C9 00        	CMP	#$00			; is error or EOF
003187  1  F0 D6        	BEQ	DOS65LOAD_3		;
003189  1  C9 01        	CMP	#$01			; EOF?
00318B  1  D0 AD        	BNE	DOS65LOAD_ERR		; ERROR, do error handling
00318D  1               DOS65LOAD_4:
00318D  1  A9 74        	LDA	#(FCB & $FF)		;
00318F  1  A0 32        	LDY	#((FCB /$100)& $FF)	;
003191  1  A2 10        	LDX	#16			;
003193  1  20 53 30     	JSR	PEM			;
003196  1  4C 07 0F     	JMP	LAB_REM			; comment out the remainder of the line (if any)
003199  1               
003199  1               
003199  1               DOS65LOAD_CONTROL:
003199  1  A9 60        	LDA	#$60			; RESTORE CONTORL DATA
00319B  1  85 E4        	STA	FCBPTR+2		; point to base of RAM
00319D  1  A9 00        	LDA	#$00			;
00319F  1  85 E5        	STA	FCBPTR+3		;
0031A1  1               
0031A1  1  A9 74        	LDA	#(FCB & $FF)		; READ record buffer from disk file
0031A3  1  A0 32        	LDY	#((FCB /$100)& $FF)	;
0031A5  1  A2 14        	LDX	#20			;
0031A7  1  20 53 30     	JSR	PEM			;
0031AA  1               
0031AA  1               DOS65LOAD_CONTROL1:
0031AA  1  B1 E2        	LDA	(FCBPTR),Y		; load from BUFFER
0031AC  1  91 E4        	STA	(FCBPTR+2),Y		; save to RAM
0031AE  1  C8           	INY				; bump index
0031AF  1  C0 80        	CPY	#$80			; end of buffer?
0031B1  1  D0 F7        	BNE	DOS65LOAD_CONTROL1	; no, loop
0031B3  1  60           	RTS
0031B4  1               
0031B4  1               DOS65FCBPREP:
0031B4  1  20 C2 00     	JSR	LAB_GBYT		; GET DRIVE LETTER
0031B7  1  38           	SEC				;
0031B8  1  E9 40        	SBC	#64			; PARSE DRIVE NUMBER
0031BA  1  8D 74 32     	STA	DOSDRIVE		; STORE IT IN FCB
0031BD  1  20 BC 00     	JSR	LAB_IGBY		; GET ":"
0031C0  1  C9 3A        	CMP	#':'			;
0031C2  1  F0 0E        	BEQ	DOS65FCBPREP_1		; YES, IT WAS A DRIVE, CONTINUE
0031C4  1  A9 24        	LDA	#(FILEERROR1 & $FF)	; NO, ERROR OUT
0031C6  1  A0 32        	LDY	#((FILEERROR1 /$100)& $FF)
0031C8  1  A2 09        	LDX	#9
0031CA  1  20 53 30     	JSR	PEM
0031CD  1  20 07 0F     	JSR	LAB_REM
0031D0  1  38           	SEC
0031D1  1  60           	RTS
0031D2  1               DOS65FCBPREP_1:
0031D2  1  A9 74        	LDA	#(FCB & $FF)		; SETUP FCBPTR
0031D4  1  85 E2        	STA	FCBPTR			;
0031D6  1  A9 32        	LDA	#((FCB /$100)& $FF)	;
0031D8  1  85 E3        	STA	FCBPTR+1		;
0031DA  1  A0 01        	LDY	#$01			; POINT Y TO FCB FILE NAME
0031DC  1  A9 20        	LDA	#$20			; LOAD SPACE CHAR INTO A
0031DE  1               DOS65FCBPREP_1A:			; BLANK OUT FCB
0031DE  1  91 E2        	STA	(FCBPTR),Y		;
0031E0  1  C8           	INY				;
0031E1  1  C0 09        	CPY	#$09			; IS DONE
0031E3  1  D0 F9        	BNE	DOS65FCBPREP_1A		; NO, LOOP
0031E5  1  A0 01        	LDY	#$01			; POINT Y TO FCB FILE NAME
0031E7  1               DOS65FCBPREP_2:				; COPY FILE NAME PARAMETER INTO FCB
0031E7  1  20 BC 00     	JSR	LAB_IGBY		;
0031EA  1  F0 0A        	BEQ	DOS65FCBPREP_3		;
0031EC  1  91 E2        	STA	(FCBPTR),Y		;
0031EE  1  C8           	INY				;
0031EF  1  C0 09        	CPY	#$09			;
0031F1  1  F0 03        	BEQ	DOS65FCBPREP_3		;
0031F3  1  4C E7 31     	JMP	DOS65FCBPREP_2		;
0031F6  1               DOS65FCBPREP_3:				;
0031F6  1  18           	CLC
0031F7  1  60           	RTS				;
0031F8  1               
0031F8  1               ;SUBROUTINES
0031F8  1               ;OPEN FILE
0031F8  1  A2 0F        OPNFIL	LDX	#15
0031FA  1  4C 53 30     	JMP	PEM
0031FD  1               ;CLOSE FILE
0031FD  1  A2 10        CLSFIL	LDX	#16
0031FF  1  4C 53 30     	JMP	PEM
003202  1               ;DELETE FILE
003202  1  A2 13        DLTFIL	LDX	#19
003204  1  4C 53 30     	JMP	PEM
003207  1               ;READ RECORD
003207  1  A2 14        RDERCR	LDX	#20
003209  1  4C 53 30     	JMP	PEM
00320C  1               ;WRITE RECORD
00320C  1  A2 15        WRTRCR	LDX	#21
00320E  1  4C 53 30     	JMP	PEM
003211  1               ;CREATE FILE
003211  1  A2 16        CRTFIL	LDX	#22
003213  1  4C 53 30     	JMP	PEM
003216  1               ;RENAME FILE
003216  1  A2 17        RNMFIL	LDX	#23
003218  1  4C 53 30     	JMP	PEM
00321B  1               ;SET BUFFER
00321B  1  A2 1A        SETBUF	LDX	#26
00321D  1  4C 53 30     	JMP	PEM
003220  1               
003220  1               
003220  1  59 30        VDOS65SAVE	.word	DOS65SAVE
003222  1  1E 31        VDOS65LOAD	.word	DOS65LOAD
003224  1  2A 2A 20 4E  FILEERROR1:	.byte	"** NO DRIVE SPECIFIED, OPERATION ABORTED"
003228  1  4F 20 44 52  
00322C  1  49 56 45 20  
00324C  1  0D 0A 24     		.byte	$0D,$0A,'$'
00324F  1  2A 2A 20 44  FILEERROR2:	.byte	"** DOS/65 ERROR, OPERATION ABORTED"
003253  1  4F 53 2F 36  
003257  1  35 20 45 52  
003271  1  0D 0A 24     		.byte	$0D,$0A,'$'
003274  1               FCB:
003274  1  00           DOSDRIVE	.byte	0		; DRIVE NUMBER
003275  1  20 20 20 20  DOSFN		.byte	"        "	; FILE NAME
003279  1  20 20 20 20  
00327D  1  42 41 53     DOSEX		.byte	"BAS"		; EXTENSION
003280  1  00 00 00     DOSET		.byte	0,0,0		; EXTENT
003283  1  00           DOSNR		.byte	0		; NUMBER OF RECORDS IN FILE
003284  1  00 00 00 00  DOSBL		.byte	0,0,0,0,0,0,0,0	; BLOCKS IN FILE
003288  1  00 00 00 00  
00328C  1  00 00 00 00  		.byte	0,0,0,0,0,0,0,0	;
003290  1  00 00 00 00  
003294  1  00           DOSNX		.byte	0		; NEXT RECORD
003295  1               FCBBUFFER
003295  1  44 45 52 49  ENDOFBASIC	.byte	"DERIVED FROM ehBASIC"
003299  1  56 45 44 20  
00329D  1  46 52 4F 4D  
0032A9  1               
0032A9  1               
0032A9  1               ; Ibuffs can now be anywhere in RAM AS LONG AS IT IS BEFORE RAM_BASE AND IS NOT PAGE ALIGNED!, ensure that the max length is < $80
0032A9  1               
0032A9  1               Ibuffs		=  (ENDOFBASIC & $FF00)+$181
0032A9  1               Ibuffe		= Ibuffs+$47; end of input buffer
0032A9  1               
0032A9  1               Ram_base	= (Ibuffe & $FF00)+$100	; start of user RAM (set as needed, should be page aligned)
0032A9  1               Ram_top		= $B800						; end of user RAM+1 (set as needed, should be page aligned)
0032A9  1               
0032A9  1               
0032A9  1               
0032A9  1               LAB_MSZM_LO = (LAB_MSZM & $FF)
0032A9  1               LAB_MSZM_HI = ((LAB_MSZM & $FF00) >>8)
0032A9  1               Ram_top_HI = ((Ram_top & $FF00) >>8)
0032A9  1               Ram_base_LO = (Ram_base & $FF)
0032A9  1               Ram_base_HI = ((Ram_base & $FF00) >>8)
0032A9  1               LAB_SMSG_LO = (LAB_SMSG & $FF)
0032A9  1               LAB_SMSG_HI = ((LAB_SMSG & $FF00) >>8)
0032A9  1               LAB_1274_LO = (LAB_1274 & $FF)
0032A9  1               LAB_1274_HI = ((LAB_1274 & $FF00) >>8)
0032A9  1               LAB_EMSG_LO = (LAB_EMSG & $FF)
0032A9  1               LAB_EMSG_HI = ((LAB_EMSG & $FF00) >>8)
0032A9  1               LAB_RMSG_LO = (LAB_RMSG & $FF)
0032A9  1               LAB_RMSG_HI = ((LAB_RMSG & $FF00) >>8)
0032A9  1               Ibuffs_LO = (Ibuffs & $FF)
0032A9  1               TAB_1STC_LO = (TAB_1STC & $FF)
0032A9  1               TAB_1STC_HI = ((TAB_1STC & $FF00) >>8)
0032A9  1               LAB_KEYT_HI = ((LAB_KEYT & $FF00) >>8)
0032A9  1               LAB_KEYT_LO = (LAB_KEYT & $FF)
0032A9  1               LAB_159F_LO = (LAB_159F & $FF)
0032A9  1               LAB_159F_HI = ((LAB_159F & $FF00) >>8)
0032A9  1               Ibuffs_HI = ((Ibuffs & $FF00) >>8)
0032A9  1               LAB_BMSG_LO = (LAB_BMSG & $FF)
0032A9  1               LAB_BMSG_HI = ((LAB_BMSG & $FF00) >>8)
0032A9  1               LAB_2AFD_LO = (LAB_2AFD & $FF)
0032A9  1               FAC1_e_LO = (FAC1_e & $FF)
0032A9  1               FAC1_e_HI = ((FAC1_e & $FF00) >>8)
0032A9  1               LAB_REDO_LO = (LAB_REDO & $FF)
0032A9  1               LAB_REDO_HI = ((LAB_REDO & $FF00) >>8)
0032A9  1               LAB_IMSG_LO = (LAB_IMSG & $FF)
0032A9  1               LAB_IMSG_HI = ((LAB_IMSG & $FF00) >>8)
0032A9  1               LAB_STAK_HI = ((LAB_STAK & $FF00) >>8)
0032A9  1               FAC2_e_LO = (FAC2_e & $FF)
0032A9  1               FAC2_e_HI = ((FAC2_e & $FF00) >>8)
0032A9  1               LAB_1C18p2_LO = (LAB_1C18p2 & $FF)
0032A9  1               LAB_1D96_LO = (LAB_1D96 & $FF)
0032A9  1               LAB_1D96_HI = ((LAB_1D96 & $FF00) >>8)
0032A9  1               LAB_1DF7_LO = (LAB_1DF7 & $FF)
0032A9  1               LAB_1DF7_HI = ((LAB_1DF7 & $FF00) >>8)
0032A9  1               CallExit_HI = ((CallExit & $FF00) >>8)
0032A9  1               CallExit_LO = (CallExit & $FF)
0032A9  1               LAB_2A96_LO = (LAB_2A96 & $FF)
0032A9  1               LAB_2A96_HI = ((LAB_2A96 & $FF00) >>8)
0032A9  1               LAB_25AD_LO = (LAB_25AD & $FF)
0032A9  1               LAB_25AD_HI = ((LAB_25AD & $FF00) >>8)
0032A9  1               LAB_25B1_LO = (LAB_25B1 & $FF)
0032A9  1               LAB_25B1_HI = ((LAB_25B1 & $FF00) >>8)
0032A9  1               LAB_25A0_LO = (LAB_25A0 & $FF)
0032A9  1               LAB_25A0_HI = ((LAB_25A0 & $FF00) >>8)
0032A9  1               LAB_25B5_LO = (LAB_25B5 & $FF)
0032A9  1               LAB_25B5_HI = ((LAB_25B5 & $FF00) >>8)
0032A9  1               LAB_25B9_LO = (LAB_25B9 & $FF)
0032A9  1               LAB_25B9_HI = ((LAB_25B9 & $FF00) >>8)
0032A9  1               LAB_26B5_LO = (LAB_26B5 & $FF)
0032A9  1               LAB_26B5_HI = ((LAB_26B5 & $FF00) >>8)
0032A9  1               LAB_LMSG_LO = (LAB_LMSG & $FF)
0032A9  1               LAB_LMSG_HI = ((LAB_LMSG & $FF00) >>8)
0032A9  1               LAB_294F_LO = (LAB_294F & $FF)
0032A9  1               LAB_294F_HI = ((LAB_294F & $FF00) >>8)
0032A9  1               LAB_294B_LO = (LAB_294B & $FF)
0032A9  1               LAB_294B_HI = ((LAB_294B & $FF00) >>8)
0032A9  1               LAB_2947_LO = (LAB_2947 & $FF)
0032A9  1               LAB_2947_HI = ((LAB_2947 & $FF00) >>8)
0032A9  1               Decssp1_LO = (Decssp1 & $FF)
0032A9  1               Decssp1_HI = ((Decssp1 & $FF00) >>8)
0032A9  1               func_l_LO = (func_l & $FF)
0032A9  1               func_l_HI = ((func_l & $FF00) >>8)
0032A9  1               garb_l_LO = (garb_l & $FF)
0032A9  1               garb_l_HI = ((garb_l & $FF00) >>8)
0032A9  1               LAB_2AFA_LO = (LAB_2AFA & $FF)
0032A9  1               LAB_2AFA_HI = ((LAB_2AFA & $FF00) >>8)
0032A9  1               LAB_2AFE_LO = (LAB_2AFE & $FF)
0032A9  1               LAB_2AFE_HI = ((LAB_2AFE & $FF00) >>8)
0032A9  1               Adatal_LO = (Adatal & $FF)
0032A9  1               Adatal_HI = ((Adatal & $FF00) >>8)
0032A9  1               numexp_LO = (numexp & $FF)
0032A9  1               numexp_HI = ((numexp & $FF00) >>8)
0032A9  1               LAB_2C80_LO = (LAB_2C80 & $FF)
0032A9  1               LAB_2C80_HI = ((LAB_2C80 & $FF00) >>8)
0032A9  1               LAB_2C84_LO = (LAB_2C84 & $FF)
0032A9  1               LAB_2C84_HI = ((LAB_2C84 & $FF00) >>8)
0032A9  1               LAB_259C_LO = (LAB_259C & $FF)
0032A9  1               LAB_259C_HI = ((LAB_259C & $FF00) >>8)
0032A9  1               LAB_2CC9_LO = (LAB_2CC9 & $FF)
0032A9  1               LAB_2CC9_HI = ((LAB_2CC9 & $FF00) >>8)
0032A9  1               LAB_2C78_LO = (LAB_2C78 & $FF)
0032A9  1               LAB_2C78_HI = ((LAB_2C78 & $FF00) >>8)
0032A9  1               LAB_2C7C_LO = (LAB_2C7C & $FF)
0032A9  1               LAB_2C7C_HI = ((LAB_2C7C & $FF00) >>8)
0032A9  1               
0032A9  1               
0032A9  1               		 .END
