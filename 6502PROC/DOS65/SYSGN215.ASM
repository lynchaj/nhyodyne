;SYSGEN
;VERSION 2.15-A
;RELEASED:	30 NOVEMBER 1985 (2.10)
;LAST REVISED:	2 MAY 1996 (2.11)
;			ELIMINATED WORD MODE FOR 1024 BLOCKS
;			MADE EXTENT A SINGLE BYTE
;		3 MAY 1996 (2.12)
;			ADDED INITIAL EXM RELATED CODE
;		11 MAY 1996 (2.13)
;			ADDED USE OF EXM IN GETBLK
;			ADDED CODE TO SET EXM & CEXM1F
;			CORRECTED ERRORS
;		19 MAY 1996 (2.14)
;			CHANGED CCM REN TO "TO FROM" SYNTAX
;			ALLOWED _ IN FILE NAMES
;		13 MARCH 2008 (2.15)
;			REFORMATTED FOR TASM & ASM210+
;			ELIMINATED DEPENDENCE ON "IBM" FORMAT
;			  BY READING FIRST SECTOR # USING SIM+51
;			  TRANSLATE CODE. IF TRANSLATE
;			  DOES NOT HAVE FIRST PHYSICAL SECTOR IN FIRST
;			  POSITION THIS APPROACH MAY NOT WORK.
;			  SIM CAN ALSO PERFORM NO TRANSLATION AT ALL.
;			  ALSO ASSUMES BOOT & SIM BOTH KNOW CORRECT
;			  STARTING SECTOR FOR COLD & WARM BOOT. IT
;			  SHOULD WORK REGARDLESS OF PHYSICAL SECTOR
;			  SIZE AS LONG AS EXISTING SIM IS CONFIGURED
;			  CORRECTLY FOR DESTINATION DRIVE. BOOT
;			  MUST CORRECTLY HANDLE SECTORS > 128 BYTES
;			  AS MUST WARM BOOT IN SIM.
;			  IN ANY CASE BOOT AND WARM BOOT MUST
;			  READ SECTORS IN SEQUENTIAL ORDER, I.E.,
;			  NO INTERLEAVE.
;THIS PROGRAM CONTAINS THE COMPLETE DOS/65 OPERATING
;SYSTEM EXCEPT FOR THE BOOT AND SIM.
;WHEN USED BY THE SYSTEM OPERATOR THIS PROGRAM
;PROVIDES THE CAPABILITY TO CONSTRUCT A NEW
;OPERATING SYSTEM INCLUDING THE USERS BOOT AND SIM.
;THE SYSTEM IS RELOCATED TO FIT THE MEMORY SIZE
;SPECIFIED BY THE USER AND IS WRITTEN ONTO
;THE SYSTEM TRACKS OF THE SPECIFIED DRIVE.
;IMPROVEMENTS OVER VERSION 2.0 INCLUDE:
;	USE OF "FROM TO" SYNTAX FOR REN
;	ADDITION OF GO COMMAND
;	ADDITION OF LOAD COMMAND
;	ABILITY TO ENTER NUMBERS AS DECIMAL OR HEX
;	ADDRESS PARAMETER ADDED TO SAVE
;	ERROR CHECKING IN SYSGEN (WRITE)
;	WRITE TYPE FOR DEBLOCKING ADDED
;	PAGE ZERO 0 & 1 NOT USED
;	ALLOW _ IN FILE NAMES
;BASE ADDRESSES AND DEFINITIONS


BTEJMP	=	$100		;WARM BOOT JUMP
PEMJMP	=	$103		;JUMP TO PEM
IOSTAT	=	$106		;I/O STATUS
DFLFCB	=	$107		;DEFAULT FCB
DFLBUF	=	$128		;DEFAULT BUFFER
TEA	=	$800		;TEA START
CCMLNG	=	2048		;CCM LENGTH
PEMLNG	=	3072		;PEM LENGTH
;ZERO PAGE FOR SETUP
	*=	$02
TRKNUM				;CURRENT TRACK
	*=	*+2
DCBADD				;DCB ADDRESS
	*=	*+2
NMSSTR				;NUMBER SYSTEM TRACKS
	*=	*+2
NSECTR				;NUMBER SECTORS PER TRACK
	*=	*+2
TTLSEC				;TOTAL SECTORS TO WRITE
	*=	*+1
TRKCNT	=	TTLSEC
SIZE				;ASCII SIZE
	*=	*+2
LOKIM				;LOW KIM LIMIT
	*=	*+2
HIKIM				;HIGH KIM LIMIT
	*=	*+2
OFFSET				;RELOCATION OFFSET
	*=	*+2
KIMCNT				;KIM COUNTER
	*=	*+1
POINTR				;POINTER
	*=	*+2
LENGT				;INST LENGTH
	*=	*+1
POINT				;RELOCATE POINTER
	*=	*+2
ADJUST				;RELOCATE DISTANCE
	*=	*+2
KIMPNT				;KIM FILE INDEX
	*=	*+1
SAVEX				;SAVE FOR X
	*=	*+1
SAVEY				;SAVE FOR Y
	*=	*+1
NUMBER				;INPUT PACK BUFFER
	*=	*+2
DSTDRV				;DESTINATION DRIVE
	*=	*+1
DEFALT				;DEFAULT DRIVE
	*=	*+1
SECCNT				;SECTOR COUNT
	*=	*+2
SECNUM				;SECTOR NUMBER
	*=	*+2
CURCCM				;START OF CURRENT CCM
	*=	*+2
SIMLNG				;LENGTH OF SIM
	*=	*+2
ROOM				;MEMORY NEEDED FOR SYSGEN
	*=	*+2
STKSAV				;SAVE STACK REGISTER
	*=	*+1
FRSTSC				;FIRST SECTOR NUMBER OF DISK
	*=	*+1
LASTZP
;FIXED PARAMETERS
LF	=	$A		;LINEFEEED
CR	=	$D		;RETURN
EOF	=	$1A		;END OF FILE
NULL	=	0		;NULL
CTLC	=	3		;ABORT
CTLE	=	5		;PHYSICAL CR LF
CTLI	=	9		;TAB CHARACTER
CTLP	=	$10		;TOGGLE PRINTER
CTLR	=	$12		;REPEAT LINE
CTLS	=	$13		;FREEZE
CTLX	=	$18		;CANCEL
SEMICO	=	$3B		;SEMICOLON
DELETE	=	$7F		;DELETE CHARACTER
NUMCMD	=	36		;NUMBER COMMANDS
;MAIN PROGRAM
	*=	TEA
	JMP	SYSGEN		;JUMP TO MAIN
;COPYRIGHT NOTICE
	.BYTE	"COPYRIGHT (C) 2008 - "
	.BYTE	"RICHARD A. LEARY"
SYSGEN	LDY	BTEJMP+2	;GET SIM PAGE FROM BOOT VECTOR
	STY	JSHOME+2
	STY	JSSELD+2
	STY	JSSETT+2
	STY	JSSETS+2
	STY	JSSETD+2
	STY	JSWRIT+4
	STY	JSXLAT+2
;INITIALIZE
	LDX	#2		;SET START LOCATION
	LDA	#0		;CLEAR ACCUM
CLRZP	STA	$00,X		;CLEAR MEM
	INX			;BUMP INDEX
	CPX	#LASTZP		;SEE IF PAST END
	BNE	CLRZP		;LOOP IF NOT
;SAVE STACK REGISTER FOR EXIT
	TSX			;MOVE TO X
	STX	STKSAV		;SAVE IT
;CALCULATE CURRENT CCM START
	SEC			;SET CARRY
	LDA	PEMJMP+1	;SUBTRACT CCM LENGTH FROM PEM START
	SBC	#LO_CCMLNG
	STA	CURCCM
	LDA	PEMJMP+2
	SBC	#HI_CCMLNG
	STA	CURCCM+1
	LDA	#LO_OPNMSG	;SEND
	LDY	#HI_OPNMSG	;"OPENING"
	JSR	WRTMSG		;MESSAGE
	LDX	#25		;READ
	JSR	PEMJMP		;DEFAULT DRIVE
	STA	DEFALT		;AND SAVE
	JSR	GNS		;GET NEW SIZE
	JSR	BCDBYT		;PACK INTO BYTE
	STA	ADJUST		;AND SAVE
;CONVERT XX K TO BYTES
	LDX	#10		;MULTIPLY
M1024	ASL	ADJUST		;BY
	ROL	ADJUST+1	;1024
	DEX			;TO GET
	BNE	M1024		;SIZE IN BYTES
;CALCULATE ROOM AVAILABLE FOR SYSGEN
	LDA	ADJUST		;GET MSIZE
	LDY	ADJUST+1
	SEC			;NOW SUBTRACT CCM IMAGE START
	SBC	#LO_CCM
	STA	ROOM		;AND SAVE
	TYA
	SBC	#HI_CCM
	STA	ROOM+1
	LSR	ROOM+1		;DIVIDE BY TWO
	ROR	ROOM
;GET SIM LENGTH
	LDA	#0		;CLEAR SIZE
	STA	SIZE
	STA	SIZE+1
	JSR	GSS
	JSR	BCDBYT		;PACK INTO BYTE
	STA	SIMLNG		;AND SAVE
;CONVERT XX PAGES TO BYTES
	LDX	#8
M256	ASL	SIMLNG		;MULTIPLY
	ROL	SIMLNG+1
	DEX
	BNE	M256
;CALCULATE NEW SYSTEM LENGTH
	CLC			;BY ADDING SIM LENGTH TO SYSLNG
	LDA	SYSLNG
	ADC	SIMLNG
	STA	SYSLNG
	LDA	SYSLNG+1
	ADC	SIMLNG+1
	STA	SYSLNG+1	;AND SAVING
;CALCULATE NEW SYSTEM START
	SEC			;SUBTRACT
	LDA	ADJUST		;SYSTEM
	SBC	SYSLNG		;LENGTH
	STA	ADJUST		;FROM
	LDA	ADJUST+1	;TOP
	SBC	SYSLNG+1	;LIMIT TO
	STA	ADJUST+1	;GET NEW START
;MAKE SURE ANOTHER SYSGEN IS POSSIBLE
	LDA	ROOM		;SEE IF ROOM
	CMP	SYSLNG		;IS >= SYSLNG
	LDA	ROOM+1
	SBC	SYSLNG+1
	BCS	RMOK		;OK IF IS
	LDA	#LO_BIGMSG	;ELSE SEND TOO BIG MESSAGE
	LDY	#HI_BIGMSG
	JMP	ERREXT		;AND EXIT
;NOW CALCULATE RELOCATION DISTANCE
RMOK	SEC			;NOW
	LDA	ADJUST		;SUBTRACT
	SBC	#LO_CCM		;OLD START
	STA	ADJUST		;FROM NEW
	LDA	ADJUST+1	;TO GET
	SBC	#HI_CCM		;RELOCATION
	STA	ADJUST+1	;DISTANCE
;RELOCATE CCM
	LDA	#LO_CCM		;SET
	LDY	#HI_CCM		;POINTER
	STA	POINT
	STY	POINT+1
	JSR	STRTRL		;RELOCATE IT
;THEN PEM
	LDA	#LO_PEM		;SET
	LDY	#HI_PEM		;POINTER
	STA	POINT
	STY	POINT+1
	JSR	STRTRL		;DO IT
;GET NEW BOOT AND SIM
	JSR	GNBTE		;GET NEW BOOT
	JSR	GNSIM		;AND SIM
;WRITE SYSTEM TO SPECIFIED DRIVE
WRTDRV	LDA	#LO_CRTMSG	;SEND
	LDY	#HI_CRTMSG	;"DEST DRIVE"
	JSR	WRTMSG		;MESSAGE
	JSR	RINCLW		;GET ANSWER
	CMP	#'A'		;IF LESS THAN "A"
	BCC	INVD		;TRY AGAIN
	CMP	#'H'+1		;IF OVER "H"
	BCS	INVD		;ALSO TRY AGAIN
	AND	#%1111		;LOOK AT LSBS
	SEC			;DROP
	SBC	#1		;ONE
	STA	DSTDRV		;AND SAVE
	INY			;IF
	LDA	CTXT,Y		;ANYTHING ELSE
	BNE	INVD		;IS ERROR
	LDA	DSTDRV		;GET DRIVE
	JSR	JSSELD		;AND SET
	STA	DCBADD		;SAVE DCB ADDRESS
	STY	DCBADD+1
	ORA	DCBADD+1	;SEE IF LEGAL
	BNE	VLD		;OK IF NOT ZERO
INVD	LDA	#LO_INVMSG	;ELSE POINT TO INVALID DRIVE MESSAGE
	LDY	#HI_INVMSG
	JSR	WRTMSG		;SEND IT
	JMP	WRTDRV		;AND TRY AGAIN
VLD	LDY	#2		;GET SECTORS PER TRACK
	LDA	(DCBADD),Y
	STA	NSECTR
	INY
	LDA	(DCBADD),Y
	STA	NSECTR+1
	INY			;GET NUMBER SYSTEMS TRACKS
	LDA	(DCBADD),Y
	STA	NMSSTR
	INY
	LDA	(DCBADD),Y
	STA	NMSSTR+1
;SEND A LOGICAL SECTOR 0 TO TRANSLATE TO DETERMINE FIRST PHYSICAL SECTOR
	LDA	#0		;LOW AND HIGH TO 0
	TAY
	JSR	JSXLAT		;AND TRANSLATE
;ONLY LOOK AT LOW - ASSUME FIRST IS PROBABLY 0 OR 1
	STA	FRSTSC		;AND SAVE
;CALCULATE ACTUAL AMOUNT OF DATA TO WRITE
	LDA	POINTR		;SEE IF PART
	AND	#$7F		;OF A SECTOR
	BEQ	WHLSEC		;NO SO OK AS IS
	LDA	POINTR		;GET AGAIN
	AND	#$80		;CAPTURE MOD 128
	CLC			;THEN ADD 128
	ADC	#128
	STA	POINTR
	BCC	*+4		;WITH CARRY
	INC	POINTR+1
WHLSEC	SEC			;CALCULATE ACTUAL DATA LENGTH
	LDA	POINTR
	SBC	#LO_CCM
	STA	SYSLNG
	LDA	POINTR+1
	SBC	#HI_CCM
	STA	SYSLNG+1	;AND SAVE
;CALCULATE TOTAL SECTOR COUNT
	LDA	SYSLNG
	LDX	#7		;DIVIDE BY 128
D128	LSR	SYSLNG+1
	ROR	A
	DEX
	BNE	D128
	CLC			;ADD ONE FOR BOOT
	ADC	#1
	STA	TTLSEC
;CALCULATE NUMBER OF TRACKS NEEDED
	LDX	#0		;USE X AS COUNTER
	LDA	TTLSEC		;GET TOTAL
TCNTL	INX
	SEC
	SBC	NSECTR		;DROP BY NUMBER IN TRACK
	BEQ	*+4		;DONE IF ZERO
	BCS	TCNTL		;LOOP IF MORE
	STX	TRKCNT		;SET COUNTER
	DEX			;DROP FOR COMPARE
	CPX	NMSSTR		;COMPARE TO AVAIL
	BCS	ROMERR		;ERROR IF TOO BIG
	JSR	JSHOME		;HOME IT
	LDA	#LO_BOOT		;SET POINTER
	LDY	#HI_BOOT		;TO
	STA	POINTR		;BOOT
	STY	POINTR+1	;START
WRSYSL	JSR	WRITIT		;WRITE A TRACK
	DEC	TRKCNT		;DROP COUNT
	BNE	WRSYSL		;LOOP IF MORE
;DONE - CLEAN UP AND EXIT
CUPEXT	JSR	STDFBF		;POINT BACK TO DEFAULT
	LDX	STKSAV		;GET STACK REGISTER
	TXS			;AND SET
	LDA	DEFALT		;GET DEFAULT
	JMP	JSSELD		;SELECT IT
;ROOM ERROR EXIT
ROMERR	LDA	#LO_ROMMSG	;SEND NOT ENOUGH TRACK MESSAGE
	LDY	#HI_ROMMSG
ERREXT	JSR	WRTMSG
	JMP	CUPEXT		;CLEAN UP AND EXIT
;PACK BCD SIZE INTO BYTE
BCDBYT	CLC			;CLEAR CARRY
	LDA	#0		;AND ACCUM
	LDX	#10		;THEN ADD HIGH
	ADC	SIZE+1		;TO ACCUM
	DEX			;10
	BNE	*-3		;TIMES
	ADC	SIZE		;THEN ADD LOW
	RTS			;AND QUIT
;JUMPS TO SIM ROUTINES
;ONLY THE LOW PART OF THE ADDRESS IS SHOWN HERE - PAGE IS CAPTURED FROM
;EXISTING WARM BOOT ENTRY POINT
;HOME
JSHOME	JMP	24
;SELECT DRIVE
JSSELD	JMP	27
;SET TRACK
JSSETT	JMP	30
;SET SECTOR
JSSETS	JMP	33
;SET DMA
JSSETD	JMP	36
;TRANSLATE SECTORT
JSXLAT	JMP	51
;WRITE SECTOR
JSWRIT	LDA	#1		;FORCE IMMEDIATE WRITE
	JSR	42
	AND	#$FF		;CHECK FOR ERROR
	BNE	TWRERR		;IF SO QUIT
	RTS
TWRERR	LDA	#LO_WERMSG	;POINT TO ERROR MSG
	LDY	#HI_WERMSG
	JMP	ERREXT		;AND EXIT
;WRITE NSECTR SECTORS (RECORDS) IN TRACK
WRITIT	LDA	TRKNUM		;GET TRACK NUMBER
	LDY	TRKNUM+1
	JSR	JSSETT		;SET IT
	INC	TRKNUM		;BUMP FOR NEXT
	BNE	*+4
	INC	TRKNUM+1
	LDA	NSECTR		;SET COUNTER
	LDY	NSECTR+1
	STA	SECCNT		;TO NUMBER SECTORS IN TRACK
	STY	SECCNT+1
	LDA	FRSTSC		;FROM VALUE CAPTURED EARLIER
	LDY	#0		;SET STARTING SECTOR
	STA	SECNUM		;NUMBER (PROBABLY 0 OR 1)
	STY	SECNUM+1
WRTSLP	LDA	SECNUM		;GET SECTOR NUMBER
	LDY	SECNUM+1
	JSR	JSSETS		;SET IT
	LDA	POINTR		;GET
	LDY	POINTR+1	;POINTER
	JSR	JSSETD		;SET ADDRESS
	JSR	JSWRIT		;WRITE SECTOR
	CLC			;THEN
	LDA	POINTR		;BUMP
	ADC	#128		;BY
	STA	POINTR		;128
	BCC	*+4		;FOR
	INC	POINTR+1	;NEXT
	INC	SECNUM		;BUMP SECTOR NUMBER
	BNE	*+4
	INC	SECNUM+1
	LDA	SECCNT
	BNE	*+4
	DEC	SECCNT+1
	DEC	SECCNT		;DROP COUNT
	LDA	SECCNT
	ORA	SECCNT+1
	BNE	WRTSLP		;LOOP IF MORE
	RTS
;GET NEW BOOT
GNBTE	LDA	#LO_BTEMSG	;SEND
	LDY	#HI_BTEMSG	;"BOOT NAME"
	JSR	WRTMSG		;MESSAGE
	JSR	RINCLW		;GET RESPONSE
	JSR	INPTFN		;CONVERT TO FCB
	BCS	GNBERR		;BRANCH IF ERROR
	LDA	#LO_BOOT		;OFFSET
	LDY	#HI_BOOT		;IS SAME
	STA	OFFSET		;AS BOOT
	STY	OFFSET+1	;START
	STA	LOKIM		;AS IS LOWER
	STY	LOKIM+1		;LIMIT
	LDA	#(BOOT+128*256/256) & $FF	;SET
	LDY	#BOOT+128/256	;UPPER
	STA	HIKIM		;LIMIT
	STY	HIKIM+1		;THEN
	JSR	XQREAD		;READ FILE
	BCS	GNBERR		;BRANCH IF ERROR
	RTS
GNBERR	LDA	#LO_FLEMSG	;SEND
	LDY	#HI_FLEMSG	;"FILE ERROR"
	JMP	ERREXT		;MESSAGE AND EXIT
;GET NEW SIM
GNSIM	LDA	#LO_SIMMSG	;SEND
	LDY	#HI_SIMMSG	;"SIM NAME"
	JSR	WRTMSG		;MESSAGE
	JSR	RINCLW		;GET INPUT
	JSR	INPTFN		;CONVERT TO FCB
	BCS	GNSIRR		;BRANCH IF ERROR
	LDA	#LO_SIM		;SET LOWER
	LDY	#HI_SIM		;LIMIT
	STA	LOKIM		;FOR
	STY	LOKIM+1		;LOAD
	LDA	CURCCM		;AND
	LDY	CURCCM+1	;UPPER
	STA	HIKIM		;LIMIT
	STY	HIKIM+1		;FOR LOAD
	LDA	ADJUST		;GET
	LDY	ADJUST+1	;RELOCATION
	EOR	#$FF		;DISTANCE
	STA	OFFSET		;AND
	TYA			;COMPLEMENT
	EOR	#$FF		;IT
	STA	OFFSET+1	;THEN
	INC	OFFSET		;BUMP TO
	BNE	*+4		;GET
	INC	OFFSET+1	;LOAD OFFSET
	JSR	XQREAD		;READ FILE
	BCS	GNSIRR		;BRANCH IF ERROR
	RTS
GNSIRR	JMP	GNBERR		;ERROR EXIT
;RELOCATION ROUTINE
; POINT MUST BE SET TO FIRST CODE BYTE OF SEGMENT
; TO RELOCATE. PAGLIM MUST BE SET TO
; UPPER ADDRESS CHANGE LIMITS.
STRTRL	LDY	#0		;GET OPCODE
	LDA	(POINT),Y	;FROM MEMORY
	TAY			;SAVE IN Y
	LDX	#7		;SEARCH SEVEN
RLLOOP	TYA			;GET OPCODE
	AND	TABLE1-1,X	;REMOVE BITS
	EOR	TABLE2-1,X	;TEST REST
	BEQ	GOTOPC		;IF ZERO A MATCH
	DEX			;ELSE TRY
	BNE	RLLOOP		;NEXT
GOTOPC	LDY	TABLE3,X	;GET LENGTH/FLAG
	BPL	SKIPBY		;NO CHANGE IF POSITIVE
	INY			;ADD ONE
	BMI	EXRELC		;EXIT IF TERMINATOR
	INY			;ELSE ADD ONE MORE
	LDA	(POINT),Y	;GET LOW
	TAX			;SAVE IN X
	INY			;THEN GET
	LDA	(POINT),Y	;HIGH
	CMP	#LO_PAGLIM	;IF AT HIGH LIMIT
	BCS	NORELC		;DO NOTHING
	CMP	#TEA+1/256	;IF ABOVE
	BNE	TRYLOW		;LOWER LIMIT
	CPX	#(TEA+1*256/256) & $FF	;THEN
TRYLOW	BCC	NORELC		;DO NOTHING
	PHA			;ELSE SAVE HIGH
	TXA			;ADD OFFSET
	CLC			;TO LOW
	ADC	ADJUST		;AND THEN
	TAX			;SAVE
	PLA			;GET HIGH
	ADC	ADJUST+1	;ADD AGAIN
NORELC	STA	(POINT),Y	;PUT BACK
	DEY			;BACKUP
	TXA			;GET LOW
	STA	(POINT),Y	;SAVE
	LDY	#3		;GO UP THREE
SKIPBY	INC	POINT		;ADD ONE
	BNE	*+4		;WITH
	INC	POINT+1		;CARRY
	DEY			;LOOP IF
	BNE	SKIPBY		;MORE
	BEQ	STRTRL		;THEN START OVER
EXRELC	RTS
;RELOCATION TABLES
TABLE1	.BYTE	$C,$1F,$D,$87,$1F,$FF,$3
TABLE2	.BYTE	$C,$19,$8,$0,$10,$20,$3
TABLE3	.BYTE	2,$FF,$FF,1,1,2,$FF,$FE
;READ INPUT AND CONVERT LOWER CASE TO UPPER
; ERROR IF NO INPUT OR IF INPUT IS ALL BLANKS.
; AT EXIT Y IS INDEX INTO CTXT
;         A IS CHARACTER AT CTXT,Y
RINCLW	LDA	#LO_CBUF		;POINT TO
	LDY	#HI_CBUF		;BUFFER
	JSR	RDEINP		;READ INPUT
	LDA	#LF		;SEND
	JSR	CHAROT		;A LF
	LDY	#0		;CLEAR INDEX
	LDX	CLNG		;GET LENGTH
	BEQ	RDINER		;ERROR IF ZERO
LWRCNV	LDA	CTXT,Y		;GET CHAR
	CMP	#'A'		;IF LESS THAN A
	BCC	DOCHG		;IS OK
	CMP	#'Z'+1		;IF OVER Z
	BCS	DOCHG		;IS OK
	AND	#%01011111	;ELSE CONVERT
	STA	CTXT,Y		;AND SAVE
DOCHG	INY			;BUMP INDEX
	DEX			;DROP COUNT
	BNE	LWRCNV		;LOOP IF MORE
	TXA			;CLEAR A
	STA	CTXT,Y		;INSERT ZERO
	TAY			;CLEAR INDEX
	JSR	SPCSKP		;FIND FIRST NON-BLANK
	BEQ	RDINER		;ERROR IF NONE
	RTS			;ELSE OK
RDINER	LDA	#LO_IERMSG	;POINT TO
	LDY	#HI_IERMSG	;INPUT ERROR MESSAGE
	JSR	WRTMSG		;PRINT IT
	JMP	RINCLW		;TRY ALL OVER
;CHECK FOR DECIMAL
; IF DECIMAL THEN C=1 ELSE C=0
CHKDEC	CMP	#'0'		;IF LESS THAN "0"
	BCC	*+7		;NOT NUMBER
	CMP	#'9'+1		;IF LESS THAN "9"+1
	BCC	*+4		;IS A NUMBER
	CLC			;NOT A NUMBER
	RTS
	SEC			;A NUMBER
	RTS
;GET AND SAVE SIM LENGTH
GSS	LDA	#LO_NWSMSG	;SEND "ENTER SIZE"
	LDY	#HI_NWSMSG	;MESSAGE
	JSR	WRTMSG
GSSAGN	JSR	RINCLW		;GET INPUT
	JSR	CHKDEC		;SEE IF FIRST IS DECIMAL
	BCC	GSSERR		;ERROR IF NOT
	CMP	#'1'		;IF AT LEAST 1 IS OK
	BCC	GSSERR		;ELSE ERROR
	AND	#%00001111	;GET LOW NIBBLE
	TAX			;SAVE IN X
	STA	SIZE+1		;STORE IN HIGH
	INY			;NEXT CHAR
	LDA	CTXT,Y		;GET IT
	BNE	NOT1PG		;IF NOT ZERO MORE THAN ONE
	STX	SIZE		;ELSE SET LOW TO OLD HIGH
	STA	SIZE+1		;AND CLEAR HIGH
	RTS
NOT1PG	JSR	CHKDEC		;SEE IF DECIMAL
	BCC	GSSERR		;ERROR IF NOT
	AND	#%00001111	;GET NIBBLE
	STA	SIZE		;PUT IN LOW
	INY			;NEXT CHAR
	LDA	CTXT,Y		;GET IT
	BNE	GSSERR		;ERROR IF NOT END
	RTS
GSSERR	LDA	#LO_IERMSG	;SEND ILLEGAL INPUT MESSAGE
	LDY	#HI_IERMSG
	JSR	WRTMSG
	JMP	GSSAGN		;AND LOOP
;GET AND SAVE NEW MEMORY SIZE
; CHECK FOR DECIMAL AND FOR 64K>=SIZE>=16K
GNS	LDA	#LO_SZEMSG	;SEND
	LDY	#HI_SZEMSG	;"ENTER SIZE"
	JSR	WRTMSG		;MESSAGE
GNSAGN	JSR	RINCLW		;GET INPUT
	JSR	CHKDEC		;TEST FOR DECIMAL
	BCC	GNSERR		;ERROR IF NOT
	CMP	#'6'+1		;IF OVER "6"
	BCS	GNSERR		;IS ERROR
	CMP	#'0'		;IF "0"
	BEQ	GNSERR		;IS ERROR
	TAX			;SAVE IN X
	AND	#%00001111	;GET LOW NIBBLE ONLY
	STA	SIZE+1		;ELSE SAVE
	INY			;MOVE TO NEXT
	LDA	CTXT,Y		;GET CHAR
	JSR	CHKDEC		;TEST IT ALSO
	BCC	GNSERR		;ERROR IF NOT DECIMAL
	CPX	#'1'		;IF NOT ONE
	BNE	GNS20		;IS 20 OR MORE
	CMP	#'6'		;BUT IF LOW UNDER 6
	BCC	GNSERR		;IS AN ERROR
	BCS	GNSHI		;ELSE IS OK (17 TO 19)
GNS20	CPX	#'6'		;IF HIGH NOT 6
	BNE	GNSHI		;IS OK (20 TO 59)
	CMP	#'4'+1		;IF LOW OVER 4
	BCS	GNSERR		;IS ERROR
GNSHI	AND	#%00001111	;GET LOW NIBBLE
	STA	SIZE		;ELSE OK SO SAVE LOW
	INY			;LOOK PAST NUMBER
	LDA	CTXT,Y		;GET CHAR
	BNE	GNSERR		;ERROR IF NOT NULL
	RTS			;ELSE OK
GNSERR	LDA	#LO_IERMSG	;SEND
	LDY	#HI_IERMSG	;"ILLEGAL INPUT"
	JSR	WRTMSG		;MESSAGE
	JMP	GNSAGN		;TRY AGAIN
;INPUT FILE DESIGNATOR
; AT INPUT Y MUST BE SET TO FIRST NON-BLANK OF FIELD
INPTFN	LDX	#11		;FILL
	LDA	#' '		;NAME
	STA	DFLFCB,X	;AND
	DEX			;TYPE
	BNE	*-4		;WITH SPACES
	INX			;SET INDEX TO ONE
	LDA	CTXT,Y		;GET FIRST CHAR
	AND	#%00001111	;CONVERT TO NUMBER
	STA	DFLFCB		;SET AUTOMATIC
	INY			;POINT TO NEXT
	LDA	CTXT,Y		;GET CHAR
	CMP	#':'		;IF : THEN
	BEQ	GETNME		;THEN CONTINUE
	DEY			;ELSE BACKUP
	DEY			;TWO PLACES
	LDA	#0		;THEN CLEAR
	STA	DFLFCB		;AUTOMATIC
GETNME	INY			;GO TO NEXT
GTMRNM	LDA	CTXT,Y		;GET CHAR
	BEQ	ENDALL		;OVER IF NONE
	JSR	LGLTST		;MAKE SURE ITS LEGAL
	BEQ	INPERR		;IF NOT ERROR
	STA	DFLFCB,X	;ELSE PUT IN FCB
	INY			;POINT TO
	INX			;NEXT POSITIONS
	CPX	#9		;IF NOT TO BIG
	BNE	GTMRNM		;GET MORE
	LDA	CTXT,Y		;GET INPUT
	BNE	INPERR		;THEN ERROR
ENDALL	DEX			;AND IF NO
	BEQ	INPERR		;INPUT IS ERROR
	CLC			;NO ERROR
	RTS			;ELSE RETURN
INPERR	SEC			;ERROR
	RTS
;READ KIM FILE
XQREAD	LDA	#0		;CLEAR
	LDX	#32		;FCB
ZERFCB	STA	DFLFCB,X	;EXCEPT
	DEX			;FOR NAME
	CPX	#11		;AND TYPE
	BNE	ZERFCB		;AND DRIVE
	LDX	#2		;SET TO
TYPSET	LDA	KIMTYP,X	;MOVE KIM
	STA	DFLFCB+9,X	;TYPE TO FCB
	DEX			;COUNT DOWN
	BPL	TYPSET		;AND LOOP UNTIL DONE
	JSR	OPNDFL		;TRY TO OPEN
	BPL	*+5		;GOT IT
	JMP	XQRERR		;ELSE ERROR
	LDA	#128		;SET POINTER
	STA	KIMPNT		;TO ILLEGAL
KIMLOP	JSR	GETCHR		;GET CHAR
	BCC	*+5		;CONTINUE IF OK
	JMP	XQRERR		;ELSE ERROR
	CMP	#'$'		;IF $
	BEQ	ENDKIM		;THEN DONE
	CMP	#EOF		;IF EOF
	BEQ	ENDKIM		;THEN DONE
	CMP	#SEMICO		;IF NOT FILE MARK
	BNE	KIMLOP		;TRY AGAIN
	JSR	GETTWO		;GET COUNT
	BEQ	ENDKIM		;DONE IF ZERO
	STA	KIMCNT		;SET COUNT
	JSR	GETTWO		;GET HIGH ADDR
	STA	POINTR+1	;AND SAVE
	JSR	GETTWO		;GET LOW ADDR
	CLC			;ADD
	ADC	OFFSET		;OFFSET
	STA	POINTR		;AND SAVE
	PHA			;LOCALLY
	LDA	POINTR+1	;GET HIGH
	ADC	OFFSET+1	;ADD OFFSET
	STA	POINTR+1	;AND SAVE
	TAY			;SET HIGH
	PLA			;AND LOW
	PHA			;SAVE LOW AGAIN
	CMP	LOKIM		;SEE IF
	TYA			;TOO
	SBC	LOKIM+1		;SMALL
	PLA			;GET LOW BACK
	BCS	*+5		;IF OK CONTINUE
	JMP	XQRERR		;ELSE ERROR
	CLC			;ADD
	ADC	KIMCNT		;COUNT
	BCC	*+3		;TO START
	INY			;AND SAVE
	SEC			;SET CARRY
	SBC	#1		;DROP
	BCS	*+3		;BY ONE TO
	DEY			;GET LAST ADDRESS
	CMP	HIKIM		;SEE IF
	TYA			;TOO
	SBC	HIKIM+1		;BIG
	BCC	*+5		;IF OK CONTINUE
	JMP	XQRERR		;ELSE ERROR
KMHIOK	JSR	GETTWO		;GET BYTE
	LDY	#0		;CLEAR INDEX
	STA	(POINTR),Y	;STORE BYTE
	INC	POINTR		;BUMP LOW
	BNE	*+4		;DONE IF NOT ZERO
	INC	POINTR+1	;ELSE BUMP HIGH
	DEC	KIMCNT		;COUNT DOWN
	BNE	KMHIOK		;LOOP IF MORE
	JSR	GETTWO		;IGNORE
	JSR	GETTWO		;CHECKSUM
	JMP	KIMLOP		;AND LOOP
ENDKIM	CLC			;NO ERROR
	RTS
XQRERR	SEC			;ERROR
	RTS
;SKIP BLANKS
SPCSKP	LDA	CTXT,Y		;GET CHAR
	BEQ	SPCEXT		;DONE IF NONE
	CMP	#' '		;IF NOT SPACE
	BNE	SPCEXT		;THEN DONE
	INY			;ELSE LOOP
	BNE	SPCSKP		;AND TRY AGAIN
SPCEXT	RTS
;TEST FOR ILLEGAL
; IF AN ERROR THEN Z=1 ELSE Z=0
LGLTST	LDA	CTXT,Y		;GET CHAR
	BEQ	LGLEXT		;DONE IF NULL
	CMP	#' '		;IF LESS THAN SPACE
	BCC	INPTBD		;IS AN ERROR
	BEQ	LGLEXT
	CMP	#'?'
	BEQ	LGLEXT
	CMP	#'*'
	BEQ	LGLEXT
	CMP	#'='
	BEQ	LGLEXT
	CMP	#'.'
	BEQ	LGLEXT
	CMP	#':'
	BEQ	LGLEXT
	CMP	#SEMICO
	BEQ	LGLEXT
	CMP	#'<'
	BEQ	LGLEXT
	CMP	#'>'
LGLEXT	RTS
INPTBD	LDA	#0		;ERROR
	RTS
;GET CHARACTER
GETCHR	LDX	KIMPNT		;GET POINTER
	BPL	NOREAD		;IF OK USE
	JSR	RDEDFL		;ELSE READ
	BEQ	GETOK		;IF OK CONTINUE
	BPL	*+5		;OK IF EOF
	JMP	GCERR		;ELSE ERROR
	LDA	#EOF		;GET AN EOF
	STA	DFLBUF		;PUT IN BUFFER
	LDA	#0		;CLEAR A TO
GETOK	TAX			;CLEAR INDEX
	STX	KIMPNT		;AND POINTER
NOREAD	INC	KIMPNT		;BUMP POINTER
	LDA	DFLBUF,X	;GET CHAR
	AND	#%01111111	;MASK OUT PARITY
	CLC			;NO ERROR
	RTS
GCERR	SEC			;READ ERROR
	RTS
;GET BYTE
GETTWO	LDA	#0		;CLEAR
	STA	NUMBER		;BUFFER
	STA	NUMBER+1	;SO NO ERROR
	JSR	GETONE		;GET NIBBLE
	BCS	GETERR		;BRANCH IF ERROR
GETONE	JSR	GETCHR		;GET CHAR
	BCS	GETERR		;BRANCH IF ERROR
	JSR	PACK		;PACK AND CONVERT
	BCS	GETERR		;ERROR IF CARRY
	LDA	NUMBER		;ELSE GET RESULT
	CLC			;NO ERROR
GETERR	RTS
;PACK ASCII
PACK	CMP	#'0'		;IF TOO SMALL
	BMI	PACKER		;THEN ERROR
	CMP	#'9'+1		;IF "0" TO "9"
	BMI	DECNUM		;IS DECIMAL
	CMP	#'A'		;IF LESS THAN "A"
	BMI	PACKER		;THEN ERROR
	CMP	#'F'+1		;IF MORE THAN "F"
	BPL	PACKER		;THEN ERROR
	CLC			;ELSE ADD
	ADC	#9		;NINE
DECNUM	ROL	A		;MOVE
	ROL	A		;TO
	ROL	A		;HIGH
	ROL	A		;NIBBLE
	LDX	#4		;SHIFT
PACKLP	ROL	A		;INPUT
	ROL	NUMBER		;AND
	ROL	NUMBER+1	;BUFFER
	BCS	PACKER		;ERROR IF CARRY
	DEX			;COUNT DOWN
	BNE	PACKLP		;AND LOOP
	RTS
PACKER	SEC			;ERROR
	RTS			;RETURN
;OUTPUT SPACE
OUTSPC	LDA	#' '		;GET SPACE
;OUTPUT WITH SAVE
CHAROT	PHA			;SAVE CHAR
	STX	SAVEX		;SAVE X
	STY	SAVEY		;AND Y
	JSR	OUTCHR		;SEND
	LDY	SAVEY		;RESTORE
	LDX	SAVEX		;X AND Y
	PLA			;THEN CHAR
	RTS
;DEFAULT FILE REFERENCES
STDFBF	LDA	#LO_DFLBUF	;POINT TO
	LDY	#HI_DFLBUF	;DEFAULT BUFFER
BUFSET	LDX	#26		;SET DMA
	BNE	TOPEM
OPNDFL	LDX	#15		;OPEN FILE
	BNE	SETDFL
RDEDFL	LDX	#20		;READ RECORD
SETDFL	LDA	#LO_DFLFCB	;POINT TO
	LDY	#HI_DFLFCB	;DEFAULT FCB
	JMP	TOPEM		;GO
;GENERAL PEM REFERENCES
CHRINP	LDX	#1		;CHARACTER INPUT
	BNE	TOPEM
OUTCHR	LDX	#2		;CHARACTER OUTPUT
	BNE	TOPEM
WRTMSG	LDX	#9		;WRITE MESSAGE
	BNE	TOPEM
SELECT	LDX	#14		;SELECT DRIVE
	BNE	TOPEM
RDEINP	LDA	#LO_CBUF		;READ BUFFER
	LDY	#HI_CBUF
	LDX	#10
TOPEM	JMP	PEMJMP
;KIM TYPE FIELD
KIMTYP	.BYTE	"KIM"
;MESSAGES
OPNMSG	.BYTE	"SYSGEN"
	.BYTE	CR,LF,"VERSION 2.15-A$"
SZEMSG	.BYTE	CR,LF,"ENTER MEMORY SIZE IN DECIMAL "
	.BYTE	"K BYTES (K=1024) $"
BTEMSG	.BYTE	CR,LF,"ENTER DRIVE AND NAME FIELD "
	.BYTE	"FOR BOOT .KIM FILE $"
FLEMSG	.BYTE	CR,LF
	.BYTE	"ILLEGAL FILE NAME, BAD DATA OR"
	.BYTE	CR,LF
	.BYTE	"ILLEGAL ADDRESS IN INPUT FILE "
	.BYTE	"- ABORTING$"
NWSMSG	.BYTE	CR,LF,"ENTER SIM LENGTH IN DECIMAL "
	.BYTE	"PAGES (PAGE=256) (1 TO 99) $"
SIMMSG	.BYTE	CR,LF,"ENTER DRIVE AND NAME "
	.BYTE	"FIELD FOR SIM .KIM FILE $"
IERMSG	.BYTE	"ILLEGAL INPUT - REENTER $"
CRTMSG	.BYTE	CR,LF,"INSERT DISKETTE THEN ENTER "
	.BYTE	"DESTINATION DRIVE (A-H) $"
ROMMSG	.BYTE	CR,LF,"NOT ENOUGH SYSTEM TRACKS - "
	.BYTE	"ABORTING$"
INVMSG	.BYTE	CR,LF,"INVALID DRIVE - TRY AGAIN$"
BIGMSG	.BYTE	CR,LF
	.BYTE	"SYSTEM IS TOO LONG - ABORTING$"
WERMSG	.BYTE	CR,LF
	.BYTE	"ERROR DURING WRITE - ABORTING$"
;VARIABLES
SYSLNG	.WORD	CCMLNG+PEMLNG	;SYSTEM LENGTH
;INPUT BUFFER
CBUF
CMAX	.BYTE	32		;INPUT
CLNG	.BYTE	0		;BUFFER
CTXT
	*=	*+32
;ALIGN CODE ON HALF PAGE INORDER TO ASSIST IN
;DEBUGGING AND TO ALLOW JMP (XXXX) TO BE
;PLACED AT WORD BOUNDARY.
	*=	*/256*256+384
SYSDEF


PAGLIM	=	CCM+CCMLNG+PEMLNG/256+1	;ALLOW ONE PAGE FOR SIM

LO_CCMLNG	.EQU	CCMLNG & $FF
HI_CCMLNG	.EQU	((CCMLNG & $FF00) >> 8)
LO_OPNMSG	.EQU	OPNMSG & $FF
HI_OPNMSG	.EQU	((OPNMSG & $FF00) >> 8)
LO_CCM		.EQU	CCM & $FF
HI_CCM		.EQU	((CCM & $FF00) >> 8)
LO_BIGMSG	.EQU	BIGMSG & $FF
HI_BIGMSG	.EQU	((BIGMSG & $FF00) >> 8)
LO_PEM		.EQU	PEM & $FF
HI_PEM		.EQU	((PEM & $FF00) >> 8)
LO_CRTMSG	.EQU	CRTMSG & $FF
HI_CRTMSG	.EQU	((CRTMSG & $FF00) >> 8)
LO_INVMSG	.EQU	INVMSG & $FF
HI_INVMSG	.EQU	((INVMSG & $FF00) >> 8)
LO_BOOT		.EQU	BOOT & $FF
HI_BOOT		.EQU	((BOOT & $FF00) >> 8)
LO_ROMMSG	.EQU	ROMMSG & $FF
HI_ROMMSG	.EQU	((ROMMSG & $FF00) >> 8)
LO_WERMSG	.EQU	WERMSG & $FF
HI_WERMSG	.EQU	((WERMSG & $FF00) >> 8)
LO_BTEMSG	.EQU	BTEMSG & $FF
HI_BTEMSG	.EQU	((BTEMSG & $FF00) >> 8)
LO_FLEMSG	.EQU	FLEMSG & $FF
HI_FLEMSG	.EQU	((FLEMSG & $FF00) >> 8)
LO_SIMMSG	.EQU	SIMMSG & $FF
HI_SIMMSG	.EQU	((SIMMSG & $FF00) >> 8)
LO_SIM		.EQU	SIM & $FF
HI_SIM		.EQU	((SIM & $FF00) >> 8)
LO_PAGLIM	.EQU	PAGLIM & $FF
LO_CBUF		.EQU	CBUF & $FF
HI_CBUF		.EQU	((CBUF & $FF00) >> 8)
LO_IERMSG	.EQU	IERMSG & $FF
HI_IERMSG	.EQU	((IERMSG & $FF00) >> 8)
LO_NWSMSG	.EQU	NWSMSG & $FF
HI_NWSMSG	.EQU	((NWSMSG & $FF00) >> 8)
LO_SZEMSG	.EQU	SZEMSG & $FF
HI_SZEMSG	.EQU	((SZEMSG & $FF00) >> 8)
LO_DFLBUF	.EQU	DFLBUF & $FF
HI_DFLBUF	.EQU	((DFLBUF & $FF00) >> 8)
LO_DFLFCB	.EQU	DFLFCB & $FF
HI_DFLFCB	.EQU	((DFLFCB & $FF00) >> 8)
LO_TEA		.EQU	TEA & $FF
HI_TEA		.EQU	((TEA & $FF00) >> 8)



	.END
