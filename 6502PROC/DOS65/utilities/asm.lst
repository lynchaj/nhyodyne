ca65 V2.18 - Ubuntu 2.19-1
Main file   : asm211.asm
Current file: asm211.asm

000000r 1               ;ASM -- DOS/65 ASSEMBLER
000000r 1               ;VERSION 2.11-A
000000r 1               ;RELEASED:	7 MARCH 2008
000000r 1               ;THIS VERSION INCORPORATES THE FOLLOWING CHANGES FROM 2.04
000000r 1               ;	FORMAT FOR *= CHANGED FOR TASM COMPATIBILITY
000000r 1               ;		THIS MEANS FIRST * NOT IN COLUMN 1
000000r 1               ;		ALL SUCH STATEMENTS ARE ON A SEPARATE LINE FROM LABLE
000000r 1               ;	.BYT & .WOR CHANGED TO .BYTE & .WORD FOR TASM
000000r 1               ;	ALL COMMENTS HAVE ; FOR TASM
000000r 1               ;	MADE ' & " INTERCHANGEABLE SO STRINGS CAN US
000000r 1               ;		"" FOR TASM COMPATIBILITY.
000000r 1               ;		NOTE THAT ASM210 USES ' ONLY
000000r 1               ;		AND SHOULD BE ASSEMBLED EITHER BY
000000r 1               ;		ITSELF, ASM204, OR IF ALL STRINGS
000000r 1               ;		IN .BYTE STATEMENT ARE CHANGED TO "
000000r 1               ;		IT CAN BE ASSEMBLED BY TASM.
000000r 1               ;	MADE ALL #' ' HAVE CLOSING ' (OR ") FOR TASM
000000r 1               ;	STRINGS BROKEN UP TO 31 MAX FOR TASM
000000r 1               ;	MANY COMMENTS ADDED OR CLARIFIED
000000r 1               ;	MORE ASCII CHARACTERS DEFINED TO SIMPLIFY COMPATIBILITY
000000r 1               ;LAST REVISION:
000000r 1               ;	31 MARCH 2008
000000r 1               ;		CHANGED STRING DELIMITERS TO ""
000000r 1               ;		ADDED FIVE MISSING SEMICOLONS
000000r 1               ;ASCII CHARACTER DEFINITIONS
000000r 1               TAB	=	$9		;TAB CHAR
000000r 1               LF	=	$A		;LINEFEED
000000r 1               CR	=	$D		;RETURN
000000r 1               EOF	=	$1A		;END OF FILE
000000r 1               BLANK	=	$20		;BLANK
000000r 1               QUOTE	=	$22		;VALUE OF "
000000r 1               APOST	=	$27		;VALUE OF '
000000r 1               SEMICO	=	$3B		;VALUE OF SEMICOLON ;
000000r 1               DELETE	=	$7F		;DEL CHAR
000000r 1               ;FIXED PARAMETERS
000000r 1               NUMASM	=	15		;NUMBER DIRECTIVES OR PARAMETERS
000000r 1               NUMSAV	=	10		;NUMBER OPT PARAMETERS
000000r 1               LINESZ	=	80		;CHARACTERS PER LINE (NOT INCL CR/LF)
000000r 1               BYTSRC	=	24		;BYTES PER KIM RECORD
000000r 1               SRCLNG	=	1024		;SOURCE BUFFER LENGTH
000000r 1               KIMLNG	=	1024		;KIM BUFFER LENGTH
000000r 1               LSTLNG	=	1024		;LIST BUFFER LENGTH
000000r 1               ;EXTERNAL REFERENCES
000000r 1               TEA	=	$800
000000r 1               PEM	=	$103
000000r 1               DFLFCB	=	$107
000000r 1               DFLBUF	=	$128
000000r 1               ;PAGE ZERO VARIABLES
000000r 1               
000000r 1               
000000r 1               N	=$02			;COUNT IN SORT
000000r 1               PASNUM	=$04			;PASS NUMBER
000000r 1               SRCIND	=$05			;SOURCE BUFFER INDEX
000000r 1               KIMIND	=$07			;KIM BUFFER INDEX
000000r 1               LSTIND	=$09			;LIST BUFFER INDEX
000000r 1               STSAVE	=$0B			;SYMBOL TABLE START
000000r 1               TBLSZ	=$0D			;SYMBOL TABLE END
000000r 1               SYMTBL	=$0F			;ADDRESS OF SYMBOL FOUND
000000r 1               OPRTBL	=$11			;ADDRESS OF OPCODE IN TABLE
000000r 1               TBLPTR	=$13			;USED IN ASSEMBLER DIRECTIVE SEARCHES
000000r 1               COLCNT	=$15			;COLUMN COUNT
000000r 1               LINENO	=$16			;LINE NUMBER (HL)
000000r 1               NOSYM	=$18			;NUMBER SYMBOLS (HL)
000000r 1               ERCT	=$1A			;TOTAL ERROR COUNT (HL)
000000r 1               PC	=$1C			;PROGRAM COUNTER
000000r 1               FLAGS	=$1E			;SET OF FLAGS
000000r 1               ;FLAG BIT FUNCTIONS
000000r 1               ; FLAG	(7)	IF 1 THEN DO NOT GENERATE STRINGS
000000r 1               ;	(6)	IF 1 THEN LIST SYMBOL TABLE
000000r 1               ;	(5)	IF 1 THEN GENERATE KIM FILE
000000r 1               ;	(4)	IF 1 AND IF FLAG(2)=0 THEN LIST ERRORS
000000r 1               ;	(3)
000000r 1               ;	(2)	IF 1 THEN PRODUCE LISTING
000000r 1               ;	(1)
000000r 1               ;	(0)
000000r 1               ; FLAG+1(7)
000000r 1               ;	(6)
000000r 1               ;	(5)
000000r 1               ;	(4)	EXPR RETURN FLAG
000000r 1               ;	(3)	EXPR OVERFLOW FLAG
000000r 1               ;	(2)
000000r 1               ;	(1)	SIGN BIT
000000r 1               ;	(0)	EXP SIGN BIT
000000r 1               COLP	=$20			;CURRENT COLUMN
000000r 1               CSB	=$21			;CURRENT STRING BEGINNING
000000r 1               CSE	=$22			;CURRENT STRING END
000000r 1               CSL	=$23			;CURRENT STRING LENGTH
000000r 1               LSST	=$24			;START OF LABEL
000000r 1               EXP	=$25			;VALUE OF EXPRESSION (HL)
000000r 1               PARST	=$27			;PARSE STARTING COLUMN
000000r 1               MAXCL	=$28			;MAX COLUMN IN LINE
000000r 1               LABL	=$29			;FLAG SET IF LABEL IN LINE
000000r 1               ORG	=$2A			;FLAG SET IF ORG IN LINE
000000r 1               BYWOR	=$2B			;BYTE/WORD FLAG
000000r 1               LCDPT	=$2C			;MULTIPLE LINES FLAG
000000r 1               SYMPTR	=$2D			;CURRENT # SYMBOLS SEARCHED IN FIND
000000r 1               LEN	=$2F			;LENGTH OF STRING TO BE PACKED
000000r 1               BASE	=$30			;BASE OF NUMBER
000000r 1               OP	=$31			;NEXT OPERATOR IN EVAL
000000r 1               LOW	=$32			;< FLAG
000000r 1               HIGH	=$33			;> FLAG
000000r 1               VAL	=$34			;INTERMEDIATE VALUE IN EVAL (HL)
000000r 1               RETURN	=$36			;RETURN CODE
000000r 1               OPBAS	=$37			;BASE OPCODE
000000r 1               OPTEM	=$38			;OPCODE TEMPLATE
000000r 1               OPLEN	=$39			;OPERAND LENGTH
000000r 1               OPTYP	=$3A			;OPERAND TYPE
000000r 1               NOPV	=$3B			;FLAG FOR NO OPERAND VALUE
000000r 1               J	=$3C			;UTILITY VARIABLE
000000r 1               ERCOL	=$3D			;COLUMN WITH ERROR
000000r 1               EROR	=$3E			;ERROR NUMBER
000000r 1               TEMP	=$3F			;UTILITY VARIABLE
000000r 1               TEMB	=$41			;UTILITY VARIABLE
000000r 1               LTBL	=$43			;LENGTH TABLE - INFO BUFFER
000000r 1               SRTFLG	=$48			;SORT FLAG
000000r 1               CURADR	=$49			;CURRENT SYMBOL FOR SORT
000000r 1               NXTADR	=$4B			;NEXT SYMBOL FOR SORT
000000r 1               BYTCNT	=$4D			;KIM RECORD BYTE COUNT
000000r 1               FRSTPC	=$4E			;FIRST PC IN KIM RECORD
000000r 1               KIMREC	=$50			;KIM RECORD BUFFER
000000r 1               CHKSUM	=$68			;KIM RECORD CHECKSUM
000000r 1               CURNPC	=$6A			;CURRENT KIM PC
000000r 1               CDEPTR	=$6C			;CODE POINTER
000000r 1               SAVE	=$6E			;SAVE FOR X AND Y
000000r 1               ACC	=$70			;MUL AND DIV ACCUM
000000r 1               KINDEX	=$72			;KIM RECORD INDEX
000000r 1               KIMCNT	=$73			;KIM CODE COUNT
000000r 1               RDSCCN	=$74			;READ SOURCE SECTOR COUNT
000000r 1               LNGKIM	=$75			;LENGTH OF BUFFER AT WRITE
000000r 1               LNGLST	=$77			;LENGTH OF LIST BUFFER
000000r 1               MPNT	=$79			;POINTER FOR STRING WRITE
000000r 1               MAXECH	=$7B			;LAST ECHO POSITION
000000r 1               STRING	=$7C			;LOWERCASE FLAG
000000r 1               LSTFLG	=$7D			;LIST FILE TO CONSOLE IF > 127
000000r 1               NLSFLG	=$7E			;NO LIST FILE OUTPUT IF > 127
000000r 1               NKMFLG	=$7F			;NO KIM FILE OUTPUT IF > 127
000000r 1               STRDEL	=$80			;STRING DELIMITER IN .BYT
000000r 1               LASTZP	=$81
000000r 1               ;ENTRY POINT
000000r 1                		.segment "TEA"
000000r 1               		.ORG $0800
000800  1               
000800  1  4C 44 19     	JMP	MAIN		;SKIP TO MAIN SECTION
000803  1  10           SYMLEN:	.BYTE	16		;MAX SYMBOL LENGTH
000804  1  43 4F 50 59  	.BYTE	"COPYRIGHT (C) 2008 -"
000808  1  52 49 47 48  
00080C  1  54 20 28 43  
000818  1  20 52 49 43  	.BYTE	" RICHARD A. LEARY"
00081C  1  48 41 52 44  
000820  1  20 41 2E 20  
000829  1               ;SUBROUTINES
000829  1               ;CHECK FOR CORRECT DRIVE RANGE
000829  1  C9 41        CHKDRV:	CMP	#'A'		;IF LESS THAN A
00082B  1  90 07        	BCC	BADRV		;IS BAD
00082D  1  C9 49        	CMP	#'H'+1		;IF OVER H
00082F  1  B0 03        	BCS	BADRV		;IS BAD
000831  1  29 0F        	AND	#15		;LOOK AT LSBS ONLY
000833  1  60           	RTS
000834  1  A9 26        BADRV:	LDA	#<ILDMSG	;POINT TO MESSAGE
000836  1  A0 1B        	LDY	#>ILDMSG
000838  1  20 50 08     	JSR	WRCNMS		;WRITE IT
00083B  1               ;WARM BOOT
00083B  1  A2 00        WRMBTE:	LDX	#0
00083D  1  F0 2B        	BEQ	PEMENT
00083F  1               ;CONSOLE OUTPUT
00083F  1  C9 1A        CNSOUT:	CMP	#EOF		;SEE IF EOF CHAR
000841  1  D0 01        	BNE	*+3		;CONTINUE IF NOT
000843  1  60           	RTS			;ELSE DONE
000844  1  A2 02        	LDX	#2
000846  1  D0 22        	BNE	PEMENT
000848  1               ;SELECT DRIVE
000848  1  A2 0E        DRVSEL:	LDX	#14
00084A  1  D0 1E        	BNE	PEMENT
00084C  1               ;SET BUFFER ADDRESS
00084C  1  A2 1A        SETBUF:	LDX	#26
00084E  1  D0 1A        	BNE	PEMENT
000850  1               ;WRITE CONSOLE MESSAGE
000850  1  A2 09        WRCNMS:	LDX	#9
000852  1  D0 16        	BNE	PEMENT
000854  1               ;OPEN FILE
000854  1  A2 0F        OPNFIL:	LDX	#15
000856  1  D0 15        	BNE	PEM255
000858  1               ;CLOSE FILE
000858  1  A2 10        CLSFIL:	LDX	#16
00085A  1  D0 11        	BNE	PEM255
00085C  1               ;DELETE FILE
00085C  1  A2 13        DLTFIL:	LDX	#19
00085E  1  D0 0D        	BNE	PEM255
000860  1               ;CREATE FILE
000860  1  A2 16        CRTFIL:	LDX	#22
000862  1  D0 09        	BNE	PEM255
000864  1               ;READ RECORD
000864  1  A2 14        RDERCR:	LDX	#20
000866  1  D0 02        	BNE	PEMENT
000868  1               ;WRITE RECORD
000868  1  A2 15        WRTRCR:	LDX	#21
00086A  1               ;PEM ENTRY
00086A  1  4C 03 01     PEMENT:	JMP	PEM		;EXECUTE
00086D  1               ;PEM ENTRY WITH TEST A=255
00086D  1  20 03 01     PEM255:	JSR	PEM		;EXECUTE
000870  1  C9 FF        	CMP	#255		;TEST FOR INVALID
000872  1  60           	RTS
000873  1               ;WRITE MESSAGE TO LIST FILE
000873  1               ;INPUT: A,Y POINT TO MESSAGE
000873  1               ;OUTPUT: NONE
000873  1               ;ALTERS: ALL
000873  1  85 79        WRLSMS:	STA	MPNT		;SAVE
000875  1  84 7A        	STY	MPNT+1		;POINTER
000877  1  A0 00        	LDY	#0		;CLEAR INDEX
000879  1  B1 79        WR:	LDA	(MPNT),Y	;GET CHAR
00087B  1  C9 24        	CMP	#'$'		;SEE IF $
00087D  1  D0 01        	BNE	*+3		;CONTINUE IF NOT
00087F  1  60           	RTS			;ELSE DONE
000880  1  20 9C 09     	JSR	OUTPUT		;SEND IT
000883  1  C8           	INY			;BUMP INDEX
000884  1  D0 F3        	BNE	WR		;JUMP ALWAYS
000886  1               ;DOS ERROR HANDLER
000886  1  A9 8F        DOSERR:	LDA	#<PERMSG	;PRINT ERROR
000888  1  A0 1B        	LDY	#>PERMSG	;MESSAGE ON
00088A  1  20 50 08     	JSR	WRCNMS		;CONSOLE
00088D  1  4C 3B 08     	JMP	WRMBTE		;AND DO BOOT
000890  1               ;SET SOURCE FCB
000890  1  A9 1C        SSRFCB:	LDA	#<SRCFCB
000892  1  A0 21        	LDY	#>SRCFCB
000894  1  60           	RTS
000895  1               ;SET KIM FCB
000895  1  A9 3D        SKMFCB:	LDA	#<KIMFCB
000897  1  A0 21        	LDY	#>KIMFCB
000899  1  60           	RTS
00089A  1               ;SET LIST FCB
00089A  1  A9 5E        SLSFCB:	LDA	#<LSTFCB
00089C  1  A0 21        	LDY	#>LSTFCB
00089E  1  60           	RTS
00089F  1               ;DELETE KIM FILE
00089F  1  20 95 08     DLTKIM:	JSR	SKMFCB		;SET FCB
0008A2  1  4C 5C 08     	JMP	DLTFIL		;DELETE AND RETURN
0008A5  1               ;READ SOURCE RECORD
0008A5  1  A9 7F        RDESRC:	LDA	#<SRCBUF 	;SET
0008A7  1  A0 21        	LDY	#>SRCBUF 	;BUFFER
0008A9  1  20 4C 08     	JSR	SETBUF		;ADDRESS
0008AC  1  20 90 08     	JSR	SSRFCB		;POINT TO FCB
0008AF  1  4C 64 08     	JMP	RDERCR		;READ
0008B2  1               ;WRITE KIM RECORD
0008B2  1  38           WRTKIM:	SEC			;SUBTRACT
0008B3  1  A5 07        	LDA	KIMIND		;START
0008B5  1  E9 7F        	SBC	#<KIMBUF 	;FROM
0008B7  1  85 75        	STA	LNGKIM		;INDEX
0008B9  1  A5 08        	LDA	KIMIND+1	;TO GET
0008BB  1  E9 25        	SBC	#>KIMBUF	;LENGTH
0008BD  1  85 76        	STA	LNGKIM+1	;OF BUFFER
0008BF  1  A2 07        	LDX	#7		;DIVIDE
0008C1  1  46 76        WRTDV:	LSR	LNGKIM+1	;BY 128
0008C3  1  66 75        	ROR	LNGKIM		;TO GET
0008C5  1  CA           	DEX			;NUMBER
0008C6  1  D0 F9        	BNE	WRTDV		;OF RECORDS
0008C8  1  E4 75        	CPX	LNGKIM		;IF NOT ZERO
0008CA  1  D0 01        	BNE	*+3		;GO WRITE
0008CC  1  60           	RTS			;ELSE DONE
0008CD  1  20 F1 08     	JSR	CLKIND		;CLEAR INDEX
0008D0  1  A5 07        WRTKLP:	LDA	KIMIND		;GET RECORD
0008D2  1  A4 08        	LDY	KIMIND+1	;START
0008D4  1  20 4C 08     	JSR	SETBUF		;AND SET BUFFER
0008D7  1  20 95 08     	JSR	SKMFCB		;POINT TO FCB
0008DA  1  20 68 08     	JSR	WRTRCR		;WRITE SECTOR
0008DD  1  F0 03        	BEQ	*+5		;CONTINUE IF OK
0008DF  1  4C 86 08     	JMP	DOSERR		;ELSE DOS/65 ERROR
0008E2  1  18           	CLC			;ADD
0008E3  1  A5 07        	LDA	KIMIND		;128
0008E5  1  69 80        	ADC	#128		;TO
0008E7  1  85 07        	STA	KIMIND		;KIM
0008E9  1  90 02        	BCC	*+4		;INDEX
0008EB  1  E6 08        	INC	KIMIND+1	;FOR NEXT
0008ED  1  C6 75        	DEC	LNGKIM		;DROP COUNT
0008EF  1  D0 DF        	BNE	WRTKLP		;LOOP IF MORE
0008F1  1               ;CLEAR KIM INDEX
0008F1  1  A9 7F        CLKIND:	LDA	#<KIMBUF 	;SET
0008F3  1  A0 25        	LDY	#>KIMBUF	;INDEX
0008F5  1  85 07        	STA	KIMIND		;TO BUFFER
0008F7  1  84 08        	STY	KIMIND+1	;START
0008F9  1  60           	RTS
0008FA  1               ;LIST FILE CHARACTER OUTPUT
0008FA  1               ;INPUT: ASCII CHAR IN A
0008FA  1               ;OUTPUT: NONE
0008FA  1               ;ALTERS: ALL
0008FA  1               ;WRITE LIST BUFFER TO DISK IF FULL AND
0008FA  1               ;THEN INSERT CHAR INTO BUFFER
0008FA  1  24 7E        LSTOUT:	BIT	NLSFLG		;TEST FOR NO LIST OUTPUT
0008FC  1  30 22        	BMI	LSTEXT		;DONE IF SET
0008FE  1  24 7D        	BIT	LSTFLG		;TEST FLAG
000900  1  10 03        	BPL	*+5		;IF CLEAR TO DISK
000902  1  4C 3F 08     	JMP	CNSOUT		;ELSE TO CONSOLE
000905  1  A6 09        	LDX	LSTIND		;GET LOW INDEX
000907  1  E0 7F        	CPX	#<(LSTBUF+LSTLNG)	;COMPARE TO LIMIT
000909  1  D0 0B        	BNE	NOLSWR		;JUMP IF OK
00090B  1  A6 0A        	LDX	LSTIND+1	;ELSE TRY
00090D  1  E0 2D        	CPX	#>(LSTBUF+LSTLNG)	;SAME FOR HIGH
00090F  1  D0 05        	BNE	NOLSWR		;OK IF DIFFERENT
000911  1  48           	PHA			;SAVE CHAR
000912  1  20 21 09     	JSR	WRTLST		;WRITE BUFFER
000915  1  68           	PLA			;GET CHAR
000916  1  A0 00        NOLSWR:	LDY	#0		;CLEAR INDEX
000918  1  91 09        	STA	(LSTIND),Y	;INSERT CHAR
00091A  1  E6 09        	INC	LSTIND		;BUMP
00091C  1  D0 02        	BNE	*+4		;INDEX
00091E  1  E6 0A        	INC	LSTIND+1	;BY ONE
000920  1  60           LSTEXT:	RTS
000921  1               ;WRITE LIST BUFFER TO DISK
000921  1               ;INPUT: NONE
000921  1               ;OUTPUT: NONE
000921  1               ;ALTERS: ALL
000921  1               ;ALSO SETS INDEX TO START
000921  1  38           WRTLST:	SEC			;SUBTRACT
000922  1  A5 09        	LDA	LSTIND		;BUFFER START
000924  1  E9 7F        	SBC	#<LSTBUF	;FROM
000926  1  85 77        	STA	LNGLST		;CURRENT
000928  1  A5 0A        	LDA	LSTIND+1	;INDEX TO
00092A  1  E9 29        	SBC	#>LSTBUF	;GET
00092C  1  85 78        	STA	LNGLST+1	;LENGTH
00092E  1  A2 07        	LDX	#7		;DIVIDE
000930  1  46 78        WRLDV:	LSR	LNGLST+1	;THAT
000932  1  66 77        	ROR	LNGLST		;BY 128
000934  1  CA           	DEX			;TO CALCULATE
000935  1  D0 F9        	BNE	WRLDV		;NUMBER RECORDS
000937  1  E4 77        	CPX	LNGLST		;IF NOT ZERO
000939  1  D0 01        	BNE	*+3		;THEN GO WRITE
00093B  1  60           	RTS			;ELSE DONE
00093C  1  20 60 09     	JSR	CLLIND		;SET INDEX TO START
00093F  1  A5 09        WRTLLP:	LDA	LSTIND		;GET INDEX
000941  1  A4 0A        	LDY	LSTIND+1	;AND SET
000943  1  20 4C 08     	JSR	SETBUF		;AS BUFFER START
000946  1  20 9A 08     	JSR	SLSFCB		;POINT TO FCB
000949  1  20 68 08     	JSR	WRTRCR		;WRITE RECORD
00094C  1  F0 03        	BEQ	*+5		;CONTINUE IF OK
00094E  1  4C 86 08     	JMP	DOSERR		;ELSE A FATAL ERROR
000951  1  18           	CLC			;NOW
000952  1  A5 09        	LDA	LSTIND		;ADD
000954  1  69 80        	ADC	#128		;128
000956  1  85 09        	STA	LSTIND		;TO
000958  1  90 02        	BCC	*+4		;INDEX
00095A  1  E6 0A        	INC	LSTIND+1	;FOR NEXT
00095C  1  C6 77        	DEC	LNGLST		;DROP COUNT
00095E  1  D0 DF        	BNE	WRTLLP		;LOOP IF MORE
000960  1               ;CLEAR LIST INDEX
000960  1               ;INPUT: NONE
000960  1               ;OUTPUT: NONE
000960  1               ;ALTERS: A,Y,P
000960  1  A9 7F        CLLIND:	LDA	#<LSTBUF	;SET LIST
000962  1  A0 29        	LDY	#>LSTBUF	;INDEX
000964  1  85 09        	STA	LSTIND		;TO
000966  1  84 0A        	STY	LSTIND+1	;BUFFER
000968  1  60           	RTS			;START
000969  1               ;CONVERT NIBBLE TO HEX
000969  1  29 0F        NIBHEX:	AND	#$F		;MASK OUT MSN
00096B  1  09 30        	ORA	#'0'		;CONVERT TO ASCII
00096D  1  C9 3A        	CMP	#'9'+1		;IF DECIMAL
00096F  1  90 02        	BCC	*+4		;OK
000971  1  69 06        	ADC	#6		;ELSE MAKE ALPHA
000973  1  60           	RTS
000974  1               ;KIM FILE BYTE OUTPUT
000974  1  48           KIMBYT:	PHA			;SAVE BYTE
000975  1  4A           	LSR	A		;MOVE
000976  1  4A           	LSR	A		;MSN
000977  1  4A           	LSR	A		;TO
000978  1  4A           	LSR	A		;LSN
000979  1  20 7D 09     	JSR	KIMHEX		;CONVERT AND SEND
00097C  1  68           	PLA			;GET BYTE
00097D  1               ;KIM FILE NIBBLE OUTPUT
00097D  1  20 69 09     KIMHEX:	JSR	NIBHEX		;CONVERT
000980  1               ;KIM FILE CHAR OUTPUT
000980  1  A6 07        KIMOUT:	LDX	KIMIND		;COMPARE INDEX
000982  1  E0 7F        	CPX	#<(KIMBUF+KIMLNG) 	;TO LIMIT
000984  1  D0 0B        	BNE	NOKMWR		;CONTINUE IF LESS
000986  1  A6 08        	LDX	KIMIND+1	;DO SAME
000988  1  E0 29        	CPX	#>(KIMBUF+KIMLNG)	;FOR
00098A  1  D0 05        	BNE	NOKMWR		;HIGH BYTES
00098C  1  48           	PHA			;SAVE BYTE
00098D  1  20 B2 08     	JSR	WRTKIM		;WRITE BUFFER
000990  1  68           	PLA			;RESTORE CHAR
000991  1  A0 00        NOKMWR:	LDY	#0		;CLEAR INDEX
000993  1  91 07        	STA	(KIMIND),Y	;SAVE CHAR
000995  1  E6 07        	INC	KIMIND		;BUMP
000997  1  D0 02        	BNE	*+4		;INDEX
000999  1  E6 08        	INC	KIMIND+1	;BY ONE
00099B  1  60           	RTS
00099C  1               ;OUTPUT SINGLE CHAR TO LIST FILE
00099C  1  08           OUTPUT:	PHP			;SAVE FLAGS
00099D  1  48           	PHA			;SAVE CHAR
00099E  1  86 6E        	STX	SAVE		;SAVE X
0009A0  1  84 6F        	STY	SAVE+1		;AND Y
0009A2  1  24 04        	BIT	PASNUM
0009A4  1  10 03        	BPL	*+5
0009A6  1  20 FA 08     	JSR	LSTOUT		;DO OUTPUT
0009A9  1  A4 6F        	LDY	SAVE+1		;RESTORE Y
0009AB  1  A6 6E        	LDX	SAVE		;AND X
0009AD  1  68           	PLA			;RESTORE CHAR
0009AE  1  28           	PLP			;RESTORE FLAGS
0009AF  1  60           	RTS
0009B0  1               ;OUTPUT BYTE AS HEX TO LIST FILE
0009B0  1  48           NUMA:	PHA			;SAVE BYTE
0009B1  1  4A           	LSR	A		;MOVE
0009B2  1  4A           	LSR	A		;MSN
0009B3  1  4A           	LSR	A		;TO
0009B4  1  4A           	LSR	A		;LSN
0009B5  1  20 69 09     	JSR	NIBHEX		;CONVERT
0009B8  1  20 9C 09     	JSR	OUTPUT		;AND SEND
0009BB  1  68           	PLA			;GET CHAR
0009BC  1  20 69 09     	JSR	NIBHEX		;CONVERT LSN
0009BF  1  4C 9C 09     	JMP	OUTPUT		;AND SEND
0009C2  1               ;OUTPUT BYTE AS HEX TO CONSOLE
0009C2  1               ;INPUT: A
0009C2  1               ;OUTPUT: NONE
0009C2  1               ;ALTERS: A,P
0009C2  1  48           CNUMA:	PHA			;SAVE BYTE
0009C3  1  4A           	LSR	A		;MOVE
0009C4  1  4A           	LSR	A		;MSN
0009C5  1  4A           	LSR	A		;TO
0009C6  1  4A           	LSR	A		;LSN
0009C7  1  20 69 09     	JSR	NIBHEX		;CONVERT
0009CA  1  20 3F 08     	JSR	CNSOUT		;SEND TO CONSOLE
0009CD  1  68           	PLA			;GET BYTE
0009CE  1  20 69 09     	JSR	NIBHEX		;CONVERT LOW
0009D1  1  4C 3F 08     	JMP	CNSOUT		;SEND IT
0009D4  1               ;DO A CR AND LF TO LIST FILE
0009D4  1  A9 0D        CRLF:	LDA	#CR		;GET CR
0009D6  1  20 9C 09     	JSR	OUTPUT		;SEND
0009D9  1  A9 0A        	LDA	#LF		;THEN GET LF
0009DB  1  4C 9C 09     	JMP	OUTPUT		;SEND IT
0009DE  1               ;DO A CR AND LF TO CONSOLE
0009DE  1  A9 0D        CCRLF:	LDA	#CR		;GET CR
0009E0  1  20 3F 08     	JSR	CNSOUT		;SEND
0009E3  1  A9 0A        	LDA	#LF		;THEN GET LF
0009E5  1  4C 3F 08     	JMP	CNSOUT		;AND SEND IT
0009E8  1               ;SET NEXT SORT ADDRESS
0009E8  1  18           ADRNS:	CLC			;ADD
0009E9  1  A5 49        	LDA	CURADR		;LENGTH+2
0009EB  1  6D 03 08     	ADC	SYMLEN		;TO CURRENT
0009EE  1  85 4B        	STA	NXTADR		;TO
0009F0  1  A5 4A        	LDA	CURADR+1	;MAKE
0009F2  1  69 00        	ADC	#0		;POINTER TO
0009F4  1  85 4C        	STA	NXTADR+1	;NEXT ENTRY
0009F6  1  18           	CLC			;DO +2 PART NOW
0009F7  1  A5 4B        	LDA	NXTADR
0009F9  1  69 02        	ADC	#2
0009FB  1  85 4B        	STA	NXTADR
0009FD  1  90 02        	BCC	ADRNSX		;DONE IF NO CARRY
0009FF  1  E6 4C        	INC	NXTADR+1	;ELSE BUMP HIGH
000A01  1  60           ADRNSX:	RTS
000A02  1               ;SORT SYMBOL TABLE
000A02  1               ;USES BUBBLE SORT BUT KEEPS TRACK
000A02  1               ;OF HIGHEST SYMBOL TO SORT
000A02  1               ;CHECK FOR ZERO OR ONE SYMBOL
000A02  1  A4 19        SORT:	LDY	NOSYM+1		;SET LOW
000A04  1  84 03        	STY	N+1		;COUNT
000A06  1  A5 18        	LDA	NOSYM		;AND HIGH
000A08  1  85 02        	STA	N		;COUNT
000A0A  1  D0 1C        	BNE	SORT1		;IF > 255 GO DO SORT
000A0C  1  98           	TYA			;GET LOW
000A0D  1  F0 04        	BEQ	SORTX		;DONE IF ZERO
000A0F  1  C9 01        	CMP	#1		;IF MORE THAN
000A11  1  D0 15        	BNE	SORT1		;ONE DO SORT
000A13  1  60           SORTX:	RTS			;ELSE DONE
000A14  1               ;DROP AND CHECK COUNT
000A14  1  A5 03        SORT0:	LDA	N+1		;CHECK LOW
000A16  1  D0 02        	BNE	*+4		;SKIP IF NOT ZERO
000A18  1  C6 02        	DEC	N		;ELSE DROP HIGH
000A1A  1  C6 03        	DEC	N+1		;THEN LOW
000A1C  1  A5 02        	LDA	N		;GET NEW HIGH
000A1E  1  D0 08        	BNE	SORT1		;DO IT IF <> 0
000A20  1  A5 03        	LDA	N+1		;NOW GET LOW
000A22  1  F0 EF        	BEQ	SORTX		;DONE IF ZERO
000A24  1  C9 01        	CMP	#1		;SEE IF ONE
000A26  1  F0 EB        	BEQ	SORTX		;DONE IF IS
000A28  1               ;INTIALIZE FOR PASS
000A28  1  A9 FF        SORT1:	LDA	#$FF		;SET
000A2A  1  85 48        	STA	SRTFLG		;FLAG
000A2C  1  A5 0B        	LDA	STSAVE		;SET
000A2E  1  85 49        	STA	CURADR		;POINTER
000A30  1  A5 0C        	LDA	STSAVE+1	;TO FIRST
000A32  1  85 4A        	STA	CURADR+1	;ENTRY
000A34  1  A9 01        	LDA	#1		;THEN
000A36  1  85 2E        	STA	SYMPTR+1	;SET
000A38  1  A9 00        	LDA	#0		;COUNTER
000A3A  1  85 2D        	STA	SYMPTR		;TO ONE
000A3C  1  20 E8 09     	JSR	ADRNS		;SET NEXT ADDRESS
000A3F  1               ;COMPARE SYMBOLS
000A3F  1  A0 00        SORT11:	LDY	#0		;CLEAR INDEX
000A41  1  B1 49        SORT2:	LDA	(CURADR),Y	;COMPARE FIRST
000A43  1  D1 4B        	CMP	(NXTADR),Y	;TO NEXT
000A45  1  D0 08        	BNE	SORT21		;JUMP IF NOT SAME
000A47  1  C8           	INY			;ELSE BUMP INDEX
000A48  1  CC 03 08     	CPY	SYMLEN		;IF STILL SMALL
000A4B  1  D0 F4        	BNE	SORT2		;FOR NEXT
000A4D  1  F0 16        	BEQ	SORT3		;ELSE DO NEXT PAIR
000A4F  1  90 14        SORT21:	BCC	SORT3		;IF ORDER OK DO NEXT
000A51  1               ;SWITCH SYMBOLS
000A51  1  AC 03 08     	LDY	SYMLEN		;DO SYMBOL AND VALUE
000A54  1  C8           	INY
000A55  1  B1 49        RX1:	LDA	(CURADR),Y	;GET LOW
000A57  1  48           	PHA			;SAVE
000A58  1  B1 4B        	LDA	(NXTADR),Y	;THEN MOVE HIGH
000A5A  1  91 49        	STA	(CURADR),Y	;TO LOW
000A5C  1  68           	PLA			;RESTORE LOW
000A5D  1  91 4B        	STA	(NXTADR),Y	;MOVE TO HIGH
000A5F  1  88           	DEY			;COUNT DOWN
000A60  1  10 F3        	BPL	RX1		;LOOP IF MORE
000A62  1  C8           	INY			;CLEAR FLAG
000A63  1  84 48        	STY	SRTFLG		;TO SHOW SWITCH
000A65  1               ;NEXT PAIR
000A65  1  A5 4B        SORT3:	LDA	NXTADR		;CHANGE
000A67  1  85 49        	STA	CURADR		;POINTER
000A69  1  A5 4C        	LDA	NXTADR+1	;TO NEXT
000A6B  1  85 4A        	STA	CURADR+1	;SYMBOL
000A6D  1  20 E8 09     	JSR	ADRNS		;AND SET NEXT
000A70  1  E6 2E        	INC	SYMPTR+1	;BUMP
000A72  1  D0 02        	BNE	*+4		;COUNTER
000A74  1  E6 2D        	INC	SYMPTR		;BY 1
000A76  1  A5 2D        	LDA	SYMPTR		;IF MORE
000A78  1  C5 02        	CMP	N		;THEN GO
000A7A  1  90 C3        	BCC	SORT11		;SORT MORE
000A7C  1  A5 2E        	LDA	SYMPTR+1	;DO SAME
000A7E  1  C5 03        	CMP	N+1		;WITH LOW
000A80  1  90 BD        	BCC	SORT11		;PART OF COUNT
000A82  1  24 48        	BIT	SRTFLG		;TEST SWITCH
000A84  1  10 8E        	BPL	SORT0		;GO IF WAS A SWITCH
000A86  1  60           	RTS			;ELSE DONE
000A87  1               ;INCREMENT LINE BUFFER POINTER
000A87  1               ; IF X <= MAXCL THEN C=0 ELSE C=1
000A87  1  E8           INCRP:	INX
000A88  1  E4 28        	CPX	MAXCL
000A8A  1  D0 01        	BNE	*+3
000A8C  1  18           	CLC
000A8D  1  60           	RTS
000A8E  1               ;CHECK IF EXP IS A VALID INDIRECT ADDRESS
000A8E  1               ; IF EXP < 255 THEN C=1 ELSE C=0
000A8E  1  A5 25        INDADR:	LDA	EXP		;IF EXP>255 IS TOO BIG
000A90  1  F0 02        	BEQ	*+4
000A92  1  18           	CLC
000A93  1  60           	RTS
000A94  1  A5 26        	LDA	EXP+1		;IF EXP=255 IS TOO BIG
000A96  1  C9 FF        	CMP	#255
000A98  1  F0 F8        	BEQ	*-6
000A9A  1  38           	SEC
000A9B  1  60           	RTS
000A9C  1               ;CHECK IF A RELATIVE BRANCH IS OUT OF RANGE
000A9C  1               ; TEMP MUST = PC AND EXP MUST =	DEST ADDR
000A9C  1               ; IF VALID THEN C=1 ELSE C=0
000A9C  1  18           RELADR:	CLC			;COMPUTE RELATIVE OFFSET
000A9D  1  A5 3F        	LDA	TEMP
000A9F  1  69 02        	ADC	#2
000AA1  1  85 42        	STA	TEMB+1
000AA3  1  A5 40        	LDA	TEMP+1
000AA5  1  69 00        	ADC	#0
000AA7  1  85 41        	STA	TEMB
000AA9  1  38           	SEC
000AAA  1  A5 26        	LDA	EXP+1
000AAC  1  E5 42        	SBC	TEMB+1
000AAE  1  85 26        	STA	EXP+1
000AB0  1  A8           	TAY
000AB1  1  A5 25        	LDA	EXP
000AB3  1  E5 41        	SBC	TEMB
000AB5  1  85 25        	STA	EXP
000AB7  1  D0 05        	BNE	HRA20		;CHECK FOR POSITIVE OUT OF RANGE
000AB9  1  98           	TYA
000ABA  1  30 09        	BMI	HRA30
000ABC  1  38           HRA10:	SEC
000ABD  1  60           	RTS
000ABE  1  C9 FF        HRA20:	CMP	#255		;CHECK FOR NEGATIVE OUT OF RANGE
000AC0  1  D0 03        	BNE	HRA30
000AC2  1  98           	TYA
000AC3  1  30 F7        	BMI	HRA10
000AC5  1  18           HRA30:	CLC
000AC6  1  60           	RTS
000AC7  1               ;FIND NEXT NON-BLANK
000AC7  1               ; IF FOUND THEN C=1 ELSE C=0
000AC7  1  A5 28        FNDNB:	LDA	MAXCL		;IF MAX >127
000AC9  1  30 18        	BMI	J30		;IS NO GOOD
000ACB  1  A6 20        	LDX	COLP		;GET COL POINTER
000ACD  1  E4 28        J10:	CPX	MAXCL		;IF POINTER <= MAXCL
000ACF  1  F0 02        	BEQ	*+4		;BRANCH IF EQUAL
000AD1  1  B0 10        	BCS	J30		;BRANCH IF >
000AD3  1  BD CB 2D     	LDA	LINE,X		;GET CHAR
000AD6  1  C9 20        	CMP	#BLANK		;IF A BLANK
000AD8  1  F0 04        	BEQ	*+6		;THEN BRANCH
000ADA  1  86 21        	STX	CSB		;ELSE SAVE POINTER IN CSB
000ADC  1  38           	SEC
000ADD  1  60           	RTS
000ADE  1  E8           	INX			;BUMP POINTER
000ADF  1  86 20        	STX	COLP
000AE1  1  D0 EA        	BNE	J10		;LOOP ALWAYS
000AE3  1               ;DID NOT FIND A NON-BLANK
000AE3  1  18           J30:	CLC			;WAS ALL BLANKS
000AE4  1  60           	RTS
000AE5  1               ;FIND END OF CURRENT STRING
000AE5  1               ;  IF FOUND THEN C=1 ELSE C=0
000AE5  1  A0 00        FNDEN:	LDY	#0
000AE7  1  84 23        	STY	CSL
000AE9  1  A6 20        	LDX	COLP		;GET POINTER
000AEB  1  E4 28        I10:	CPX	MAXCL		;TEST AGAINST MAX
000AED  1  F0 02        	BEQ	*+4		;BRANCH IF OK
000AEF  1  B0 18        	BCS	I30		;BRANCH IF TOO BIG
000AF1  1  BD CB 2D     	LDA	LINE,X		;GET CHAR
000AF4  1  C9 20        	CMP	#BLANK		;IF A BLANK
000AF6  1  F0 08        	BEQ	I20		;THEN BRANCH
000AF8  1  C9 3D        	CMP	#'='		;IF AN =
000AFA  1  F0 04        	BEQ	I20		;THEN BRANCH
000AFC  1  C9 3B        	CMP	#SEMICO		;IF NOT A SEMI
000AFE  1  D0 0F        	BNE	I40		;THEN BRANCH
000B00  1  C0 00        I20:	CPY	#0		;IS Y=0
000B02  1  D0 16        	BNE	I60		;BRANCH IF NOT
000B04  1  CA           I25:	DEX
000B05  1  86 22        	STX	CSE		;UPDATE END OF STRING
000B07  1  38           	SEC
000B08  1  60           	RTS
000B09  1  C0 00        I30:	CPY	#0
000B0B  1  F0 F7        	BEQ	I25
000B0D  1  18           	CLC
000B0E  1  60           	RTS
000B0F  1  C9 27        I40:	CMP	#APOST		;IS IT AN APOSTROPHE
000B11  1  D0 07        	BNE	I60		;BRANCH IF NOT
000B13  1  C8           	INY			;ELSE BUMP TEMP
000B14  1  C0 02        	CPY	#2		;IF 2
000B16  1  D0 02        	BNE	I60		;CONTINUE ELSE
000B18  1  A0 00        	LDY	#0		;RESET TEMP
000B1A  1  E8           I60:	INX			;BUMP POINTER
000B1B  1  E6 23        	INC	CSL
000B1D  1  D0 CC        	BNE	I10		;LOOP ALWAYS
000B1F  1               ;FIND NON-EMBEDDED COMMA OR RIGHT PAREN
000B1F  1               ; IF FOUND THEN C=1 ELSE C=0
000B1F  1  A6 20        FNCMP:	LDX	COLP		;GET POINTER
000B21  1  E4 28        K40:	CPX	MAXCL		;COMPARE TO MAX
000B23  1  F0 02        	BEQ	*+4
000B25  1  B0 2E        	BCS	K10		;END OF LINE
000B27  1  BD CB 2D     	LDA	LINE,X		;GET CHAR
000B2A  1  C9 27        	CMP	#APOST		;IF NOT STRING START
000B2C  1  D0 13        	BNE	K20		;BRANCH
000B2E  1  20 87 0A     K30:	JSR	INCRP		;SKIP OVER STRING
000B31  1  86 20        	STX	COLP
000B33  1  B0 20        	BCS	K10
000B35  1  BD CB 2D     	LDA	LINE,X		;GET NEW CHAR
000B38  1  C9 27        	CMP	#APOST		;IF NOT APOSTROPHE
000B3A  1  D0 F2        	BNE	K30		;THEN BRANCH
000B3C  1  E8           	INX
000B3D  1  86 20        	STX	COLP		;BUMP POINTER
000B3F  1  D0 E0        	BNE	K40
000B41  1  BD CB 2D     K20:	LDA	LINE,X		;GET CHAR
000B44  1  C9 20        	CMP	#BLANK		;IF BLANK
000B46  1  F0 0D        	BEQ	K10		;DONE
000B48  1  C9 29        	CMP	#')'
000B4A  1  F0 0A        	BEQ	K15
000B4C  1  C9 2C        	CMP	#','
000B4E  1  F0 06        	BEQ	K15
000B50  1  E8           	INX
000B51  1  86 20        	STX	COLP		;BUMP POINTER
000B53  1  D0 CC        	BNE	K40
000B55  1  18           K10:	CLC			;ERROR
000B56  1  60           K15:	RTS
000B57  1               ;TEST A CHAR TO SEE IF ALPHANUMERIC
000B57  1               ; IF ALPHANUMERIC THEN C=1 ELSE C=0
000B57  1  20 5D 0B     ALNUM:	JSR	ALPH
000B5A  1  90 10        	BCC	NUMRC
000B5C  1  60           	RTS
000B5D  1               ;TEST A CHAR TO SEE IF ALPHA
000B5D  1               ; IF ALPHA THEN C=1 ELSE C=0
000B5D  1  BD CB 2D     ALPH:	LDA	LINE,X		;GET CHAR
000B60  1  C9 41        	CMP	#'A'		;IF LESS THAN A
000B62  1  90 05        	BCC	*+7		;NOT ALPHA
000B64  1  C9 5B        	CMP	#'Z'+1		;IF LESS THAN Z+1
000B66  1  90 02        	BCC	*+4		;IS ALPHA
000B68  1  18           	CLC			;NOT ALPHA
000B69  1  60           	RTS
000B6A  1  38           	SEC			;ALPHA
000B6B  1  60           	RTS
000B6C  1               ;TEST A CHAR TO SEE IF NUMBER
000B6C  1               ; IF NUMBER THEN C=1 ELSE C=0
000B6C  1  BD CB 2D     NUMRC:	LDA	LINE,X		;GET CHAR
000B6F  1  C9 30        	CMP	#'0'		;IF LESS THAN 0
000B71  1  90 05        	BCC	*+7		;NOT NUMBER
000B73  1  C9 3A        	CMP	#'9'+1		;IF LESS THAN 9+1
000B75  1  90 02        	BCC	*+4		;IS A NUMBER
000B77  1  18           	CLC			;NOT NUMBER
000B78  1  60           	RTS
000B79  1  38           	SEC			;NUMBER
000B7A  1  60           	RTS
000B7B  1               ;CONSTRUCT A SYMBOL
000B7B  1               ; IF NON-ALPHA CHAR THEN C=0 ELSE C=1
000B7B  1  A0 FF        CONSYM:	LDY	#$FF		;USE Y AS COUNTER
000B7D  1  C8           C10:	INY			;BUMP Y
000B7E  1  CC 03 08     	CPY	SYMLEN		;AND TEST
000B81  1  F0 0A        	BEQ	C15
000B83  1  C4 2F        	CPY	LEN		;IF ALL CHAR IN SYMBOL
000B85  1  B0 10        	BCS	C30		;GO FILL BLANKS
000B87  1  20 57 0B     	JSR	ALNUM
000B8A  1  B0 02        	BCS	C20
000B8C  1  18           	CLC			;NON-ALPHANUMERIC
000B8D  1  60           C15:	RTS
000B8E  1  BD CB 2D     C20:	LDA	LINE,X		;GET CHAR
000B91  1  99 6F 2E     	STA	SYM,Y
000B94  1  E8           	INX			;BUMP POINTER
000B95  1  B0 E6        	BCS	C10
000B97  1  A9 20        C30:	LDA	#BLANK		;FILL IN BLANKS
000B99  1  99 6F 2E     	STA	SYM,Y
000B9C  1  B0 DF        	BCS	C10
000B9E  1               ;EVALUATE EXPRESSION
000B9E  1               ; ON EXIT ERCOL POINTS TO BAD CHAR IF ANY
000B9E  1               ;         X POINTS TO NEXT CHAR IF GOOD EXPR
000B9E  1               ;         RETURN IS SET AS FOLLOWS
000B9E  1               ;          -1 IF OK AND EXP IS SET TO VALUE
000B9E  1               ;           0 IF UNDEFINED SYMBOL
000B9E  1               ;           1 IF UNINTERPRETABLE
000B9E  1  A9 00        EVAL:	LDA	#0		;INITIALIZE
000BA0  1  85 25        	STA	EXP
000BA2  1  85 26        	STA	EXP+1
000BA4  1  A9 01        	LDA	#1
000BA6  1  85 36        	STA	RETURN
000BA8  1  A9 FE        	LDA	#%11111110	;SET SIGN TO PLUS
000BAA  1  25 1F        	AND	FLAGS+1
000BAC  1  85 1F        	STA	FLAGS+1
000BAE  1  86 3D        	STX	ERCOL
000BB0  1  86 3C        	STX	J
000BB2  1  20 58 0E     	JSR	ENDTST		;IF MORE
000BB5  1  90 01        	BCC	*+3		;CONTINUE
000BB7  1  60           	RTS
000BB8  1               ;GET INITIAL OPERATION
000BB8  1  A0 2B        	LDY	#'+'		;SET TO PLUS
000BBA  1  C9 2D        	CMP	#'-'		;IF NOT MINUS
000BBC  1  D0 07        	BNE	D15		;OK
000BBE  1  A8           	TAY			;SET TO MINUS
000BBF  1  20 87 0A     D11A:	JSR	INCRP		;POINT TO NEXT CHAR
000BC2  1  90 01        	BCC	D15
000BC4  1  60           	RTS
000BC5  1  84 31        D15:	STY	OP		;SAVE OPER
000BC7  1  86 3D        	STX	ERCOL
000BC9  1  A9 00        	LDA	#0		;INITIALIZE
000BCB  1  85 32        	STA	LOW		;FLAGS
000BCD  1  85 33        	STA	HIGH
000BCF  1  20 58 0E     	JSR	ENDTST		;IF MORE
000BD2  1  90 01        	BCC	*+3		;CONTINUE
000BD4  1  60           	RTS
000BD5  1  C9 3C        	CMP	#'<'		;IF NOT <
000BD7  1  D0 04        	BNE	D150
000BD9  1  E6 32        	INC	LOW		;ELSE BUMP LOW
000BDB  1  D0 06        	BNE	D151
000BDD  1  C9 3E        D150:	CMP	#'>'		;IF NOT >
000BDF  1  D0 08        	BNE	D158
000BE1  1  E6 33        	INC	HIGH
000BE3  1  20 87 0A     D151:	JSR	INCRP
000BE6  1  90 01        	BCC	D158
000BE8  1  60           	RTS
000BE9  1  86 3D        D158:	STX	ERCOL
000BEB  1  20 6C 0B     	JSR	NUMRC		;IS CHAR A NUMBER
000BEE  1  90 05        	BCC	*+7		;NO - NOT BASE 10
000BF0  1  A0 0A        	LDY	#10		;IS BASE 10
000BF2  1  4C BB 0C     	JMP	D55		;GET CHAR AND EVAL
000BF5  1  C9 24        	CMP	#'$'		;IS CHAR A $
000BF7  1  D0 05        	BNE	*+7		;NO - NOT HEX
000BF9  1  A0 10        	LDY	#16		;ELSE IS HEX
000BFB  1  4C AD 0C     	JMP	D50		;GO EVALUATE
000BFE  1  C9 40        	CMP	#'@'		;IS CHAR A @
000C00  1  D0 05        	BNE	*+7		;NO - NOT OCTAL
000C02  1  A0 08        	LDY	#8		;ELSE IS OCTAL
000C04  1  4C AD 0C     	JMP	D50		;GO EVALUATE
000C07  1  C9 25        	CMP	#'%'		;IS CHAR A %
000C09  1  D0 05        	BNE	*+7		;NO - NOT BASE 2
000C0B  1  A0 02        	LDY	#2		;ELSE IS BINARY
000C0D  1  4C AD 0C     	JMP	D50		;GO EVALUATE
000C10  1  20 5D 0B     	JSR	ALPH		;IS IT ALPHA
000C13  1  90 47        	BCC	D46		;NO CHECK FOR PC
000C15  1               ;PROCESS A SYMBOL
000C15  1  20 07 0E     	JSR	FNDLN		;FIND LENGTH
000C18  1  38           	SEC			;DROP BY ONE
000C19  1  E9 01        	SBC	#1
000C1B  1  CD 03 08     	CMP	SYMLEN		;IF NOT TOO BIG
000C1E  1  90 01        	BCC	D43		;CONTINUE
000C20  1  60           	RTS
000C21  1  20 7B 0B     D43:	JSR	CONSYM		;CONSTRUCT SYMBOL
000C24  1  20 0E 0F     	JSR	FIND
000C27  1  90 03        	BCC	*+5
000C29  1  4C C6 0C     	JMP	D60
000C2C  1  70 03        	BVS	*+5		;BRANCH IF NOT DEFINED
000C2E  1  20 75 0F     	JSR	SETCHN		;CREATE IT
000C31  1  A5 2B        	LDA	BYWOR		;IF .BYT OR .WOR
000C33  1  D0 1F        	BNE	D44E		;BRANCH
000C35  1  A5 2A        	LDA	ORG		;IF EQU OR ORG
000C37  1  D0 1B        	BNE	D44E		;BRANCH
000C39  1  A5 26        	LDA	EXP+1		;ERROR IF EXPR
000C3B  1  D0 1E        	BNE	D452
000C3D  1  A5 25        	LDA	EXP
000C3F  1  D0 1A        	BNE	D452
000C41  1  A5 31        	LDA	OP		;ERROR IF NOT +
000C43  1  C9 2B        	CMP	#'+'
000C45  1  D0 10        	BNE	D44F
000C47  1  86 3D        	STX	ERCOL
000C49  1  CA           	DEX			;ERROR IF EXPR AFTER SYMBOL
000C4A  1  20 87 0A     	JSR	INCRP
000C4D  1  B0 05        	BCS	D44E
000C4F  1  20 58 0E     	JSR	ENDTST
000C52  1  90 07        	BCC	D452
000C54  1  4C 02 0E     D44E:	JMP	D200
000C57  1  A6 3C        D44F:	LDX	J
000C59  1  86 3D        	STX	ERCOL
000C5B  1  60           D452:	RTS
000C5C  1               ;EVALUATE FIELD WITH PC (*)
000C5C  1  C9 2A        D46:	CMP	#'*'		;IF NOT ASTERIX
000C5E  1  D0 0B        	BNE	D47		;CONTINUE
000C60  1  A5 1C        	LDA	PC		;SAVE PC
000C62  1  85 35        	STA	VAL+1		;IN
000C64  1  A5 1D        	LDA	PC+1		;VALUE
000C66  1  85 34        	STA	VAL
000C68  1  E8           	INX			;NEXT CHAR
000C69  1  D0 5B        	BNE	D60		;DO OP
000C6B  1               ;GET A SINGLE CHAR
000C6B  1  C9 27        D47:	CMP	#APOST		;IF '
000C6D  1  F0 01        	BEQ	*+3		;MAYBE OK
000C6F  1  60           	RTS
000C70  1  20 87 0A     	JSR	INCRP		;NEXT POS
000C73  1  90 01        	BCC	*+3		;NOT END
000C75  1  60           	RTS
000C76  1  BD CB 2D     	LDA	LINE,X		;GET CHAR
000C79  1  C9 27        	CMP	#APOST		;SEE IF ANOTHER APOST
000C7B  1  D0 0C        	BNE	D47A		;BRANCH IF NOT
000C7D  1  20 87 0A     	JSR	INCRP		;BUMP X
000C80  1  B0 25        	BCS	STROPR		;ERROR IF END
000C82  1  BD CB 2D     	LDA	LINE,X		;NOW GET NEXT
000C85  1  C9 27        	CMP	#APOST		;SEE IF APOST AGAIN
000C87  1  D0 1E        	BNE	STROPR		;BRANCH IF IS
000C89  1  85 35        D47A:	STA	VAL+1		;STORE
000C8B  1  A9 00        	LDA	#0		;CLEAR
000C8D  1  85 34        	STA	VAL		;HIGH
000C8F  1  20 87 0A     	JSR	INCRP		;NEXT
000C92  1  B0 32        	BCS	D60
000C94  1  BD CB 2D     	LDA	LINE,X		;GET CHAR
000C97  1  C9 27        	CMP	#APOST		;IF '
000C99  1  D0 0C        	BNE	STROPR
000C9B  1  20 87 0A     	JSR	INCRP
000C9E  1  B0 26        	BCS	D60
000CA0  1  BD CB 2D     	LDA	LINE,X
000CA3  1  C9 27        	CMP	#APOST
000CA5  1  D0 1F        	BNE	D60
000CA7  1  A6 3D        STROPR:	LDX	ERCOL
000CA9  1  60           	RTS
000CAA  1  E8           	INX			;NEXT POS
000CAB  1  D0 19        	BNE	D60		;DO OPER
000CAD  1               ;EVALUATE NUMERIC FIELD
000CAD  1  20 87 0A     D50:	JSR	INCRP		;NEXT CHAR
000CB0  1  90 01        	BCC	*+3		;CONTINUE IF OK
000CB2  1  60           	RTS
000CB3  1  86 3D        	STX	ERCOL
000CB5  1  20 57 0B     	JSR	ALNUM
000CB8  1  B0 01        	BCS	D55		;IF NUMBER CONTINUE
000CBA  1  60           	RTS
000CBB  1  84 30        D55:	STY	BASE		;SAVE BASE
000CBD  1               ;GET LENGTH
000CBD  1  20 07 0E     	JSR	FNDLN		;POINT TO NEXT
000CC0  1               ;COMPUTE VALUE
000CC0  1  20 6D 0E     	JSR	NUMBER		;COMPUTE
000CC3  1  B0 01        	BCS	D60		;CONTINUE IF OK
000CC5  1  60           	RTS
000CC6  1               ;DO OPER
000CC6  1  A5 32        D60:	LDA	LOW		;LOW ONLY?
000CC8  1  F0 06        	BEQ	D68		;NO SO JUNP
000CCA  1  A9 00        	LDA	#0		;IS OW ONLY SO CLEAR HIGH
000CCC  1  85 34        	STA	VAL
000CCE  1  F0 0C        	BEQ	D69
000CD0  1  A5 33        D68:	LDA	HIGH		;HIGH ONLY?
000CD2  1  F0 08        	BEQ	D69		;NO
000CD4  1  A5 34        	LDA	VAL		;IS SO PUT HIGH
000CD6  1  85 35        	STA	VAL+1		;IN LOW
000CD8  1  A9 00        	LDA	#0		;CLEAR HIGH
000CDA  1  85 34        	STA	VAL
000CDC  1  A5 31        D69:	LDA	OP		;GET OPER
000CDE  1  C9 2B        	CMP	#'+'		;IF NOT ADD
000CE0  1  D0 3A        	BNE	D65		;BRANCH
000CE2  1               ;ADD OPERATION
000CE2  1  A5 26        	LDA	EXP+1		;GET LOW
000CE4  1  18           	CLC			;ADD
000CE5  1  65 35        	ADC	VAL+1		;LOW OF NUMBER
000CE7  1  85 26        	STA	EXP+1		;SAVE
000CE9  1  A5 25        	LDA	EXP		;THEN DO
000CEB  1  65 34        	ADC	VAL		;SAME FOR
000CED  1  85 25        	STA	EXP		;HIGH
000CEF  1  A9 00        	LDA	#0		;PUT CARRY
000CF1  1  2A           	ROL	A		;IN A
000CF2  1  A8           	TAY			;THEN Y
000CF3  1  20 1A 0E     	JSR	CMPSGN		;COMPARE SIGNS
000CF6  1  D0 0F        	BNE	D62		;BRANCH IF DIFFERENT
000CF8  1  98           	TYA			;IF CARRY
000CF9  1  D0 03        	BNE	D61		;THEN OVERFLOW
000CFB  1  4C EA 0D     	JMP	D70		;ELSE CONTINUE
000CFE  1  A9 08        D61:	LDA	#8		;GET OVERFLOW MASK
000D00  1  05 1F        	ORA	FLAGS+1		;SET FLAG
000D02  1  85 1F        	STA	FLAGS+1		;SAVE
000D04  1  4C EA 0D     	JMP	D70		;CONTINUE
000D07  1  98           D62:	TYA			;CHECK CARRY
000D08  1  F0 09        	BEQ	D63		;IF NONE IS NEG
000D0A  1  A9 FE        	LDA	#254		;GET POS MASK
000D0C  1  25 1F        	AND	FLAGS+1		;SET
000D0E  1  85 1F        	STA	FLAGS+1		;SAVE
000D10  1  4C EA 0D     	JMP	D70
000D13  1  A9 01        D63:	LDA	#1		;NEGATIVE MASK
000D15  1  05 1F        	ORA	FLAGS+1		;SET SIGN
000D17  1  85 1F        	STA	FLAGS+1		;SAVE
000D19  1  4C EA 0D     	JMP	D70		;CONTINUE
000D1C  1  C9 2D        D65:	CMP	#'-'		;IF NOT -
000D1E  1  D0 41        	BNE	TRYMUL		;TRY MULT
000D20  1               ;SUBTRACT OPERATION SECTION
000D20  1  A5 26        	LDA	EXP+1		;GET LOW
000D22  1  38           	SEC			;SUBTRACT
000D23  1  E5 35        	SBC	VAL+1		;NUMBER
000D25  1  85 26        	STA	EXP+1		;SAVE
000D27  1  A5 25        	LDA	EXP		;DO
000D29  1  E5 34        	SBC	VAL		;SAME
000D2B  1  85 25        	STA	EXP		;FOR HIGH
000D2D  1  A9 00        	LDA	#0		;SAVE
000D2F  1  2A           	ROL	A		;CARRY
000D30  1  A8           	TAY
000D31  1  20 1A 0E     	JSR	CMPSGN		;COMPARE SIGNS
000D34  1  D0 15        	BNE	D67		;BRANCH IF DIFFERENT
000D36  1  98           	TYA			;GET CARRY
000D37  1  F0 09        	BEQ	D66		;IF NONE BRANCH
000D39  1  A9 FE        	LDA	#254		;SET POS
000D3B  1  25 1F        	AND	FLAGS+1		;MASK
000D3D  1  85 1F        	STA	FLAGS+1		;FOR EXPR
000D3F  1  4C EA 0D     	JMP	D70		;CONTINUE
000D42  1  A9 01        D66:	LDA	#1		;SET NEG
000D44  1  05 1F        	ORA	FLAGS+1		;MASK
000D46  1  85 1F        	STA	FLAGS+1		;FOR EXPR
000D48  1  4C EA 0D     	JMP	D70		;CONTINUE
000D4B  1  84 3F        D67:	STY	TEMP		;SAVE CARRY
000D4D  1  A9 01        	LDA	#1		;GET EXP
000D4F  1  25 1F        	AND	FLAGS+1		;SIGN
000D51  1  45 3F        	EOR	TEMP		;COMPARE TO CARRY
000D53  1  D0 03        	BNE	*+5		;BRANCH IF NOT EQUAL
000D55  1  4C EA 0D     	JMP	D70		;ELSE CONTINUE
000D58  1  A9 08        	LDA	#8		;LOAD
000D5A  1  05 1F        	ORA	FLAGS+1		;OVERFLOW MASK
000D5C  1  85 1F        	STA	FLAGS+1		;FOR EXP
000D5E  1  4C EA 0D     	JMP	D70
000D61  1  C9 2A        TRYMUL:	CMP	#'*'		;IF NOT MULT
000D63  1  D0 4E        	BNE	TRYDIV		;TRY DIVISION
000D65  1               ;MULTIPLICATION OPERATION
000D65  1  A9 00        	LDA	#0		;CLEAR
000D67  1  85 71        	STA	ACC+1		;ACCUM
000D69  1  85 70        	STA	ACC
000D6B  1  20 28 0E     	JSR	SMEXP		;MAKE EXP SIGN/MAGN
000D6E  1  20 40 0E     	JSR	SMVAL		;SAME FOR VAL
000D71  1  8A           	TXA			;SAVE
000D72  1  48           	PHA			;CURRENT INDEX
000D73  1  A2 10        	LDX	#16		;DO 16 BITS
000D75  1  46 34        MULLPE:	LSR	VAL		;SHIFT MULT
000D77  1  66 35        	ROR	VAL+1		;RIGHT
000D79  1  90 0D        	BCC	NOADD		;IF ZERO NO ADD
000D7B  1  18           	CLC			;ELSE
000D7C  1  A5 71        	LDA	ACC+1		;GET ACCUM
000D7E  1  65 26        	ADC	EXP+1		;ADD EXP
000D80  1  85 71        	STA	ACC+1		;SAVE
000D82  1  A5 70        	LDA	ACC		;SAME
000D84  1  65 25        	ADC	EXP		;FOR
000D86  1  85 70        	STA	ACC		;HIGH
000D88  1  06 26        NOADD:	ASL	EXP+1		;MULT EXP
000D8A  1  26 25        	ROL	EXP		;BY TWO
000D8C  1  CA           	DEX			;COUNT DOWN
000D8D  1  D0 E6        	BNE	MULLPE		;LOOP IF MORE
000D8F  1  68           	PLA			;RESTORE
000D90  1  AA           	TAX			;X
000D91  1  A5 71        ENDMUL:	LDA	ACC+1		;SET
000D93  1  85 26        	STA	EXP+1		;EXP
000D95  1  A5 70        	LDA	ACC		;TO ACCUM
000D97  1  85 25        	STA	EXP		;VALUE
000D99  1  20 1A 0E     	JSR	CMPSGN		;COMPARE SIGNS
000D9C  1  D0 09        	BNE	EXPNEG		;NEGATIVE
000D9E  1  A9 FE        	LDA	#254		;ELSE
000DA0  1  25 1F        	AND	FLAGS+1		;POSITIVE
000DA2  1  85 1F        	STA	FLAGS+1		;RESULT
000DA4  1  4C EA 0D     	JMP	D70
000DA7  1  A9 01        EXPNEG:	LDA	#1		;SET SIGN
000DA9  1  05 1F        	ORA	FLAGS+1		;TO NEG
000DAB  1  85 1F        	STA	FLAGS+1		;IN FLAGS
000DAD  1  20 2E 0E     	JSR	TCPEXP		;MAKE TWOS COMPL
000DB0  1  4C EA 0D     	JMP	D70		;CONTINUE
000DB3  1  C9 2F        TRYDIV:	CMP	#'/'		;IF NOT DIV
000DB5  1  F0 05        	BEQ	DODIV		;ERROR ELSE OK
000DB7  1  A6 3C        	LDX	J
000DB9  1  86 3D        	STX	ERCOL
000DBB  1  60           	RTS
000DBC  1               ;DIVISION OPERATION
000DBC  1  A9 00        DODIV:	LDA	#0		;CLEAR
000DBE  1  85 71        	STA	ACC+1		;ACCUM
000DC0  1  85 70        	STA	ACC
000DC2  1  20 28 0E     	JSR	SMEXP		;CONVERT
000DC5  1  20 40 0E     	JSR	SMVAL		;TO SIGN/MAGN
000DC8  1  A5 35        	LDA	VAL+1		;IF DIVISOR
000DCA  1  05 34        	ORA	VAL		;NOT ZERO
000DCC  1  D0 05        	BNE	DIVLPE		;THEN OK
000DCE  1  A6 3C        	LDX	J
000DD0  1  86 3D        	STX	ERCOL
000DD2  1  60           	RTS
000DD3  1  38           DIVLPE:	SEC			;SUBTRACT
000DD4  1  A5 26        	LDA	EXP+1		;VAL
000DD6  1  E5 35        	SBC	VAL+1		;FROM EXP
000DD8  1  85 26        	STA	EXP+1		;UNTIL
000DDA  1  A5 25        	LDA	EXP		;A
000DDC  1  E5 34        	SBC	VAL		;BORROW
000DDE  1  85 25        	STA	EXP
000DE0  1  90 AF        	BCC	ENDMUL		;THEN DONE
000DE2  1  E6 71        	INC	ACC+1		;BUMP LOW
000DE4  1  D0 ED        	BNE	DIVLPE		;LOOP IF NO CARRY
000DE6  1  E6 70        	INC	ACC		;ELSE BUMP HIGH
000DE8  1  D0 E9        	BNE	DIVLPE		;LOOP ALWAYS
000DEA  1               ;END OPER
000DEA  1  E4 28        D70:	CPX	MAXCL		;SEE IF END
000DEC  1  F0 02        	BEQ	D71		;NO
000DEE  1  10 0D        	BPL	D100		;YES DONE
000DF0  1  20 58 0E     D71:	JSR	ENDTST		;AT END OF EXPR
000DF3  1  B0 08        	BCS	D100		;YES BUT BAD
000DF5  1  BC CB 2D     	LDY	LINE,X		;GET OP
000DF8  1  86 3C        	STX	J
000DFA  1  4C BF 0B     	JMP	D11A		;START OVER
000DFD  1               ;EXITS
000DFD  1  A9 FF        D100:	LDA	#255		;GOOD
000DFF  1  85 36        	STA	RETURN		;RETURN
000E01  1  60           	RTS
000E02  1  A9 00        D200:	LDA	#0		;UNDEFINED
000E04  1  85 36        	STA	RETURN		;SYMBOL
000E06  1  60           	RTS
000E07  1               ;FINDS LENGTH OF FIELD
000E07  1               ; LOOPS UNTIL NON-ALPHANUMERIC FOUND
000E07  1               ; ERCOL MUST = X
000E07  1               ; RESULT IN LEN
000E07  1  20 87 0A     FNDLN:	JSR	INCRP		;BUMP POINTER
000E0A  1  B0 05        	BCS	HLN220
000E0C  1  20 57 0B     	JSR	ALNUM
000E0F  1  B0 F6        	BCS	FNDLN
000E11  1  8A           HLN220:	TXA			;GET ENDING
000E12  1  38           	SEC			;SUBTRACT
000E13  1  E5 3D        	SBC	ERCOL		;START
000E15  1  85 2F        	STA	LEN		;SAVE ANSWER
000E17  1  A6 3D        	LDX	ERCOL
000E19  1  60           	RTS
000E1A  1               ;COMPARE SIGNS OF EXP AND VAL
000E1A  1  A9 01        CMPSGN:	LDA	#1		;GET SIGN
000E1C  1  25 1F        	AND	FLAGS+1		;OF EXP
000E1E  1  0A           	ASL	A		;MOVE TO VAL POS
000E1F  1  85 3F        	STA	TEMP		;SAVE
000E21  1  A9 02        	LDA	#2		;GET SIGN
000E23  1  25 1F        	AND	FLAGS+1		;OF VAL
000E25  1  45 3F        	EOR	TEMP		;SEE IF DIFFERENT
000E27  1  60           	RTS
000E28  1               ;CONVERT EXP TO SIGN/MAGN
000E28  1  A9 01        SMEXP:	LDA	#1		;GET
000E2A  1  25 1F        	AND	FLAGS+1		;SIGN
000E2C  1  F0 11        	BEQ	SM1		;DONE IF
000E2E  1               ;CONVERT EXPR
000E2E  1  18           TCPEXP:	CLC			;ELSE DO
000E2F  1  A5 26        	LDA	EXP+1		;A
000E31  1  49 FF        	EOR	#$FF		;TWO'S
000E33  1  69 01        	ADC	#1		;COMPLEMENT
000E35  1  85 26        	STA	EXP+1
000E37  1  A5 25        	LDA	EXP
000E39  1  49 FF        	EOR	#$FF
000E3B  1  69 00        	ADC	#0
000E3D  1  85 25        	STA	EXP
000E3F  1  60           SM1:	RTS
000E40  1               ;CONVERT VAL TO SIGN/MAGN
000E40  1  A9 02        SMVAL:	LDA	#2		;GET
000E42  1  25 1F        	AND	FLAGS+1		;SIGN
000E44  1  F0 F9        	BEQ	SM1		;DONE IF +
000E46  1  18           	CLC			;ELSE DO
000E47  1  A5 35        	LDA	VAL+1		;A
000E49  1  49 FF        	EOR	#$FF		;TWO'S
000E4B  1  69 01        	ADC	#1		;COMPLEMENT
000E4D  1  85 35        	STA	VAL+1
000E4F  1  A5 34        	LDA	VAL
000E51  1  49 FF        	EOR	#$FF
000E53  1  69 00        	ADC	#0
000E55  1  85 34        	STA	VAL
000E57  1  60           	RTS
000E58  1               ;TEST FOR END OF STRING
000E58  1               ; IF FOUND THEN C=1 ELSE C=0
000E58  1  BD CB 2D     ENDTST:	LDA	LINE,X		;GET CHAR
000E5B  1  C9 20        	CMP	#BLANK		;IF BLANK
000E5D  1  F0 0D        	BEQ	DD10		;SET CARRY
000E5F  1  C9 2C        	CMP	#','		;IF COMMA
000E61  1  F0 09        	BEQ	DD10		;SET CARRY
000E63  1  C9 29        	CMP	#')'		;IF RIGHT PAREN
000E65  1  F0 05        	BEQ	DD10		;SET CARRY
000E67  1  C9 3B        	CMP	#SEMICO		;IF SEMI
000E69  1  F0 01        	BEQ	DD10		;SET CARRY
000E6B  1  18           	CLC			;ELSE CLEAR
000E6C  1  60           DD10:	RTS
000E6D  1               ;CONVERT INPUT STRING TO NUMBER
000E6D  1               ; IF OK THEN C=1 ELSE C=0
000E6D  1  A9 00        NUMBER:	LDA	#0		;CLEAR
000E6F  1  85 34        	STA	VAL		;VALUE
000E71  1  85 35        	STA	VAL+1
000E73  1  BD CB 2D     E10:	LDA	LINE,X		;GET CHAR
000E76  1  20 6C 0B     	JSR	NUMRC		;IF NOT NUMBER
000E79  1  90 04        	BCC	E20		;THEN BRANCH
000E7B  1  29 0F        	AND	#$F		;REMOVE ZONE
000E7D  1  10 08        	BPL	E30		;JUMP
000E7F  1  20 5D 0B     E20:	JSR	ALPH		;IF NOT ALPHA
000E82  1  90 07        	BCC	E40		;IS ERROR
000E84  1  38           	SEC
000E85  1  E9 37        	SBC	#$37		;REMOVE ZONE
000E87  1  C5 30        E30:	CMP	BASE		;IS BASE VALID
000E89  1  90 02        	BCC	E50		;YES
000E8B  1  18           E40:	CLC			;ELSE BAD BASE
000E8C  1  60           	RTS
000E8D  1  85 15        E50:	STA	COLCNT
000E8F  1  8A           	TXA
000E90  1  48           	PHA
000E91  1  A4 30        	LDY	BASE		;GET BASE
000E93  1  C0 02        	CPY	#2		;IS IT 2
000E95  1  D0 04        	BNE	E60		;NO
000E97  1  A2 01        	LDX	#1		;SHIFT ONE
000E99  1  D0 1E        	BNE	E90
000E9B  1  C0 08        E60:	CPY	#8		;IS IT 8
000E9D  1  D0 04        	BNE	E70		;NO
000E9F  1  A2 03        	LDX	#3		;SHIFT THREE
000EA1  1  D0 16        	BNE	E90
000EA3  1  C0 10        E70:	CPY	#16		;IS IT 16
000EA5  1  D0 04        	BNE	E80		;NO
000EA7  1  A2 04        	LDX	#4		;SHIFT FOUR
000EA9  1  D0 0E        	BNE	E90
000EAB  1  C0 0A        E80:	CPY	#10		;IF NOT 10
000EAD  1  D0 DC        	BNE	E40		;IS INVALID
000EAF  1  A5 34        	LDA	VAL		;SAVE
000EB1  1  85 3F        	STA	TEMP		;VAL
000EB3  1  A5 35        	LDA	VAL+1
000EB5  1  85 40        	STA	TEMP+1
000EB7  1  A2 03        	LDX	#3		;10 MEANS 3 SHIFTS + 1 SHIFT
000EB9  1  06 35        E90:	ASL	VAL+1		;SHIFT
000EBB  1  26 34        	ROL	VAL		;LEFT
000EBD  1  90 06        	BCC	E100		;BRANCH IF NO CARRY
000EBF  1  A5 1F        	LDA	FLAGS+1		;ELSE OVERFLOW
000EC1  1  09 08        	ORA	#8
000EC3  1  85 1F        	STA	FLAGS+1
000EC5  1  CA           E100:	DEX			;COUNT DOWN
000EC6  1  D0 F1        	BNE	E90		;LOOP IF MORE
000EC8  1  C0 0A        	CPY	#10		;IF NOT BASE 10
000ECA  1  D0 21        	BNE	E120		;DONE
000ECC  1  06 40        	ASL	TEMP+1		;MUST DO ANOTHER
000ECE  1  26 3F        	ROL	TEMP
000ED0  1  90 06        	BCC	E115		;IF CLEAR OK
000ED2  1  A5 1F        	LDA	FLAGS+1		;ELSE SET
000ED4  1  09 08        	ORA	#8		;OVERFLOW
000ED6  1  85 1F        	STA	FLAGS+1
000ED8  1  A5 35        E115:	LDA	VAL+1		;ADD PARTS
000EDA  1  18           	CLC
000EDB  1  65 40        	ADC	TEMP+1
000EDD  1  85 35        	STA	VAL+1
000EDF  1  A5 34        	LDA	VAL
000EE1  1  65 3F        	ADC	TEMP
000EE3  1  85 34        	STA	VAL
000EE5  1  90 06        	BCC	E120		;NO OVERFLOW
000EE7  1  A5 1F        	LDA	FLAGS+1
000EE9  1  09 08        	ORA	#8		;SET OVERFLOW
000EEB  1  85 1F        	STA	FLAGS+1
000EED  1  A5 15        E120:	LDA	COLCNT		;GET FIRST
000EEF  1  18           	CLC			;ADD
000EF0  1  65 35        	ADC	VAL+1		;TO VAL
000EF2  1  85 35        	STA	VAL+1
000EF4  1  A5 34        	LDA	VAL
000EF6  1  69 00        	ADC	#0
000EF8  1  85 34        	STA	VAL
000EFA  1  90 06        	BCC	E130
000EFC  1  A5 1F        	LDA	FLAGS+1		;SET
000EFE  1  09 08        	ORA	#8		;OVERFLOW
000F00  1  85 1F        	STA	FLAGS+1
000F02  1  68           E130:	PLA
000F03  1  AA           	TAX
000F04  1  E8           	INX			;BUMP POINTER
000F05  1  C6 2F        	DEC	LEN		;DROP COUNT
000F07  1  F0 03        	BEQ	E140
000F09  1  4C 73 0E     	JMP	E10		;LOOP FOR MORE
000F0C  1  38           E140:	SEC
000F0D  1  60           	RTS
000F0E  1               ;SEARCH SYMBOL TABLE
000F0E  1               ; IF FOUND AND DEFINED THEN C=1 AND V=0
000F0E  1               ; IF FOUND AND NOT DEFINED THEN C=0 AND V=1
000F0E  1               ; IF NOT FOUND THEN C=0 AND V=0
000F0E  1               ; SYMTBL CONTAINS NEXT AVAILABLE ADDRESS
000F0E  1  A5 0B        FIND:	LDA	STSAVE		;GET START
000F10  1  85 0F        	STA	SYMTBL		;SET POINTER
000F12  1  A5 0C        	LDA	STSAVE+1
000F14  1  85 10        	STA	SYMTBL+1
000F16  1  A9 01        	LDA	#1
000F18  1  85 2E        	STA	SYMPTR+1
000F1A  1  A9 00        	LDA	#0
000F1C  1  85 2D        	STA	SYMPTR
000F1E  1  B8           G10:	CLV
000F1F  1  A5 2D        	LDA	SYMPTR
000F21  1  C5 18        	CMP	NOSYM
000F23  1  90 0A        	BCC	G20
000F25  1  D0 2C        	BNE	G50
000F27  1  A5 2E        	LDA	SYMPTR+1
000F29  1  C5 19        	CMP	NOSYM+1
000F2B  1  F0 02        	BEQ	G20
000F2D  1  B0 24        	BCS	G50
000F2F  1  AC 03 08     G20:	LDY	SYMLEN		;GET LENGTH
000F32  1  88           	DEY			;DROP BY ONE
000F33  1  B1 0F        G30:	LDA	(SYMTBL),Y
000F35  1  10 05        	BPL	G32
000F37  1  29 7F        	AND	#$7F
000F39  1  2C CB 1F     	BIT	KLUDG		;SET V
000F3C  1  D9 6F 2E     G32:	CMP	SYM,Y
000F3F  1  D0 14        	BNE	G70
000F41  1  88           	DEY
000F42  1  10 EF        	BPL	G30
000F44  1  AC 03 08     	LDY	SYMLEN
000F47  1  B1 0F        	LDA	(SYMTBL),Y
000F49  1  85 34        	STA	VAL
000F4B  1  C8           	INY
000F4C  1  B1 0F        	LDA	(SYMTBL),Y
000F4E  1  85 35        	STA	VAL+1
000F50  1  70 01        	BVS	G50
000F52  1  60           	RTS
000F53  1  18           G50:	CLC			;NO MATCH
000F54  1  60           	RTS
000F55  1               ;TRY NEXT SYMBOL
000F55  1  A5 0F        G70:	LDA	SYMTBL		;GET LOW ADDR
000F57  1  18           	CLC			;ADD LENGTH
000F58  1  6D 03 08     	ADC	SYMLEN
000F5B  1  85 0F        	STA	SYMTBL
000F5D  1  90 02        	BCC	G751
000F5F  1  E6 10        	INC	SYMTBL+1
000F61  1  18           G751:	CLC			;ADD TWO
000F62  1  A5 0F        	LDA	SYMTBL
000F64  1  69 02        	ADC	#2
000F66  1  85 0F        	STA	SYMTBL
000F68  1  90 02        	BCC	G75		;SKIP IF NO CARRY
000F6A  1  E6 10        	INC	SYMTBL+1
000F6C  1  E6 2E        G75:	INC	SYMPTR+1
000F6E  1  D0 AE        	BNE	G10
000F70  1  E6 2D        	INC	SYMPTR
000F72  1  4C 1E 0F     	JMP	G10
000F75  1               ;CREATE UNDEFINED SYMBOL
000F75  1  A9 FF        SETCHN:	LDA	#$FF		;SET
000F77  1  85 34        	STA	VAL		;NULL
000F79  1  85 35        	STA	VAL+1		;VALUE
000F7B  1  AD 6F 2E     	LDA	SYM		;SET
000F7E  1  09 80        	ORA	#$80		;UNDEFINED
000F80  1  8D 6F 2E     	STA	SYM		;FLAG
000F83  1               ;INSERT A NEW SYMBOL INTO TABLE
000F83  1               ;IF V=1 JUST UPDATE ENTRY WITH NEW VALUES
000F83  1               ;IF V=0 THEN CREATE NEW ENTRY BY BUMPING NOSYM
000F83  1  A5 10        INSERT:	LDA	SYMTBL+1
000F85  1  C5 0E        	CMP	TBLSZ+1
000F87  1  90 08        	BCC	G105
000F89  1  D0 27        	BNE	G110
000F8B  1  A5 0F        	LDA	SYMTBL
000F8D  1  C5 0D        	CMP	TBLSZ
000F8F  1  B0 21        	BCS	G110
000F91  1  AC 03 08     G105:	LDY	SYMLEN		;PUT SYMBOL AND VALUE IN TABLE
000F94  1  88           	DEY			;DROP BY ONE
000F95  1  B9 6F 2E     G100:	LDA	SYM,Y		;GET CHAR
000F98  1  91 0F        	STA	(SYMTBL),Y	;INSERT
000F9A  1  88           	DEY			;NEXT CHAR
000F9B  1  10 F8        	BPL	G100		;LOOP IF MORE
000F9D  1  AC 03 08     	LDY	SYMLEN
000FA0  1  A5 34        	LDA	VAL
000FA2  1  91 0F        	STA	(SYMTBL),Y
000FA4  1  A5 35        	LDA	VAL+1
000FA6  1  C8           	INY
000FA7  1  91 0F        	STA	(SYMTBL),Y
000FA9  1  70 06        	BVS	G104		;ONLY DEFINING UNDEFINED
000FAB  1  E6 19        	INC	NOSYM+1
000FAD  1  D0 02        	BNE	G104
000FAF  1  E6 18        	INC	NOSYM
000FB1  1  60           G104:	RTS
000FB2  1  38           G110:	SEC
000FB3  1  60           	RTS
000FB4  1               ;FILL LINE UNTIL LF OR EOF
000FB4  1               ; EXPAND TAB (CTL-I) DURING FILL
000FB4  1               ; CONVERT ALL NON-EMBEDDED ALPHA TO UPPERCASE
000FB4  1  A9 00        LINEIN:	LDA	#0		;CLEAR
000FB6  1  85 28        	STA	MAXCL		;INDEX
000FB8  1  85 7B        	STA	MAXECH		;AND ECHO INDEX
000FBA  1  85 7C        	STA	STRING		;AND CONVERT FLAG
000FBC  1  20 27 10     GNC:	JSR	GNX		;GET NEXT BYTE
000FBF  1  A6 7B        	LDX	MAXECH		;GET ECHO INDEX
000FC1  1  9D 1D 2E     	STA	ECHBUF,X	;SAVE IN ECHO BUFFER
000FC4  1  C9 27        	CMP	#APOST		;SEE IF APOST
000FC6  1  F0 04        	BEQ	INSTR		;IS SO START STRING
000FC8  1  C9 22        	CMP	#QUOTE		;NOW CHECK FOR DOUBLE QUOTE
000FCA  1  D0 08        	BNE	NTS		;ISN'T SO NOT STRING START OR END
000FCC  1  48           INSTR:	PHA			;SAVE CHAR
000FCD  1  A5 7C        	LDA	STRING		;ELSE GET FLAG
000FCF  1  49 FF        	EOR	#$FF		;COMPLEMENT
000FD1  1  85 7C        	STA	STRING		;AND SAVE
000FD3  1  68           	PLA			;GET CHAR BACK
000FD4  1  24 7C        NTS:	BIT	STRING		;TEST FLAG
000FD6  1  30 0A        	BMI	NLCC		;BRANCH IF SET
000FD8  1               ;NOT IN STRING SO COVERT LOWERCASE TO UPPERCASE
000FD8  1  C9 41        	CMP	#'A'		;IF < A
000FDA  1  90 06        	BCC	NLCC		;DO NOTHING
000FDC  1  C9 5B        	CMP	#'Z'+1		;IF OVER Z
000FDE  1  B0 02        	BCS	NLCC		;DO NOTHING
000FE0  1  29 5F        	AND	#$5F		;ELSE MAKE UPPER
000FE2  1  A6 28        NLCC:	LDX	MAXCL		;GET INDEX
000FE4  1  9D CB 2D     	STA	LINE,X		;SAVE CHAR
000FE7  1  C9 09        	CMP	#TAB		;IF NOT TAB
000FE9  1  D0 16        	BNE	NTT		;BRANCH
000FEB  1  E6 7B        	INC	MAXECH		;BUMP ECHO POINTER
000FED  1               ;EXPAND TAB
000FED  1  A9 20        CTB:	LDA	#BLANK		;GET BLANK
000FEF  1  9D CB 2D     	STA	LINE,X		;STORE
000FF2  1  E6 28        	INC	MAXCL		;BUMP INDEX
000FF4  1  A6 28        	LDX	MAXCL		;GET INDEX
000FF6  1  E0 51        	CPX	#LINESZ+1	;IF TOO BIG
000FF8  1  B0 19        	BCS	ER23		;IS ERROR
000FFA  1  8A           	TXA			;IF INDEX
000FFB  1  29 07        	AND	#7		;NOT MOD 8
000FFD  1  D0 EE        	BNE	CTB		;EXPAND
000FFF  1  F0 BB        	BEQ	GNC		;ELSE NEXT CHAR
001001  1               ;NOT A TAB
001001  1  C9 1A        NTT:	CMP	#EOF		;IF AN EOF
001003  1  F0 20        	BEQ	EXT		;DONE
001005  1  C9 0A        	CMP	#LF		;IF LF
001007  1  F0 1C        	BEQ	EXT		;DONE
001009  1  E6 7B        	INC	MAXECH		;BUMP ECHO POINTER
00100B  1  E6 28        	INC	MAXCL		;NEXT
00100D  1  A5 28        	LDA	MAXCL		;GET INDEX
00100F  1  C9 52        	CMP	#LINESZ+2	;IF NOT TOO BIG
001011  1  90 A9        	BCC	GNC		;GET NEXT
001013  1               ;LINE TOO LONG
001013  1  A9 0D        ER23:	LDA	#CR		;SET
001015  1  8D 1B 2E     	STA	LINE+LINESZ
001018  1  8D 6D 2E     	STA	ECHBUF+LINESZ	;BUFFER END
00101B  1  A9 0A        	LDA	#LF		;END
00101D  1  8D 1C 2E     	STA	LINE+LINESZ+1
001020  1  8D 6E 2E     	STA	ECHBUF+LINESZ+1	;FOR BOTH
001023  1  38           	SEC			;ERROR
001024  1  60           RDE:	RTS
001025  1               ;NORMAL
001025  1  18           EXT:	CLC
001026  1  60           	RTS
001027  1               ;GET NEXT SOURCE CHAR
001027  1  A5 05        GNX:	LDA	SRCIND		;IF INDEX
001029  1  C9 7F        	CMP	#<(SRCBUF+SRCLNG) 	;IS LESS
00102B  1  A5 06        	LDA	SRCIND+1	;THAN
00102D  1  E9 25        	SBC	#>(SRCBUF+SRCLNG)	;MAXIMUM
00102F  1  90 37        	BCC	BUFULL		;USE IT
001031  1  20 7A 10     	JSR	CLSIND		;ELSE SET TO START
001034  1  A9 08        	LDA	#SRCLNG/128	;SET NUMBER
001036  1  85 74        	STA	RDSCCN		;RECORDS
001038  1  A5 05        RDESLP:	LDA	SRCIND		;GET BUFFER
00103A  1  A4 06        	LDY	SRCIND+1	;START
00103C  1  20 4C 08     	JSR	SETBUF		;SET IT
00103F  1  20 90 08     	JSR	SSRFCB		;POINT TO FCB
001042  1  20 64 08     	JSR	RDERCR		;READ RECORD
001045  1  F0 0F        	BEQ	RDESOK		;BRANCH IF OK
001047  1  C9 01        	CMP	#1		;IF A ONE
001049  1  F0 03        	BEQ	*+5		;IS JUST EOF
00104B  1  4C 86 08     	JMP	DOSERR		;ELSE IS ERROR
00104E  1  A0 00        	LDY	#0		;CLEAR INDEX
001050  1  A9 1A        	LDA	#EOF		;GET AN EOF
001052  1  91 05        	STA	(SRCIND),Y	;INSERT IT
001054  1  D0 0F        	BNE	ENDRDE		;AND EXIT
001056  1  18           RDESOK:	CLC			;ADD
001057  1  A5 05        	LDA	SRCIND		;128
001059  1  69 80        	ADC	#128		;TO
00105B  1  85 05        	STA	SRCIND		;SOURCE
00105D  1  90 02        	BCC	*+4		;INDEX
00105F  1  E6 06        	INC	SRCIND+1	;THEN
001061  1  C6 74        	DEC	RDSCCN		;DROP COUNT
001063  1  D0 D3        	BNE	RDESLP		;LOOP IF MORE
001065  1  20 7A 10     ENDRDE:	JSR	CLSIND		;SET INDEX TO START
001068  1  A0 00        BUFULL:	LDY	#0		;CLEAR INDEX
00106A  1  B1 05        	LDA	(SRCIND),Y	;GET CHAR
00106C  1  29 7F        	AND	#$7F		;MASK PARITY
00106E  1  C9 1A        	CMP	#EOF		;IF NOT EOF
001070  1  D0 01        	BNE	*+3		;GO BUMP INDEX
001072  1  60           	RTS			;ELSE DONE
001073  1  E6 05        	INC	SRCIND		;BUMP LOW
001075  1  D0 02        	BNE	*+4		;THEN AS NEEDED
001077  1  E6 06        	INC	SRCIND+1	;BUMP HIGH
001079  1  60           	RTS
00107A  1               ;SET SOURCE INDEX TO START
00107A  1  A9 7F        CLSIND:	LDA	#<SRCBUF	;GET
00107C  1  A0 21        	LDY	#>SRCBUF	;ADDRESS
00107E  1  85 05        	STA	SRCIND		;AND
001080  1  84 06        	STY	SRCIND+1	;SET
001082  1  60           	RTS
001083  1               ;SEARCH OPCODE TABLE FOR VALID CODE
001083  1               ; IF FOUND THEN C=1 ELSE C=0
001083  1  A9 23        OPFND:	LDA	#<OPRNDS	;GET LOW
001085  1  85 11        	STA	OPRTBL		;SAVE
001087  1  A9 1F        	LDA	#>OPRNDS	;THEN
001089  1  85 12        	STA	OPRTBL+1	;HIGH
00108B  1  A2 00        	LDX	#0		;CLEAR OPCODE NUMBER
00108D  1  A0 02        G200:	LDY	#2		;OFFSET FOR COMPARE
00108F  1  B9 6F 2E     G210:	LDA	SYM,Y		;GET CHAR
001092  1  D1 11        	CMP	(OPRTBL),Y	;COMPARE
001094  1  D0 0E        	BNE	G220		;NO MATCH
001096  1  88           	DEY			;NEXT CHAR
001097  1  10 F6        	BPL	G210		;TRY NEXT
001099  1               ;FOUND VALID
001099  1  BD AC 20     	LDA	KTMPL,X		;GET TEMPLATE
00109C  1  85 38        	STA	OPTEM		;SAVE
00109E  1  BD E4 20     	LDA	KCODE,X
0010A1  1  85 37        	STA	OPBAS		;SAVE
0010A3  1  60           	RTS
0010A4  1               ;NO MATCH
0010A4  1  A5 11        G220:	LDA	OPRTBL		;GET LOW ADDR
0010A6  1  18           	CLC			;POINT
0010A7  1  69 03        	ADC	#3		;TO
0010A9  1  85 11        	STA	OPRTBL		;NEXT
0010AB  1  90 02        	BCC	*+4		;OPCODE
0010AD  1  E6 12        	INC	OPRTBL+1	;IN
0010AF  1  E8           	INX			;BUMP NUMBER
0010B0  1  E0 39        	CPX	#57		;LOOKED AT ALL?
0010B2  1  30 D9        	BMI	G200		;NO
0010B4  1  18           	CLC			;NOT FOUND
0010B5  1  60           	RTS
0010B6  1               ;MAKE AN ENTRY IN LENGTH TABLE
0010B6  1               ; X=COL WITH ERROR
0010B6  1               ; Y=LENGTH
0010B6  1               ; A=ERROR CODE
0010B6  1  85 47        LTINS:	STA	LTBL+4		;SAVE ERROR
0010B8  1  84 43        	STY	LTBL		;SAVE LENGTH
0010BA  1  86 44        	STX	LTBL+1		;AND COL
0010BC  1  A5 1C        	LDA	PC
0010BE  1  85 45        	STA	LTBL+2		;SAVE PC
0010C0  1  A5 1D        	LDA	PC+1
0010C2  1  85 46        	STA	LTBL+3
0010C4  1  98           	TYA			;ADD
0010C5  1  18           	CLC			;LENGTH
0010C6  1  65 1C        	ADC	PC		;TO PC
0010C8  1  85 1C        	STA	PC
0010CA  1  90 02        	BCC	*+4
0010CC  1  E6 1D        	INC	PC+1
0010CE  1  A5 47        	LDA	LTBL+4		;GET ERROR FLAG
0010D0  1  D0 0C        	BNE	LTI		;BRANCH IF ERROR
0010D2  1  A9 04        	LDA	#%00000100	;TEST PRINT FLAG
0010D4  1  25 1E        	AND	FLAGS
0010D6  1  F0 03        	BEQ	*+5		;NO PRINT
0010D8  1  4C B2 11     	JMP	PRTLN
0010DB  1  4C 40 12     	JMP	PRT170		;GO DO KIM OUTPUT
0010DE  1  85 3E        LTI:	STA	EROR
0010E0  1  F8           	SED
0010E1  1  18           	CLC
0010E2  1  A5 1B        	LDA	ERCT+1
0010E4  1  69 01        	ADC	#1
0010E6  1  85 1B        	STA	ERCT+1
0010E8  1  A5 1A        	LDA	ERCT
0010EA  1  69 00        	ADC	#0
0010EC  1  85 1A        	STA	ERCT
0010EE  1  D8           	CLD
0010EF  1  A5 2B        	LDA	BYWOR		;GET BYTE/WORD FLAG
0010F1  1  D0 05        	BNE	*+7		;BRANCH IF SET
0010F3  1  A9 00        	LDA	#0		;ELSE CLEAR
0010F5  1  8D 7F 2D     	STA	CODE		;OPCODE
0010F8  1  A9 14        	LDA	#%00010100	;CHECK FOR
0010FA  1  25 1E        	AND	FLAGS		;ERROR PRINT
0010FC  1  F0 06        	BEQ	*+8		;NO
0010FE  1  20 B2 11     	JSR	PRTLN
001101  1  4C 0F 13     	JMP	ERRHND
001104  1  4C 40 12     	JMP	PRT170		;GO DO KIM FILE
001107  1               ;PRINT THE SYMBOL TABLE
001107  1               ;PRINTS ONE SYMBOL PER LINE
001107  1  A5 0B        NSTAT:	LDA	STSAVE		;POINT TO START
001109  1  85 0F        	STA	SYMTBL
00110B  1  A5 0C        	LDA	STSAVE+1
00110D  1  85 10        	STA	SYMTBL+1
00110F  1  A9 01        	LDA	#1		;START AT BEGINNING
001111  1  85 2E        	STA	SYMPTR+1
001113  1  A9 00        	LDA	#0
001115  1  85 2D        	STA	SYMPTR
001117  1  B8           R20:	CLV
001118  1  A5 2D        	LDA	SYMPTR
00111A  1  C5 18        	CMP	NOSYM
00111C  1  F0 03        	BEQ	R30
00111E  1  90 09        	BCC	R42
001120  1  60           R25:	RTS
001121  1  A5 2E        R30:	LDA	SYMPTR+1
001123  1  C5 19        	CMP	NOSYM+1
001125  1  F0 02        	BEQ	R42
001127  1  B0 F7        	BCS	R25
001129  1  20 51 13     R42:	JSR	OUTCL1
00112C  1  A0 00        	LDY	#0		;SYMBOL AND VALUE (* IF UNDEF)
00112E  1  B1 0F        R43A:	LDA	(SYMTBL),Y
001130  1  10 05        	BPL	R43B
001132  1  29 7F        	AND	#$7F
001134  1  2C CB 1F     	BIT	KLUDG		;SET V
001137  1  20 9C 09     R43B:	JSR	OUTPUT
00113A  1  C8           	INY
00113B  1  CC 03 08     	CPY	SYMLEN		;COMPARE TO LENGTH
00113E  1  D0 EE        	BNE	R43A
001140  1  20 4E 13     	JSR	OUTCL2
001143  1  50 07        	BVC	R43C
001145  1  A0 04        	LDY	#4
001147  1  20 7A 11     	JSR	PRAST
00114A  1  F0 0B        	BEQ	R43D
00114C  1  B1 0F        R43C:	LDA	(SYMTBL),Y
00114E  1  20 B0 09     	JSR	NUMA
001151  1  C8           	INY
001152  1  B1 0F        	LDA	(SYMTBL),Y
001154  1  20 B0 09     	JSR	NUMA
001157  1  20 D4 09     R43D:	JSR	CRLF
00115A  1  18           	CLC
00115B  1  A5 0F        	LDA	SYMTBL		;ADD LENGTH
00115D  1  6D 03 08     	ADC	SYMLEN		;TO TABLE POINTER
001160  1  85 0F        	STA	SYMTBL
001162  1  90 02        	BCC	R431
001164  1  E6 10        	INC	SYMTBL+1
001166  1  18           R431:	CLC			;ADD TWO
001167  1  A5 0F        	LDA	SYMTBL
001169  1  69 02        	ADC	#2
00116B  1  85 0F        	STA	SYMTBL
00116D  1  90 02        	BCC	R432		;SKIP IF NO CARRY
00116F  1  E6 10        	INC	SYMTBL+1
001171  1  E6 2E        R432:	INC	SYMPTR+1
001173  1  D0 A2        	BNE	R20
001175  1  E6 2D        	INC	SYMPTR
001177  1  4C 17 11     	JMP	R20
00117A  1               ;PRINT NUMBER * IN Y
00117A  1  A9 2A        PRAST:	LDA	#'*'		;GET *
00117C  1  20 53 13     	JSR	OUTCNT
00117F  1  88           	DEY
001180  1  D0 F8        	BNE	PRAST
001182  1  60           	RTS
001183  1               ;END OF ASSEMBLY CODE (.END)
001183  1  A2 00        H10:	LDX	#0
001185  1  8A           	TXA
001186  1  A8           	TAY
001187  1  20 B6 10     	JSR	LTINS
00118A  1  24 04        	BIT	PASNUM		;TEST PASS NUMBER
00118C  1  10 1F        	BPL	H10X		;SKIP IF FIRST
00118E  1  20 63 13     	JSR	CR2
001191  1  A9 40        	LDA	#$40
001193  1  25 1E        	AND	FLAGS
001195  1  F0 0C        	BEQ	MNOS
001197  1  20 63 13     	JSR	CR2
00119A  1  20 02 0A     	JSR	SORT		;DO FINAL SORT
00119D  1  20 07 11     	JSR	NSTAT
0011A0  1  20 D4 09     	JSR	CRLF		;AND A LAST CR AND LF
0011A3  1  A9 F5        MNOS:	LDA	#<ENDMSG	;POINT TO
0011A5  1  A0 1A        	LDY	#>ENDMSG	;END MESSAGE
0011A7  1  20 50 08     	JSR	WRCNMS		;PRINT IT
0011AA  1  20 DE 09     	JSR	CCRLF
0011AD  1  A2 FB        H10X:	LDX	#$FB
0011AF  1  9A           	TXS
0011B0  1  38           	SEC
0011B1  1  60           	RTS
0011B2  1               ;PRINT OUTPUT LINE
0011B2  1  A9 7F        PRTLN:	LDA	#<CODE
0011B4  1  85 6C        	STA	CDEPTR
0011B6  1  A9 2D        	LDA	#>CODE
0011B8  1  85 6D        	STA	CDEPTR+1
0011BA  1  A5 45        	LDA	LTBL+2
0011BC  1  85 1C        	STA	PC
0011BE  1  A5 46        	LDA	LTBL+3
0011C0  1  85 1D        	STA	PC+1
0011C2  1  A5 43        	LDA	LTBL
0011C4  1  48           PRT10:	PHA
0011C5  1  A9 00        	LDA	#0
0011C7  1  85 15        	STA	COLCNT
0011C9  1  20 51 13     	JSR	OUTCL1
0011CC  1  A5 1D        	LDA	PC+1
0011CE  1  20 41 13     	JSR	NUMC2
0011D1  1  A5 1C        	LDA	PC
0011D3  1  20 41 13     	JSR	NUMC2
0011D6  1  20 51 13     	JSR	OUTCL1		;SEND A BLANK
0011D9  1  68           	PLA
0011DA  1  D0 0E        	BNE	PRT20		;OK IF NOT ZERO
0011DC  1  48           	PHA			;SAVE ZERO AGAIN
0011DD  1  A5 2C        	LDA	LCDPT		;GET MULT LINES FLAG
0011DF  1  D0 42        	BNE	PRT140		;BRANCH IF SET
0011E1  1  20 58 13     	JSR	OUTTB		;SEND TAB
0011E4  1  20 58 13     	JSR	OUTTB		;AND ANOTHER
0011E7  1  4C 20 12     	JMP	PRT130		;GO ECHO LINE
0011EA  1               ;WAS SOMETHING TO PRINT
0011EA  1  AA           PRT20:	TAX
0011EB  1  C9 04        	CMP	#4
0011ED  1  90 08        	BCC	PRT40
0011EF  1  A2 03        	LDX	#3
0011F1  1  38           	SEC
0011F2  1  E9 03        	SBC	#3
0011F4  1  4C F9 11     	JMP	PRT50
0011F7  1  A9 00        PRT40:	LDA	#0
0011F9  1  48           PRT50:	PHA
0011FA  1  CA           PRT60:	DEX
0011FB  1  30 18        	BMI	PRT100
0011FD  1  A0 00        	LDY	#0
0011FF  1  B1 6C        	LDA	(CDEPTR),Y
001201  1  20 41 13     PRT70:	JSR	NUMC2
001204  1  20 51 13     PRT80:	JSR	OUTCL1
001207  1  E6 1C        	INC	PC
001209  1  D0 02        	BNE	*+4
00120B  1  E6 1D        	INC	PC+1
00120D  1  E6 6C        	INC	CDEPTR
00120F  1  D0 E9        	BNE	PRT60
001211  1  E6 6D        	INC	CDEPTR+1
001213  1  D0 E5        	BNE	PRT60
001215  1  A5 2C        PRT100:	LDA	LCDPT
001217  1  D0 0A        	BNE	PRT140
001219  1  A6 28        	LDX	MAXCL
00121B  1  30 06        	BMI	PRT140
00121D  1  20 58 13     	JSR	OUTTB		;SEND A TAB
001220  1  20 FC 12     PRT130:	JSR	ECHOPR		;NOW DO LINE
001223  1  20 D4 09     PRT140:	JSR	CRLF
001226  1  E6 2C        	INC	LCDPT
001228  1  68           	PLA
001229  1  F0 15        	BEQ	PRT170
00122B  1  AA           	TAX
00122C  1  A9 80        	LDA	#128
00122E  1  25 1E        	AND	FLAGS
001230  1  D0 04        	BNE	PRT160
001232  1  8A           	TXA
001233  1  4C C4 11     	JMP	PRT10
001236  1  18           PRT160:	CLC
001237  1  8A           	TXA
001238  1  65 1C        	ADC	PC
00123A  1  85 1C        	STA	PC
00123C  1  90 02        	BCC	PRT170
00123E  1  E6 1D        	INC	PC+1
001240  1  24 04        PRT170:	BIT	PASNUM
001242  1  10 10        	BPL	EXTKIM		;EXIT IF FIRST PASS
001244  1  A5 43        	LDA	LTBL
001246  1  F0 0C        	BEQ	EXTKIM		;OR IF NO OUTPUT
001248  1  85 73        	STA	KIMCNT
00124A  1  A5 1E        	LDA	FLAGS		;GET FLAG
00124C  1  29 20        	AND	#%00100000	;ISOLATE KIM BIT
00124E  1  F0 04        	BEQ	EXTKIM		;EXIT IF KIM DISABLED
001250  1  24 7F        	BIT	NKMFLG		;SEE IF COMMAND LINE Z
001252  1  10 01        	BPL	*+3		;IT WASN'T SO CONTINUE
001254  1  60           EXTKIM:	RTS			;ELSE DONE
001255  1               ;FOLLOWING CODE ACTUALLY DOES KIM OUTPUT
001255  1  A5 4D        	LDA	BYTCNT
001257  1  D0 0C        	BNE	NONEW
001259  1  A5 45        NWKIM:	LDA	LTBL+2		;INITIALIZE PROGRAM COUNTER
00125B  1  85 4F        	STA	FRSTPC+1
00125D  1  85 6B        	STA	CURNPC+1
00125F  1  A5 46        	LDA	LTBL+3
001261  1  85 4E        	STA	FRSTPC
001263  1  85 6A        	STA	CURNPC
001265  1  A5 45        NONEW:	LDA	LTBL+2
001267  1  C5 6B        	CMP	CURNPC+1
001269  1  F0 06        	BEQ	*+8
00126B  1  20 A9 12     W0:	JSR	WRKMRC
00126E  1  4C 59 12     	JMP	NWKIM
001271  1  A5 46        	LDA	LTBL+3
001273  1  C5 6A        	CMP	CURNPC
001275  1  D0 F4        	BNE	W0
001277  1  A0 00        	LDY	#0
001279  1  A6 4D        W1:	LDX	BYTCNT
00127B  1  B9 7F 2D     KFL:	LDA	CODE,Y
00127E  1  95 50        	STA	KIMREC,X
001280  1  E6 6B        	INC	CURNPC+1
001282  1  D0 02        	BNE	*+4
001284  1  E6 6A        	INC	CURNPC
001286  1  C8           	INY
001287  1  E8           	INX
001288  1  86 4D        	STX	BYTCNT
00128A  1  C6 73        	DEC	KIMCNT
00128C  1  D0 05        	BNE	*+7
00128E  1  E0 18        	CPX	#BYTSRC
001290  1  F0 17        	BEQ	WRKMRC
001292  1  60           	RTS
001293  1  E0 18        	CPX	#BYTSRC
001295  1  D0 E4        	BNE	KFL
001297  1  98           	TYA
001298  1  48           	PHA
001299  1  20 A9 12     	JSR	WRKMRC
00129C  1  68           	PLA
00129D  1  A8           	TAY
00129E  1  A5 6B        	LDA	CURNPC+1
0012A0  1  85 4F        	STA	FRSTPC+1
0012A2  1  A5 6A        	LDA	CURNPC
0012A4  1  85 4E        	STA	FRSTPC
0012A6  1  4C 79 12     	JMP	W1
0012A9  1               ;WRITE KIM RECORD
0012A9  1  A9 00        WRKMRC:	LDA	#0		;CLEAR CHECKSUM
0012AB  1  85 69        	STA	CHKSUM+1
0012AD  1  85 68        	STA	CHKSUM
0012AF  1  A5 4D        	LDA	BYTCNT		;GET BYTE COUNT
0012B1  1  D0 01        	BNE	*+3
0012B3  1  60           	RTS			;DONE IF ZERO
0012B4  1               ;START OUTPUT WITH SEMICOLON
0012B4  1  A9 3B        	LDA	#SEMICO
0012B6  1  20 80 09     	JSR	KIMOUT
0012B9  1  A5 4D        	LDA	BYTCNT
0012BB  1  20 F0 12     	JSR	ADDCK		;ADD COUNT TO CHECKSUM
0012BE  1  20 74 09     	JSR	KIMBYT
0012C1  1  A5 4D        	LDA	BYTCNT		;ADJUST TO GET ADDRESS
0012C3  1  18           	CLC
0012C4  1  69 02        	ADC	#2
0012C6  1  85 4D        	STA	BYTCNT
0012C8  1  A9 01        	LDA	#1
0012CA  1  85 72        	STA	KINDEX
0012CC  1  A6 72        WRK1:	LDX	KINDEX
0012CE  1  B5 4D        	LDA	BYTCNT,X
0012D0  1  20 F0 12     	JSR	ADDCK		;ADD TO CHECKSUM
0012D3  1  20 74 09     	JSR	KIMBYT
0012D6  1  E6 72        	INC	KINDEX
0012D8  1  C6 4D        	DEC	BYTCNT
0012DA  1  D0 F0        	BNE	WRK1
0012DC  1  A5 68        	LDA	CHKSUM		;SEND HIGH
0012DE  1  20 74 09     	JSR	KIMBYT		;CHECKSUM
0012E1  1  A5 69        	LDA	CHKSUM+1	;THEN
0012E3  1  20 74 09     	JSR	KIMBYT		;LOW PART
0012E6  1  A9 0D        	LDA	#CR
0012E8  1  20 80 09     	JSR	KIMOUT
0012EB  1  A9 0A        	LDA	#LF
0012ED  1  4C 80 09     	JMP	KIMOUT
0012F0  1               ;ADD BYTE IN A TO CHECKSUM AND SAVE A
0012F0  1  48           ADDCK:	PHA			;SAVE BYTE
0012F1  1  18           	CLC			;NOW DO ADD
0012F2  1  65 69        	ADC	CHKSUM+1
0012F4  1  85 69        	STA	CHKSUM+1
0012F6  1  90 02        	BCC	ADDCKX		;DONE IF NO CARRY
0012F8  1  E6 68        	INC	CHKSUM		;ELSE BUMP HIGH
0012FA  1  68           ADDCKX:	PLA			;GET INPUT BYTE
0012FB  1  60           	RTS
0012FC  1               ;PRINT LINE AS IN BUFFER
0012FC  1  A2 FF        ECHOPR:	LDX	#$FF
0012FE  1  C6 7B        	DEC	MAXECH		;DROP LIMIT
001300  1  E8           ECH10:	INX			;BUMP INDEX
001301  1  E4 7B        	CPX	MAXECH		;COMPARE TO MAX
001303  1  B0 09        	BCS	ECH20
001305  1  BD 1D 2E     	LDA	ECHBUF,X	;GET CHAR
001308  1  20 9C 09     	JSR	OUTPUT		;SEND
00130B  1  4C 00 13     	JMP	ECH10		;AND LOOP
00130E  1  60           ECH20:	RTS
00130F  1               ;PRINT ERROR MESSAGE AND POINTER
00130F  1  24 04        ERRHND:	BIT	PASNUM		;TEST PASS NUMBER
001311  1  30 01        	BMI	ERH01		;CONTINUE IF SECOND
001313  1  60           	RTS			;ELSE DONE
001314  1  A9 85        ERH01:	LDA	#<ERRMSG 	;POINT TO
001316  1  A0 1B        	LDY	#>ERRMSG 	;ERROR MESSAGE
001318  1  20 73 08     	JSR	WRLSMS		;WRITE IT
00131B  1  20 58 13     	JSR	OUTTB		;SEND A TAB
00131E  1  A6 44        	LDX	LTBL+1		;GET ERROR COLUMN
001320  1  CA           ERH10:	DEX
001321  1  30 06        	BMI	ERH20
001323  1  20 51 13     	JSR	OUTCL1
001326  1  4C 20 13     	JMP	ERH10
001329  1  A9 5E        ERH20:	LDA	#'^'
00132B  1  20 9C 09     	JSR	OUTPUT
00132E  1  20 D4 09     	JSR	CRLF
001331  1  A5 3E        	LDA	EROR		;GET ERROR NUMBER
001333  1  0A           	ASL	A		;MULT BY TWO
001334  1  AA           	TAX			;MAKE INTO INDEX
001335  1  BD B6 1B     	LDA	ERRVEC,X	;GET LOW
001338  1  BC B7 1B     	LDY	ERRVEC+1,X	;AND HIGH ADDRESS
00133B  1  20 73 08     	JSR	WRLSMS		;WRITE MESSAGE
00133E  1  4C D4 09     	JMP	CRLF		;AND CR LF
001341  1               ;PRINT BYTE AND ADJUST COLUMN COUNT
001341  1  E6 15        NUMC2:	INC	COLCNT
001343  1  E6 15        	INC	COLCNT
001345  1  4C B0 09     	JMP	NUMA
001348  1               ;OUTPUT BLANKS AND ADJUST COUNT
001348  1  20 51 13     OUTCL4:	JSR	OUTCL1
00134B  1  20 51 13     	JSR	OUTCL1
00134E  1  20 51 13     OUTCL2:	JSR	OUTCL1
001351  1  A9 20        OUTCL1:	LDA	#BLANK
001353  1  E6 15        OUTCNT:	INC	COLCNT
001355  1  4C 9C 09     	JMP	OUTPUT
001358  1               ;SEND A TAB
001358  1  A9 09        OUTTB:	LDA	#TAB		;GET IT
00135A  1  4C 9C 09     	JMP	OUTPUT		;AND SEND
00135D  1               ;CR LF ROUTINES
00135D  1  20 D4 09     CR4:	JSR	CRLF
001360  1  20 D4 09     	JSR	CRLF
001363  1  20 D4 09     CR2:	JSR	CRLF
001366  1  4C D4 09     	JMP	CRLF
001369  1               ;-------------------------------
001369  1               ;PROCESS A SINGLE LINE
001369  1               ;-------------------------------
001369  1  A9 00        PROCES:	LDA	#0
00136B  1  A2 0D        	LDX	#13
00136D  1  95 1F        	STA	FLAGS+1,X
00136F  1  CA           	DEX
001370  1  10 FB        	BPL	*-3
001372  1  A2 4B        	LDX	#LINESZ-5	;CLEAR
001374  1  9D 7F 2D     	STA	CODE,X		;ALL OF
001377  1  CA           	DEX			;CODE
001378  1  10 FA        	BPL	*-4		;BUFFER
00137A  1  20 B4 0F     	JSR	LINEIN		;GET THE INPUT LINE
00137D  1  CA           	DEX
00137E  1  CA           	DEX
00137F  1  86 28        	STX	MAXCL
001381  1  C9 1A        	CMP	#EOF
001383  1  D0 15        	BNE	NTEOF		;CONTINUE IF NOT EOF
001385  1  A9 0D        	LDA	#CR		;STUFF CR AND LF
001387  1  8D 1D 2E     	STA	ECHBUF
00138A  1  A9 0A        	LDA	#LF
00138C  1  8D 1E 2E     	STA	ECHBUF+1
00138F  1  A2 FF        	LDX	#255		;SET COLUMN TO -1
001391  1  85 28        	STA	MAXCL
001393  1  A2 01        	LDX	#1
001395  1  86 7B        	STX	MAXECH		;SET MAX ECHO COL TO 1
001397  1  4C 83 11     	JMP	H10
00139A  1               ;NOT EOF SO PROCESS LINE
00139A  1  F8           NTEOF:	SED			;SET DECIMAL MODE
00139B  1  A5 17        	LDA	LINENO+1	;BUMP LINE NUMBER BY 1
00139D  1  69 01        	ADC	#1
00139F  1  85 17        	STA	LINENO+1
0013A1  1  A5 16        	LDA	LINENO
0013A3  1  69 00        	ADC	#0
0013A5  1  85 16        	STA	LINENO
0013A7  1  D8           	CLD			;BACK TO BINARY MODE
0013A8  1  20 C7 0A     	JSR	FNDNB		;GET FIRST NON-BLANK
0013AB  1  B0 08        	BCS	H88
0013AD  1               ;BLANK LINE SO IGNORE
0013AD  1  A0 00        HL0000:	LDY	#0
0013AF  1  A2 00        HLY000:	LDX	#0
0013B1  1  8A           	TXA
0013B2  1  4C 2E 19     	JMP	LTS1
0013B5  1               ;THERE IS SOMETHING IN THE LINE OTHER THAN BLANKS
0013B5  1  20 6C 0B     H88:	JSR	NUMRC		;SEE IF FIRST CHAR A NUMBER
0013B8  1  90 0B        	BCC	H88B		;JUMP IF NOT
0013BA  1  20 87 0A     	JSR	INCRP		;NUMBER SO GO TO NEXT CHAR
0013BD  1  86 27        	STX	PARST		;PREPARE TO USE
0013BF  1  86 20        	STX	COLP
0013C1  1  B0 EA        	BCS	HL0000		;HIT EOL SO IGNORE LINE
0013C3  1  90 F0        	BCC	H88		;NOT EOL SO LOOP UNTIL PAST NUMBER
0013C5  1               ;AT THIS POINT LINE NUMBER HAS BEEN IGNORED & WE ARE READY TO CONTINUE PARSING
0013C5  1               ;THIS IS ALSO MAIN LOOP ENTRY AFTER SUCCESSIVE FIELDS ARE EVALUATED
0013C5  1  20 C7 0A     H88B:	JSR	FNDNB		;FIND NON-BLANK
0013C8  1  90 E3        	BCC	HL0000		;NONE SO IGNORE BLANK LINE
0013CA  1  BD CB 2D     H88A:	LDA	LINE,X		;GET THE CHARACTER
0013CD  1  C9 3B        	CMP	#SEMICO		;IF START OF COMMENT THEN ALSO IGNORE
0013CF  1  F0 DC        	BEQ	HL0000
0013D1  1  20 E5 0A     	JSR	FNDEN		;FIND END OF CHARACTER SEQUENCE
0013D4  1  B0 09        	BCS	H1		;JUMP IF FOUND
0013D6  1  A9 03        HL303B:	LDA	#3		;ELSE ERR03 - ILLEGAL OR MISSING OPCODE
0013D8  1  A0 03        HL3AAB:	LDY	#3
0013DA  1  A6 21        HLYAAB:	LDX	CSB
0013DC  1  4C 2E 19     	JMP	LTS1
0013DF  1               ;HAVE FOUND A CHARACTER STRING - START TESTING IT
0013DF  1  A6 21        H1:	LDX	CSB		;GO BACK TO STRING START
0013E1  1  BD CB 2D     	LDA	LINE,X		;GET CHAR
0013E4  1  C9 2E        	CMP	#'.'		;SEE IF START OF DIRECTIVE
0013E6  1  D0 03        	BNE	*+5		;IF NOT THEN JUMP
0013E8  1  4C 47 15     	JMP	H5		;IF IS GO TO DIRECTIVE PROCESSING SECTION
0013EB  1  C9 2A        	CMP	#'*'		;SEE IF PC PROCESSING
0013ED  1  D0 03        	BNE	*+5		;IF NOT THEN JUMP
0013EF  1  4C 9E 14     	JMP	H102		;IF IS PROCESS PC CHANGE
0013F2  1               ;AT THIS POINT WE EITHER HAVE A LABEL OR AN OPCODE BUT NEED TO CHECK LENGTH
0013F2  1  A4 23        	LDY	CSL		;GET CHAR STRING LENGTH
0013F4  1  CC 03 08     	CPY	SYMLEN		;COMPARE TO MAX
0013F7  1  90 09        	BCC	H76		;OK IS LESS
0013F9  1  F0 07        	BEQ	H76		;OK IF SAME
0013FB  1               ;ERR09 - LABEL TOO LONG
0013FB  1  A9 09        	LDA	#9
0013FD  1  A0 03        HL3AAX:	LDY	#3
0013FF  1  4C 2E 19     	JMP	LTS1
001402  1               ;THERE IS A STRING THAT MAY BE LABEL OR OPCODE
001402  1  84 2F        H76:	STY	LEN		;SET LENGTH
001404  1  20 7B 0B     	JSR	CONSYM		;TRY TO CONSTRUCT SYMBOL
001407  1  B0 04        	BCS	H76OK		;JUMP IF ALL ALPHA-NUMERIC
001409  1  A9 0A        	LDA	#10		;ELSE ERR10 - NON-ALPHANUMERIC
00140B  1  D0 F0        	BNE	HL3AAX
00140D  1  A5 23        H76OK:	LDA	CSL		;SEE IF SYMBOL IS RIGHT LENGTH
00140F  1  C9 03        	CMP	#3		;FOR OPCODE
001411  1  D0 08        	BNE	CSLNT3		;JUMP IF NOT
001413  1  20 83 10     	JSR	OPFND		;SEE IF OPCODE
001416  1  90 03        	BCC	CSLNT3		;NOT SO PROCESS AS LABEL
001418  1  4C ED 16     	JMP	H201		;IS SO PROCESS OPCODE
00141B  1               ;AT THIS POINT WE HAVE A STRING THAT LOOKS LIKE A LABEL
00141B  1  A5 29        CSLNT3:	LDA	LABL		;FIRST SEE IF ALREADY A LABEL
00141D  1  D0 B7        	BNE	HL303B		;ERR03 IF IS - ILLEGAL OPCODE
00141F  1  E6 29        	INC	LABL		;BUT NOW SAY THERE IS A LABEL
001421  1  A6 20        	LDX	COLP		;POINT TO START
001423  1  20 5D 0B     	JSR	ALPH		;SEE IF ALPHA
001426  1  B0 04        	BCS	H94		;OK IF IS
001428  1  A9 08        	LDA	#8		;ELSE ERR08 - LABEL DOES NOT START WITH ALPHA
00142A  1  D0 D1        	BNE	HL3AAX
00142C  1               ;LABEL STARTS WITH ALPHA
00142C  1  AD 70 2E     H94:	LDA	SYM+1		;SEE IF SINGLE CHARACTER LONG
00142F  1  C9 20        	CMP	#BLANK		;JUMP MORE THAN ONE CHAR
001431  1  D0 1C        	BNE	H93
001433  1  AD 6F 2E     	LDA	SYM
001436  1  C9 41        	CMP	#'A'		;TEST FOR ILLEGAL LABEL
001438  1  F0 10        	BEQ	H97		;A IS ILLEGAL
00143A  1  C9 58        	CMP	#'X'
00143C  1  F0 0C        	BEQ	H97		;X IS ILLEGAL
00143E  1  C9 59        	CMP	#'Y'
001440  1  F0 08        	BEQ	H97		;Y IS ILLEGAL
001442  1  C9 53        	CMP	#'S'
001444  1  F0 04        	BEQ	H97		;S IS ILLEGAL
001446  1  C9 50        	CMP	#'P'
001448  1  D0 05        	BNE	H93		;NOT P SO LEGAL
00144A  1               ;ERR20 - LABEL IS A RESERVED SINGLE CHARACTER
00144A  1  A9 14        H97:	LDA	#20
00144C  1  4C FD 13     	JMP	HL3AAX
00144F  1               ;LABEL IS NOT RESERVED AND IS NOT OPCODE
00144F  1  86 24        H93:	STX	LSST
001451  1  A2 00        	LDX	#0
001453  1               ;PUSH SYMBOL AND THEN SYMBOL LENGTH ONTO STACK
001453  1  BD 6F 2E     H8845:	LDA	SYM,X		;GET CHAR
001456  1  48           	PHA			;PUSH ONTO STACK
001457  1  E8           	INX			;BUMP POINTER
001458  1  EC 03 08     	CPX	SYMLEN		;COMPARE TO MAX
00145B  1  D0 F6        	BNE	H8845		;LOOP IF MORE
00145D  1  A5 23        	LDA	CSL		;NOW GET LENGTH
00145F  1  48           	PHA			;AND PUSH IT
001460  1  A6 22        	LDX	CSE		;POINT TO END OF STRING
001462  1  E8           	INX			;AND GO ONE PAST
001463  1  86 20        	STX	COLP		;SAVE AS POINTER
001465  1  20 C7 0A     	JSR	FNDNB		;LOOK FOR NON BLANK
001468  1  90 07        	BCC	H120		;NONE FOUND
00146A  1  BD CB 2D     	LDA	LINE,X
00146D  1  C9 3D        	CMP	#'='
00146F  1  F0 47        	BEQ	H121
001471  1  20 0E 0F     H120:	JSR	FIND		;SEE IF EXITING LABEL
001474  1  90 11        	BCC	H95		;EITHER NOT FOUND OR NOT NOT DEFINED
001476  1               ;LABEL IS EXISTING LABEL AND IS DEFINED SO MAKE SURE IT IS NOT BEING CHANGED
001476  1  A5 34        	LDA	VAL		;FIRST TEST HIGH
001478  1  C5 1D        	CMP	PC+1
00147A  1  D0 06        	BNE	MRO2		;ERROR IF DIFFERENT
00147C  1  A5 35        	LDA	VAL+1		;NOW TEST LOW
00147E  1  C5 1C        	CMP	PC
001480  1  F0 10        	BEQ	H95A		;OK IF SAME
001482  1               ;ERR02 - LABEL PREVIOUSLY DEFINED
001482  1  A0 03        MRO2:	LDY	#3
001484  1  4C 32 15     	JMP	HLY02L
001487  1               ;AT THIS POINT WE HAVE A VALID LABEL SO CREATE OR UPDATE ENTRY
001487  1               ;V FLAG MUST NOT HAVE BEEN ALTERED SINCE JSR FIND WAS EXECUTED AT H120
001487  1               ;AS THAT FLAG DETERMINES IF INSERT CREATES NEW ENTRY OR JUST UPDATES
001487  1               ;VALUE OF EXISTING ENTRY
001487  1  A5 1D        H95:	LDA	PC+1		;SET VAL TO CURRENT PC
001489  1  85 34        	STA	VAL
00148B  1  A5 1C        	LDA	PC
00148D  1  85 35        	STA	VAL+1
00148F  1  20 83 0F     	JSR	INSERT		;DO INSERT OR UPDATE
001492  1  A6 21        H95A:	LDX	CSB		;TEST START OF STRING
001494  1  E4 24        	CPX	LSST		;AGAINST LABEL START
001496  1  F0 03        	BEQ	*+5		;IF SAME THEN DONE WITH LINE
001498  1  4C CA 13     	JMP	H88A		;ELSE LOOP TO FIND NEXT FIELD
00149B  1  4C AD 13     	JMP	HL0000
00149E  1               ;PROCESS PC REFERENCE STATEMENT
00149E  1  E6 2A        H102:	INC	ORG		;SET FLAG TO SAY AN ORG IS IN LINE
0014A0  1  E6 20        	INC	COLP
0014A2  1  86 24        	STX	LSST
0014A4  1  20 C7 0A     	JSR	FNDNB		;FIND NEXT NON BLANK
0014A7  1  B0 03        	BCS	H103		;GOT ONE SO CONTINUE
0014A9  1  4C 21 17     	JMP	HL307B		;ELSE ERR07 - RAN OFF LINE
0014AC  1  BD CB 2D     H103:	LDA	LINE,X		;GET THAT NEXT CHAR
0014AF  1  C9 3D        	CMP	#'='		;SEE IF =
0014B1  1  F0 05        	BEQ	H121		;IS SO OK
0014B3  1  A9 16        	LDA	#22		;IF NOT IS ERR22 - EXPECTING = FOR ORG
0014B5  1  4C FD 13     	JMP	HL3AAX
0014B8  1               ;ENTRY POINT FOR NORMAL * = PROCESSING AS WELL AS <LABEL> = PROCESSING
0014B8  1  E6 2A        H121:	INC	ORG		;MAKE SURE FLAG SET
0014BA  1  20 87 0A     	JSR	INCRP		;BUMP POINTER
0014BD  1  86 20        	STX	COLP		;AND SAVE
0014BF  1  90 03        	BCC	*+5		;OK IF NOT EOL
0014C1  1  4C 21 17     	JMP	HL307B		;ELSE ERR07 - RAN OFF LINE
0014C4  1  20 C7 0A     	JSR	FNDNB		;FIND A NON-BLANK
0014C7  1  B0 05        	BCS	H104		;GOT ONE
0014C9  1  A0 00        	LDY	#0		;ELSE ERR
0014CB  1  4C 13 17     	JMP	HLY07E
0014CE  1  20 9E 0B     H104:	JSR	EVAL
0014D1  1  A5 36        	LDA	RETURN
0014D3  1  30 0C        	BMI	H105
0014D5  1  D0 05        	BNE	H8806
0014D7  1  A9 0B        	LDA	#11		;ELSE ERR11 - FORWARD REFERENCE IN EQUATE OR ORG
0014D9  1  4C 80 17     	JMP	HL3AAJ
0014DC  1  A9 0D        H8806:	LDA	#13		;ERR13 - INVALID EXPRESSION
0014DE  1  4C 80 17     	JMP	HL3AAJ
0014E1  1  A5 2A        H105:	LDA	ORG
0014E3  1  C9 01        	CMP	#1
0014E5  1  F0 2A        	BEQ	H9
0014E7  1  A9 01        	LDA	#1
0014E9  1  25 1F        	AND	FLAGS+1
0014EB  1  F0 12        	BEQ	H150
0014ED  1  A6 21        	LDX	CSB
0014EF  1  A9 15        	LDA	#21
0014F1  1  A0 00        	LDY	#0
0014F3  1  20 B6 10     	JSR	LTINS
0014F6  1  A2 00        	LDX	#0
0014F8  1  86 1C        	STX	PC
0014FA  1  86 1D        	STX	PC+1
0014FC  1  4C 31 19     	JMP	NXT
0014FF  1  A2 00        H150:	LDX	#0
001501  1  8A           	TXA
001502  1  A8           	TAY
001503  1  20 B6 10     	JSR	LTINS
001506  1  A5 25        	LDA	EXP
001508  1  85 1D        	STA	PC+1
00150A  1  A5 26        	LDA	EXP+1
00150C  1  85 1C        	STA	PC
00150E  1  4C 31 19     	JMP	NXT
001511  1  68           H9:	PLA
001512  1  85 23        	STA	CSL
001514  1  AE 03 08     	LDX	SYMLEN		;GET LENGTH
001517  1  CA           	DEX			;AND DROP
001518  1  68           H8846:	PLA
001519  1  9D 6F 2E     	STA	SYM,X
00151C  1  CA           	DEX
00151D  1  10 F9        	BPL	H8846
00151F  1  20 0E 0F     	JSR	FIND
001522  1  90 15        	BCC	H106
001524  1  A5 34        	LDA	VAL
001526  1  C5 25        	CMP	EXP
001528  1  D0 06        	BNE	MR01
00152A  1  A5 35        	LDA	VAL+1
00152C  1  C5 26        	CMP	EXP+1
00152E  1  F0 14        	BEQ	H106A
001530  1  A0 00        MR01:	LDY	#0
001532  1  A9 02        HLY02L:	LDA	#2
001534  1  A6 24        	LDX	LSST
001536  1  4C 2E 19     	JMP	LTS1
001539  1  A5 25        H106:	LDA	EXP
00153B  1  85 34        	STA	VAL
00153D  1  A5 26        	LDA	EXP+1
00153F  1  85 35        	STA	VAL+1
001541  1  20 83 0F     	JSR	INSERT
001544  1  4C AD 13     H106A:	JMP	HL0000
001547  1               ;ASSEMBLER DIRECTIVE PROCESSING
001547  1               ;SEARCH DIRECTIVE TABLE AND PROCESS IF FOUND
001547  1  A6 21        H5:	LDX	CSB		;GET STRING START
001549  1  E8           	INX			;GO PAST "."
00154A  1  A9 F6        	LDA	#<ASMDIR	;INITIALIZE POINTER TO TABLE START
00154C  1  85 13        	STA	TBLPTR
00154E  1  A9 1E        	LDA	#>ASMDIR
001550  1  85 14        	STA	TBLPTR+1
001552  1  A9 03        	LDA	#3		;SET LENGTH TO 3
001554  1  85 2F        	STA	LEN
001556  1  20 7B 0B     	JSR	CONSYM		;BUILD A SYMBOL
001559  1  CA           	DEX			;DROP INDEX SO POINTING TO THIRD CHAR
00155A  1               ;LOOP ENTRY FOR SEARCH
00155A  1  20 87 0A     H8847:	JSR	INCRP		;GO TO NEXT CHAR
00155D  1  B0 07        	BCS	H8849		;JUMP IF EOL
00155F  1  BD CB 2D     	LDA	LINE,X		;ELSE GET CHAR
001562  1  C9 20        	CMP	#BLANK		;TEST AGAINST BLANK
001564  1  D0 F4        	BNE	H8847		;LOOP IF NOT TO HANDLE FULL LENGTH DIRECTIVES
001566  1  86 20        H8849:	STX	COLP		;SAVE POINTER
001568  1  B0 07        	BCS	H8835		;JUMP IF VALID DIRECTIVE
00156A  1  A0 00        HL014B:	LDY	#0		;ELSE SAY ERR14 - INVALID DIRECTIVE
00156C  1  A9 0E        	LDA	#14
00156E  1  4C DA 13     	JMP	HLYAAB
001571  1               ;START TESTING SYMBOL AGAINST VALID DIRECTIVE TABLE ENTRIES
001571  1  A2 0E        H8835:	LDX	#NUMASM-1	;SET X TO LAST ENTRY
001573  1  A0 02        H9938:	LDY	#2		;Y IS CHAR INDEX STARTING AT END
001575  1  B9 6F 2E     H9939:	LDA	SYM,Y		;GET SYMBOL CHAR
001578  1  D1 13        	CMP	(TBLPTR),Y	;COMPARE TO TABLE ENTRY CHAR
00157A  1  D0 15        	BNE	H9940		;JUMP IF NO MATCH
00157C  1  88           	DEY			;MATCH SO FAR SO DROP INDEX
00157D  1  10 F6        	BPL	H9939		;LOOP IF MORE TO TEST
00157F  1  8A           	TXA			;FULL MATCH SO SET X TO 2X
001580  1  0A           	ASL	A
001581  1  AA           	TAX
001582  1  BD D8 1E     	LDA	ASMJMP,X	;GET ENTRY ADDRESS AND
001585  1  85 13        	STA	TBLPTR		;SET POINTER
001587  1  BD D9 1E     	LDA	ASMJMP+1,X
00158A  1  85 14        	STA	TBLPTR+1
00158C  1               ;FOLLOWING LINE MAY BE REDUNDANT - NEED TO DOUBLE CHECK
00158C  1  A5 1E        	LDA	FLAGS		;GET FLAGS FOR DIRECTIVE USE
00158E  1  6C 13 00     	JMP	(TBLPTR)	;GO TO ENTRY POINT
001591  1               ;THERE WAS NOT A MATCH SO TRY NEXT TABLE ENTRY
001591  1  A5 13        H9940:	LDA	TBLPTR
001593  1  18           	CLC
001594  1  69 03        	ADC	#3
001596  1  85 13        	STA	TBLPTR
001598  1  90 02        	BCC	*+4
00159A  1  E6 14        	INC	TBLPTR+1
00159C  1  CA           	DEX			;DROP COUNTER
00159D  1  10 D4        	BPL	H9938		;LOOP IF MORE
00159F  1  30 C9        	BMI	HL014B		;ELSE ERROR
0015A1  1               ;EXECUTE .PAG DIRECTIVE
0015A1  1  A5 1E        PAGE:	LDA	FLAGS		;GET FLAGS
0015A3  1  29 04        	AND	#%00000100	;TEST LIST
0015A5  1  F0 0C        	BEQ	NOPAGE		;BRANCH IF NO LIST
0015A7  1  AD 02 01     	LDA	$100+2		;GET SIM PAGE
0015AA  1  8D AF 15     	STA	GETFF+2
0015AD  1  AD 3E FF     GETFF:	LDA	$FF00+62	;GET FORMFEED CODE
0015B0  1  20 9C 09     	JSR	OUTPUT		;SEND IT
0015B3  1  4C AD 13     NOPAGE:	JMP	HL0000		;AND CONTINUE
0015B6  1               ;PROCESS .BYT DIRECTIVE
0015B6  1  A0 01        H111:	LDY	#1		;VALUE FOR .BYT FOR FLAG
0015B8  1  D0 02        	BNE	H13A		;JUMP ALWAYS
0015BA  1               ;PROCESS .WOR DIRECTIVE
0015BA  1  A0 02        H113:	LDY	#2		;VALUE FOR .WOR FOR FLAG
0015BC  1  84 2B        H13A:	STY	BYWOR		;SAVE .BYT OR .WOR FLAG
0015BE  1  20 C7 0A     	JSR	FNDNB		;FIND NEXT NON-BLANK
0015C1  1  B0 03        	BCS	HBW10
0015C3  1  4C 13 17     	JMP	HLY07E
0015C6  1  20 9E 0B     HBW10:	JSR	EVAL		;EVALUATE EXPRESSION
0015C9  1  A5 36        	LDA	RETURN		;GET RETURN CODE
0015CB  1  F0 5B        	BEQ	HBW40		;UNDEFINED SYMBOL
0015CD  1  10 5D        	BPL	HBW60		;UNINTERPRETABLE
0015CF  1  86 20        	STX	COLP		;ELSE SET POINTER TO NEXT
0015D1  1  A6 2B        	LDX	BYWOR		;GET FLAG
0015D3  1  A0 00        	LDY	#0		;POINT TO LOW PART OF CODE
0015D5  1  A5 26        	LDA	EXP+1		;GET LOW PART OF RESULT
0015D7  1  99 7F 2D     	STA	CODE,Y		;SAVE IN CODE BUFFER
0015DA  1  E0 02        	CPX	#2		;SEE IF .WOR
0015DC  1  D0 06        	BNE	HBW20A		;JUMP IF NOT
0015DE  1  A5 25        	LDA	EXP		;IF .WOR GET HIGH PART
0015E0  1  C8           	INY			;BUMP CODE INDEX
0015E1  1  99 7F 2D     	STA	CODE,Y		;AND SAVE HIGH PART
0015E4  1  A5 1F        HBW20A:	LDA	FLAGS+1
0015E6  1  29 09        	AND	#9
0015E8  1  D0 08        	BNE	HBW20B
0015EA  1  E0 01        	CPX	#1
0015EC  1  D0 0D        	BNE	HBW20C
0015EE  1  A5 25        	LDA	EXP
0015F0  1  F0 09        	BEQ	HBW20C
0015F2  1  A4 2B        HBW20B:	LDY	BYWOR
0015F4  1  A9 04        	LDA	#4
0015F6  1  A6 21        	LDX	CSB
0015F8  1  4C FF 15     	JMP	HIYAAX
0015FB  1  A4 2B        HBW20C:	LDY	BYWOR
0015FD  1  A9 00        HIY00X:	LDA	#0
0015FF  1  20 B6 10     HIYAAX:	JSR	LTINS
001602  1  A6 20        HBW30:	LDX	COLP		;GET POINTER
001604  1  E4 28        	CPX	MAXCL		;SEE IF AT MAX
001606  1  F0 02        	BEQ	*+4		;OK IF IS
001608  1  B0 0E        	BCS	EXTBYT		;DONE IF PAST LAST
00160A  1  BD CB 2D     	LDA	LINE,X		;AND CHAR
00160D  1  C9 2C        	CMP	#','		;SEE IF COMMA
00160F  1  F0 0A        	BEQ	GOTCMA		;OK IF IS
001611  1  C9 20        	CMP	#BLANK		;SEE IF SPACE
001613  1  F0 03        	BEQ	EXTBYT		;EXIT IF IS
001615  1  4C FE 17     BADOPR:	JMP	HL318B		;BAD OPERAND FORMAT
001618  1  4C 31 19     EXTBYT:	JMP	NXT		;ELSE END OF LINE
00161B  1  20 87 0A     GOTCMA:	JSR	INCRP
00161E  1  86 20        	STX	COLP
001620  1  20 C7 0A     	JSR	FNDNB
001623  1  B0 A1        	BCS	HBW10
001625  1  4C 21 17     	JMP	HL307B
001628  1  A9 06        HBW40:	LDA	#6
00162A  1  D0 19        	BNE	HIJAAJ
00162C  1               ;EXPRESSION EVALUATION SAID EXPRESSION UNINTERPRETABLE
00162C  1               ;SO TEST FOR STRING
00162C  1  BD CB 2D     HBW60:	LDA	LINE,X		;GET FIRST CHAR
00162F  1  85 80        	STA	STRDEL		;SAVE FOR LATER USE
001631  1  C9 27        	CMP	#APOST		;SEE IF '
001633  1  F0 04        	BEQ	HBW60V		;IS SO MAY BE STRING
001635  1  C9 22        	CMP	#QUOTE		;ALSO CHECK "
001637  1  D0 0A        	BNE	HBW60A		;NOT SO IS ERR13 - INVALID EXP
001639  1  E4 21        HBW60V:	CPX	CSB		;MAY BE START OF STRING SO CHECK
00163B  1  D0 06        	BNE	HBW60A		;JUMP TO ERR13 IF INDEX AND STRING START NOT =
00163D  1  A4 2B        	LDY	BYWOR		;GET MODE FLAG
00163F  1  C0 01        	CPY	#1		;SEE IF .BYT
001641  1  F0 0E        	BEQ	HBW60B		;IS SO GET STRING
001643  1  A9 0D        HBW60A:	LDA	#13
001645  1  48           HIJAAJ:	PHA			;SAVE ERROR CODE
001646  1  20 1F 0B     	JSR	FNCMP		;SKIP TO NEXT FIELD
001649  1  68           	PLA			;GET ERROR CODE BACK
00164A  1  A4 2B        	LDY	BYWOR
00164C  1  A6 3D        	LDX	ERCOL
00164E  1  4C FF 15     	JMP	HIYAAX
001651  1               ;START PROCESSING .BYT '....'
001651  1  86 20        HBW60B:	STX	COLP		;SAVE POINTER
001653  1  A0 00        	LDY	#0		;SET INDEX TO START
001655  1               ;LOOP ENTRY FOR .BYT '....' PROCESSING
001655  1  A6 20        HBW70:	LDX	COLP		;GET POINTER
001657  1  20 87 0A     	JSR	INCRP		;GO TO NEXT CHAR
00165A  1  86 20        	STX	COLP		;SAVE POINTER
00165C  1  90 03        	BCC	*+5		;JUMP IS NOT EOL
00165E  1  4C 23 17     	JMP	HLY07B		;ELSE RAN OFF EOL ERROR
001661  1  BD CB 2D     	LDA	LINE,X		;GET CHAR
001664  1  C5 80        	CMP	STRDEL		;SEE IF SAME AS START DELIMITER
001666  1  D0 10        	BNE	HBW80		;IF NOT GO TEST FOR VALID
001668  1               ;HAVE A VALID STRING DELIMITER
001668  1  A6 20        	LDX	COLP		;GET POINTER
00166A  1  20 87 0A     	JSR	INCRP		;GO TO NEXT CHAR
00166D  1  86 20        	STX	COLP		;SAVE POINTER
00166F  1  B0 8C        	BCS	HIY00X		;IF EOL GO TO EOL PROCESSING
001671  1  BD CB 2D     	LDA	LINE,X		;GET CHAR
001674  1  C5 80        	CMP	STRDEL		;SEE IF SAME AS FIRST DELIMITER
001676  1  D0 85        	BNE	HIY00X		;NOT SO NOT DOUBLE
001678  1               ;HAVE A CHARACTER - SEE IF VALID
001678  1  C9 20        HBW80:	CMP	#BLANK		;SEE IF LESS THAN SPACE
00167A  1  90 04        	BCC	HBW80A		;IS SO ENTER 0
00167C  1  C9 7F        	CMP	#DELETE		;SEE IF < DELETE
00167E  1  90 02        	BCC	HBW80B		;IS SO VALID CHAR
001680  1  A9 00        HBW80A:	LDA	#0
001682  1  99 7F 2D     HBW80B:	STA	CODE,Y		;SAVE CHAR IN CODE BUFFER
001685  1  C8           	INY			;POINT TO NEXT BUFFER POSITION
001686  1  4C 55 16     	JMP	HBW70		;AND LOOP FOR MORE
001689  1               ;PROCESS .OPT DIRECTIVE
001689  1  20 C7 0A     H301:	JSR	FNDNB
00168C  1  B0 03        	BCS	*+5
00168E  1  4C AD 13     	JMP	HL0000
001691  1  A6 21        	LDX	CSB
001693  1  A9 03        	LDA	#3
001695  1  85 2F        	STA	LEN
001697  1  20 7B 0B     	JSR	CONSYM
00169A  1  B0 03        	BCS	*+5
00169C  1  4C 6A 15     	JMP	HL014B
00169F  1  A9 05        	LDA	#<OPTDIR
0016A1  1  85 13        	STA	TBLPTR
0016A3  1  A9 1F        	LDA	#>OPTDIR
0016A5  1  85 14        	STA	TBLPTR+1
0016A7  1  A2 09        	LDX	#NUMSAV-1
0016A9  1  4C 73 15     	JMP	H9938
0016AC  1               ;GENERATE KIM FILE
0016AC  1  09 20        KIM:	ORA	#%00100000	;SET BIT
0016AE  1  D0 26        	BNE	H390
0016B0  1               ;DO NOT GENERATE KIM FILE
0016B0  1  29 DF        NOKIM:	AND	#%11011111	;CLEAR BIT
0016B2  1  4C D6 16     	JMP	H390
0016B5  1  29 7F        H323:	AND	#127
0016B7  1  4C D6 16     	JMP	H390
0016BA  1  09 80        H302:	ORA	#128
0016BC  1  D0 18        	BNE	H390
0016BE  1  09 40        H303:	ORA	#64
0016C0  1  D0 14        	BNE	H390
0016C2  1  29 BF        H304:	AND	#191
0016C4  1  4C D6 16     	JMP	H390
0016C7  1  09 10        H307:	ORA	#16
0016C9  1  D0 0B        	BNE	H390
0016CB  1  29 EF        H308:	AND	#239
0016CD  1  4C D6 16     	JMP	H390
0016D0  1  09 04        H311:	ORA	#4
0016D2  1  D0 02        	BNE	H390
0016D4  1  29 FB        H312:	AND	#251
0016D6  1  85 1E        H390:	STA	FLAGS
0016D8  1  20 1F 0B     H390A:	JSR	FNCMP
0016DB  1  B0 03        	BCS	H8840
0016DD  1  4C AD 13     H8839:	JMP	HL0000
0016E0  1  BD CB 2D     H8840:	LDA	LINE,X
0016E3  1  C9 2C        	CMP	#','
0016E5  1  D0 F6        	BNE	H8839
0016E7  1  E8           	INX
0016E8  1  86 20        	STX	COLP
0016EA  1  4C 89 16     	JMP	H301
0016ED  1               ;OPCODE & OPERAND PSOCESSING SECTION
0016ED  1               ;FIRST CLEAR FLAGS AND VALUES
0016ED  1  A9 00        H201:	LDA	#0
0016EF  1  85 3A        	STA	OPTYP
0016F1  1  85 39        	STA	OPLEN
0016F3  1  85 3B        	STA	NOPV
0016F5  1  A8           	TAY
0016F6  1  A5 37        	LDA	OPBAS		;THIS WAS SET BY OPFND
0016F8  1  8D 7F 2D     	STA	CODE
0016FB  1  A5 38        	LDA	OPTEM
0016FD  1  C9 14        	CMP	#20
0016FF  1  D0 05        	BNE	H17
001701  1  A0 01        HL1000:	LDY	#1
001703  1  4C AF 13     	JMP	HLY000
001706  1  A5 22        H17:	LDA	CSE
001708  1  85 20        	STA	COLP
00170A  1  E6 20        	INC	COLP
00170C  1  20 C7 0A     	JSR	FNDNB
00170F  1  B0 09        	BCS	H9917
001711  1  A0 03        	LDY	#3
001713  1               ;ERR07 - RAN OFF LINE AT CSE
001713  1  A9 07        HLY07E:	LDA	#7
001715  1  A6 22        	LDX	CSE
001717  1  4C 2E 19     	JMP	LTS1
00171A  1  BD CB 2D     H9917:	LDA	LINE,X
00171D  1  C9 3B        	CMP	#SEMICO
00171F  1  D0 07        	BNE	H9934
001721  1  A0 03        HL307B:	LDY	#3
001723  1  A9 07        HLY07B:	LDA	#7
001725  1  4C DA 13     	JMP	HLYAAB
001728  1  C9 41        H9934:	CMP	#'A'
00172A  1  D0 20        	BNE	H39
00172C  1  E4 28        	CPX	MAXCL
00172E  1  F0 07        	BEQ	H9965
001730  1  BC CC 2D     	LDY	LINE+1,X
001733  1  C0 20        	CPY	#BLANK
001735  1  D0 15        	BNE	H39
001737  1  A4 38        H9965:	LDY	OPTEM
001739  1  B9 D9 1F     	LDA	KLTBL-1,Y
00173C  1  30 09        	BMI	HL305B
00173E  1  18           	CLC
00173F  1  65 37        	ADC	OPBAS
001741  1  8D 7F 2D     	STA	CODE
001744  1  4C 01 17     	JMP	HL1000
001747  1  A9 05        HL305B:	LDA	#5
001749  1  4C D8 13     	JMP	HL3AAB
00174C  1  C9 23        H39:	CMP	#'#'
00174E  1  D0 05        	BNE	H24
001750  1  A9 0A        	LDA	#10
001752  1  4C 5B 17     	JMP	H831
001755  1  C9 28        H24:	CMP	#'('
001757  1  D0 0E        	BNE	H23
001759  1  A9 05        	LDA	#5
00175B  1  85 3A        H831:	STA	OPTYP
00175D  1  E6 21        	INC	CSB
00175F  1  20 87 0A     	JSR	INCRP
001762  1  90 03        	BCC	H23
001764  1  4C 21 17     	JMP	HL307B
001767  1               ;EVALUATE THE OPERAND
001767  1  20 9E 0B     H23:	JSR	EVAL
00176A  1  A5 36        	LDA	RETURN		;TEST RESULT CODE
00176C  1  30 5C        	BMI	H20		;JUMP IF IT WAS GOOD!
00176E  1  A5 3A        	LDA	OPTYP		;IF BAD SEE IF WAS IMMEDIATE MODE
001770  1  C9 0A        	CMP	#10
001772  1  F0 11        	BEQ	H9935		;IF SO MAY BE SINGLE ASCII CHAR
001774  1  A5 36        	LDA	RETURN
001776  1  F0 4C        	BEQ	H202
001778  1               ;AT THIS POINT WE HAVE A GOOFY EXPRESSION
001778  1               ;MAKE A CHECK FOR RELATIVE ADDRESSING SO ONLY TWO BYTES
001778  1               ;GET ALLOCATED DURING FIRST PASS
001778  1  A5 38        	LDA	OPTEM		;GET TEMPLATE
00177A  1  C9 0E        	CMP	#14		;SEE IF RELATIVE
00177C  1  F0 3D        	BEQ	BAD2BY		;IF SO ALLOCATE ONLY TWO BYTES
00177E  1               ;GOOFY EXPRESSION AND 3 BYTE INSTRUCTION
00177E  1  A9 0D        HL313J:	LDA	#13
001780  1  A6 3D        HL3AAJ:	LDX	ERCOL
001782  1  4C FD 13     	JMP	HL3AAX
001785  1               ;BAD EXPRESSION AND IMMEDIATE MODE
001785  1  BD CB 2D     H9935:	LDA	LINE,X		;GET CHARACTER
001788  1               ;FIRST SEE IF A SINGLE CHARACTER
001788  1  C9 27        	CMP	#APOST		;LOOK FOR STARTING '
00178A  1  D0 2F        	BNE	BAD2BY		;NO SO SAY IS BAD
00178C  1  20 87 0A     	JSR	INCRP		;BUMP POINTER
00178F  1  90 05        	BCC	*+7		;JUMP IF NOT AT END
001791  1  A0 02        	LDY	#2		;ELSE FLAG AS ERROR
001793  1  4C 23 17     	JMP	HLY07B
001796  1  BD CB 2D     	LDA	LINE,X		;GET CHAR AFTER '
001799  1  C9 20        	CMP	#BLANK		;SEE IF SMALLER THAN SPACE
00179B  1  90 04        	BCC	H9921		;IS SO VALUE 0
00179D  1  C9 7F        	CMP	#DELETE		;SEE IF SMALLER THAN DELETE
00179F  1  90 02        	BCC	H9922		;IS SO STORE AS RESULT
0017A1  1  A9 00        H9921:	LDA	#0		;CLEAR LOW BYTE (HL ORDER)
0017A3  1  85 26        H9922:	STA	EXP+1		;STORE LOW (0 OR CHAR)
0017A5  1  A9 00        	LDA	#0		;HIGH PART ALWAYS 0
0017A7  1  85 25        	STA	EXP
0017A9  1  A9 F6        	LDA	#%11110110	;SET FLAG ASNO OVERFLOW & POS
0017AB  1  25 1F        	AND	FLAGS+1
0017AD  1  85 1F        	STA	FLAGS+1
0017AF  1  20 87 0A     	JSR	INCRP		;LOOK FOR NEXT CHAR
0017B2  1               ;CODE AT THIS POINT ALLOWS SINGLE CHARACTER TO BE TERMINATED BY
0017B2  1               ;END OF LINE OR A BLANK - THIS IS CANDIDATE FOR CHANGE TO RESTRICT
0017B2  1               ;SYNTAX.
0017B2  1  B0 16        	BCS	H20		;REACHED EOL
0017B4  1  BD CB 2D     	LDA	LINE,X		;GET CHAR
0017B7  1  C9 20        	CMP	#BLANK		;SEE IF SPACE
0017B9  1  F0 0F        	BEQ	H20		;IF SO OK
0017BB  1               ;WE HAVE A BAD 2-BYTE INSTRUCTION SO ERR 13
0017BB  1  A9 0D        BAD2BY:	LDA	#13
0017BD  1  A6 3D        HL2AAJ:	LDX	ERCOL
0017BF  1  A0 02        	LDY	#2
0017C1  1  4C 2E 19     	JMP	LTS1
0017C4  1  E6 3B        H202:	INC	NOPV
0017C6  1  A9 02        	LDA	#2
0017C8  1  85 39        	STA	OPLEN
0017CA  1  20 1F 0B     H20:	JSR	FNCMP		;FIND NON-EMBEDDED , OR )
0017CD  1  90 57        	BCC	H500		;JUMP IF NONE FOUND
0017CF  1  BD CB 2D     	LDA	LINE,X		;GET THE CHAR
0017D2  1  C9 29        	CMP	#')'
0017D4  1  D0 1B        	BNE	H51
0017D6  1  E6 3A        	INC	OPTYP
0017D8  1  E6 3A        	INC	OPTYP
0017DA  1  A5 37        	LDA	OPBAS
0017DC  1  C9 4C        	CMP	#$4C
0017DE  1  F0 4C        	BEQ	H140
0017E0  1  20 87 0A     	JSR	INCRP
0017E3  1  90 03        	BCC	*+5		;OK IF A CHAR
0017E5  1  4C 21 17     	JMP	HL307B
0017E8  1  BD CB 2D     	LDA	LINE,X		;GET CHAR
0017EB  1  C9 2C        	CMP	#','		;SEE IF COMMA
0017ED  1  F0 14        	BEQ	H51A		;BRANCH IF N),
0017EF  1  D0 0D        	BNE	HL318B		;ELSE N) IS ILLEGAL
0017F1  1  BD CB 2D     H51:	LDA	LINE,X
0017F4  1  C9 2C        	CMP	#','
0017F6  1  D0 13        	BNE	H203
0017F8  1  A5 37        	LDA	OPBAS		;GET BASE OPCODE
0017FA  1  C9 4C        	CMP	#$4C		;SEE IF JMP
0017FC  1  D0 05        	BNE	H51A		;JUMP IF NOT
0017FE  1               ;IF IS THEN IS ILLEGAL OPERAND FOR JMP
0017FE  1  A9 12        HL318B:	LDA	#18		;ERROR 18
001800  1  4C D8 13     	JMP	HL3AAB
001803  1  20 87 0A     H51A:	JSR	INCRP		;LOOK FOR NEXT CHAR
001806  1  90 03        	BCC	H203		;JUMP IF OK
001808  1  4C 21 17     	JMP	HL307B
00180B  1  BD CB 2D     H203:	LDA	LINE,X		;GET CHAR
00180E  1  C9 58        	CMP	#'X'
001810  1  D0 05        	BNE	H25
001812  1  E6 3A        	INC	OPTYP
001814  1  4C 4B 18     	JMP	H40
001817  1  C9 59        H25:	CMP	#'Y'
001819  1  F0 05        	BEQ	H27
00181B  1  A9 0C        	LDA	#12
00181D  1  4C FD 13     	JMP	HL3AAX
001820  1  E6 3A        H27:	INC	OPTYP
001822  1  E6 3A        	INC	OPTYP
001824  1  D0 25        	BNE	H40
001826  1  A5 37        H500:	LDA	OPBAS		;GET BASE OPCODE
001828  1  C9 4C        	CMP	#$4C		;SEE IF JMP
00182A  1  D0 1F        	BNE	H40		;JUMP IF NOT
00182C  1  A5 3A        H140:	LDA	OPTYP
00182E  1  D0 07        	BNE	H145
001830  1  A0 02        H140A:	LDY	#2
001832  1  84 39        	STY	OPLEN
001834  1  4C E4 18     	JMP	H46
001837  1  C9 07        H145:	CMP	#7
001839  1  D0 C3        	BNE	HL318B
00183B  1  A9 20        	LDA	#32
00183D  1  20 87 0A     	JSR	INCRP
001840  1  B0 EE        	BCS	H140A
001842  1  BC CB 2D     	LDY	LINE,X
001845  1  C0 20        	CPY	#BLANK
001847  1  F0 E7        	BEQ	H140A
001849  1  D0 B3        	BNE	HL318B
00184B  1  A5 3B        H40:	LDA	NOPV
00184D  1  D0 4E        	BNE	H41
00184F  1  A9 02        	LDA	#2
001851  1  85 39        	STA	OPLEN
001853  1  A5 38        	LDA	OPTEM
001855  1  C9 0E        	CMP	#14
001857  1  D0 18        	BNE	H22
001859  1  A5 1C        	LDA	PC
00185B  1  85 3F        	STA	TEMP
00185D  1  A5 1D        	LDA	PC+1
00185F  1  85 40        	STA	TEMP+1
001861  1  20 9C 0A     	JSR	RELADR
001864  1  B0 07        	BCS	HOP70
001866  1  A9 11        	LDA	#17		;RELATIVE BRANCH OUT OF RANGE ERROR
001868  1  A0 02        HL2AAB:	LDY	#2		;DO A TWO BYTE ERROR FOR CODE IN A
00186A  1  4C DA 13     	JMP	HLYAAB		;DO IT
00186D  1  A9 00        HOP70:	LDA	#0
00186F  1  85 25        	STA	EXP
001871  1  A5 3A        H22:	LDA	OPTYP
001873  1  C9 06        	CMP	#6
001875  1  90 0E        	BCC	H400
001877  1  C9 0A        	CMP	#10
001879  1  B0 0A        	BCS	H400
00187B  1  20 8E 0A     	JSR	INDADR
00187E  1  B0 05        	BCS	H400
001880  1  A9 13        	LDA	#19		;INDIRECT OPERAND OUT-OF-RANGE
001882  1  4C BD 17     	JMP	HL2AAJ		;DO TWO BYTE ERROR
001885  1  A5 25        H400:	LDA	EXP
001887  1  D0 14        	BNE	H41
001889  1  A9 01        	LDA	#1
00188B  1  85 39        	STA	OPLEN
00188D  1  A5 3A        	LDA	OPTYP
00188F  1  18           	CLC
001890  1  69 02        	ADC	#2
001892  1  85 3A        	STA	OPTYP
001894  1  C9 0D        H50:	CMP	#13
001896  1  90 10        	BCC	H45
001898  1  A9 0F        	LDA	#15
00189A  1  4C D8 13     	JMP	HL3AAB
00189D  1  A5 3A        H41:	LDA	OPTYP
00189F  1  18           	CLC
0018A0  1  69 0D        	ADC	#13
0018A2  1  85 3A        	STA	OPTYP
0018A4  1  C9 10        H47:	CMP	#16
0018A6  1  B0 0E        	BCS	H49
0018A8  1  A8           H45:	TAY
0018A9  1  88           	DEY
0018AA  1  B9 CB 1F     	LDA	KLUDG,Y
0018AD  1  18           	CLC
0018AE  1  65 38        	ADC	OPTEM
0018B0  1  A8           	TAY
0018B1  1  B9 DA 1F     	LDA	KLTBL,Y
0018B4  1  10 2E        	BPL	H46
0018B6  1  A5 3B        H49:	LDA	NOPV
0018B8  1  F0 15        	BEQ	H48
0018BA  1  A5 39        	LDA	OPLEN
0018BC  1  C9 02        	CMP	#2
0018BE  1  F0 03        	BEQ	*+5
0018C0  1  4C FE 17     	JMP	HL318B
0018C3  1  C6 39        	DEC	OPLEN
0018C5  1  A5 3A        	LDA	OPTYP
0018C7  1  38           	SEC
0018C8  1  E9 0B        	SBC #11
0018CA  1  85 3A        	STA	OPTYP
0018CC  1  4C 94 18     	JMP	H50
0018CF  1  A5 39        H48:	LDA	OPLEN
0018D1  1  C9 01        	CMP	#1
0018D3  1  F0 03        	BEQ	*+5
0018D5  1  4C FE 17     	JMP	HL318B
0018D8  1  E6 39        	INC	OPLEN
0018DA  1  A5 3A        	LDA	OPTYP
0018DC  1  18           	CLC
0018DD  1  69 0B        	ADC	#11
0018DF  1  85 3A        	STA	OPTYP
0018E1  1  4C A4 18     	JMP	H47
0018E4  1  18           H46:	CLC
0018E5  1  65 37        	ADC	OPBAS
0018E7  1  A0 00        	LDY	#0
0018E9  1  99 7F 2D     	STA	CODE,Y
0018EC  1  A5 3B        	LDA	NOPV
0018EE  1  D0 30        	BNE	HL301X
0018F0  1  C8           	INY
0018F1  1  A5 26        	LDA	EXP+1
0018F3  1  99 7F 2D     	STA	CODE,Y
0018F6  1  C8           	INY
0018F7  1  A5 39        	LDA	OPLEN
0018F9  1  C9 01        	CMP	#1
0018FB  1  F0 05        	BEQ	H9931A
0018FD  1  A5 25        	LDA	EXP
0018FF  1  99 7F 2D     	STA	CODE,Y
001902  1  A9 09        H9931A:	LDA	#9
001904  1  25 1F        	AND	FLAGS+1
001906  1  F0 08        	BEQ	H9931B
001908  1  A4 39        HLJ04B:	LDY	OPLEN
00190A  1  C8           	INY
00190B  1  A9 04        	LDA	#4
00190D  1  4C DA 13     	JMP	HLYAAB
001910  1  A5 39        H9931B:	LDA	OPLEN
001912  1  C9 01        	CMP	#1
001914  1  D0 04        	BNE	HLJ000
001916  1  A5 25        	LDA	EXP
001918  1  D0 EE        	BNE	HLJ04B
00191A  1  A4 39        HLJ000:	LDY	OPLEN
00191C  1  C8           	INY
00191D  1  4C AF 13     	JMP	HLY000
001920  1  AD 7F 2D     HL301X:	LDA	CODE
001923  1  A0 03        	LDY	#3
001925  1  29 1F        	AND	#$1F
001927  1  C9 10        	CMP	#$10
001929  1  D0 01        	BNE	*+3
00192B  1  88           	DEY
00192C  1  A9 01        	LDA	#1
00192E  1               ;GENERAL ERROR HANDLER
00192E  1               ;FIRST INSERTS AN ERROR CODE INTO TABLE
00192E  1               ;THEN RESETS STACK SO THAT SYSTEM RETURNS TO RECOVERY POINT
00192E  1               ;REGARDLESS OF HOW FAR DOWN THE PARSER HAS GONE.
00192E  1               ;ASM RESETS STACK TO $FF SO THIS IS WHAT DEFINES RECOVERY POINT
00192E  1               ;	STACK = $FD --> AFTER JSR DOPASS (EITHER 1ST OR 2ND)
00192E  1               ;	STACK = $FB --> AFTER JSR PROCES
00192E  1               ;C=0 SO DOPASS WILL TRY NEXT LINE
00192E  1  20 B6 10     LTS1:	JSR	LTINS		;SAVE CODE
001931  1  A2 FB        NXT:	LDX	#$FB		;RECOVER TO JSR PROCES
001933  1  9A           	TXS
001934  1  18           	CLC			;NOT EOF
001935  1  60           	RTS
001936  1               ;DO ONE PASS THROUGH THE SOURCE FILE
001936  1  A9 7F        DOPASS:	LDA	#<(SRCBUF+SRCLNG)	;SET INDEX
001938  1  A0 25        	LDY	#>(SRCBUF+SRCLNG)	;TO
00193A  1  85 05        	STA	SRCIND		;ILLEGAL
00193C  1  84 06        	STY	SRCIND+1	;VALUE
00193E  1  20 69 13     	JSR	PROCES
001941  1  90 FB        	BCC	*-3
001943  1  60           	RTS
001944  1               ;-------------------------------
001944  1               ;MAIN PROCESSING ROUTINE
001944  1               ;-------------------------------
001944  1  A9 03        MAIN:	LDA	#<STRMSG	;POINT TO
001946  1  A0 1B        	LDY	#>STRMSG	;START MESSAGE
001948  1  20 50 08     	JSR	WRCNMS		;WRITE IT
00194B  1               ;CLEAR PAGE ZERO
00194B  1  A2 02        	LDX	#2		;SET INDEX
00194D  1  A9 00        	LDA	#0		;CLEAR A
00194F  1  95 00        CLRZP:	STA	$00,X		;CLEAR MEM
001951  1  E8           	INX			;BUMP COUNT
001952  1  E0 81        	CPX	#LASTZP		;COMPARE TO END
001954  1  D0 F9        	BNE	CLRZP		;LOOP IF MORE
001956  1               ;MAKE SURE SYMLEN AT LEAST 6
001956  1  AD 03 08     	LDA	SYMLEN		;GET SYMBOL LENGTH
001959  1  C9 06        	CMP	#6		;AND TEST
00195B  1  B0 05        	BCS	SYMLOK		;OK IF >= 6
00195D  1  A9 06        	LDA	#6		;ELSE FORCE TO 6
00195F  1  8D 03 08     	STA	SYMLEN
001962  1               ;CHECK DEFAULT FCB FOR VALID UFN FOR SOURCE
001962  1  A2 08        SYMLOK:	LDX	#8
001964  1  BD 07 01     SFB:	LDA	DFLFCB,X
001967  1  C9 3F        	CMP	#'?'
001969  1  F0 0E        	BEQ	BDF		;IS AN AFN SO NOT VALID
00196B  1  9D 1C 21     	STA	SRCFCB,X
00196E  1  9D 3D 21     	STA	KIMFCB,X
001971  1  9D 5E 21     	STA	LSTFCB,X	;INSERT IN LIST FCB
001974  1  CA           	DEX
001975  1  10 ED        	BPL	SFB
001977  1  30 03        	BMI	*+5
001979  1  4C 86 08     BDF:	JMP	DOSERR		;ABORT FOR DISK ERROR
00197C  1  AD 10 01     	LDA	DFLFCB+9	;GET SOURCE LOC IF ANY
00197F  1  C9 20        	CMP	#BLANK		;SEE IF BLANK
001981  1  F0 3B        	BEQ	USEDFL		;USE DEFAULT IF IS
001983  1  20 29 08     	JSR	CHKDRV		;CHECK FOR LEGAL
001986  1  8D 1C 21     	STA	SRCFCB		;AND SET
001989  1  AD 11 01     	LDA	DFLFCB+10	;TRY FOR KIM
00198C  1  C9 20        	CMP	#BLANK		;SEE IF NONE
00198E  1  F0 2E        	BEQ	USEDFL		;USE DEFAULT IF SO
001990  1  C9 5A        	CMP	#'Z'		;SEE IF Z
001992  1  D0 05        	BNE	TRYKAH		;IF NOT TRY FOR A-H
001994  1  38           	SEC			;ELSE SET NO KIM FLAG
001995  1  66 7F        	ROR	NKMFLG
001997  1  30 06        	BMI	TSTPRN		;THEN GO TRY PRN
001999  1  20 29 08     TRYKAH:	JSR	CHKDRV		;ELSE GO CHECK
00199C  1  8D 3D 21     	STA	KIMFCB		;AND SET
00199F  1  AD 12 01     TSTPRN:	LDA	DFLFCB+11	;TRY LIST
0019A2  1  C9 20        	CMP	#BLANK		;DO SAME FOR IT
0019A4  1  F0 18        	BEQ	USEDFL		;IF BLANK
0019A6  1  C9 58        	CMP	#'X'		;SEE IF X
0019A8  1  D0 05        	BNE	TRYLST		;IF NOT TRY Z
0019AA  1  38           	SEC			;SET CONSOLE OUTPUT
0019AB  1  66 7D        	ROR	LSTFLG
0019AD  1  30 0F        	BMI	USEDFL		;AND PRESS ON
0019AF  1  C9 5A        TRYLST:	CMP	#'Z'		;SEE IF Z
0019B1  1  D0 05        	BNE	TRYAH		;IF NOT TRY A TO H
0019B3  1  38           	SEC			;SET NO LIST FLAG
0019B4  1  66 7E        	ROR	NLSFLG
0019B6  1  30 06        	BMI	USEDFL		;AND PRESS
0019B8  1  20 29 08     TRYAH:	JSR	CHKDRV		;THEN CHECK
0019BB  1  8D 5E 21     	STA	LSTFCB		;AND SET
0019BE  1  20 90 08     USEDFL:	JSR	SSRFCB
0019C1  1  20 54 08     	JSR	OPNFIL
0019C4  1  F0 B3        	BEQ	BDF
0019C6  1  20 9F 08     	JSR	DLTKIM
0019C9  1  24 7F        	BIT	NKMFLG		;TEST NO KIM FLAG
0019CB  1  30 10        	BMI	SKPKIM		;SKIP IF SET
0019CD  1  20 95 08     	JSR	SKMFCB
0019D0  1  20 60 08     	JSR	CRTFIL
0019D3  1  F0 A4        	BEQ	BDF
0019D5  1  20 95 08     	JSR	SKMFCB
0019D8  1  20 54 08     	JSR	OPNFIL
0019DB  1  F0 9C        	BEQ	BDF
0019DD  1  20 9A 08     SKPKIM:	JSR	SLSFCB		;POINT TO LIST FCB
0019E0  1  20 5C 08     	JSR	DLTFIL		;DELETE IT
0019E3  1  A5 7D        	LDA	LSTFLG		;SEE IF NO .PRN FILE
0019E5  1  05 7E        	ORA	NLSFLG
0019E7  1  30 10        	BMI	SKPLST		;IF SO SKIP AHEAD
0019E9  1  20 9A 08     	JSR	SLSFCB		;POINT AGAIN
0019EC  1  20 60 08     	JSR	CRTFIL		;NOW MAKE IT
0019EF  1  F0 88        	BEQ	BDF		;EXIT IF BAD
0019F1  1  20 9A 08     	JSR	SLSFCB		;POINT ONCE MORE
0019F4  1  20 54 08     	JSR	OPNFIL		;OPEN IT
0019F7  1  F0 80        	BEQ	BDF		;EXIT IF BAD
0019F9  1  A9 F4        SKPLST:	LDA	#%11110100	;SET DEFAULT
0019FB  1  85 1E        	STA	FLAGS		;FLAGS
0019FD  1               ;CALCULATE SYMBOL TABLE START ADDRESS
0019FD  1  A9 6F        	LDA	#<SYM		;GET BUFFER START
0019FF  1  A0 2E        	LDY	#>SYM
001A01  1  18           	CLC			;NO ADD SYMBOL LENGTH
001A02  1  6D 03 08     	ADC	SYMLEN
001A05  1  85 0B        	STA	STSAVE		;SET LOW
001A07  1  90 01        	BCC	STHIOK		;HIGH OK IF NO CARRY
001A09  1  C8           	INY			;ELSE BUMP HIGH
001A0A  1  84 0C        STHIOK:	STY	STSAVE+1	;SAVE HIGH
001A0C  1               ;NOW CALCULATE UPPER LIMIT
001A0C  1  AD 04 01     	LDA	PEM+1		;GET PEM ADDRESS
001A0F  1  AC 05 01     	LDY	PEM+2
001A12  1  38           	SEC			;DROP BY SYMBOL LENGTH
001A13  1  ED 03 08     	SBC	SYMLEN
001A16  1  85 0D        	STA	TBLSZ
001A18  1  B0 01        	BCS	*+3
001A1A  1  88           	DEY
001A1B  1  84 0E        	STY	TBLSZ+1
001A1D  1  38           	SEC			;DROP BY TWO MORE
001A1E  1  A5 0D        	LDA	TBLSZ
001A20  1  E9 02        	SBC	#2
001A22  1  85 0D        	STA	TBLSZ
001A24  1  B0 02        	BCS	NTBORW		;DONE IF NO BORROW
001A26  1  C6 0E        	DEC	TBLSZ+1
001A28  1  A2 FF        NTBORW:	LDX	#$FF
001A2A  1  9A           	TXS
001A2B  1  A9 D1        	LDA	#<PS1MSG 	;SEND START OF PASS 1 MSG
001A2D  1  A0 1A        	LDY	#>PS1MSG
001A2F  1  20 50 08     	JSR	WRCNMS
001A32  1  20 36 19     	JSR	DOPASS
001A35  1  A9 3F        	LDA	#<SRTMSG 	;POINT TO
001A37  1  A0 1B        	LDY	#>SRTMSG 	;END OF PASS ONE MESSAGE
001A39  1  20 50 08     	JSR	WRCNMS		;PRINT IT
001A3C  1  A9 00        	LDA	#0
001A3E  1  85 16        	STA	LINENO
001A40  1  85 17        	STA	LINENO+1
001A42  1  85 1C        	STA	PC
001A44  1  85 1D        	STA	PC+1
001A46  1  85 1A        	STA	ERCT
001A48  1  85 1B        	STA	ERCT+1
001A4A  1  85 4D        	STA	BYTCNT
001A4C  1  8D 28 21     	STA	SRCFCB+12
001A4F  1  8D 29 21     	STA	SRCFCB+13	;CLEAR BOTH EXTENT BYTES
001A52  1  8D 3C 21     	STA	SRCFCB+32
001A55  1  A9 F4        	LDA	#%11110100	;SET DEFAULT
001A57  1  85 1E        	STA	FLAGS		;FLAGS
001A59  1  A9 FF        	LDA	#$FF		;CHANGE
001A5B  1  85 04        	STA	PASNUM		;PASS NUMBER
001A5D  1  20 90 08     	JSR	SSRFCB
001A60  1  20 54 08     	JSR	OPNFIL
001A63  1  20 02 0A     	JSR	SORT		;SORT SYMBOL TABLE
001A66  1  20 DE 09     	JSR	CCRLF		;SEND CR AND LF TO CONSOLE
001A69  1  A9 E3        	LDA	#<PS2MSG	;SEND START OF PASS 2 MSG
001A6B  1  A0 1A        	LDY	#>PS2MSG
001A6D  1  20 50 08     	JSR	WRCNMS
001A70  1  20 F1 08     	JSR	CLKIND		;CLEAR KIM INDEX
001A73  1  20 60 09     	JSR	CLLIND		;CLEAR LIST INDEX
001A76  1  20 36 19     	JSR	DOPASS
001A79  1  A9 71        	LDA	#<ERNMSG 	;POINT TO
001A7B  1  A0 1B        	LDY	#>ERNMSG 	;ERROR COUNT MESSAGE
001A7D  1  20 50 08     	JSR	WRCNMS		;WRITE IT
001A80  1  A5 1A        	LDA	ERCT		;THEN HIGH
001A82  1  20 C2 09     	JSR	CNUMA		;BYTE OF COUNT
001A85  1  A5 1B        	LDA	ERCT+1		;THEN LOW
001A87  1  20 C2 09     	JSR	CNUMA		;BYTE OF COUNT
001A8A  1  20 DE 09     	JSR	CCRLF		;SEND A LAST CR AND LF
001A8D  1  24 7F        	BIT	NKMFLG		;TEST FOR NO KIM
001A8F  1  30 1D        	BMI	SKKMFO		;DONE IF SET
001A91  1  20 A9 12     	JSR	WRKMRC
001A94  1  38           FLSHKM:	SEC			;SEE IF
001A95  1  A5 07        	LDA	KIMIND		;WHOLE
001A97  1  E9 7F        	SBC	#<KIMBUF	;NUMBER
001A99  1  29 7F        	AND	#127		;SECTORS
001A9B  1  F0 08        	BEQ	WHLREC		;BRANCH IF IT IS
001A9D  1  A9 1A        	LDA	#EOF		;ELSE INSERT
001A9F  1  20 80 09     	JSR	KIMOUT		;AN EOF
001AA2  1  4C 94 1A     	JMP	FLSHKM		;AND LOOP
001AA5  1  20 B2 08     WHLREC:	JSR	WRTKIM		;WRITE LAST SECTOR
001AA8  1  20 95 08     	JSR	SKMFCB
001AAB  1  20 58 08     	JSR	CLSFIL
001AAE  1  A5 7D        SKKMFO:	LDA	LSTFLG		;SEE IF NO LIST
001AB0  1  05 7E        	ORA	NLSFLG
001AB2  1  30 1A        	BMI	EXTSYS		;EXIT IF NONE
001AB4  1  38           FLSHLS:	SEC			;SEE IF LIST
001AB5  1  A5 09        	LDA	LSTIND		;INDEX A WHOLE
001AB7  1  E9 7F        	SBC	#<LSTBUF	;NUMBER SECTORS
001AB9  1  29 7F        	AND	#127		;OF 128
001ABB  1  F0 08        	BEQ	WHLLST		;JUMP IF IT IS
001ABD  1  A9 1A        	LDA	#EOF		;ELSE GET AN EOF
001ABF  1  20 9C 09     	JSR	OUTPUT		;SEND TO BUFFER
001AC2  1  4C B4 1A     	JMP	FLSHLS		;AND LOOP
001AC5  1  20 21 09     WHLLST:	JSR	WRTLST		;NOW WRITE FILE
001AC8  1  20 9A 08     	JSR	SLSFCB		;POINT TO IT
001ACB  1  20 58 08     	JSR	CLSFIL		;CLOSE IT
001ACE  1  4C 3B 08     EXTSYS:	JMP	WRMBTE
001AD1  1               ;MESSAGES
001AD1  1  53 54 41 52  PS1MSG:	.BYTE	"START OF PASS 1",CR,LF,"$"
001AD5  1  54 20 4F 46  
001AD9  1  20 50 41 53  
001AE3  1  53 54 41 52  PS2MSG:	.BYTE	"START OF PASS 2",CR,LF,"$"
001AE7  1  54 20 4F 46  
001AEB  1  20 50 41 53  
001AF5  1  45 4E 44 20  ENDMSG:	.BYTE	"END OF PASS 2$"
001AF9  1  4F 46 20 50  
001AFD  1  41 53 53 20  
001B03  1  44 4F 53 2F  STRMSG:	.BYTE	"DOS/65 ASSEMBLER",CR,LF
001B07  1  36 35 20 41  
001B0B  1  53 53 45 4D  
001B15  1  56 45 52 53  	.BYTE	"VERSION 2.11-A",CR,LF,"$"
001B19  1  49 4F 4E 20  
001B1D  1  32 2E 31 31  
001B26  1  49 4C 4C 45  ILDMSG:	.BYTE	"ILLEGAL DRIVE DESIGNATOR$"
001B2A  1  47 41 4C 20  
001B2E  1  44 52 49 56  
001B3F  1  45 4E 44 20  SRTMSG:	.BYTE	"END OF PASS 1",CR,LF
001B43  1  4F 46 20 50  
001B47  1  41 53 53 20  
001B4E  1  53 4F 52 54  	.BYTE	"SORTING SYMBOL TABLE"
001B52  1  49 4E 47 20  
001B56  1  53 59 4D 42  
001B62  1  20 2D 20 50  	.BYTE	" - PLEASE WAIT$"
001B66  1  4C 45 41 53  
001B6A  1  45 20 57 41  
001B71  1  4E 55 4D 42  ERNMSG:	.BYTE	"NUMBER OF ERRORS = $"
001B75  1  45 52 20 4F  
001B79  1  46 20 45 52  
001B85  1  2A 2A 45 52  ERRMSG:	.BYTE	"**ERROR**$"
001B89  1  52 4F 52 2A  
001B8D  1  2A 24        
001B8F  1  0D 0A 44 4F  PERMSG:	.BYTE	CR,LF,"DOS/65 FILE ERROR - ASSEMBLY "
001B93  1  53 2F 36 35  
001B97  1  20 46 49 4C  
001BAE  1  41 42 4F 52  	.BYTE	"ABORTED$"
001BB2  1  54 45 44 24  
001BB6  1               ;ERROR MESSAGE VECTOR TABLE
001BB6  1  00 00 EA 1B  ERRVEC:	.WORD	0,ERR01,ERR02,ERR03,ERR04
001BBA  1  FB 1B 14 1C  
001BBE  1  2E 1C        
001BC0  1  40 1C 5D 1C  	.WORD	ERR05,ERR06,ERR07,ERR08,ERR09
001BC4  1  7F 1C 93 1C  
001BC8  1  C2 1C        
001BCA  1  D1 1C FB 1C  	.WORD	ERR10,ERR11,ERR12,ERR13,ERR14
001BCE  1  1E 1D 3D 1D  
001BD2  1  50 1D        
001BD4  1  6E 1D 91 1D  	.WORD	ERR15,ERR16,ERR17,ERR18,ERR19
001BD8  1  B3 1D D0 1D  
001BDC  1  FA 1D        
001BDE  1  1F 1E 42 1E  	.WORD	ERR20,ERR21,ERR22,ERR23,ERR24
001BE2  1  68 1E 90 1E  
001BE6  1  A5 1E        
001BE8  1  C2 1E        	.WORD	ERR25
001BEA  1               ;ASSEMBLER ERROR MESSAGES
001BEA  1  55 4E 44 45  ERR01:	.BYTE	"UNDEFINED SYMBOL$"
001BEE  1  46 49 4E 45  
001BF2  1  44 20 53 59  
001BFB  1  4C 41 42 45  ERR02:	.BYTE	"LABEL PREVIOUSLY DEFINED$"
001BFF  1  4C 20 50 52  
001C03  1  45 56 49 4F  
001C14  1  49 4C 4C 45  ERR03:	.BYTE	"ILLEGAL OR MISSING OPCODE$"
001C18  1  47 41 4C 20  
001C1C  1  4F 52 20 4D  
001C2E  1  41 44 44 52  ERR04:	.BYTE	"ADDRESS NOT VALID$"
001C32  1  45 53 53 20  
001C36  1  4E 4F 54 20  
001C40  1  41 43 43 55  ERR05:	.BYTE	"ACCUMULATOR MODE NOT ALLOWED$"
001C44  1  4D 55 4C 41  
001C48  1  54 4F 52 20  
001C5D  1  46 4F 52 57  ERR06:	.BYTE	"FORWARD REFERENCE IN .BYT OR "
001C61  1  41 52 44 20  
001C65  1  52 45 46 45  
001C7A  1  2E 57 4F 52  	.BYTE	".WOR$"
001C7E  1  24           
001C7F  1  52 41 4E 20  ERR07:	.BYTE	"RAN OFF END OF LINE$"
001C83  1  4F 46 46 20  
001C87  1  45 4E 44 20  
001C93  1  4C 41 42 45  ERR08:	.BYTE	"LABEL DOES NOT BEGIN WITH "
001C97  1  4C 20 44 4F  
001C9B  1  45 53 20 4E  
001CAD  1  41 4C 50 48  	.BYTE	"ALPHABETIC CHARACTER$"
001CB1  1  41 42 45 54  
001CB5  1  49 43 20 43  
001CC2  1  4C 41 42 45  ERR09:	.BYTE	"LABEL TOO LONG$"
001CC6  1  4C 20 54 4F  
001CCA  1  4F 20 4C 4F  
001CD1  1  4C 41 42 45  ERR10:	.BYTE	"LABEL OR OPCODE CONTAINS "
001CD5  1  4C 20 4F 52  
001CD9  1  20 4F 50 43  
001CEA  1  4E 4F 4E 2D  	.BYTE	"NON-ALPHANUMERIC$"
001CEE  1  41 4C 50 48  
001CF2  1  41 4E 55 4D  
001CFB  1  46 4F 52 57  ERR11:	.BYTE	"FORWARD REFERENCE IN EQUATE "
001CFF  1  41 52 44 20  
001D03  1  52 45 46 45  
001D17  1  4F 52 20 4F  	.BYTE	"OR ORG$"
001D1B  1  52 47 24     
001D1E  1  49 4E 56 41  ERR12:	.BYTE	"INVALID INDEX - MUST BE X OR"
001D22  1  4C 49 44 20  
001D26  1  49 4E 44 45  
001D3A  1  20 59 24     	.BYTE	" Y$"
001D3D  1  49 4E 56 41  ERR13:	.BYTE	"INVALID EXPRESSION$"
001D41  1  4C 49 44 20  
001D45  1  45 58 50 52  
001D50  1  55 4E 44 45  ERR14:	.BYTE	"UNDEFINED ASSEMBLER DIRECTIVE$"
001D54  1  46 49 4E 45  
001D58  1  44 20 41 53  
001D6E  1  49 4E 56 41  ERR15:	.BYTE	"INVALID OPERAND FOR PAGE ZERO "
001D72  1  4C 49 44 20  
001D76  1  4F 50 45 52  
001D8C  1  4D 4F 44 45  	.BYTE	"MODE$"
001D90  1  24           
001D91  1  49 4E 56 41  ERR16:	.BYTE	"INVALID OPERAND FOR ABSOLUTE "
001D95  1  4C 49 44 20  
001D99  1  4F 50 45 52  
001DAE  1  4D 4F 44 45  	.BYTE	"MODE$"
001DB2  1  24           
001DB3  1  52 45 4C 41  ERR17:	.BYTE	"RELATIVE BRANCH OUT OF RANGE$"
001DB7  1  54 49 56 45  
001DBB  1  20 42 52 41  
001DD0  1  49 4C 4C 45  ERR18:	.BYTE	"ILLEGAL OPERAND TYPE FOR THIS "
001DD4  1  47 41 4C 20  
001DD8  1  4F 50 45 52  
001DEE  1  49 4E 53 54  	.BYTE	"INSTRUCTION$"
001DF2  1  52 55 43 54  
001DF6  1  49 4F 4E 24  
001DFA  1  4F 55 54 20  ERR19:	.BYTE	"OUT OF BOUNDS ON INDIRECT "
001DFE  1  4F 46 20 42  
001E02  1  4F 55 4E 44  
001E14  1  41 44 44 52  	.BYTE	"ADDRESSING$"
001E18  1  45 53 53 49  
001E1C  1  4E 47 24     
001E1F  1  41 2C 58 2C  ERR20:	.BYTE	"A,X,Y,S, AND P ARE RESERVED "
001E23  1  59 2C 53 2C  
001E27  1  20 41 4E 44  
001E3B  1  4C 41 42 45  	.BYTE	"LABELS$"
001E3F  1  4C 53 24     
001E42  1  50 52 4F 47  ERR21:	.BYTE	"PROGRAM COUNTER NEGATIVE - "
001E46  1  52 41 4D 20  
001E4A  1  43 4F 55 4E  
001E5D  1  52 45 53 45  	.BYTE	"RESET TO 0$"
001E61  1  54 20 54 4F  
001E65  1  20 30 24     
001E68  1  49 4E 56 41  ERR22:	.BYTE	"INVALID CHARACTER - EXPECTING"
001E6C  1  4C 49 44 20  
001E70  1  43 48 41 52  
001E85  1  20 3D 20 46  	.BYTE	" = FOR ORG$"
001E89  1  4F 52 20 4F  
001E8D  1  52 47 24     
001E90  1  53 4F 55 52  ERR23:	.BYTE	"SOURCE LINE TOO LONG$"
001E94  1  43 45 20 4C  
001E98  1  49 4E 45 20  
001EA5  1  44 49 56 49  ERR24:	.BYTE	"DIVIDE BY ZERO IN EXPRESSION$"
001EA9  1  44 45 20 42  
001EAD  1  59 20 5A 45  
001EC2  1  53 59 4D 42  ERR25:	.BYTE	"SYMBOL TABLE OVERFLOW$"
001EC6  1  4F 4C 20 54  
001ECA  1  41 42 4C 45  
001ED8  1               ;DIRECTIVE AND OPTION JUMP TABLE
001ED8  1  D4 16 D0 16  ASMJMP:	.WORD	H312,H311,H308,H307
001EDC  1  CB 16 C7 16  
001EE0  1  B0 16 AC 16  	.WORD	NOKIM,KIM,H304,H303,H302
001EE4  1  C2 16 BE 16  
001EE8  1  BA 16        
001EEA  1  B5 16 89 16  	.WORD	H323,H301,H10,PAGE
001EEE  1  83 11 A1 15  
001EF2  1  BA 15 B6 15  	.WORD	H113,H111
001EF6  1               ;ASSEMBLER DIRECTIVES
001EF6  1  42 59 54 57  ASMDIR:	.BYTE	"BYTWORPAGENDOPT"
001EFA  1  4F 52 50 41  
001EFE  1  47 45 4E 44  
001F05  1               ;OPTION PARAMETERS
001F05  1  47 45 4E 4E  OPTDIR:	.BYTE	"GENNOGSYMNOSKIMNOK"
001F09  1  4F 47 53 59  
001F0D  1  4D 4E 4F 53  
001F17  1  45 52 52 4E  	.BYTE	"ERRNOELISNOL"
001F1B  1  4F 45 4C 49  
001F1F  1  53 4E 4F 4C  
001F23  1               ;OP-CODES
001F23  1  41 44 43 41  OPRNDS:	.BYTE	"ADCANDASLBCCBCSBEQBITBMI"
001F27  1  4E 44 41 53  
001F2B  1  4C 42 43 43  
001F3B  1  42 4E 45 42  	.BYTE	"BNEBPLBRKBVCBVSCLCCLDCLI"
001F3F  1  50 4C 42 52  
001F43  1  4B 42 56 43  
001F53  1  43 4C 56 43  	.BYTE	"CLVCMPCPXCPYDECDEXDEYEOR"
001F57  1  4D 50 43 50  
001F5B  1  58 43 50 59  
001F6B  1  49 4E 43 49  	.BYTE	"INCINXINYJMPJSRLDALDXLDY"
001F6F  1  4E 58 49 4E  
001F73  1  59 4A 4D 50  
001F83  1  4C 53 52 4E  	.BYTE	"LSRNOPORAPHAPHPPLAPLPROL"
001F87  1  4F 50 4F 52  
001F8B  1  41 50 48 41  
001F9B  1  52 4F 52 52  	.BYTE	"RORRTIRTSSBCSECSEDSEISTA"
001F9F  1  54 49 52 54  
001FA3  1  53 53 42 43  
001FB3  1  53 54 58 53  	.BYTE	"STXSTYTAXTAYTSXTXATXSTYA"
001FB7  1  54 59 54 41  
001FBB  1  58 54 41 59  
001FCB  1  FF 0D 1B 29  KLUDG:	.BYTE	255,13,27,41,55,69,83,97
001FCF  1  37 45 53 61  
001FD3  1  6F 7D 8B 99  	.BYTE	111,125,139,153,167,181,195
001FD7  1  A7 B5 C3     
001FDA  1  FF FF FF FF  KLTBL:	.BYTE	255,255,255,255,4,255,255,255
001FDE  1  04 FF FF FF  
001FE2  1  FF FF FF FF  	.BYTE	255,255,255,255,255,255,4,4
001FE6  1  FF FF 04 04  
001FEA  1  FF FF 00 04  	.BYTE	255,255,0,4,0,4,0,0
001FEE  1  00 04 00 00  
001FF2  1  04 00 FF 00  	.BYTE	4,0,255,0,20,20,255,255
001FF6  1  14 14 FF FF  
001FFA  1  10 FF FF 14  	.BYTE	16,255,255,20,255,16,255,16
001FFE  1  FF 10 FF 10  
002002  1  FF FF FF FF  	.BYTE	255,255,255,255,255,255,255,255
002006  1  FF FF FF FF  
00200A  1  FF FF 10 FF  	.BYTE	255,255,16,255,20,255,255,255
00200E  1  14 FF FF FF  
002012  1  FF FF FF FF  	.BYTE	255,255,255,255,255,255,255,255
002016  1  FF FF FF FF  
00201A  1  FF FF FF FF  	.BYTE	255,255,255,255,255,255,255,255
00201E  1  FF FF FF FF  
002022  1  FF FF FF FF  	.BYTE	255,255,255,255,255,255,255,255
002026  1  FF FF FF FF  
00202A  1  FF FF FF FF  	.BYTE	255,255,255,255,255,255,255,255
00202E  1  FF FF FF FF  
002032  1  FF FF FF FF  	.BYTE	255,255,255,255,255,255,255,255
002036  1  FF FF FF FF  
00203A  1  FF FF 00 00  	.BYTE	255,255,0,0,32,255,255,255
00203E  1  20 FF FF FF  
002042  1  FF FF FF FF  	.BYTE	255,255,255,255,255,255,255,255
002046  1  FF FF FF FF  
00204A  1  FF FF FF FF  	.BYTE	255,255,255,255,255,255,255,255
00204E  1  FF FF FF FF  
002052  1  FF FF FF FF  	.BYTE	255,255,255,255,255,255,255,255
002056  1  FF FF FF FF  
00205A  1  FF FF FF FF  	.BYTE	255,255,255,255,255,255,255,255
00205E  1  FF FF FF FF  
002062  1  FF FF FF FF  	.BYTE	255,255,255,255,16,16,255,255
002066  1  10 10 FF FF  
00206A  1  FF FF FF FF  	.BYTE	255,255,255,255,255,255,255,255
00206E  1  FF FF FF FF  
002072  1  FF FF 08 FF  	.BYTE	255,255,8,255,255,255,255,0
002076  1  FF FF FF 00  
00207A  1  FF 00 FF FF  	.BYTE	255,0,255,255,0,255,255,255
00207E  1  00 FF FF FF  
002082  1  0C 0C 00 00  	.BYTE	12,12,0,0,8,12,8,12
002086  1  08 0C 08 0C  
00208A  1  08 08 0C 08  	.BYTE	8,8,12,8,255,255,28,28
00208E  1  FF FF 1C 1C  
002092  1  FF FF 18 FF  	.BYTE	255,255,24,255,255,28,255,255
002096  1  FF 1C FF FF  
00209A  1  FF 18 FF FF  	.BYTE	255,24,255,255,24,24,255,255
00209E  1  18 18 FF FF  
0020A2  1  FF FF FF FF  	.BYTE	255,255,255,255,255,255,$1C,255
0020A6  1  FF FF 1C FF  
0020AA  1  FF FF        	.BYTE	255,255
0020AC  1               ;TEMPLATE TABLE THAT DEFINES GROUPS OF OPCODES
0020AC  1               ;THAT HAVE THE SAME ADDRESSING MODES
0020AC  1               ;THIS COMMENT INCLUDES 65C02 OPCODES NOT YET IN ASM
0020AC  1               ; 1=ADC,AND,CMP,EOR,LDA,ORA,SBC
0020AC  1               ; 2=STA
0020AC  1               ; 3=JMP
0020AC  1               ; 4=JSR
0020AC  1               ; 5=ASL,LSR,ROL,ROR
0020AC  1               ; 6=CPX,CPY
0020AC  1               ; 7=BIT
0020AC  1               ; 8=LDY
0020AC  1               ; 9=STX
0020AC  1               ; 10=STY
0020AC  1               ; 11=LDX
0020AC  1               ; 12=DEC,INC
0020AC  1               ; 13 NOT USED
0020AC  1               ; 14=BCC,BCS,BEQ,BMI,BNE,BPL,BRA,BVC,BVS
0020AC  1               ; 15-19 NOT USED
0020AC  1               ; 20=ALL IMPLIED (E.G., TAY AND BRK)
0020AC  1  01 01 05 0E  KTMPL:	.BYTE	1,1,5,14,14,14,7,14
0020B0  1  0E 0E 07 0E  
0020B4  1  0E 0E 14 0E  	.BYTE	14,14,20,14,14,20,20,20
0020B8  1  0E 14 14 14  
0020BC  1  14 01 06 06  	.BYTE	20,1,6,6,12,20,20,1
0020C0  1  0C 14 14 01  
0020C4  1  0C 14 14 03  	.BYTE	12,20,20,3,4,1,11,8
0020C8  1  04 01 0B 08  
0020CC  1  05 14 01 14  	.BYTE	5,20,1,20,20,20,20,5
0020D0  1  14 14 14 05  
0020D4  1  05 14 14 01  	.BYTE	5,20,20,1,20,20,20,2
0020D8  1  14 14 14 02  
0020DC  1  09 0A 14 14  	.BYTE	9,10,20,20,20,20,20,20
0020E0  1  14 14 14 14  
0020E4  1               ;TABLE OF BASE OPCODES ARRANGED IN SAME
0020E4  1               ;ORDER AS OPRNDS TABLE
0020E4  1               ;THE ENTRY IN THIS TABLE IS THE ACTUAL OPCODE
0020E4  1               ;FOR TEMPLATE GROUPS 4, 14, AND 20.  FOR ALL
0020E4  1               ;OTHERS, THE ENTRY IS THE SMALLEST NUMERICAL
0020E4  1               ;OPCODE FOR THAT MNEMONIC.
0020E4  1  61 21 06 90  KCODE:	.BYTE	97,33,6,144,176,240,36,48
0020E8  1  B0 F0 24 30  
0020EC  1  D0 10 00 50  	.BYTE	208,16,0,80,112,24,216,88
0020F0  1  70 18 D8 58  
0020F4  1  B8 C1 E0 C0  	.BYTE	184,193,224,192,198,202,136,65
0020F8  1  C6 CA 88 41  
0020FC  1  E6 E8 C8 4C  	.BYTE	230,232,200,76,32,161,162,160
002100  1  20 A1 A2 A0  
002104  1  46 EA 01 48  	.BYTE	70,234,1,72,8,104,40,38
002108  1  08 68 28 26  
00210C  1  66 40 60 E1  	.BYTE	$66,64,96,225,56,248,120,129
002110  1  38 F8 78 81  
002114  1  86 84 AA A8  	.BYTE	134,132,170,168,186,138,154,152
002118  1  BA 8A 9A 98  
00211C  1               ;SOURCE FCB
00211C  1  00           SRCFCB:	.BYTE	0
00211D  1  xx xx xx xx  	.RES 	8
002121  1  xx xx xx xx  
002125  1  41 53 4D 00  	.BYTE	"ASM",0,0,0
002129  1  00 00        
00212B  1  xx xx xx xx  	.RES 	17
00212F  1  xx xx xx xx  
002133  1  xx xx xx xx  
00213C  1  00           	.BYTE	0
00213D  1               ;KIM FCB
00213D  1  00           KIMFCB:	.BYTE	0
00213E  1  xx xx xx xx  	.RES 	8
002142  1  xx xx xx xx  
002146  1  4B 49 4D 00  	.BYTE	"KIM",0,0,0
00214A  1  00 00        
00214C  1  xx xx xx xx  	.RES 	17
002150  1  xx xx xx xx  
002154  1  xx xx xx xx  
00215D  1  00           	.BYTE	0
00215E  1               ;LIST FCB
00215E  1  00           LSTFCB:	.BYTE	0
00215F  1  xx xx xx xx  	.RES 	8
002163  1  xx xx xx xx  
002167  1  50 52 4E 00  	.BYTE	"PRN",0,0,0
00216B  1  00 00        
00216D  1  xx xx xx xx  	.RES 	17
002171  1  xx xx xx xx  
002175  1  xx xx xx xx  
00217E  1  00           	.BYTE	0
00217F  1               ;SOURCE DISK BUFFER
00217F  1               SRCBUF:
00217F  1  xx xx xx xx  	.RES 	SRCLNG
002183  1  xx xx xx xx  
002187  1  xx xx xx xx  
00257F  1               ;KIM DISK BUFFER
00257F  1               KIMBUF:
00257F  1  xx xx xx xx  	.RES 	KIMLNG
002583  1  xx xx xx xx  
002587  1  xx xx xx xx  
00297F  1               ;LIST DISK BUFFER
00297F  1               LSTBUF:
00297F  1  xx xx xx xx  	.RES 	LSTLNG
002983  1  xx xx xx xx  
002987  1  xx xx xx xx  
002D7F  1               ;CODE BUFFER
002D7F  1               CODE:
002D7F  1  xx xx xx xx  	.RES 	LINESZ-4
002D83  1  xx xx xx xx  
002D87  1  xx xx xx xx  
002DCB  1               ;LINE BUFFER
002DCB  1               LINE:
002DCB  1  xx xx xx xx  	.RES 	LINESZ+2
002DCF  1  xx xx xx xx  
002DD3  1  xx xx xx xx  
002E1D  1               ;INPUT ECHO BUFFER
002E1D  1               ECHBUF:				;ECHO BUFFER
002E1D  1  xx xx xx xx  	.RES 	LINESZ+2
002E21  1  xx xx xx xx  
002E25  1  xx xx xx xx  
002E6F  1               ;SYMBOL BUFFER
002E6F  1               ;LENGTH IS DETERMINED BY SYMLEN
002E6F  1               SYM:
002E6F  1               	.END
