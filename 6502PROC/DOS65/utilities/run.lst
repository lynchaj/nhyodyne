ca65 V2.18 - Ubuntu 2.19-1
Main file   : run205.asm
Current file: run205.asm

000000r 1               ;RUN
000000r 1               ;BASIC-E/65 RUN TIME INTERPRETER
000000r 1               ;VERSION 2.05-A
000000r 1               ;COPYRIGHT - RICHARD A. LEARY - 1982
000000r 1               ;RELEASED:	30 OCTOBER 1982
000000r 1               ;LAST REVISION:
000000r 1               ;	3 FEBRUARY 1983
000000r 1               ;		CORRECTED SLE ERROR
000000r 1               ;	5 MARCH 1983
000000r 1               ;		CORRECTED CONRDE ERROR
000000r 1               ;	17 NOVEMBER 1983
000000r 1               ;		CORRECTED ERROR NUMBER IN EX92
000000r 1               ;		CORRECTED LINE COUNT IN OUTMSG
000000r 1               ;	28 JULY 1985
000000r 1               ;		CORRECTED OR ERROR
000000r 1               ;		MADE PAGE ZERO 6510 COMPATIBLE
000000r 1               ;	2 APRIL 2008
000000r 1               ;		REFORMATTED FOR TASM AND ASM211
000000r 1               ;		MOVED MULTIPLE VARIABLES OUT OF PAGE ZERO
000000r 1               ;EXTERNAL REFERENCES
000000r 1               BOOT	=	$100		;BOOT ENTRY
000000r 1               PEM	=	$103		;PEM ENTRY
000000r 1               DFLFCB	=	$107		;DEFAULT FCB
000000r 1               BUF	=	$128		;DEFAULT BUFFER
000000r 1               TEA	=	$800		;LOAD ADDRESS
000000r 1               ;FIXED PARAMETERS AND CONSTANTS
000000r 1               ;CAUTION: WHEN A REGISTER IS SET TO TRUE, Z IS SET TO 0 (I.E. NE).  IF A
000000r 1               ;REGISTER IS SET TO FALSE THEN Z IS SET TO 1 (I.E. EQ).
000000r 1               TRUE	=	$FF
000000r 1               FALSE	=	0
000000r 1               ;ASCII CHARACTERS
000000r 1               TAB	=	9		;TAB
000000r 1               LF	=	10		;LINEFEED
000000r 1               CR	=	13		;RETURN AND EOL
000000r 1               EOF	=	26		;EOF CHAR
000000r 1               SEMICO	=	59		;SEMICOLON
000000r 1               ;OTHER PARAMETERS
000000r 1               NUMFIL	=	20		;MAX NUMBER USER FILES
000000r 1               PRBFLN	=	132		;PRINT BUFFER LENGTH
000000r 1               NRSTCK	=	24*4		;STACK SIZE * 4
000000r 1               MAXPSN	=	8		;MAX NUMBER TAB POSITIONS (132 COL PAPER)
000000r 1               ;BASIC-E/65 OPCODES
000000r 1               DAT	=	51
000000r 1               ILS	=	28
000000r 1               DEF	=	94
000000r 1               BRS	=	54
000000r 1               BRC	=	55
000000r 1               PRO	=	30
000000r 1               CON	=	46
000000r 1               ;PAGE ZERO VARIABLES
000000r 1               ;ALL NON-ZERO INITIAL VALUES ARE SHOWN AS I=XXXX WHERE XXXX IS THE INITIAL
000000r 1               ;VALUE. PL/M NAME IS SHOWN IF SIGNIFICANTLY DIFFERENT.
000000r 1               EXH	=$02			;HOLD IN EX81 AND EX82
000000r 1               WTCHLD	=$04			;HOLD IN WRTTCN [WRITE$TO$CONSOLE]
000000r 1               RCRPNT	=$06			;RECORD$POINTER
000000r 1               DOBF	=$08			;BUFFER IN DISK$OPEN
000000r 1               WTFPNT	=$0A			;POINT IN WRTOFL (WRITE$TO$FILE)
000000r 1               DCBPNT	=$0C			;DCB POINTER
000000r 1               CONBPT	=$0E			;CONBUFFPTR
000000r 1               GTSTMP	=$10			;TEMP IN GET$STRING$FIELD
000000r 1               NWSTAD	=$12			;NEWSTRING ADDRESS
000000r 1               PTRADR	=$14			;PTRADDR IN STORE
000000r 1               SPTR	=$16			;PTR IN STORE
000000r 1               FRSTST	=$18			;FIRSTSTRING
000000r 1               SCNDST	=$1A			;SECONDSTRING
000000r 1               SSTMP	=$1C			;TEMPA IN STRSEG [STRING$SEGMENT]
000000r 1               ARYADR	=$1E			;ARRAY ADDRESS
000000r 1               SPACE	=$20			;
000000r 1               DSPNT	=$22			;
000000r 1               DSTMP	=$24			;
000000r 1               DSTMP1	=$26			;
000000r 1               DSTMP2	=$28			;
000000r 1               DSTMP3	=$2A			;TEMP IN UNLINK
000000r 1               MFROM	=$2C			;FROM IN MOVE
000000r 1               MTO	=$2E			;TO IN MOVE
000000r 1               SX		=$30			;SECONDARY
000000r 1               PX		=$32			;PRIMARY
000000r 1               FN		=$36			;N FOR FILL
000000r 1               TRIGS	=$38			;TRIG FUNCTION SIGN
000000r 1               LSB	=$39			;SAVE LSB IN INT
000000r 1               SRPNT	=$3A			;SERIES EVALUATION POINTER
000000r 1               SRCNT	=$3C			;SERIES EVALUATION COUNTER
000000r 1               TY		=$3D			;TEMP IN FLTOUT
000000r 1               DVZERO	=$3E			;DIVIDE BY ZERO FLAG
000000r 1               OVERFL	=$3F			;OVERFLOW FLAG
000000r 1               ME		=$40			;MEMORY POINTER
000000r 1               SL		=$42			;STORE MEMORY POINTER
000000r 1               CNVIND	=$44			;NUMBER CONVERT BUFFER INDEX
000000r 1               SAVPR	=$45			;SAVE FOR PR IN ADPRSC
000000r 1               NE		=$46			;EXPONENT
000000r 1               DPFLG	=$47			;DECIMAL POINT FLAG
000000r 1               DPOFF	=$48			;DP OFFSET
000000r 1               NESFLG	=$49			;EXPONENT SIGN FLAG
000000r 1               NS		=$4A			;SIGN
000000r 1               PE		=$4B			;EXPONENT
000000r 1               PM		=$4C			;MANTISSA
000000r 1               PS		=$4F			;SIGN
000000r 1               PC		=$50			;CARRY
000000r 1               PR		=$51			;ROUNDING
000000r 1               SE		=$52			;EXPONENT
000000r 1               SM		=$53			;MANTISSA
000000r 1               SS		=$56			;SIGN
000000r 1               QE		=$57			;EXPONENT
000000r 1               QM		=$58			;MANTISSA
000000r 1               SGNCMP	=$5B			;PRIMARY . SECONDARY SIGN COMPARISON
000000r 1               RA		=$5C			;ADDRESS OF REGISTER A
000000r 1               RB		=$5E			;ADDRESS OF REGISTER B
000000r 1               RC		=$60			;ADDRESS OF REGISTER C
000000r 1               SB		=$62			;STACK BOTTOM
000000r 1               ST		=$64			;STACK TOP
000000r 1               MPR	=$66			;BASE ADDRESS OF PRT
000000r 1               MDA	=$68			;BASE ADDRESS OF DATA AREA
000000r 1               MCD	=$6A			;BASE OF CODE AREA
000000r 1               CURLIN	=$6C			;CURRENT SOURCE LINE
000000r 1               DTARPT	=$6E			;DATAAREAPTR, CURRENT LOCATION IN DATA AREA
000000r 1               MBASE	=$70			;BEGINNING OF FREE STORAGE AREA
000000r 1               IBASE	=$72			;BASEIN INITMM [INITMEM]
000000r 1               PRBUFF	=$74			;PRINTBUFFER (INDEX TO BUFFER)
000000r 1               FILADR	=$75			;FILEADDR, CURRENT FCB POINTER BASE
000000r 1               EOFADR	=$77			;EOFADDR
000000r 1               BUFEND	=$79			;BUFFER$END
000000r 1               INFSAT	=$7B			;TEMP IN INFSA
000000r 1               SEDPTR	=$7C			;POINTER (PTR) IN SEDAAD
000000r 1               SEDAAT	=$7E			;TEMP IN SET$DATA$ADDR (SEDAAD)
000000r 1               BUFFER	=$7F			;ADDRESS OF DISKBUFFER
000000r 1               FCB	=$81			;ADDRESS OF FCB
000000r 1               TIME4T	=$83			;TEMP IN TIMES4
000000r 1               LCLSED	=$84			;LOCAL SEED FOR RANDOM NUMBER
000000r 1               BASE	=$86			;BASE ADDRESS IN BUILD
000000r 1               AP		=$88			;ACCUM INDEX
000000r 1               TBASE	=$89			;TEMP IN BUILD
000000r 1               LZ		=$8B			;
000000r 1               ;ENTRY POINT
000000r 1               	.FEATURE labels_without_colons
000000r 1                	.segment "TEA"
000000r 1               	.ORG $0800
000800  1  4C C0 30     	JMP	BUILD
000803  1               ;SPECIAL I/O ROUTINES
000803  1  4C 70 08     	JMP	SETLST
000806  1  4C 76 08     	JMP	CLRLST
000809  1  4C 7A 08     	JMP	DOPEM
00080C  1  4C 90 08     	JMP	DOSIM
00080F  1               ;SPECIAL I/O VARIABLES
00080F  1  00           AREG	.BYTE	0		;A
000810  1  00           YREG	.BYTE	0		;Y
000811  1  00           XREG	.BYTE	0		;X
000812  1  00           LSTFLG	.BYTE	FALSE		;LIST FLAG
000813  1               ;COPYRIGHT NOTICE
000813  1  43 4F 50 59  	.BYTE	"COPYRIGHT - RICHARD"
000817  1  52 49 47 48  
00081B  1  54 20 2D 20  
000826  1  20 41 2E 20  	.BYTE	" A. LEARY - 2008"
00082A  1  4C 45 41 52  
00082E  1  59 20 2D 20  
000836  1               ;GENERAL STORAGE AREA - VARIABLES THAT WERE IN PAGE ZERO - SECTION
000836  1               ;NAME IS SAME AS THAT USED FOR REMAINING PAGE ZERO VARIABLES
000836  1               ;FILE PROCESSING VARIABLES
000836  1  00 00        EOFRA	.WORD	0		;EOF LOCATION FOR RA
000838  1  00 00        EOFRB	.WORD	0		;SAME FOR RB
00083A  1  00 00        BLKSZE	.WORD	0		;BLOCKSIZE
00083C  1  00 00        BYTSWR	.WORD	0		;BYTES WRITTEN
00083E  1  00           FRSFLD	.BYTE	0		;FIRSTFIELD
00083F  1  00           EXTSZE	.BYTE	0		;EXTENT SIZE FLAG (0=16K, 128=8K)
000840  1  00           DFLDRV	.BYTE	0		;DEFAULT DRIVE
000841  1               ;GENERALIZED INPUT VARIABLES
000841  1  00 00        RERDAD	.WORD	0		;REREADADDR
000843  1  00           INPTYP	.BYTE	0		;INPUTTYPE
000844  1  00           INPIND	.BYTE	0		;INPUTINDEX
000845  1  00 00        INPPTR	.WORD	0		;INPUTPTR
000847  1               ;STRING PROCESSING VARIABLES
000847  1  00           FRSTLN	.BYTE	0		;FIRSTSTRING LENGTH
000848  1  00           SCSTLN	.BYTE	0		;SECONDSTRING LENGTH
000849  1  00           NWSTLN	.BYTE	0		;NEWSTRING LENGTH
00084A  1               ;ARRAY ADDRESSING VARIABLES
00084A  1  00 00        ASIZE	.WORD	0		;ARRAY SIZE IN CLCROW
00084C  1  00 00        SAVERA	.WORD	0		;SAVE FOR RA
00084E  1  00 00        SAVERB	.WORD	0		;SAVE FOR RB
000850  1  00           CI	.BYTE	0		;I IN CLCROW
000851  1  00           CLCT	.BYTE	0		;TEMP IN CLCROW
000852  1  00 00        LOCATN	.WORD	0		;LOCATION IN CLCSUB
000854  1  00           NUMDIM	.BYTE	0		;NUMBER DIMENSIONS
000855  1               ;DYNAMIC STORAGE ALLOCATION VARIABLES
000855  1  00 00        NBYTES	.WORD	0
000857  1  00 00        HOLD	.WORD	0
000859  1  00 00        TOTAL	.WORD	0
00085B  1  00 00        AVLLT2	.WORD	0		;NBYTES+5 IN AVLL
00085D  1  00 00        AVLLT	.WORD	0		;TEMP IN AVLL
00085F  1               ;FOR MOVE
00085F  1  00 00        MCOUNT	.WORD	0		;COUNT IN MOVE
000861  1               ;DATA FOR BUILD
000861  1  00           CURCHR	.BYTE	0		;CURRENT CHAR FROM .INT FILE
000862  1  00           BUFF	.BYTE	0		;INDEX FOR .INT FILE
000863  1  00 00        OFFSET	.WORD	0		;OFFSET IN BUILD
000865  1               ;CONVERT LOWERCASE TO UPPER
000865  1  C9 41        LWRUPR	CMP	#'A'		;SEE IF UNDER A
000867  1  90 06        	BCC	NOTLWR		;SKIP IF IS
000869  1  C9 5B        	CMP	#'Z'+1		;SEE IF OVER Z
00086B  1  B0 02        	BCS	NOTLWR		;SKIP IF IS
00086D  1  29 5F        	AND	#$5F		;ELSE CONVERT
00086F  1  60           NOTLWR	RTS
000870  1               ;SET LIST FLAG
000870  1  A9 FF        SETLST	LDA	#TRUE
000872  1  8D 12 08     	STA	LSTFLG
000875  1  60           	RTS
000876  1               ;CLEAR LIST FLAG
000876  1  4E 12 08     CLRLST	LSR	LSTFLG
000879  1  60           	RTS
00087A  1               ;DO DIRECT PEM CALL
00087A  1  AD 0F 08     DOPEM	LDA	AREG
00087D  1  AC 10 08     	LDY	YREG
000880  1  AE 11 08     	LDX	XREG
000883  1  20 03 01     	JSR	PEM
000886  1  8D 0F 08     	STA	AREG
000889  1  8C 10 08     	STY	YREG
00088C  1  8E 11 08     	STX	XREG
00088F  1  60           	RTS
000890  1               ;DO DIRECT SIM CALL
000890  1  AD 02 01     DOSIM	LDA	BOOT+2
000893  1  8D A4 08     	STA	SIMJSR+2
000896  1  AD 11 08     	LDA	XREG
000899  1  8D A3 08     	STA	SIMJSR+1
00089C  1  AD 0F 08     	LDA	AREG
00089F  1  AC 10 08     	LDY	YREG
0008A2  1  20 FF FF     SIMJSR	JSR	$FFFF
0008A5  1  8D 0F 08     	STA	AREG
0008A8  1  8C 10 08     	STY	YREG
0008AB  1  8E 11 08     	STX	XREG
0008AE  1  60           	RTS
0008AF  1               ;INTERPRETER INITIALIZATION ROUTINES
0008AF  1               ;GET$PARAMETERS
0008AF  1  A5 6A        GETPAR	LDA	MCD
0008B1  1  A4 6B        	LDY	MCD+1
0008B3  1  85 60        	STA	RC
0008B5  1  84 61        	STY	RC+1		;RC:=MCD
0008B7  1  A4 69        	LDY	MDA+1
0008B9  1  A6 68        	LDX	MDA
0008BB  1  D0 01        	BNE	*+3
0008BD  1  88           	DEY
0008BE  1  CA           	DEX
0008BF  1  86 6E        	STX	DTARPT
0008C1  1  84 6F        	STY	DTARPT+1	;DATAAREAPTR:=MDA-1
0008C3  1  18           	CLC
0008C4  1  A5 62        	LDA	SB
0008C6  1  69 60        	ADC	#NRSTCK
0008C8  1  85 64        	STA	ST
0008CA  1  85 70        	STA	MBASE
0008CC  1  A4 63        	LDY	SB+1
0008CE  1  90 01        	BCC	*+3
0008D0  1  C8           	INY
0008D1  1  84 65        	STY	ST+1
0008D3  1  84 71        	STY	MBASE+1		;MBASE,ST:=SB+NRSTACK
0008D5  1  A5 62        	LDA	SB
0008D7  1  A4 63        	LDY	SB+1
0008D9  1  85 5E        	STA	RB
0008DB  1  84 5F        	STY	RB+1		;RB:=SB
0008DD  1  18           	CLC
0008DE  1  69 04        	ADC	#4
0008E0  1  85 5C        	STA	RA
0008E2  1  90 01        	BCC	*+3
0008E4  1  C8           	INY
0008E5  1  84 5D        	STY	RA+1		;RA:=SB+4
0008E7  1  60           	RTS
0008E8  1               ;INITMEM
0008E8  1  A9 3D        INITMM	LDA	#<MEMORY
0008EA  1  A0 30        	LDY	#>MEMORY
0008EC  1  85 2E        	STA	MTO
0008EE  1  84 2F        	STY	MTO+1		;TO:=.MEMORY
0008F0  1  18           	CLC
0008F1  1  6D 63 08     	ADC	OFFSET
0008F4  1  85 2C        	STA	MFROM
0008F6  1  98           	TYA
0008F7  1  6D 64 08     	ADC	OFFSET+1
0008FA  1  85 2D        	STA	MFROM+1		;FROM:=.MEMORY+OFFSET
0008FC  1  38           	SEC
0008FD  1  A5 66        	LDA	MPR
0008FF  1  E9 3D        	SBC	#<MEMORY
000901  1  AA           	TAX
000902  1  A5 67        	LDA	MPR+1
000904  1  E9 30        	SBC	#>MEMORY
000906  1  A8           	TAY
000907  1  8A           	TXA
000908  1  20 7C 17     	JSR	MOVE		;MOVE(BEGIN+OFFSET,BEGIN,MPR-BEGIN)
00090B  1  38           	SEC
00090C  1  A5 70        	LDA	MBASE
00090E  1  E5 66        	SBC	MPR
000910  1  85 36        	STA	FN
000912  1  A5 71        	LDA	MBASE+1
000914  1  E5 67        	SBC	MPR+1
000916  1  85 37        	STA	FN+1
000918  1  A2 00        	LDX	#0
00091A  1  A5 66        	LDA	MPR
00091C  1  A4 67        	LDY	MPR+1
00091E  1  20 B6 17     	JSR	FILL		;FILL(MPR,0,MBASE-MPR)
000921  1  A5 64        	LDA	ST
000923  1  A4 65        	LDY	ST+1
000925  1  85 72        	STA	IBASE
000927  1  84 73        	STY	IBASE+1
000929  1  A0 00        	LDY	#0
00092B  1  38           	SEC
00092C  1  AD 04 01     	LDA	PEM+1
00092F  1  E9 04        	SBC	#4
000931  1  91 72        	STA	(IBASE),Y
000933  1  C8           	INY
000934  1  AD 05 01     	LDA	PEM+2
000937  1  E9 00        	SBC	#0
000939  1  91 72        	STA	(IBASE),Y	;A(0):=TOP-4
00093B  1  A9 00        	LDA	#0
00093D  1  A0 02        	LDY	#1*2		;WORD ADDRESSING
00093F  1  91 72        L051	STA	(IBASE),Y
000941  1  C8           	INY
000942  1  C0 06        	CPY	#3*2
000944  1  D0 F9        	BNE	L051		;A(1),A(2):=0
000946  1  A0 00        	LDY	#0*2
000948  1  B1 72        	LDA	(IBASE),Y
00094A  1  48           	PHA
00094B  1  C8           	INY
00094C  1  B1 72        	LDA	(IBASE),Y
00094E  1  A8           	TAY
00094F  1  68           	PLA
000950  1  85 72        	STA	IBASE
000952  1  84 73        	STY	IBASE+1		;BASE:=A(0)
000954  1  A0 00        	LDY	#0
000956  1  98           	TYA
000957  1  91 72        	STA	(IBASE),Y
000959  1  C8           	INY
00095A  1  91 72        	STA	(IBASE),Y	;A(0):=0
00095C  1  C8           	INY
00095D  1  A5 64        	LDA	ST
00095F  1  91 72        	STA	(IBASE),Y
000961  1  C8           	INY
000962  1  A5 65        	LDA	ST+1
000964  1  91 72        	STA	(IBASE),Y	;A(1):=ST
000966  1  60           	RTS
000967  1               ;INITIALIZE$EXECUTE
000967  1  20 AF 08     INTLEX	JSR	GETPAR		;GET$PARAMETERS
00096A  1  20 E8 08     	JSR	INITMM		;INITMEM
00096D  1  A2 50        	LDX	#NUMFIL*4
00096F  1  A9 00        	LDA	#0
000971  1  9D EC 2F     L052	STA	FILES-1,X
000974  1  CA           	DEX
000975  1  D0 FA        	BNE	L052		;FILL(.FILES,0,TIMES4(NUMFILES))
000977  1  4C 27 1A     	JMP	CLRPBF		;CLEAR$PRINT$BUFF
00097A  1               ;GENERALIZED INPUT ROUTINES
00097A  1               ;CONSOLE$READ
00097A  1  A9 3F        CONRDE	LDA	#'?'
00097C  1  20 3B 15     	JSR	PRNCHR		;PRINTCHAR(?)
00097F  1  A9 20        	LDA	#' '
000981  1  20 3B 15     	JSR	PRNCHR		;PRINTCHAR(BLANK)
000984  1  A9 7C        	LDA	#<INPBUF
000986  1  A0 2F        	LDY	#>INPBUF
000988  1  20 4A 15     	JSR	READ		;READ(.INPUTBUFFER)
00098B  1  20 24 1A     	JSR	DMPPBF		;OUTPUT CR/LF AND CLEAR POINTER
00098E  1  AD 7E 2F     	LDA	INPSPC+1
000991  1  C9 1A        	CMP	#EOF		;IF SPACE(1) <> EOF
000993  1  D0 03        	BNE	*+5		;THEN
000995  1  20 46 10     	JSR	EXTINT		;ELSE EXIT$INTERP
000998  1  A9 7D        	LDA	#<INPSPC
00099A  1  A0 2F        	LDY	#>INPSPC
00099C  1  85 0E        	STA	CONBPT
00099E  1  84 0F        	STY	CONBPT+1	;CONBUFFPTR:=.SPACE
0009A0  1  AE 7D 2F     	LDX	INPSPC
0009A3  1  E8           	INX
0009A4  1  A9 0D        	LDA	#CR
0009A6  1  9D 7D 2F     	STA	INPSPC,X	;SPACE(SPACE(0)+1):=EOLCHAR
0009A9  1  60           	RTS
0009AA  1               ;MORE$CON$INPUT
0009AA  1  38           MRECIN	SEC
0009AB  1  A5 0E        	LDA	CONBPT
0009AD  1  E9 7D        	SBC	#<INPSPC
0009AF  1  CD 7D 2F     	CMP	INPSPC
0009B2  1  90 03        	BCC	*+5		;IF CONBUFFPTR<.SPACE(SPACE(0))
0009B4  1  A9 00        	LDA	#FALSE
0009B6  1  60           	RTS
0009B7  1  A9 FF        	LDA	#TRUE
0009B9  1  60           	RTS
0009BA  1               ;CONSOLE$INPUT$ERROR
0009BA  1  20 52 19     CONIER	JSR	POPSTK		;POP$STACK
0009BD  1  AD 41 08     	LDA	RERDAD
0009C0  1  AC 42 08     	LDY	RERDAD+1
0009C3  1  85 60        	STA	RC
0009C5  1  84 61        	STY	RC+1		;RC:=REREADADDR
0009C7  1  A9 07        	LDA	#7		;ILLEGAL INPUT WARNING
0009C9  1  20 CA 18     	JSR	WARNNG		;WARNING(II)
0009CC  1  4C 3E 2B     	JMP	ERREXT		;ERROR$EXIT
0009CF  1               ;GET$DATA$CHAR
0009CF  1  E6 6E        GTDTCH	INC	DTARPT
0009D1  1  D0 02        	BNE	*+4
0009D3  1  E6 6F        	INC	DTARPT+1	;DATAAREAPTR:=DATAAREAPTR+1
0009D5  1  A5 6E        	LDA	DTARPT
0009D7  1  C5 62        	CMP	SB
0009D9  1  A5 6F        	LDA	DTARPT+1
0009DB  1  E5 63        	SBC	SB+1
0009DD  1  90 05        	BCC	*+7		;IF DATAAREAPTR<SB THEN OK
0009DF  1  A9 0E        	LDA	#14		;ELSE OUT OF DATA ERROR
0009E1  1  4C B8 18     	JMP	ERROR
0009E4  1  A0 00        	LDY	#0
0009E6  1  B1 6E        	LDA	(DTARPT),Y	;A:=CHAR
0009E8  1  60           	RTS
0009E9  1               ;GET$CON$CHAR
0009E9  1  E6 0E        GTCNCH	INC	CONBPT
0009EB  1  D0 02        	BNE	*+4
0009ED  1  E6 0F        	INC	CONBPT+1	;CONBUFFPTR:=CONBUFFPTR+1
0009EF  1  A0 00        	LDY	#0
0009F1  1  B1 0E        	LDA	(CONBPT),Y	;A:=CHAR
0009F3  1  60           	RTS
0009F4  1               ;NEXT$INPUT$CHAR
0009F4  1  AD 43 08     NXINCH	LDA	INPTYP
0009F7  1  D0 28        	BNE	L008
0009F9  1  A9 50        L009	LDA	#80
0009FB  1  CD 44 08     	CMP	INPIND
0009FE  1  B0 05        	BCS	*+7		;IF INPUTINDEX<=CONBUFFSIZE THEN
000A00  1  A9 19        	LDA	#25		;ELSE DATA FIELD TOO LONG
000A02  1  4C B8 18     	JMP	ERROR
000A05  1  20 69 0F     	JSR	GTDSCH		;GETDISKCHAR
000A08  1  AE 44 08     	LDX	INPIND
000A0B  1  9D 7D 2F     	STA	INPSPC,X	;SPACE(INPUTINDEX):=
000A0E  1  C9 0A        	CMP	#LF
000A10  1  D0 0A        	BNE	L010		;IF NOT LF THEN
000A12  1  20 5D 0C     	JSR	VARBSZ
000A15  1  F0 E2        	BEQ	L009		;IF NOT VAR$BLOCKSIZE THEN OK
000A17  1  A9 11        	LDA	#17		;ELSE ATTEMPT TO READ PAST END ERROR
000A19  1  4C B8 18     	JMP	ERROR
000A1C  1  A0 00        L010	LDY	#0
000A1E  1  B1 06        	LDA	(RCRPNT),Y	;RETURN NEXTDISKCHAR
000A20  1  60           	RTS
000A21  1  C9 01        L008	CMP	#1		;IF INPUTTYPE
000A23  1  D0 03        	BNE	*+5		;<> 1 THEN
000A25  1  4C E9 09     	JMP	GTCNCH		;ELSE RETURN GETCONCHAR
000A28  1  C9 02        	CMP	#2		;IF INPUTTYPE
000A2A  1  D0 03        	BNE	*+5		;<> 2 THEN
000A2C  1  4C CF 09     	JMP	GTDTCH		;ELSE RETURN GETDATACHAR
000A2F  1  60           	RTS
000A30  1               ;COUNT$INPUT
000A30  1               ;DETERMINES EXTENT OF NEXT FIELD AND COLLECT THE FIELD IN THE APPROPRIATE BUFF
000A30  1               IHOLD
000A30  1  xx           	.res	1
000A31  1               DELIM
000A31  1  xx           	.res	1
000A32  1  A9 00        COUNTI	LDA	#0
000A34  1  8D 44 08     	STA	INPIND		;INPUT$INDEX:=0
000A37  1  20 F4 09     L011	JSR	NXINCH		;DO WHILE(HOLD:=NEXT$INPUT$CHAR)=' '
000A3A  1  8D 30 0A     	STA	IHOLD
000A3D  1  C9 20        	CMP	#' '
000A3F  1  F0 F6        	BEQ	L011		;ELIMNATES BLANKS
000A41  1  AD 43 08     	LDA	INPTYP		;IF INPUTTYPE
000A44  1  D0 0D        	BNE	L012		;<> 0 THEN
000A46  1  A9 7D        	LDA	#<INPSPC	;ELSE
000A48  1  A0 2F        	LDY	#>INPSPC
000A4A  1  8D 45 08     	STA	INPPTR
000A4D  1  8C 46 08     	STY	INPPTR+1	;INPUTPTR:=.SPACE
000A50  1  4C 72 0A     	JMP	L014
000A53  1  C9 01        L012	CMP	#1		;IF INPUTTYPE
000A55  1  D0 0D        	BNE	L013		;<> 1 THEN
000A57  1  A5 0E        	LDA	CONBPT
000A59  1  A4 0F        	LDY	CONBPT+1
000A5B  1  8D 45 08     	STA	INPPTR
000A5E  1  8C 46 08     	STY	INPPTR+1	;INPUTPTR:=CONBUFFPTR
000A61  1  4C 72 0A     	JMP	L014
000A64  1  C9 02        L013	CMP	#2
000A66  1  D0 0A        	BNE	L014		;IF INPUTTYPE<>2 THEN
000A68  1  A5 6E        	LDA	DTARPT
000A6A  1  A4 6F        	LDY	DTARPT+1
000A6C  1  8D 45 08     	STA	INPPTR
000A6F  1  8C 46 08     	STY	INPPTR+1
000A72  1  AD 30 0A     L014	LDA	IHOLD
000A75  1  C9 22        	CMP	#'"'
000A77  1  F0 08        	BEQ	L015		;IF HOLD=" THEN
000A79  1  A9 2C        	LDA	#','
000A7B  1  8D 31 0A     	STA	DELIM		;ELSE DELIM:=,
000A7E  1  4C 99 0A     	JMP	L017
000A81  1  A9 22        L015	LDA	#'"'
000A83  1  8D 31 0A     	STA	DELIM		;DELIM:="
000A86  1  AD 43 08     	LDA	INPTYP
000A89  1  F0 08        	BEQ	L016		;IF INPUTTYPE=0 THEN
000A8B  1  EE 45 08     	INC	INPPTR
000A8E  1  D0 03        	BNE	L016
000A90  1  EE 46 08     	INC	INPPTR+1	;ELSE INPUTPTR:=INPUTPTR+1
000A93  1  20 F4 09     L016	JSR	NXINCH
000A96  1  8D 30 0A     	STA	IHOLD		;HOLD:=NEXT$INPUT$CHAR
000A99  1  AD 30 0A     L017	LDA	IHOLD		;DO WHILE HOLD
000A9C  1  CD 31 0A     	CMP	DELIM		;<> DELIM
000A9F  1  F0 10        	BEQ	L018		;AND
000AA1  1  C9 0D        	CMP	#CR		;<> EOLCHAR
000AA3  1  F0 0C        	BEQ	L018
000AA5  1  EE 44 08     	INC	INPIND		;INPUTINDEX:=INPUTINDEX+1
000AA8  1  20 F4 09     	JSR	NXINCH
000AAB  1  8D 30 0A     	STA	IHOLD		;HOLD:=NEXT$INPUT$CHAR
000AAE  1  4C 99 0A     	JMP	L017
000AB1  1  AD 31 0A     L018	LDA	DELIM
000AB4  1  C9 22        	CMP	#'"'		;IF DELIM<>"
000AB6  1  D0 0E        	BNE	L020		;THEN
000AB8  1  20 F4 09     L019	JSR	NXINCH
000ABB  1  8D 30 0A     	STA	IHOLD		;HOLD:=NEXT$INPUT$CHAR
000ABE  1  C9 2C        	CMP	#','		;DO WHILE HOLD
000AC0  1  F0 04        	BEQ	L020		;<> ,
000AC2  1  C9 0D        	CMP	#CR
000AC4  1  D0 F2        	BNE	L019		;<> EOLCHAR
000AC6  1  4C 82 19     L020	JMP	PSHSTK		;PUSH$STACK
000AC9  1               ;GET$STRING$FIELD
000AC9  1  20 32 0A     GTSTFL	JSR	COUNTI		;COUNT$INPUT
000ACC  1  18           	CLC
000ACD  1  AD 44 08     	LDA	INPIND
000AD0  1  A0 00        	LDY	#0
000AD2  1  69 01        	ADC	#1
000AD4  1  20 4B 16     	JSR	GETS
000AD7  1  85 10        	STA	GTSTMP
000AD9  1  84 11        	STY	GTSTMP+1	;TEMP:=GETSPACE( )
000ADB  1  18           	CLC
000ADC  1  69 01        	ADC	#1
000ADE  1  D0 01        	BNE	*+3
000AE0  1  C8           	INY
000AE1  1  85 2E        	STA	MTO
000AE3  1  84 2F        	STY	MTO+1		;TO:=TEMP+1
000AE5  1  AD 45 08     	LDA	INPPTR
000AE8  1  AC 46 08     	LDY	INPPTR+1
000AEB  1  85 2C        	STA	MFROM
000AED  1  84 2D        	STY	MFROM+1		;FROM:=INPUTPTR
000AEF  1  AD 44 08     	LDA	INPIND
000AF2  1  A0 00        	LDY	#0
000AF4  1  20 7C 17     	JSR	MOVE		;( , ,INPUTINDEX)
000AF7  1  A0 00        	LDY	#0
000AF9  1  A5 10        	LDA	GTSTMP
000AFB  1  91 5C        	STA	(RA),Y
000AFD  1  C8           	INY
000AFE  1  A5 11        	LDA	GTSTMP+1
000B00  1  91 5C        	STA	(RA),Y		;ARA:=TEMP
000B02  1  A9 00        	LDA	#0
000B04  1  20 F1 18     	JSR	FLSTRA		;FLAG$STRING$ADDR(0)
000B07  1  A0 00        	LDY	#0
000B09  1  AD 44 08     	LDA	INPIND
000B0C  1  91 10        	STA	(GTSTMP),Y	;LNG:=INPUTINDEX
000B0E  1  60           	RTS
000B0F  1               ;GET$NUMERIC$FIELD
000B0F  1  20 32 0A     GTNMFL	JSR	COUNTI		;COUNT$INPUT
000B12  1  AE 44 08     	LDX	INPIND
000B15  1  F0 13        	BEQ	L021		;IF INPUTINDEX=0 THEN
000B17  1  AD 45 08     	LDA	INPPTR
000B1A  1  AC 46 08     	LDY	INPPTR+1
000B1D  1  20 03 21     	JSR	FLTINP		;ELSE FP$INPUT(INPUTINDEX,INPUTPTR)
000B20  1  A5 5C        	LDA	RA
000B22  1  A4 5D        	LDY	RA+1
000B24  1  20 C1 1C     	JSR	STP		;STORE ACCUM @ RA
000B27  1  4C 8D 1B     	JMP	CHKOVR		;CHECK$OVERFLOW
000B2A  1  AD 43 08     L021	LDA	INPTYP
000B2D  1  C9 01        	CMP	#1
000B2F  1  D0 03        	BNE	*+5		;IF INPUTTYPE<>1 THEN
000B31  1  4C BA 09     	JMP	CONIER		;ELSE CONSOLE$INPUT$ERROR
000B34  1  A0 00        	LDY	#0
000B36  1  98           	TYA
000B37  1  91 5C        	STA	(RA),Y		;BRAZ:=0
000B39  1  60           	RTS
000B3A  1               ;FILE PROCESSING ROUTINES
000B3A  1               ;INITIALIZE$DISK$BUFFER
000B3A  1  A0 7F        INTDBF	LDY	#127
000B3C  1  A9 1A        	LDA	#EOF
000B3E  1  91 7F        L030	STA	(BUFFER),Y	;INSERT EOF
000B40  1  88           	DEY
000B41  1  10 FB        	BPL	L030
000B43  1  60           	RTS
000B44  1               ;BUFFER$STATUS$BYTE
000B44  1  A0 21        BUFSTB	LDY	#33
000B46  1  B1 75        	LDA	(FILADR),Y
000B48  1  60           	RTS			;RETURN FCB(33)
000B49  1               ;SET$BUFFER$STATUS$BYTE(STATUS)
000B49  1  A0 21        STBFSB	LDY	#33
000B4B  1  91 75        	STA	(FILADR),Y	;FCB(33)=STATUS
000B4D  1  60           	RTS
000B4E  1               ;WRITE$MARK
000B4E  1  20 44 0B     WRTMRK	JSR	BUFSTB
000B51  1  29 01        	AND	#1		;SET FLAGS
000B53  1  60           	RTS
000B54  1               ;SET$WRITE$MARK
000B54  1  20 44 0B     SWRMRK	JSR	BUFSTB
000B57  1  09 01        	ORA	#1
000B59  1  4C 49 0B     	JMP	STBFSB
000B5C  1               ;CLEAR$WRITE$MARK
000B5C  1  20 44 0B     CWRMRK	JSR	BUFSTB
000B5F  1  29 FE        	AND	#%11111110
000B61  1  4C 49 0B     	JMP	STBFSB
000B64  1               ;ACTIVE$BUFFER
000B64  1  20 44 0B     ACTBUF	JSR	BUFSTB
000B67  1  4A           	LSR	A
000B68  1  29 01        	AND	#1
000B6A  1  60           	RTS
000B6B  1               ;SET$BUFFER$INACTIVE
000B6B  1  20 44 0B     SETBFI	JSR	BUFSTB
000B6E  1  29 F9        	AND	#%11111001
000B70  1  4C 49 0B     	JMP	STBFSB
000B73  1               ;SET$BUFFER$ACTIVE
000B73  1  20 44 0B     SETBFA	JSR	BUFSTB
000B76  1  09 02        	ORA	#%00000010
000B78  1  4C 49 0B     	JMP	STBFSB
000B7B  1               ;SET$RANDOM$MODE
000B7B  1  20 44 0B     SETRAN	JSR	BUFSTB
000B7E  1  09 80        	ORA	#%10000000
000B80  1  4C 49 0B     	JMP	STBFSB
000B83  1               ;RANDOM$MODE
000B83  1  20 44 0B     RANMDE	JSR	BUFSTB
000B86  1  2A           	ROL	A
000B87  1  2A           	ROL	A
000B88  1  29 01        	AND	#1
000B8A  1  60           	RTS
000B8B  1               ;STORE$REC$PTR
000B8B  1  A0 24        STRRPT	LDY	#18*2		;WORD ADDRESSING
000B8D  1  A5 06        	LDA	RCRPNT
000B8F  1  91 75        	STA	(FILADR),Y
000B91  1  C8           	INY
000B92  1  A5 07        	LDA	RCRPNT+1
000B94  1  91 75        	STA	(FILADR),Y	;FCBADD(18):=RECORDPOINTER
000B96  1  60           	RTS
000B97  1               ;DISK$EOF
000B97  1  A5 77        DSKEOF	LDA	EOFADR
000B99  1  05 78        	ORA	EOFADR+1	;IF EOFADDR <> 0
000B9B  1  D0 05        	BNE	*+7		;THEN
000B9D  1  A9 05        	LDA	#5		;ELSE EOF ERROR
000B9F  1  4C B8 18     	JMP	ERROR
000BA2  1  A6 77        	LDX	EOFADR
000BA4  1  A4 78        	LDY	EOFADR+1
000BA6  1  E8           	INX
000BA7  1  86 60        	STX	RC
000BA9  1  D0 01        	BNE	*+3
000BAB  1  C8           	INY
000BAC  1  84 61        	STY	RC+1		;RC:=EOFADDR+1
000BAE  1  AD 36 08     	LDA	EOFRA
000BB1  1  AC 37 08     	LDY	EOFRA+1
000BB4  1  85 5C        	STA	RA
000BB6  1  84 5D        	STY	RA+1		;RA:=EOFRA
000BB8  1  AD 38 08     	LDA	EOFRB
000BBB  1  AC 39 08     	LDY	EOFRB+1
000BBE  1  85 5E        	STA	RB
000BC0  1  84 5F        	STY	RB+1		;RB:=EOFRB
000BC2  1  A5 06        	LDA	RCRPNT
000BC4  1  C5 7F        	CMP	BUFFER
000BC6  1  D0 06        	BNE	RPBFNE		;IF RECORD$POINTER <> BUFFER THEN
000BC8  1  A5 07        	LDA	RCRPNT+1
000BCA  1  C5 80        	CMP	BUFFER+1
000BCC  1  F0 08        	BEQ	L031
000BCE  1  20 44 0B     RPBFNE	JSR	BUFSTB
000BD1  1  09 04        	ORA	#%00000100	;BUFFER$STATUS$BYTE OR 4
000BD3  1  20 49 0B     	JSR	STBFSB
000BD6  1  A5 06        L031	LDA	RCRPNT
000BD8  1  D0 02        	BNE	*+4
000BDA  1  C6 07        	DEC	RCRPNT+1
000BDC  1  C6 06        	DEC	RCRPNT		;RECORD$POINTER:=RECORD$POINTER-1
000BDE  1  20 8B 0B     	JSR	STRRPT		;STORE$REC$PTR
000BE1  1  4C 3E 2B     	JMP	EOFEXT		;DROP TO OUTER LOOP
000BE4  1               ;FILL$FILE$BUFFER
000BE4  1  20 77 15     FILFBF	JSR	DSKRDE		;IF DISKREAD <> 0
000BE7  1  D0 03        	BNE	*+5		;THEN
000BE9  1  4C 73 0B     	JMP	SETBFA		;ELSE SET$BUFFER$ACTIVE
000BEC  1  20 83 0B     	JSR	RANMDE		;IF RANDOM$MODE
000BEF  1  D0 03        	BNE	*+5		;THEN
000BF1  1  4C 97 0B     	JMP	DSKEOF		;ELSE DISK$EOF
000BF4  1  20 3A 0B     	JSR	INTDBF		;INITIALIZE$DISK$BUFFER
000BF7  1  20 73 0B     	JSR	SETBFA		;SET$BUFFER$ACTIVE
000BFA  1  A0 20        	LDY	#32
000BFC  1  B1 75        	LDA	(FILADR),Y
000BFE  1  18           	CLC
000BFF  1  69 01        	ADC	#1
000C01  1  91 75        	STA	(FILADR),Y	;FCB(32):=FCB(32)+1
000C03  1  60           	RTS
000C04  1               ;WRITE$DISK$IF$REQ
000C04  1  20 4E 0B     WDIFRQ	JSR	WRTMRK		;IF NOT WRITE$MARK
000C07  1  F0 35        	BEQ	L032		;THEN JUST SET RECORDPOINTERS
000C09  1  20 44 0B     	JSR	BUFSTB		;ELSE
000C0C  1  29 04        	AND	#4
000C0E  1  F0 13        	BEQ	L033		;IF NOT SHR(BUFFER$STATUS$BYTE,2) THEN
000C10  1  A0 20        	LDY	#32
000C12  1  B1 75        	LDA	(FILADR),Y
000C14  1  F0 05        	BEQ	L034		;IF ZERO DON'T SUBTRACT
000C16  1  38           	SEC
000C17  1  E9 01        	SBC	#1
000C19  1  91 75        	STA	(FILADR),Y	;ELSE FCB(32):=FCB(32)-1
000C1B  1  20 44 0B     L034	JSR	BUFSTB
000C1E  1  29 FB        	AND	#%11111011
000C20  1  20 49 0B     	JSR	STBFSB
000C23  1  20 80 15     L033	JSR	DSKWRT
000C26  1  F0 05        	BEQ	*+7		;IF OK THEN
000C28  1  A9 03        	LDA	#3		;ELSE DISK WRITE ERROR
000C2A  1  4C B8 18     	JMP	ERROR
000C2D  1  20 5C 0B     	JSR	CWRMRK		;CLEAR$WRITE$MARK
000C30  1  20 83 0B     	JSR	RANMDE
000C33  1  F0 06        	BEQ	*+8		;IF NOT$RANDOM$MODE THEN
000C35  1  20 6B 0B     	JSR	SETBFI		;SET$BUFFER$INACTIVE
000C38  1  4C 3E 0C     	JMP	L032
000C3B  1  20 3A 0B     	JSR	INTDBF		;INITIALIZE$DISK$BUFFER
000C3E  1  A5 7F        L032	LDA	BUFFER
000C40  1  A4 80        	LDY	BUFFER+1
000C42  1  85 06        	STA	RCRPNT
000C44  1  84 07        	STY	RCRPNT+1	;RECORD$POINTER:=BUFFER
000C46  1  60           	RTS
000C47  1               ;AT$END$DISK$BUFFER
000C47  1  E6 06        ATENDB	INC	RCRPNT
000C49  1  D0 02        	BNE	*+4
000C4B  1  E6 07        	INC	RCRPNT+1	;RECORD$POINTER:=RECORD$POINTER+1
000C4D  1  A5 06        	LDA	RCRPNT
000C4F  1  C5 79        	CMP	BUFEND
000C51  1  A5 07        	LDA	RCRPNT+1
000C53  1  E5 7A        	SBC	BUFEND+1
000C55  1  B0 03        	BCS	*+5		;IF RECORD$POINTER >= BUFFER$END THEN
000C57  1  A9 00        	LDA	#FALSE		;ELSE
000C59  1  60           	RTS
000C5A  1  A9 FF        	LDA	#TRUE
000C5C  1  60           	RTS
000C5D  1               ;VAR$BLOCK$SIZE
000C5D  1  AD 3A 08     VARBSZ	LDA	BLKSZE
000C60  1  0D 3B 08     	ORA	BLKSZE+1
000C63  1  D0 03        	BNE	*+5		;IF BLOCKSIZE <> 0 THEN
000C65  1  A9 00        	LDA	#FALSE		;ELSE
000C67  1  60           	RTS
000C68  1  A9 FF        	LDA	#TRUE
000C6A  1  60           	RTS
000C6B  1               ;WRITE$A$BYTE(CHAR)
000C6B  1  48           WRABYT	PHA			;SAVE CHAR
000C6C  1  20 5D 0C     	JSR	VARBSZ		;IF NOT VAR$BLOCK$SIZE
000C6F  1  F0 1B        	BEQ	L035		;THEN OK
000C71  1  EE 3C 08     	INC	BYTSWR
000C74  1  D0 03        	BNE	*+5
000C76  1  EE 3D 08     	INC	BYTSWR+1	;BYTESWRITTEN:=BYTESWRITTEN+1
000C79  1  AD 3A 08     	LDA	BLKSZE
000C7C  1  CD 3C 08     	CMP	BYTSWR
000C7F  1  AD 3B 08     	LDA	BLKSZE+1
000C82  1  ED 3D 08     	SBC	BYTSWR+1	;IF BLOCKSIZE >= BYTESWRITTEN
000C85  1  B0 05        	BCS	L035		;THEN OK
000C87  1  A9 06        	LDA	#6		;ELSE RECORD SIZE ERROR
000C89  1  4C B8 18     	JMP	ERROR
000C8C  1  20 47 0C     L035	JSR	ATENDB		;IF NOT AT$END$DISK$BUFFER
000C8F  1  F0 03        	BEQ	*+5		;THEN
000C91  1  20 04 0C     	JSR	WDIFRQ		;ELSE WRITE$DISK$IF$REQ
000C94  1  20 64 0B     	JSR	ACTBUF		;IF ACTIVE$BUFFER
000C97  1  D0 11        	BNE	L036		;THEN
000C99  1  20 83 0B     	JSR	RANMDE		;OR IF NOT RANDOM$MODE
000C9C  1  F0 0C        	BEQ	L036		;THEN
000C9E  1  20 E4 0B     	JSR	FILFBF		;ELSE FILL$FILE$BUFFER
000CA1  1  A0 20        	LDY	#32
000CA3  1  B1 75        	LDA	(FILADR),Y
000CA5  1  38           	SEC
000CA6  1  E9 01        	SBC	#1
000CA8  1  91 75        	STA	(FILADR),Y	;FCB(32):=FCB(32)-1
000CAA  1  68           L036	PLA
000CAB  1  A0 00        	LDY	#0
000CAD  1  91 06        	STA	(RCRPNT),Y	;NEXTDISKCHAR:=CHAR
000CAF  1  4C 54 0B     	JMP	SWRMRK		;SET$WRITE$MARK
000CB2  1               ;GET$FILE$NUMBER
000CB2  1  A0 00        GTFLNU	LDY	#0
000CB4  1  B1 5C        	LDA	(RA),Y
000CB6  1  C9 14        	CMP	#NUMFIL
000CB8  1  F0 07        	BEQ	E21		;IF BRAZ=NUMFILES THEN OK
000CBA  1  90 05        	BCC	E21		;OR IF BRAZ<NUMFILES THEN OK
000CBC  1  A9 0B        	LDA	#11		;ELSE ILLEGAL FILE ERROR
000CBE  1  4C B8 18     	JMP	ERROR
000CC1  1  60           E21	RTS
000CC2  1               ;SET$FILE$ADDR
000CC2  1  20 B2 0C     STFLAD	JSR	GTFLNU
000CC5  1  0A           	ASL	A
000CC6  1  AA           	TAX
000CC7  1  BD ED 2F     	LDA	FILES,X
000CCA  1  85 75        	STA	FILADR
000CCC  1  BD EE 2F     	LDA	FILES+1,X
000CCF  1  85 76        	STA	FILADR+1	;FILEADDR:=FILES(GET$FILE$NUMBER)
000CD1  1  05 75        	ORA	FILADR
000CD3  1  D0 05        	BNE	*+7		;IF <> 0 THEN OK
000CD5  1  A9 09        	LDA	#9
000CD7  1  4C B8 18     	JMP	ERROR		;ELSE UNOPENED FILE ERROR
000CDA  1  A0 00        	LDY	#0
000CDC  1  B1 5C        	LDA	(RA),Y
000CDE  1  0A           	ASL	A
000CDF  1  AA           	TAX
000CE0  1  BD 15 30     	LDA	EOFBRN,X
000CE3  1  85 77        	STA	EOFADR
000CE5  1  BD 16 30     	LDA	EOFBRN+1,X
000CE8  1  85 78        	STA	EOFADR+1	;EOFADDR:=EOFBRANCH(BRAZ)
000CEA  1  60           	RTS
000CEB  1               ;SET$FILE$POINTERS
000CEB  1  18           STFLPT	CLC
000CEC  1  A5 75        	LDA	FILADR
000CEE  1  A4 76        	LDY	FILADR+1
000CF0  1  69 26        	ADC	#38
000CF2  1  85 7F        	STA	BUFFER
000CF4  1  90 01        	BCC	*+3
000CF6  1  C8           	INY
000CF7  1  84 80        	STY	BUFFER+1	;BUFFER:=FILEADDR+38
000CF9  1  18           	CLC
000CFA  1  69 80        	ADC	#128
000CFC  1  85 79        	STA	BUFEND
000CFE  1  90 01        	BCC	*+3
000D00  1  C8           	INY
000D01  1  84 7A        	STY	BUFEND+1	;BUFFER$END=BUFFER+DISKRECSIZE
000D03  1  A0 22        	LDY	#17*2		;WORD ADDRESSING
000D05  1  B1 75        	LDA	(FILADR),Y
000D07  1  8D 3A 08     	STA	BLKSZE
000D0A  1  C8           	INY
000D0B  1  B1 75        	LDA	(FILADR),Y
000D0D  1  8D 3B 08     	STA	BLKSZE+1	;BLOCKSIZE:=FCBADD(17)
000D10  1  C8           	INY
000D11  1  B1 75        	LDA	(FILADR),Y
000D13  1  85 06        	STA	RCRPNT
000D15  1  C8           	INY
000D16  1  B1 75        	LDA	(FILADR),Y
000D18  1  85 07        	STA	RCRPNT+1	;RECORDPOINTER:=FCBADD(18)
000D1A  1  20 9E 15     	JSR	SETDMA		;SETDMA
000D1D  1  A0 00        	LDY	#0		;CLEAR EXTENT SIZE FLAG
000D1F  1  8C 3F 08     	STY	EXTSZE
000D22  1  B1 75        	LDA	(FILADR),Y	;GET DRIVE
000D24  1  D0 06        	BNE	CLCDRV		;USE IF NOT ZERO
000D26  1  AD 40 08     	LDA	DFLDRV		;ELSE GET DEFAULT
000D29  1  4C 2F 0D     	JMP	SETDRV
000D2C  1  38           CLCDRV	SEC			;DROP BY ONE
000D2D  1  E9 01        	SBC	#1
000D2F  1  A2 0E        SETDRV	LDX	#14
000D31  1  20 03 01     	JSR	PEM		;SELECT DRIVE
000D34  1  A2 22        	LDX	#34
000D36  1  20 03 01     	JSR	PEM		;READ DCB ADDRESS
000D39  1  85 0C        	STA	DCBPNT
000D3B  1  84 0D        	STY	DCBPNT+1
000D3D  1  A0 06        	LDY	#6
000D3F  1  B1 0C        	LDA	(DCBPNT),Y	;GET BLOCK SIZE
000D41  1  D0 0A        	BNE	EXTSTF		;DONE IF NOT 1K
000D43  1  A0 01        	LDY	#1
000D45  1  B1 0C        	LDA	(DCBPNT),Y	;GET HIGH OF MAXBLK
000D47  1  F0 04        	BEQ	EXTSTF		;DONE IF MAXBLK < 256
000D49  1  38           	SEC
000D4A  1  6E 3F 08     	ROR	EXTSZE		;ELSE SET FLAG
000D4D  1  60           EXTSTF	RTS
000D4E  1               ;SETUP$FILE$EXTENT
000D4E  1  20 65 15     SUFLEX	JSR	OPEN		;IF OPEN OK
000D51  1  10 0A        	BPL	E22		;THEN DONE
000D53  1  20 89 15     	JSR	CREATE		;THEN IF CREATE OK
000D56  1  10 F6        	BPL	SUFLEX		;THEN OPEN IT
000D58  1  A9 0A        	LDA	#10		;ELSE ERROR WHILE MAKING FILE
000D5A  1  4C B8 18     	JMP	ERROR
000D5D  1  60           E22	RTS
000D5E  1               ;TEST$LEGAL
000D5E  1               ;TEST FOR ILLEGAL CHARACTER IN FILE NAME
000D5E  1               ;IF ILLEGAL SEND ERROR MESSAGE AND EXIT
000D5E  1  C9 20        TSTLGL	CMP	#' '		;SEE IF SPACE OR LESS
000D60  1  90 2B        	BCC	ILGCHR		;ERROR IF LESS
000D62  1  F0 29        	BEQ	ILGCHR		;OR IF SPACE
000D64  1  C9 3D        	CMP	#'='
000D66  1  F0 25        	BEQ	ILGCHR		;ERROR IF =
000D68  1  C9 5F        	CMP	#'_'
000D6A  1  F0 21        	BEQ	ILGCHR		;OR IF _
000D6C  1  C9 2E        	CMP	#'.'
000D6E  1  F0 1D        	BEQ	ILGCHR		;OR IF .
000D70  1  C9 3A        	CMP	#':'
000D72  1  F0 19        	BEQ	ILGCHR		;OR IF :
000D74  1  C9 3B        	CMP	#SEMICO
000D76  1  F0 15        	BEQ	ILGCHR		;OR IF ;
000D78  1  C9 3C        	CMP	#'<'
000D7A  1  F0 11        	BEQ	ILGCHR		;OR IF <
000D7C  1  C9 3E        	CMP	#'>'
000D7E  1  F0 0D        	BEQ	ILGCHR		;OR IF >
000D80  1  C9 7F        	CMP	#$7F
000D82  1  F0 09        	BEQ	ILGCHR		;OR IF DELETE
000D84  1  C9 2A        	CMP	#'*'
000D86  1  F0 05        	BEQ	ILGCHR		;OR IF *
000D88  1  C9 3F        	CMP	#'?'
000D8A  1  F0 01        	BEQ	ILGCHR		;OR IF ?
000D8C  1  60           	RTS			;ELSE OK
000D8D  1  A9 1C        ILGCHR	LDA	#28		;FILE NAME ERROR
000D8F  1  4C B8 18     	JMP	ERROR
000D92  1               ;DISK$OPEN
000D92  1               ;OPENS THE FILE - RA CONTAINS THE ADDRESS OF THE FILE NAME AND RB CONTAINS THE
000D92  1               ;BLOCK SIZE.  THE ARRAY FILES WILL HOLD THE ADDRESS OF THE FILE CONTROL BLOCK
000D92  1               ;IN THE FSA.  THE FCB IS FOLLOWED BY 3 FLAGS - BLOCKSIZE(ADDR),
000D92  1               ;RECORDPOINTER(ADDR), WRITEFLAG(BYTE).  THIS IS FOLLOWED BY THE 128 BYTE BUFFER
000D92  1               ;TO DO FILE I/O
000D92  1               NXTFLE				;NEXTFILE
000D92  1  xx           	.res	1
000D93  1               DOI				;I
000D93  1  xx           	.res	1
000D94  1               DOIT				;TYPE INDEX
000D94  1  xx           	.res	1
000D95  1               DOJ				;J
000D95  1  xx           	.res	1
000D96  1  A9 08        DSKOPN	LDA	#8
000D98  1  8D 94 0D     	STA	DOIT		;SET TYPE INDEX
000D9B  1  A2 00        	LDX	#0		;NEXTFILE:=0
000D9D  1  E8           L022	INX
000D9E  1  E8           	INX
000D9F  1  BD ED 2F     	LDA	FILES,X
000DA2  1  1D EE 2F     	ORA	FILES+1,X
000DA5  1  D0 F6        	BNE	L022		;DO WHILE FILES( ) <> 0
000DA7  1  8E 92 0D     	STX	NXTFLE
000DAA  1  A9 A6        	LDA	#166
000DAC  1  A0 00        	LDY	#0
000DAE  1  20 4B 16     	JSR	GETS		;GETSPACE(166)
000DB1  1  85 75        	STA	FILADR
000DB3  1  84 76        	STY	FILADR+1	;FILEADDR:=
000DB5  1  AE 92 0D     	LDX	NXTFLE
000DB8  1  9D ED 2F     	STA	FILES,X
000DBB  1  98           	TYA
000DBC  1  9D EE 2F     	STA	FILES+1,X	;FILES(NEXTFILE):=
000DBF  1  18           	CLC
000DC0  1  A5 75        	LDA	FILADR
000DC2  1  A4 76        	LDY	FILADR+1
000DC4  1  69 26        	ADC	#38
000DC6  1  85 7F        	STA	BUFFER
000DC8  1  90 01        	BCC	*+3
000DCA  1  C8           	INY
000DCB  1  84 80        	STY	BUFFER+1	;BUFFER:=FILEADDR+38
000DCD  1  20 9E 15     	JSR	SETDMA
000DD0  1  A0 0B        	LDY	#11
000DD2  1  A9 20        	LDA	#' '
000DD4  1  91 75        L023	STA	(FILADR),Y
000DD6  1  88           	DEY
000DD7  1  D0 FB        	BNE	L023		;FILL((FILENAME:=FILEADDR+1),' ',11)
000DD9  1  B1 5C        	LDA	(RA),Y
000DDB  1  85 08        	STA	DOBF
000DDD  1  C8           	INY
000DDE  1  B1 5C        	LDA	(RA),Y
000DE0  1  85 09        	STA	DOBF+1		;BUFF:=ARA
000DE2  1  C8           	INY			;Y:=2
000DE3  1  B1 08        	LDA	(DOBF),Y
000DE5  1  C9 3A        	CMP	#':'		;IF CHAR(2) <> :
000DE7  1  D0 29        	BNE	L024		;THEN
000DE9  1  88           	DEY			;Y:=1
000DEA  1  B1 08        	LDA	(DOBF),Y
000DEC  1  20 65 08     	JSR	LWRUPR		;CONVERT TO UPPER CASE
000DEF  1  C9 41        	CMP	#'A'		;MAKE SURE IS A OR MORE
000DF1  1  90 9A        	BCC	ILGCHR		;ERROR IF NOT
000DF3  1  C9 49        	CMP	#'H'+1
000DF5  1  B0 96        	BCS	ILGCHR		;ERROR IF OVER H
000DF7  1  29 0F        	AND	#$F
000DF9  1  88           	DEY			;Y:=0
000DFA  1  91 75        	STA	(FILADR),Y	;FCB(0):=CHAR(1) AND $F
000DFC  1  B1 08        	LDA	(DOBF),Y
000DFE  1  38           	SEC
000DFF  1  E9 02        	SBC	#2
000E01  1  8D 93 0D     	STA	DOI		;I:=CHAR(0)-2
000E04  1  18           	CLC
000E05  1  A5 08        	LDA	DOBF
000E07  1  69 02        	ADC	#2
000E09  1  85 08        	STA	DOBF
000E0B  1  90 02        	BCC	*+4
000E0D  1  E6 09        	INC	DOBF+1		;BUFF:=BUFF+2
000E0F  1  4C 19 0E     	JMP	L026
000E12  1  A0 00        L024	LDY	#0
000E14  1  B1 08        	LDA	(DOBF),Y
000E16  1  8D 93 0D     	STA	DOI		;I:=CHAR(0)
000E19  1  AD 93 0D     L026	LDA	DOI
000E1C  1  C9 0D        	CMP	#12+1
000E1E  1  90 05        	BCC	L027
000E20  1  A9 0C        	LDA	#12
000E22  1  8D 93 0D     	STA	DOI		;I:=12
000E25  1  E6 08        L027	INC	DOBF
000E27  1  D0 02        	BNE	*+4
000E29  1  E6 09        	INC	DOBF+1		;BUFF:=BUFF+1
000E2B  1  A9 FF        	LDA	#255
000E2D  1  8D 95 0D     	STA	DOJ		;J:=255
000E30  1  EE 95 0D     L028	INC	DOJ
000E33  1  AC 95 0D     	LDY	DOJ
000E36  1  B1 08        	LDA	(DOBF),Y
000E38  1  20 65 08     	JSR	LWRUPR		;CONVERT TO UPPERCASE
000E3B  1  C9 2E        	CMP	#'.'		;IF CHAR(INCJ$)=.
000E3D  1  F0 0E        	BEQ	L029		;THEN DONE
000E3F  1  CC 93 0D     	CPY	DOI		;OR IF J >= I
000E42  1  B0 09        	BCS	L029		;THEN DONE
000E44  1  C8           	INY
000E45  1  20 5E 0D     	JSR	TSTLGL		;MAKE SURE IS LEGAL
000E48  1  91 75        	STA	(FILADR),Y	;ELSE PUT IN FCB
000E4A  1  4C 30 0E     	JMP	L028		;AND LOOP
000E4D  1  EE 95 0D     L029	INC	DOJ
000E50  1  EE 94 0D     	INC	DOIT		;BUMP TYPE INDEX
000E53  1  AC 95 0D     	LDY	DOJ
000E56  1  CC 93 0D     	CPY	DOI		;IF J >= I
000E59  1  B0 10        	BCS	L037		;THEN DONE
000E5B  1  B1 08        	LDA	(DOBF),Y
000E5D  1  20 65 08     	JSR	LWRUPR		;CONVERT TO UPPERCASE
000E60  1  AC 94 0D     	LDY	DOIT		;GET TYPE INDEX
000E63  1  20 5E 0D     	JSR	TSTLGL		;MAKE SURE IS LEGAL
000E66  1  91 75        	STA	(FILADR),Y
000E68  1  4C 4D 0E     	JMP	L029
000E6B  1  20 4E 0D     L037	JSR	SUFLEX		;SETUP$FILE$EXTENT
000E6E  1  20 3A 0B     	JSR	INTDBF		;INITIALIZE$DISK$BUFFER
000E71  1  A5 75        	LDA	FILADR
000E73  1  A6 76        	LDX	FILADR+1
000E75  1  E8           	INX			;AX:=FILEADDR+256
000E76  1  A0 24        	LDY	#18*2		;WORD ADDRESS
000E78  1  91 75        	STA	(FILADR),Y
000E7A  1  C8           	INY
000E7B  1  8A           	TXA
000E7C  1  91 75        	STA	(FILADR),Y	;FCBADD(18):=FILEADDR+256
000E7E  1  20 52 19     	JSR	POPSTK		;POP$STACK
000E81  1  A0 00        	LDY	#0
000E83  1  B1 5C        	LDA	(RA),Y
000E85  1  AA           	TAX
000E86  1  C8           	INY
000E87  1  B1 5C        	LDA	(RA),Y
000E89  1  A0 23        	LDY	#17*2+1		;HIGH OF WORD ADDRESS
000E8B  1  91 75        	STA	(FILADR),Y
000E8D  1  88           	DEY
000E8E  1  8A           	TXA
000E8F  1  91 75        	STA	(FILADR),Y	;FCBADD(17):=ARA
000E91  1  4C 52 19     	JMP	POPSTK		;POP$STACK
000E94  1               ;SET$EOF$STACK
000E94  1  A5 5C        STEFST	LDA	RA
000E96  1  A4 5D        	LDY	RA+1
000E98  1  8D 36 08     	STA	EOFRA
000E9B  1  8C 37 08     	STY	EOFRA+1		;EOFRA:=RA
000E9E  1  A5 5E        	LDA	RB
000EA0  1  A4 5F        	LDY	RB+1
000EA2  1  8D 38 08     	STA	EOFRB
000EA5  1  8C 39 08     	STY	EOFRB+1		;EOFRB:=RB
000EA8  1  60           	RTS
000EA9  1               ;SETUP$DISK$IO
000EA9  1  20 C2 0C     SUDSIO	JSR	STFLAD		;SET$FILE$ADDR
000EAC  1  20 EB 0C     	JSR	STFLPT		;SET$FILE$POINTER
000EAF  1  A9 00        	LDA	#0
000EB1  1  8D 3C 08     	STA	BYTSWR
000EB4  1  8D 3D 08     	STA	BYTSWR+1	;BYTES$WRITTEN:=0
000EB7  1  A9 FF        	LDA	#TRUE
000EB9  1  8D 3E 08     	STA	FRSFLD		;FIRSTFIELD:=TRUE
000EBC  1  4C 52 19     	JMP	POPSTK		;POP$STACK
000EBF  1               ;RANDOM$SETUP
000EBF  1               RURC				;RECORD
000EBF  1  xx           	.res	1
000EC0  1  20 5D 0C     RANSTU	JSR	VARBSZ		;IF VAR$BLOCK$SIZE
000EC3  1  D0 05        	BNE	*+7		;THEN OK
000EC5  1  A9 12        	LDA	#18		;ELSE UNBLOCKED FILE ERROR
000EC7  1  4C B8 18     	JMP	ERROR
000ECA  1  20 24 19     	JSR	RAZERA		;IF RA$ZERO$ADDRESS
000ECD  1  D0 05        	BNE	L038		;THEN ERROR
000ECF  1  20 D9 18     	JSR	RANEG		;IF POSITIVE
000ED2  1  F0 05        	BEQ	*+7		;THEN OK
000ED4  1  A9 08        L038	LDA	#8		;ELSE INVALID RECORD #
000ED6  1  4C B8 18     	JMP	ERROR
000ED9  1  A0 00        	LDY	#0
000EDB  1  38           	SEC
000EDC  1  B1 5C        	LDA	(RA),Y
000EDE  1  E9 01        	SBC	#1
000EE0  1  91 5C        	STA	(RA),Y
000EE2  1  C8           	INY
000EE3  1  B1 5C        	LDA	(RA),Y
000EE5  1  E9 00        	SBC	#0
000EE7  1  91 5C        	STA	(RA),Y
000EE9  1  20 7B 0B     	JSR	SETRAN		;SET$RANDOM$MODE
000EEC  1  20 6B 0B     	JSR	SETBFI		;SET$BUFFER$INACTIVE
000EEF  1  20 04 0C     	JSR	WDIFRQ		;WRITE$DISK$IF$REQ
000EF2  1  AD 3A 08     	LDA	BLKSZE
000EF5  1  AC 3B 08     	LDY	BLKSZE+1
000EF8  1  85 32        	STA	PX
000EFA  1  84 33        	STY	PX+1		;PX:=BLOCKSIZE
000EFC  1  20 0E 1A     	JSR	ARA		;AY:=RECORD NUMBER - 1
000EFF  1  20 96 1A     	JSR	MXAP		;AY:=AY*PX
000F02  1  29 7F        	AND	#$7F		;A:=BYTECOUNT AND $7F
000F04  1  18           	CLC
000F05  1  65 7F        	ADC	BUFFER
000F07  1  A4 80        	LDY	BUFFER+1
000F09  1  90 01        	BCC	*+3
000F0B  1  C8           	INY
000F0C  1  AA           	TAX
000F0D  1  D0 01        	BNE	*+3
000F0F  1  88           	DEY
000F10  1  CA           	DEX
000F11  1  86 06        	STX	RCRPNT
000F13  1  84 07        	STY	RCRPNT+1	;RECORDPOINTER:=( )+BUFFER-1
000F15  1  20 8B 0B     	JSR	STRRPT		;STORE$REC$PTR
000F18  1  20 60 0F     	JSR	SHFPXL		;SHIFT ACCUM LEFT
000F1B  1  A5 33        	LDA	PX+1		;GET RECORD BYTE
000F1D  1  29 7F        	AND	#$7F		;CLEAR MSB
000F1F  1  2C 3F 08     	BIT	EXTSZE		;TEST FLAG
000F22  1  10 05        	BPL	NOT8KE		;SKIP IF 16K
000F24  1  29 3F        	AND	#$3F		;ELSE TRIM SOME MORE
000F26  1  20 60 0F     	JSR	SHFPXL		;AND SHIFT EXTRA TIME
000F29  1  8D BF 0E     NOT8KE	STA	RURC		;PUT IN RECORD
000F2C  1  20 60 0F     	JSR	SHFPXL		;SHIFT LEFT AGAIN
000F2F  1  A0 0C        	LDY	#12
000F31  1  B1 75        	LDA	(FILADR),Y	;A:=FCB(12)
000F33  1  C5 34        	CMP	PX+2		;COMPARE TO LOW
000F35  1  D0 07        	BNE	CHGEXT		;CHANGE IF DIFF
000F37  1  C8           	INY
000F38  1  B1 75        	LDA	(FILADR),Y
000F3A  1  C5 35        	CMP	PX+3		;SAME FOR HIGH
000F3C  1  F0 18        	BEQ	L040		;IF EXTENT=( ) THEN
000F3E  1  20 6E 15     CHGEXT	JSR	CLOSE		;ELSE CLOSE
000F41  1  10 05        	BPL	*+7		;IF OK
000F43  1  A9 01        	LDA	#1		;ELSE FILE CLOSING ERROR
000F45  1  4C B8 18     	JMP	ERROR
000F48  1  A0 0C        	LDY	#12
000F4A  1  A5 34        	LDA	PX+2
000F4C  1  91 75        	STA	(FILADR),Y	;FCB(12):=EXTENT
000F4E  1  C8           	INY			;SAME FOR HIGH
000F4F  1  A5 35        	LDA	PX+3
000F51  1  91 75        	STA	(FILADR),Y
000F53  1  20 4E 0D     	JSR	SUFLEX		;SETUP$FILE$EXTENT
000F56  1  AD BF 0E     L040	LDA	RURC
000F59  1  A0 20        	LDY	#32
000F5B  1  91 75        	STA	(FILADR),Y	;FCB(32):=LOW(RECORD) AND $7F
000F5D  1  4C 52 19     	JMP	POPSTK		;POP$STACK
000F60  1               ;SHIFT FIXED POINT ACCUM LEFT ONE BIT
000F60  1  06 32        SHFPXL	ASL	PX
000F62  1  26 33        	ROL	PX+1
000F64  1  26 34        	ROL	PX+2
000F66  1  26 35        	ROL	PX+3
000F68  1  60           	RTS
000F69  1               ;GET$DISK$CHAR
000F69  1  20 47 0C     GTDSCH	JSR	ATENDB		;IF NOT AT$END$DISK$BUFFER
000F6C  1  F0 06        	BEQ	L041		;THEN
000F6E  1  20 04 0C     	JSR	WDIFRQ		;WRITE$DISK$IF$REQ
000F71  1  20 E4 0B     	JSR	FILFBF		;FILL$FILE$BUFFER
000F74  1  20 64 0B     L041	JSR	ACTBUF		;IF ACTIVE$BUFFER
000F77  1  D0 03        	BNE	*+5		;THEN
000F79  1  20 E4 0B     	JSR	FILFBF		;ELSE FILL$FILE$BUFFER
000F7C  1  A0 00        	LDY	#0
000F7E  1  B1 06        	LDA	(RCRPNT),Y	;IF NEXTDISKCHAR
000F80  1  C9 1A        	CMP	#EOF		;<> EOFFILLER
000F82  1  D0 03        	BNE	*+5		;THEN
000F84  1  20 97 0B     	JSR	DSKEOF		;ELSE DISK$EOF
000F87  1  A0 00        	LDY	#0
000F89  1  B1 06        	LDA	(RCRPNT),Y
000F8B  1  60           	RTS			;RETURN NEXTDISKCHAR
000F8C  1               ;INC$POINT
000F8C  1  E6 0A        INCWFP	INC	WTFPNT
000F8E  1  D0 02        	BNE	*+4
000F90  1  E6 0B        	INC	WTFPNT+1
000F92  1  60           	RTS			;POINT:=POINT+1
000F93  1               ;WRITE$TO$FILE(TYPE)
000F93  1               ;IF TYPE=0 THEN NUMBER, =1 THEN STRING
000F93  1               WFTYP				;TYPE
000F93  1  xx           	.res	1
000F94  1               WFI				;I
000F94  1  xx           	.res	1
000F95  1               WFCNT				;COUNT
000F95  1  xx           	.res	1
000F96  1  8D 93 0F     WRTOFL	STA	WFTYP		;SAVE TYPE
000F99  1  AA           	TAX
000F9A  1  D0 03        	BNE	*+5		;IF STRING THEN
000F9C  1  20 2C 1A     	JSR	NUMOUT		;ELSE NUMERICOUT
000F9F  1  2C 3E 08     	BIT	FRSFLD
000FA2  1  30 08        	BMI	L000		;IF FIRSTFIELD THEN
000FA4  1  A9 2C        	LDA	#','
000FA6  1  20 6B 0C     	JSR	WRABYT		;ELSE WRITE$A$BYTE(,)
000FA9  1  4C B1 0F     	JMP	L001
000FAC  1  A9 00        L000	LDA	#FALSE
000FAE  1  8D 3E 08     	STA	FRSFLD		;FIRSTFIELD:=FALSE
000FB1  1  A0 00        L001	LDY	#0
000FB3  1  B1 5C        	LDA	(RA),Y
000FB5  1  85 0A        	STA	WTFPNT
000FB7  1  C8           	INY
000FB8  1  B1 5C        	LDA	(RA),Y
000FBA  1  85 0B        	STA	WTFPNT+1	;POINT:=ARA
000FBC  1  88           	DEY
000FBD  1  B1 0A        	LDA	(WTFPNT),Y
000FBF  1  8D 95 0F     	STA	WFCNT		;COUNT:=CHAR
000FC2  1  AD 93 0F     	LDA	WFTYP
000FC5  1  D0 06        	BNE	L002		;IF TYPE NOT NUMERIC THEN
000FC7  1  CE 95 0F     	DEC	WFCNT		;ELSE COUNT:=COUNT-1
000FCA  1  4C D2 0F     	JMP	L003
000FCD  1  A9 22        L002	LDA	#'"'
000FCF  1  20 6B 0C     	JSR	WRABYT		;WRITE$A$BYTE(")
000FD2  1  20 8C 0F     L003	JSR	INCWFP		;INC$POINT
000FD5  1  A9 01        	LDA	#1
000FD7  1  8D 94 0F     	STA	WFI		;I:=1
000FDA  1  AD 95 0F     L004	LDA	WFCNT
000FDD  1  CD 94 0F     	CMP	WFI		;IF I > COUNT
000FE0  1  90 19        	BCC	L005		;THEN
000FE2  1  A0 00        	LDY	#0
000FE4  1  B1 0A        	LDA	(WTFPNT),Y	;A:=CHAR
000FE6  1  C9 22        	CMP	#'"'
000FE8  1  D0 05        	BNE	*+7		;IF NOT QUOTE THEN
000FEA  1  A9 18        	LDA	#24		;ELSE WRITE QUOTE ERROR
000FEC  1  4C B8 18     	JMP	ERROR
000FEF  1  20 6B 0C     	JSR	WRABYT		;WRITE$A$BYTE(CHAR)
000FF2  1  20 8C 0F     	JSR	INCWFP		;INC$POINT
000FF5  1  EE 94 0F     	INC	WFI		;BUMP I
000FF8  1  4C DA 0F     	JMP	L004		;AND LOOP
000FFB  1  AD 93 0F     L005	LDA	WFTYP
000FFE  1  F0 08        	BEQ	L006		;IF TYPE NOT STRING THEN
001000  1  A9 22        	LDA	#'"'		;ELSE
001002  1  20 6B 0C     	JSR	WRABYT		;WRITE$A$BYTE(")
001005  1  20 CE 12     	JSR	STRFRE		;STRINGFREE
001008  1  4C 52 19     L006	JMP	POPSTK		;POP$STACK
00100B  1               ;DISK$CLOSE
00100B  1  20 EB 0C     DSKCLS	JSR	STFLPT		;SET$FILE$POINTERS
00100E  1  20 04 0C     	JSR	WDIFRQ		;WRITE$DISK$IF$REQ
001011  1  20 6E 15     	JSR	CLOSE
001014  1  10 05        	BPL	*+7		;IF CLOSE OK THEN
001016  1  A9 01        	LDA	#1		;ELSE CLOSE ERROR
001018  1  4C B8 18     	JMP	ERROR
00101B  1  A5 75        	LDA	FILADR
00101D  1  A4 76        	LDY	FILADR+1
00101F  1  4C E8 16     	JMP	RELS		;RELEASE(FILEADDR)
001022  1               ;CLOSEFILES
001022  1  A2 00        CLSFLS	LDX	#0		;I:=0
001024  1  E8           L007	INX			;I:=I+1
001025  1  E0 14        	CPX	#NUMFIL
001027  1  90 03        	BCC	*+5		;IF I < NUMFILES THEN
001029  1  F0 01        	BEQ	*+3		;IF I = NUMFILES THEN
00102B  1  60           	RTS
00102C  1  8A           	TXA			;A:=I
00102D  1  48           	PHA			;SAVE ON STACK
00102E  1  0A           	ASL	A		;A:=A*2
00102F  1  AA           	TAX
001030  1  BD ED 2F     	LDA	FILES,X
001033  1  85 75        	STA	FILADR
001035  1  BD EE 2F     	LDA	FILES+1,X
001038  1  85 76        	STA	FILADR+1	;FILEADDR:=FILES(I)
00103A  1  05 75        	ORA	FILADR
00103C  1  F0 03        	BEQ	*+5		;IF FILEADDR=0 THEN
00103E  1  20 0B 10     	JSR	DSKCLS		;ELSE DISK$CLOSE
001041  1  68           	PLA			;GET I BACK
001042  1  AA           	TAX
001043  1  4C 24 10     	JMP	L007		;AND LOOP
001046  1               ;ROUTINE TO EXIT INTERPRETER
001046  1               ;EXIT$INTERP
001046  1  20 22 10     EXTINT	JSR	CLSFLS		;CLOSEFILES
001049  1  20 24 1A     	JSR	DMPPBF		;DUMP$PRINT$BUFF
00104C  1  20 34 15     	JSR	CRLF
00104F  1  4C 00 01     	JMP	BOOT
001052  1               ;STORE(TYPE)
001052  1               ;STORE PLACES RA IN THE PRT LOCATION REFERENCED BY RB. RA MAY CONTAIN A
001052  1               ;FLOATING POINT NUMBER OR A REFERENCE TO A STRING.  IN THE CASE OF A STRING
001052  1               ;THE FOLLOWING IS ALSO PERFORMED
001052  1               ;	(1)	IF THE PRT CELL ALREADY CONTAINS A REFERENCE TO A STRING IN THE
001052  1               ;		FSA THAT STRING'S COUNTER IS DECREMENTED AND IF EQUAL TO 1 THEN
001052  1               ;		THE SPACE IS FREED.
001052  1               ;	(2)	THE NEW STRING COUNTER IS INCREMENTED.  IF IT IS ALREADY 255
001052  1               ;		THEN A COPY IS MADE AND THE NEW COUNTER SET TO 2.
001052  1  48           STORE	PHA			;SAVE TYPE
001053  1  A5 5E        	LDA	RB
001055  1  A4 5F        	LDY	RB+1
001057  1  20 B8 19     	JSR	SEDAAD		;SET$DATA$ADDR(RB)
00105A  1  68           	PLA			;GET TYPE
00105B  1  29 01        	AND	#1
00105D  1  D0 03        	BNE	*+5		;IF STRING CONTINUE
00105F  1  4C 0A 11     	JMP	JSTSTR		;IF NUMBER JUST STORE
001062  1  A9 00        	LDA	#0
001064  1  20 F1 18     	JSR	FLSTRA		;FLAG$STRING$ADDR(0)
001067  1  20 03 1A     	JSR	ARB
00106A  1  85 14        	STA	PTRADR
00106C  1  84 15        	STY	PTRADR+1	;PTRADDR:=ARB
00106E  1  A0 00        	LDY	#0
001070  1  B1 14        	LDA	(PTRADR),Y
001072  1  48           	PHA
001073  1  C8           	INY
001074  1  B1 14        	LDA	(PTRADR),Y
001076  1  A8           	TAY
001077  1  68           	PLA			;AY:=STRINGADDR
001078  1  20 A5 19     	JSR	INFSA		;IN$FSA(STRINGADDR)
00107B  1  F0 2A        	BEQ	NTTHR		;BRANCH IF NOT
00107D  1  A0 00        	LDY	#0
00107F  1  B1 14        	LDA	(PTRADR),Y
001081  1  AA           	TAX
001082  1  C8           	INY
001083  1  B1 14        	LDA	(PTRADR),Y
001085  1  A8           	TAY
001086  1  8A           	TXA
001087  1  D0 01        	BNE	*+3
001089  1  88           	DEY
00108A  1  CA           	DEX			;STRINGADDR-1
00108B  1  86 16        	STX	SPTR
00108D  1  84 17        	STY	SPTR+1		;PTR:=
00108F  1  38           	SEC
001090  1  A0 00        	LDY	#0
001092  1  B1 16        	LDA	(SPTR),Y
001094  1  E9 01        	SBC	#1
001096  1  91 16        	STA	(SPTR),Y	;COUNTER:=COUNTER-1
001098  1  C9 01        	CMP	#1
00109A  1  D0 0B        	BNE	NTTHR		;IF <> 1 THEN
00109C  1  B1 14        	LDA	(PTRADR),Y
00109E  1  48           	PHA
00109F  1  C8           	INY
0010A0  1  B1 14        	LDA	(PTRADR),Y
0010A2  1  A8           	TAY
0010A3  1  68           	PLA
0010A4  1  20 E8 16     	JSR	RELS		;ELSE RELEASE(STRINGADDR)
0010A7  1  20 0E 1A     NTTHR	JSR	ARA
0010AA  1  38           	SEC
0010AB  1  E9 01        	SBC	#1
0010AD  1  B0 01        	BCS	*+3
0010AF  1  88           	DEY
0010B0  1  85 16        	STA	SPTR
0010B2  1  84 17        	STY	SPTR+1		;PTR:=ARA-1
0010B4  1  20 A5 19     	JSR	INFSA		;INFSA(PTR)
0010B7  1  F0 51        	BEQ	JSTSTR		;IF NOT THEN
0010B9  1  A0 00        	LDY	#0
0010BB  1  B1 16        	LDA	(SPTR),Y	;A:=COUNTER
0010BD  1  C9 FF        	CMP	#255		;IF NOT 255
0010BF  1  D0 40        	BNE	BMPCNT		;JUST BUMP COUNT
0010C1  1  E6 16        	INC	SPTR
0010C3  1  D0 02        	BNE	*+4
0010C5  1  E6 17        	INC	SPTR+1
0010C7  1  B1 16        	LDA	(SPTR),Y	;COUNTER
0010C9  1  18           	CLC
0010CA  1  69 01        	ADC	#1		;A:=COUNTER+1
0010CC  1  20 4B 16     	JSR	GETS		;GETSPACE(COUNTER+1)
0010CF  1  48           	PHA			;SAVE LOW
0010D0  1  98           	TYA			;HIGH TO A
0010D1  1  A0 01        	LDY	#1
0010D3  1  91 5C        	STA	(RA),Y
0010D5  1  85 2F        	STA	MTO+1
0010D7  1  88           	DEY
0010D8  1  68           	PLA
0010D9  1  91 5C        	STA	(RA),Y		;ARA:=GETSPACE(COUNTER+1)
0010DB  1  85 2E        	STA	MTO		;TO:=ARA
0010DD  1  A5 16        	LDA	SPTR
0010DF  1  A4 17        	LDY	SPTR+1
0010E1  1  85 2C        	STA	MFROM
0010E3  1  84 2D        	STY	MFROM+1		;FROM:=PTR
0010E5  1  A0 00        	LDY	#0
0010E7  1  B1 16        	LDA	(SPTR),Y
0010E9  1  18           	CLC
0010EA  1  69 01        	ADC	#1
0010EC  1  20 7C 17     	JSR	MOVE		;MOVE( , , )
0010EF  1  A0 00        	LDY	#0
0010F1  1  B1 5C        	LDA	(RA),Y
0010F3  1  AA           	TAX
0010F4  1  C8           	INY
0010F5  1  B1 5C        	LDA	(RA),Y
0010F7  1  A8           	TAY
0010F8  1  8A           	TXA
0010F9  1  D0 01        	BNE	*+3
0010FB  1  88           	DEY
0010FC  1  CA           	DEX
0010FD  1  86 16        	STX	SPTR
0010FF  1  84 17        	STY	SPTR+1		;PTR:=ARA-1
001101  1  A0 00        BMPCNT	LDY	#0
001103  1  B1 16        	LDA	(SPTR),Y
001105  1  18           	CLC
001106  1  69 01        	ADC	#1
001108  1  91 16        	STA	(SPTR),Y	;COUNTER:=COUNTER+1
00110A  1  A5 5C        JSTSTR	LDA	RA
00110C  1  A4 5D        	LDY	RA+1
00110E  1  85 2C        	STA	MFROM
001110  1  84 2D        	STY	MFROM+1		;FROM:=RA
001112  1  20 03 1A     	JSR	ARB
001115  1  85 2E        	STA	MTO
001117  1  84 2F        	STY	MTO+1		;TO:=ARB
001119  1  4C 72 17     	JMP	MOVE4		;MOVE4(FROM,TO)
00111C  1               ;ARRAY ADDRESSING ROUTINES
00111C  1               ;CALC$ROW
00111C  1               ;SETS UP AN ARRAY IN THE FSA IN ROW MAJOR ORDER. THE BYTE OF CODE FOLLOWING THE
00111C  1               ;OPERATOR IS THE NUMBER OF DIMENSIONS.  THE STACK CONTAINS THE UPPER BOUND OF
00111C  1               ;EACH DIMENSION - RA HOLDS DIMENSION N, RB N-1, ETC.  THE LOWER BOUND IS ALWAYS
00111C  1               ;ZERO.
00111C  1  A9 01        CLCROW	LDA	#1
00111E  1  A0 00        	LDY	#0
001120  1  8D 4A 08     	STA	ASIZE
001123  1  8C 4B 08     	STY	ASIZE+1		;ASIZE:=1
001126  1  20 7B 19     	JSR	STINCN		;STEP$INS$CNT
001129  1  A5 5C        	LDA	RA
00112B  1  A4 5D        	LDY	RA+1
00112D  1  8D 4C 08     	STA	SAVERA
001130  1  8C 4D 08     	STY	SAVERA+1	;SAVERA:=RA
001133  1  A5 5E        	LDA	RB
001135  1  A4 5F        	LDY	RB+1
001137  1  8D 4E 08     	STA	SAVERB
00113A  1  8C 4F 08     	STY	SAVERB+1	;SAVERB:=RB
00113D  1  A9 01        	LDA	#1
00113F  1  8D 50 08     	STA	CI		;I:=1
001142  1  A0 00        CLRP	LDY	#0
001144  1  B1 60        	LDA	(RC),Y		;GET NUMDIM
001146  1  CD 50 08     	CMP	CI		;IF I>NUMDIM
001149  1  90 2F        	BCC	GTALLD		;THEN
00114B  1  20 0E 1A     	JSR	ARA
00114E  1  18           	CLC
00114F  1  69 01        	ADC	#1
001151  1  90 01        	BCC	*+3
001153  1  C8           	INY
001154  1  85 32        	STA	PX
001156  1  84 33        	STY	PX+1		;PX:=ARA+1
001158  1  AD 4A 08     	LDA	ASIZE
00115B  1  AC 4B 08     	LDY	ASIZE+1
00115E  1  20 96 1A     	JSR	MXAP		;AY:=ASIZE*(ARA+1)
001161  1  8D 4A 08     	STA	ASIZE
001164  1  8C 4B 08     	STY	ASIZE+1		;ASIZE:=
001167  1  A0 00        	LDY	#0
001169  1  91 5C        	STA	(RA),Y
00116B  1  C8           	INY
00116C  1  AD 4B 08     	LDA	ASIZE+1
00116F  1  91 5C        	STA	(RA),Y		;ARA:=ASIZE
001171  1  20 52 19     	JSR	POPSTK		;POP$STACK
001174  1  EE 50 08     	INC	CI		;I:=I+1
001177  1  4C 42 11     	JMP	CLRP		;AND LOOP
00117A  1  AD 4C 08     GTALLD	LDA	SAVERA
00117D  1  AC 4D 08     	LDY	SAVERA+1
001180  1  85 5C        	STA	RA
001182  1  84 5D        	STY	RA+1		;RA:=SAVERA
001184  1  AD 4E 08     	LDA	SAVERB
001187  1  AC 4F 08     	LDY	SAVERB+1
00118A  1  85 5E        	STA	RB
00118C  1  84 5F        	STY	RB+1		;RB:=SAVERB
00118E  1  A0 00        	LDY	#0
001190  1  B1 60        	LDA	(RC),Y		;A:=NUMDIM
001192  1  18           	CLC
001193  1  69 01        	ADC	#1
001195  1  0A           	ASL	A
001196  1  8D 51 08     	STA	CLCT
001199  1  AD 4A 08     	LDA	ASIZE
00119C  1  AC 4B 08     	LDY	ASIZE+1
00119F  1  20 AB 17     	JSR	TIMES4		;TIMES4(ASIZE)
0011A2  1  18           	CLC
0011A3  1  6D 51 08     	ADC	CLCT
0011A6  1  90 01        	BCC	*+3
0011A8  1  C8           	INY
0011A9  1  20 4B 16     	JSR	GETS		;GETSPACE()
0011AC  1  8D 4C 08     	STA	SAVERA
0011AF  1  8C 4D 08     	STY	SAVERA+1	;SAVERA:=
0011B2  1  85 1E        	STA	ARYADR
0011B4  1  84 1F        	STY	ARYADR+1	;ARRAYADDR:=
0011B6  1  A0 00        	LDY	#0
0011B8  1  B1 60        	LDA	(RC),Y		;A:=NUMDIM
0011BA  1  91 1E        	STA	(ARYADR),Y
0011BC  1  98           	TYA
0011BD  1  C8           	INY
0011BE  1  91 1E        	STA	(ARYADR),Y	;:=0
0011C0  1  A9 01        	LDA	#1
0011C2  1  8D 50 08     	STA	CI		;I:=1
0011C5  1  A0 00        CALP	LDY	#0
0011C7  1  B1 60        	LDA	(RC),Y
0011C9  1  CD 50 08     	CMP	CI		;IF I>NUMDIM
0011CC  1  90 1F        	BCC	GTALAA		;THEN
0011CE  1  18           	CLC
0011CF  1  A5 1E        	LDA	ARYADR
0011D1  1  69 02        	ADC	#2
0011D3  1  85 1E        	STA	ARYADR
0011D5  1  90 02        	BCC	*+4
0011D7  1  E6 1F        	INC	ARYADR+1	;ARRAYADDR:=ARRAYADDR+2
0011D9  1  A0 00        	LDY	#0
0011DB  1  B1 5C        	LDA	(RA),Y
0011DD  1  91 1E        	STA	(ARYADR),Y
0011DF  1  C8           	INY
0011E0  1  B1 5C        	LDA	(RA),Y
0011E2  1  91 1E        	STA	(ARYADR),Y	;ARRAYPOS:=ARA
0011E4  1  20 52 19     	JSR	POPSTK		;POP$STACK
0011E7  1  EE 50 08     	INC	CI		;I:=I+1
0011EA  1  4C C5 11     	JMP	CALP
0011ED  1  20 82 19     GTALAA	JSR	PSHSTK		;PUSH$STACK
0011F0  1  A0 00        	LDY	#0
0011F2  1  AD 4C 08     	LDA	SAVERA
0011F5  1  91 5C        	STA	(RA),Y
0011F7  1  C8           	INY
0011F8  1  AD 4D 08     	LDA	SAVERA+1
0011FB  1  91 5C        	STA	(RA),Y		;ARA:=SAVERA
0011FD  1  60           	RTS
0011FE  1               ;INC$ARRAYADDR
0011FE  1  18           INCAAD	CLC
0011FF  1  A5 1E        	LDA	ARYADR
001201  1  69 02        	ADC	#2
001203  1  85 1E        	STA	ARYADR
001205  1  90 02        	BCC	*+4
001207  1  E6 1F        	INC	ARYADR+1	;ARRAYADDR:=ARRAYADDR+2
001209  1  60           	RTS
00120A  1               ;CALC$SUB
00120A  1               ;PERFORMS A SUBSCRIPT CALCULATION FOR THE ARRAY REFERENCED BY RA.  THE VALUE OF
00120A  1               ;EACH DIMENSION IS ON THE STACK BELOW THE ARRAY ADDRESS STARTING WITH THE NTH
00120A  1               ;DIMENSION.  A CHECK IS MADE TO SEE IF THE SELECTED ELEMENT IS OUTSIDE THE AREA
00120A  1               ;ASSIGNED TO THE ARRAY
00120A  1  20 0E 1A     CLCSUB	JSR	ARA
00120D  1  85 1E        	STA	ARYADR
00120F  1  84 1F        	STY	ARYADR+1	;ARRAYADDR:=ARA
001211  1  20 52 19     	JSR	POPSTK		;POP$STACK
001214  1  20 0E 1A     	JSR	ARA
001217  1  8D 52 08     	STA	LOCATN
00121A  1  8C 53 08     	STY	LOCATN+1	;LOCATION:=ARA
00121D  1  A0 00        	LDY	#0
00121F  1  B1 1E        	LDA	(ARYADR),Y
001221  1  8D 54 08     	STA	NUMDIM		;NUMDIM:=ARRAYPOS
001224  1  A9 02        	LDA	#2
001226  1  8D 50 08     	STA	CI		;I:=2
001229  1  AD 54 08     CLSLP	LDA	NUMDIM
00122C  1  CD 50 08     	CMP	CI		;IF I>NUMDIM
00122F  1  90 2B        	BCC	CLALSB		;THEN
001231  1  20 52 19     	JSR	POPSTK		;ELSE POP$STACK
001234  1  20 FE 11     	JSR	INCAAD		;INC$ARRAYADDR
001237  1  A0 00        	LDY	#0
001239  1  B1 1E        	LDA	(ARYADR),Y
00123B  1  85 32        	STA	PX
00123D  1  C8           	INY
00123E  1  B1 1E        	LDA	(ARYADR),Y
001240  1  85 33        	STA	PX+1
001242  1  20 0E 1A     	JSR	ARA
001245  1  20 96 1A     	JSR	MXAP		;AY:=ARA*ARRAYPOS
001248  1  18           	CLC
001249  1  6D 52 08     	ADC	LOCATN
00124C  1  8D 52 08     	STA	LOCATN
00124F  1  98           	TYA
001250  1  6D 53 08     	ADC	LOCATN+1
001253  1  8D 53 08     	STA	LOCATN+1	;LOCATION:=ARA*ARRAYPOS+LOCATION
001256  1  EE 50 08     	INC	CI		;I:=I+1
001259  1  4C 29 12     	JMP	CLSLP		;AND LOOP
00125C  1  20 FE 11     CLALSB	JSR	INCAAD		;INC$ARRAYADDR
00125F  1  A0 00        	LDY	#0
001261  1  AD 52 08     	LDA	LOCATN
001264  1  D1 1E        	CMP	(ARYADR),Y
001266  1  C8           	INY
001267  1  AD 53 08     	LDA	LOCATN+1
00126A  1  F1 1E        	SBC	(ARYADR),Y
00126C  1  90 05        	BCC	*+7		;IF ARRAYPOS>LOCATION THEN OK
00126E  1  A9 13        	LDA	#19		;ELSE SUBSCRIPTING ERROR
001270  1  4C B8 18     	JMP	ERROR
001273  1  AD 52 08     	LDA	LOCATN
001276  1  AC 53 08     	LDY	LOCATN+1
001279  1  20 AB 17     	JSR	TIMES4		;TIMES4(LOCATION)
00127C  1  18           	CLC
00127D  1  65 1E        	ADC	ARYADR
00127F  1  AA           	TAX
001280  1  98           	TYA
001281  1  65 1F        	ADC	ARYADR+1
001283  1  A8           	TAY			;+ARRAYADDR
001284  1  18           	CLC
001285  1  8A           	TXA
001286  1  69 02        	ADC	#2
001288  1  AA           	TAX
001289  1  90 01        	BCC	*+3
00128B  1  C8           	INY			;+2
00128C  1  98           	TYA
00128D  1  A0 01        	LDY	#1		;HIGH FIRST
00128F  1  91 5C        	STA	(RA),Y
001291  1  88           	DEY
001292  1  8A           	TXA
001293  1  91 5C        	STA	(RA),Y		;ARA:=
001295  1  60           	RTS
001296  1               ;BRANCHING ROUTINES
001296  1               ;UNCOND$BRANCH
001296  1  20 0E 1A     UNCBRA	JSR	ARA
001299  1  18           	CLC
00129A  1  65 60        	ADC	RC
00129C  1  AA           	TAX
00129D  1  98           	TYA
00129E  1  65 61        	ADC	RC+1
0012A0  1  A8           	TAY			;AY:=ARA+RC
0012A1  1  8A           	TXA
0012A2  1  D0 01        	BNE	*+3
0012A4  1  88           	DEY
0012A5  1  CA           	DEX
0012A6  1  86 60        	STX	RC
0012A8  1  84 61        	STY	RC+1		;RC:=RC+ARA-1
0012AA  1  4C 52 19     	JMP	POPSTK		;POP$STACK
0012AD  1               ;COND$BRANCH
0012AD  1  20 18 19     CNDBRA	JSR	RBZER
0012B0  1  F0 06        	BEQ	*+8		;IF NOT RBZERO THEN
0012B2  1  20 96 12     	JSR	UNCBRA		;ELSE DO BRANCH
0012B5  1  4C 52 19     	JMP	POPSTK
0012B8  1  20 52 19     	JSR	POPSTK		;POP$STACK TWICE
0012BB  1  4C 52 19     	JMP	POPSTK
0012BE  1               ;ABSOLUTE$BRANCH
0012BE  1  20 7B 19     ABSBRA	JSR	STINCN		;STEP$INS$CNT
0012C1  1  20 19 1A     	JSR	ARC
0012C4  1  85 60        	STA	RC
0012C6  1  84 61        	STY	RC+1		;RC:=TWOBYTEOPERAND
0012C8  1  60           	RTS
0012C9  1               ;GLOBAL STRING HANDLING ROUTINES
0012C9  1  A0 02        CHKSAD	LDY	#2
0012CB  1  B1 5C        	LDA	(RA),Y
0012CD  1  60           	RTS
0012CE  1               ;STRING$FREE
0012CE  1  20 C9 12     STRFRE	JSR	CHKSAD
0012D1  1  29 01        	AND	#1
0012D3  1  D0 01        	BNE	*+3		;IF CHECK$STRING$ADDR THEN
0012D5  1  60           	RTS
0012D6  1  20 0E 1A     	JSR	ARA
0012D9  1  4C E8 16     	JMP	RELS		;RELEASE(ARA)
0012DC  1               ;GET$STRING$LEN
0012DC  1  8D E9 12     GETSLN	STA	GETSL+1
0012DF  1  8C EA 12     	STY	GETSL+2
0012E2  1  0D EA 12     	ORA	GETSL+2
0012E5  1  D0 01        	BNE	*+3
0012E7  1  60           	RTS
0012E8  1  AD FF FF     GETSL	LDA	$FFFF
0012EB  1  60           	RTS
0012EC  1               ;COMP$FIX
0012EC  1  29 01        COMFIX	AND	#1		;IF NOT FLAG
0012EE  1  F0 0B        	BEQ	NTCFLG		;THEN
0012F0  1  A0 03        	LDY	#3
0012F2  1  B9 E6 1B     COMFXL	LDA	MONE,Y		;MOVE4(.MINUSONE,RA)
0012F5  1  91 5C        	STA	(RA),Y
0012F7  1  88           	DEY
0012F8  1  10 F8        	BPL	COMFXL
0012FA  1  60           	RTS
0012FB  1  A8           NTCFLG	TAY			;BRAZ:=0
0012FC  1  91 5C        	STA	(RA),Y
0012FE  1  60           	RTS
0012FF  1               ;CHKCARRY
0012FF  1  90 05        CHKSCY	BCC	*+7		;IF C=0 THEN OK
001301  1  A9 14        	LDA	#20		;ELSE STRING LENGTH ERROR
001303  1  4C B8 18     	JMP	ERROR
001306  1  60           	RTS
001307  1               ;CONCATENATE
001307  1               ;THE STRING POINTED TO BY RA IS CONCATENATED TO THE STRING POINTED TO BY RB AND
001307  1               ;THE POINTER TO THE RESULT IS PLACED IN RB.  THE STACK IS POPPED AND THE RESULT
001307  1               ;IS FLAGGED AS A TEMPORARY STRING.
001307  1  20 24 19     CONCAT	JSR	RAZERA		;IF RA$ZERO$ADDRESS
00130A  1  D0 08        	BNE	E14		;THEN
00130C  1  20 33 19     	JSR	RBZERA		;ELSE IF NOT RB$ZERO$ADDRESS
00130F  1  F0 06        	BEQ	DOCAT		;THEN
001311  1  20 02 19     	JSR	MVRARB		;ELSE MOVE$RA$RB
001314  1  4C 52 19     E14	JMP	POPSTK		;POP$STACK
001317  1  20 03 1A     DOCAT	JSR	ARB
00131A  1  20 DC 12     	JSR	GETSLN		;GETSTRINGLEN(ARB)
00131D  1  18           	CLC
00131E  1  69 01        	ADC	#1		;+1
001320  1  8D 47 08     	STA	FRSTLN		;FIRSTSTRINGLENGTH:=
001323  1  20 FF 12     	JSR	CHKSCY		;CHKCARRY
001326  1  20 0E 1A     	JSR	ARA
001329  1  20 DC 12     	JSR	GETSLN		;GETSTRINGLEN(ARA)
00132C  1  8D 48 08     	STA	SCSTLN		;SECONDSTRINGLENGTH:=
00132F  1  18           	CLC
001330  1  6D 47 08     	ADC	FRSTLN		;+FIRSTSTRINGLENGTH
001333  1  8D 49 08     	STA	NWSTLN		;NEWSTRINGLENGTH:=
001336  1  20 FF 12     	JSR	CHKSCY		;CHKCARRY
001339  1  AD 49 08     	LDA	NWSTLN
00133C  1  A0 00        	LDY	#0
00133E  1  20 4B 16     	JSR	GETS		;GETSPACE(NEWSTRINGLENGTH)
001341  1  85 12        	STA	NWSTAD
001343  1  84 13        	STY	NWSTAD+1	;NEWSTRINGADDRESS:=
001345  1  85 2E        	STA	MTO
001347  1  84 2F        	STY	MTO+1		;TO:=
001349  1  A0 00        	LDY	#0
00134B  1  B1 5E        	LDA	(RB),Y
00134D  1  85 2C        	STA	MFROM
00134F  1  C8           	INY
001350  1  B1 5E        	LDA	(RB),Y
001352  1  85 2D        	STA	MFROM+1		;FROM:=ARB
001354  1  AD 47 08     	LDA	FRSTLN
001357  1  88           	DEY			;LENGTH:=FIRSTSTRINGLENGTH
001358  1  20 7C 17     	JSR	MOVE		;( , , )
00135B  1  A0 00        	LDY	#0
00135D  1  B1 5C        	LDA	(RA),Y
00135F  1  85 2C        	STA	MFROM
001361  1  C8           	INY
001362  1  B1 5C        	LDA	(RA),Y
001364  1  85 2D        	STA	MFROM+1
001366  1  E6 2C        	INC	MFROM
001368  1  D0 02        	BNE	*+4
00136A  1  E6 2D        	INC	MFROM+1		;FROM:=ARA+1
00136C  1  18           	CLC
00136D  1  A5 12        	LDA	NWSTAD
00136F  1  6D 47 08     	ADC	FRSTLN
001372  1  85 2E        	STA	MTO
001374  1  A4 13        	LDY	NWSTAD+1
001376  1  90 01        	BCC	*+3
001378  1  C8           	INY
001379  1  84 2F        	STY	MTO+1		;TO:=NEWSTRINGADDRESS+FIRSTSTRINGLENGTH
00137B  1  AD 48 08     	LDA	SCSTLN
00137E  1  A0 00        	LDY	#0		;LENGTH:=SECONDSTRINGLENGTH
001380  1  20 7C 17     	JSR	MOVE		;MOVE( , , )
001383  1  20 CE 12     	JSR	STRFRE		;STRINGFREE
001386  1  20 52 19     	JSR	POPSTK		;POP$STACK
001389  1  20 CE 12     	JSR	STRFRE		;STRINGFREE
00138C  1  A0 00        	LDY	#0
00138E  1  A5 12        	LDA	NWSTAD
001390  1  91 5C        	STA	(RA),Y
001392  1  C8           	INY
001393  1  A5 13        	LDA	NWSTAD+1
001395  1  91 5C        	STA	(RA),Y		;ARA:=NEWSTRINGADDRESS
001397  1  AE 49 08     	LDX	NWSTLN
00139A  1  CA           	DEX
00139B  1  8A           	TXA
00139C  1  88           	DEY			;Y:=0
00139D  1  91 12        	STA	(NWSTAD),Y	;LENGTH:=NEWSTRINGLENGTH-1
00139F  1  A9 FF        	LDA	#TRUE
0013A1  1  4C F1 18     	JMP	FLSTRA		;FLAG$STRING$ADDR(TRUE)
0013A4  1               ;FIXSTACK
0013A4  1  20 CE 12     FIXSTK	JSR	STRFRE		;STRING$FREE
0013A7  1  20 52 19     	JSR	POPSTK		;POP$STACK
0013AA  1  4C CE 12     	JMP	STRFRE		;STRING$FREE
0013AD  1               ;INC$BRA
0013AD  1  A0 00        INCBRA	LDY	#0
0013AF  1  B1 5C        	LDA	(RA),Y
0013B1  1  18           	CLC
0013B2  1  69 01        	ADC	#1		;RETURN BRAZ+1
0013B4  1  60           	RTS
0013B5  1               ;COMPARE$STRING
0013B5  1               ;THE STRING POINTED TO BY RB IS COMPARED TO THE STRING POINTED TO BY RA
0013B5  1               ;IF RB < RA THEN RETURN 1
0013B5  1               ;   RB > RA 		2
0013B5  1               ;   RB = RA		3
0013B5  1               ;TWO STRINGS ARE EQUAL IF AND ONLY IF THE TWO STRINGS HAVE THE SAME LENGTH AND
0013B5  1               ;CONTAIN IDENTICAL CHARACTERS.  THE ASCII COLLATING SEQUENCE IS USED TO
0013B5  1               ;DETERMINE THE RELATIONSHIP BETWEEN EQUAL LENGTH STRINGS.  IF TWO STRINGS ARE
0013B5  1               ;NOT OF EQUAL LENGTH THE SHORTER IS ALWAYS LESS THAN THE LONGER ONE.  ALL NULL
0013B5  1               ;STRINGS ARE EQUAL AND LESS THAN ANY OTHER STRING.
0013B5  1               CSI				;I
0013B5  1  xx           	.res	1
0013B6  1               CSTL				;TEMPLENGTH
0013B6  1  xx           	.res	1
0013B7  1  20 24 19     CMPSTR	JSR	RAZERA		;IF NOT RA$ZERO$ADDRESS
0013BA  1  F0 0B        	BEQ	L061		;THEN
0013BC  1  A5 5C        	LDA	RA
0013BE  1  A4 5D        	LDY	RA+1
0013C0  1  85 1A        	STA	SCNDST
0013C2  1  84 1B        	STY	SCNDST+1	;SECONDSTRING:=RA
0013C4  1  4C D2 13     	JMP	L062
0013C7  1  A0 00        L061	LDY	#0
0013C9  1  B1 5C        	LDA	(RA),Y
0013CB  1  85 1A        	STA	SCNDST
0013CD  1  C8           	INY
0013CE  1  B1 5C        	LDA	(RA),Y
0013D0  1  85 1B        	STA	SCNDST+1	;SECONDSTRING:=ARA
0013D2  1  20 33 19     L062	JSR	RBZERA		;IF NOT RB$ZERO$ADDRESS
0013D5  1  F0 0B        	BEQ	L063		;THEN
0013D7  1  A5 5E        	LDA	RB
0013D9  1  A4 5F        	LDY	RB+1
0013DB  1  85 18        	STA	FRSTST
0013DD  1  84 19        	STY	FRSTST+1	;FIRSTSTRING:=RB
0013DF  1  4C ED 13     	JMP	L064
0013E2  1  A0 00        L063	LDY	#0
0013E4  1  B1 5E        	LDA	(RB),Y
0013E6  1  85 18        	STA	FRSTST
0013E8  1  C8           	INY
0013E9  1  B1 5E        	LDA	(RB),Y
0013EB  1  85 19        	STA	FRSTST+1	;FIRSTSTRING:=ARB
0013ED  1  A0 00        L064	LDY	#0
0013EF  1  B1 18        	LDA	(FRSTST),Y
0013F1  1  8D B6 13     	STA	CSTL		;TEMPLENGTH:=CHARSTRING1
0013F4  1  8C B5 13     	STY	CSI		;I:=0
0013F7  1  AD B6 13     L065	LDA	CSTL
0013FA  1  CD B5 13     	CMP	CSI		;IF I>TEMPLENGTH
0013FD  1  90 28        	BCC	L068		;THEN
0013FF  1  A0 00        	LDY	#0
001401  1  B1 18        	LDA	(FRSTST),Y
001403  1  D1 1A        	CMP	(SCNDST),Y
001405  1  B0 06        	BCS	L066		;IF CHARSTRING1 >= CHARSTRING2 THEN
001407  1  20 A4 13     	JSR	FIXSTK		;FIXSTACK
00140A  1  A9 01        	LDA	#1
00140C  1  60           	RTS
00140D  1  F0 06        L066	BEQ	L067		;IF CHARSTRING1 = CHARSTRING2 THEN
00140F  1  20 A4 13     	JSR	FIXSTK		;ELSE
001412  1  A9 02        	LDA	#2
001414  1  60           	RTS
001415  1  E6 18        L067	INC	FRSTST
001417  1  D0 02        	BNE	*+4
001419  1  E6 19        	INC	FRSTST+1
00141B  1  E6 1A        	INC	SCNDST
00141D  1  D0 02        	BNE	*+4
00141F  1  E6 1B        	INC	SCNDST+1	;BUMP STRING POINTERS
001421  1  EE B5 13     	INC	CSI		;AND INDEX
001424  1  4C F7 13     	JMP	L065		;THEN LOOP
001427  1  20 A4 13     L068	JSR	FIXSTK		;FIXSTACK
00142A  1  A9 03        	LDA	#3
00142C  1  60           	RTS
00142D  1               ;STRING$SEGMENT(TYPE)
00142D  1               SSTYPE				;TYPE
00142D  1  xx           	.res	1
00142E  1               SSTMP2				;TEMPA2
00142E  1  xx xx        	.res	2
001430  1               SSTMPB				;TEMPB1
001430  1  xx           	.res	1
001431  1               SSLNG2				;LNG2
001431  1  xx           	.res	1
001432  1  8D 2D 14     STRSEG	STA	SSTYPE		;SAVE TYPE
001435  1  A2 00        	LDX	#0
001437  1  8E 30 14     	STX	SSTMPB		;TEMPB1:=0
00143A  1  C9 02        	CMP	#2
00143C  1  D0 1F        	BNE	L070		;IF NOT MID THEN
00143E  1  20 42 19     	JSR	FLIP
001441  1  20 D9 18     	JSR	RANEG		;IF RA$NEGATIVE
001444  1  D0 05        	BNE	L069		;THEN ERROR
001446  1  20 0C 19     	JSR	RAZER		;IF NOT
001449  1  F0 05        	BEQ	*+7		;RA$ZERO THEN
00144B  1  A9 15        L069	LDA	#21		;ELSE SECOND PARM OF MID
00144D  1  4C B8 18     	JMP	ERROR		;ZERO OR NEGATIVE
001450  1  20 D4 1A     	JSR	CNVBAD		;CONV$TO$BIN$ADDR
001453  1  A0 00        	LDY	#0
001455  1  B1 5C        	LDA	(RA),Y
001457  1  8D 30 14     	STA	SSTMPB		;TEMPB1:=BRAZ
00145A  1  20 52 19     	JSR	POPSTK		;POP$STACK
00145D  1  20 D9 18     L070	JSR	RANEG
001460  1  D0 10        	BNE	L071		;IF RA$NEGATIVE THEN
001462  1  20 03 1A     	JSR	ARB
001465  1  20 DC 12     	JSR	GETSLN		;GET$STRING$LEN(ARB)
001468  1  CD 30 14     	CMP	SSTMPB		;IF < TEMPB1
00146B  1  90 05        	BCC	L071		;THEN
00146D  1  20 0C 19     	JSR	RAZER		;IF NOT
001470  1  F0 0F        	BEQ	L072		;RA$ZERO THEN
001472  1  20 52 19     L071	JSR	POPSTK		;POP$STACK
001475  1  20 CE 12     	JSR	STRFRE		;STRINGFREE
001478  1  A0 00        	LDY	#0
00147A  1  98           	TYA
00147B  1  91 5C        	STA	(RA),Y
00147D  1  C8           	INY
00147E  1  91 5C        	STA	(RA),Y		;ARA:=0
001480  1  60           	RTS
001481  1  20 D4 1A     L072	JSR	CNVBAD		;CONV$TO$BIN$ADDR
001484  1  20 03 1A     	JSR	ARB
001487  1  20 DC 12     	JSR	GETSLN		;GET$STRING$LEN(ARB)
00148A  1  38           	SEC
00148B  1  ED 30 14     	SBC	SSTMPB		;-TEMPB1
00148E  1  8D 31 14     	STA	SSLNG2		;LNG2:=
001491  1  A0 00        	LDY	#0
001493  1  D1 5C        	CMP	(RA),Y
001495  1  B0 17        	BCS	L074		;IF >= BRAZ THEN
001497  1  AD 2D 14     	LDA	SSTYPE
00149A  1  C9 02        	CMP	#2
00149C  1  D0 0B        	BNE	L073		;IF NOT MID THEN
00149E  1  18           	CLC
00149F  1  AD 31 14     	LDA	SSLNG2
0014A2  1  69 01        	ADC	#1
0014A4  1  91 5C        	STA	(RA),Y		;BRAZ:=LNG2+1
0014A6  1  4C AE 14     	JMP	L074
0014A9  1  AD 31 14     L073	LDA	SSLNG2
0014AC  1  91 5C        	STA	(RA),Y		;BRAZ:=LNG2
0014AE  1  AD 2D 14     L074	LDA	SSTYPE
0014B1  1  D0 0C        	BNE	L075		;IF TYPE <> LEFT THEN
0014B3  1  20 03 1A     	JSR	ARB
0014B6  1  8D 2E 14     	STA	SSTMP2
0014B9  1  8C 2F 14     	STY	SSTMP2+1	;TEMPA2:=ARB
0014BC  1  4C F6 14     	JMP	L077
0014BF  1  C9 01        L075	CMP	#1
0014C1  1  D0 1D        	BNE	L076		;IF NOT RIGHT THEN
0014C3  1  20 03 1A     	JSR	ARB
0014C6  1  18           	CLC
0014C7  1  6D 31 14     	ADC	SSLNG2
0014CA  1  90 01        	BCC	*+3
0014CC  1  C8           	INY
0014CD  1  8C 2F 14     	STY	SSTMP2+1
0014D0  1  38           	SEC
0014D1  1  A0 00        	LDY	#0
0014D3  1  F1 5C        	SBC	(RA),Y
0014D5  1  8D 2E 14     	STA	SSTMP2
0014D8  1  B0 03        	BCS	*+5
0014DA  1  CE 2F 14     	DEC	SSTMP2+1	;TEMPA2:=ARB+LNG2-BRAZ
0014DD  1  4C F6 14     	JMP	L077
0014E0  1  20 03 1A     L076	JSR	ARB
0014E3  1  18           	CLC
0014E4  1  6D 30 14     	ADC	SSTMPB
0014E7  1  90 01        	BCC	*+3
0014E9  1  C8           	INY
0014EA  1  38           	SEC
0014EB  1  E9 01        	SBC	#1
0014ED  1  B0 01        	BCS	*+3
0014EF  1  88           	DEY
0014F0  1  8D 2E 14     	STA	SSTMP2
0014F3  1  8C 2F 14     	STY	SSTMP2+1	;TEMPA2:=ARB+TEMPB1-1
0014F6  1  AD 2E 14     L077	LDA	SSTMP2
0014F9  1  AC 2F 14     	LDY	SSTMP2+1
0014FC  1  85 2C        	STA	MFROM
0014FE  1  84 2D        	STY	MFROM+1		;FROM:=TEMPA2
001500  1  20 AD 13     	JSR	INCBRA
001503  1  A0 00        	LDY	#0
001505  1  20 4B 16     	JSR	GETS		;GETSPACE(INC$BRA)
001508  1  85 1C        	STA	SSTMP
00150A  1  84 1D        	STY	SSTMP+1		;TEMPA:=
00150C  1  85 2E        	STA	MTO
00150E  1  84 2F        	STY	MTO+1		;TO:=
001510  1  20 AD 13     	JSR	INCBRA
001513  1  A0 00        	LDY	#0
001515  1  20 7C 17     	JSR	MOVE		;MOVE(FROM,TO,AY)
001518  1  A0 00        	LDY	#0
00151A  1  B1 5C        	LDA	(RA),Y
00151C  1  91 1C        	STA	(SSTMP),Y	;LNG:=BRAZ
00151E  1  20 52 19     	JSR	POPSTK		;POP$STACK
001521  1  20 CE 12     	JSR	STRFRE		;STRINGFREE
001524  1  A0 00        	LDY	#0
001526  1  A5 1C        	LDA	SSTMP
001528  1  91 5C        	STA	(RA),Y
00152A  1  C8           	INY
00152B  1  A5 1D        	LDA	SSTMP+1
00152D  1  91 5C        	STA	(RA),Y		;ARA:=TEMPA
00152F  1  A9 FF        	LDA	#TRUE
001531  1  4C F1 18     	JMP	FLSTRA		;FLAG$STRING$ADDR(TRUE)
001534  1               ;DOS/65 INTERFACE ROUTINES
001534  1               ;CRLF
001534  1  A9 0D        CRLF	LDA	#CR
001536  1  20 3B 15     	JSR	PRNCHR
001539  1  A9 0A        LFOUT	LDA	#LF
00153B  1               ;PRINTCHAR(CHAR)
00153B  1  2C 12 08     PRNCHR	BIT	LSTFLG		;TEST FLAG
00153E  1  30 05        	BMI	*+7		;IF SET DO LIST
001540  1  A2 02        PRNCON	LDX	#2
001542  1  4C 03 01     	JMP	PEM
001545  1  A2 05        	LDX	#5
001547  1  4C 03 01     	JMP	PEM
00154A  1               ;READ(A)
00154A  1               ;WAIT FOR FIRST CHARACTER AND SET LOCALSEED TO BE USED TO SEED RANDOM NUMBER
00154A  1               ;GENERATOR
00154A  1  48           READ	PHA			;SAVE ADDRESS ON STACK
00154B  1  98           	TYA
00154C  1  48           	PHA
00154D  1  A2 0B        READ1	LDX	#11
00154F  1  20 03 01     	JSR	PEM		;SEE IF READY
001552  1  D0 09        	BNE	READ2		;BRANCH IF IS
001554  1  E6 84        	INC	LCLSED
001556  1  D0 02        	BNE	*+4
001558  1  E6 85        	INC	LCLSED+1	;LOCALSEED:=LOCALSEED+1
00155A  1  4C 4D 15     	JMP	READ1		;AND LOOP
00155D  1  68           READ2	PLA
00155E  1  A8           	TAY
00155F  1  68           	PLA			;GET ADDRESS
001560  1  A2 0A        	LDX	#10
001562  1  4C 03 01     	JMP	PEM		;READ BUFFER
001565  1               ;OPEN A FILE
001565  1  A5 75        OPEN	LDA	FILADR
001567  1  A4 76        	LDY	FILADR+1
001569  1  A2 0F        	LDX	#15
00156B  1  4C 03 01     	JMP	PEM
00156E  1               ;CLOSE A FILE
00156E  1  A5 75        CLOSE	LDA	FILADR
001570  1  A4 76        	LDY	FILADR+1
001572  1  A2 10        	LDX	#16
001574  1  4C 03 01     	JMP	PEM
001577  1               ;DISKREAD
001577  1  A5 75        DSKRDE	LDA	FILADR
001579  1  A4 76        	LDY	FILADR+1
00157B  1  A2 14        	LDX	#20
00157D  1  4C 03 01     	JMP	PEM
001580  1               ;DISKWRITE
001580  1  A5 75        DSKWRT	LDA	FILADR
001582  1  A4 76        	LDY	FILADR+1
001584  1  A2 15        	LDX	#21
001586  1  4C 03 01     	JMP	PEM
001589  1               ;CREATE
001589  1  A5 75        CREATE	LDA	FILADR
00158B  1  A4 76        	LDY	FILADR+1
00158D  1  A2 16        	LDX	#22
00158F  1  4C 03 01     	JMP	PEM
001592  1               ;MAKE
001592  1  A5 75        MAKE	LDA	FILADR
001594  1  A4 76        	LDY	FILADR+1
001596  1  A2 13        	LDX	#19
001598  1  20 03 01     	JSR	PEM		;DELETE
00159B  1  4C 89 15     	JMP	CREATE
00159E  1               ;SETDMA
00159E  1               ;SET ADDRESS FOR DISK I/O
00159E  1  A5 7F        SETDMA	LDA	BUFFER
0015A0  1  A4 80        	LDY	BUFFER+1
0015A2  1  A2 1A        	LDX	#26
0015A4  1  4C 03 01     	JMP	PEM
0015A7  1               ;PRINT(LOCATION)
0015A7  1               ;PRINT STRING POINTED TO BY AY UNTIL $ IS ENCOUNTERED
0015A7  1  A2 09        PRINT	LDX	#9
0015A9  1  4C 03 01     	JMP	PEM
0015AC  1               ;DYNAMIC STORAGE ALLOCATION ROUTINES
0015AC  1               ;AVAILABLE
0015AC  1  8D 55 08     AVLL	STA	NBYTES
0015AF  1  8C 56 08     	STY	NBYTES+1	;SAVE INPUT PARM
0015B2  1  A5 70        	LDA	MBASE
0015B4  1  A4 71        	LDY	MBASE+1
0015B6  1  85 22        	STA	DSPNT
0015B8  1  84 23        	STY	DSPNT+1		;POINT:=MBASE
0015BA  1  A9 00        	LDA	#0
0015BC  1  8D 59 08     	STA	TOTAL
0015BF  1  8D 5A 08     	STA	TOTAL+1		;TOTAL:=0
0015C2  1  A5 22        AVLLP	LDA	DSPNT
0015C4  1  05 23        	ORA	DSPNT+1		;DO WHILE POINT<>0
0015C6  1  F0 6F        	BEQ	DSPNTZ
0015C8  1  A0 04        	LDY	#4
0015CA  1  B1 22        	LDA	(DSPNT),Y	;A:=SWITCH(4)
0015CC  1  D0 5A        	BNE	SW4NZ		;IF <>0 THEN
0015CE  1  A0 00        	LDY	#0
0015D0  1  B1 22        	LDA	(DSPNT),Y
0015D2  1  AA           	TAX
0015D3  1  C8           	INY
0015D4  1  B1 22        	LDA	(DSPNT),Y
0015D6  1  A8           	TAY			;XY:=HERE
0015D7  1  38           	SEC
0015D8  1  8A           	TXA
0015D9  1  E5 22        	SBC	DSPNT
0015DB  1  AA           	TAX
0015DC  1  98           	TYA
0015DD  1  E5 23        	SBC	DSPNT+1
0015DF  1  A8           	TAY			;XY:=HERE-POINT
0015E0  1  38           	SEC
0015E1  1  8A           	TXA
0015E2  1  E9 05        	SBC	#5
0015E4  1  B0 01        	BCS	*+3
0015E6  1  88           	DEY
0015E7  1  8D 5D 08     	STA	AVLLT		;TEMP:=HERE-POINT-5
0015EA  1  8C 5E 08     	STY	AVLLT+1
0015ED  1  18           	CLC
0015EE  1  6D 59 08     	ADC	TOTAL
0015F1  1  8D 59 08     	STA	TOTAL
0015F4  1  98           	TYA
0015F5  1  6D 5A 08     	ADC	TOTAL+1
0015F8  1  8D 5A 08     	STA	TOTAL+1		;TOTAL:=TOTAL+TEMP
0015FB  1  AD 55 08     	LDA	NBYTES
0015FE  1  0D 56 08     	ORA	NBYTES+1	;IF NBYTES<>0 THEN
001601  1  F0 25        	BEQ	SW4NZ		;ELSE
001603  1  18           	CLC
001604  1  AD 55 08     	LDA	NBYTES
001607  1  AC 56 08     	LDY	NBYTES+1
00160A  1  69 05        	ADC	#5
00160C  1  90 01        	BCC	*+3
00160E  1  C8           	INY
00160F  1  8D 5B 08     	STA	AVLLT2
001612  1  8C 5C 08     	STY	AVLLT2+1	;SAVE NBYTES+5
001615  1  AD 5D 08     	LDA	AVLLT
001618  1  CD 5B 08     	CMP	AVLLT2
00161B  1  AD 5E 08     	LDA	AVLLT+1
00161E  1  ED 5C 08     	SBC	AVLLT2+1
001621  1  90 05        	BCC	SW4NZ		;IF NBYTES+5>TEMP THEN
001623  1  A5 22        	LDA	DSPNT
001625  1  A4 23        	LDY	DSPNT+1
001627  1  60           	RTS			;ELSE RETURN POINT
001628  1  A0 00        SW4NZ	LDY	#0
00162A  1  B1 22        	LDA	(DSPNT),Y
00162C  1  AA           	TAX
00162D  1  C8           	INY
00162E  1  B1 22        	LDA	(DSPNT),Y
001630  1  86 22        	STX	DSPNT
001632  1  85 23        	STA	DSPNT+1		;POINT:=HERE
001634  1  4C C2 15     	JMP	AVLLP		;LOOP TO DO WHILE
001637  1  AD 55 08     DSPNTZ	LDA	NBYTES
00163A  1  0D 56 08     	ORA	NBYTES+1
00163D  1  F0 05        	BEQ	*+7		;OK IF NBYTES=0
00163F  1  A9 17        	LDA	#23		;ELSE NO MEMORY ERROR
001641  1  4C B8 18     	JMP	ERROR
001644  1  AD 59 08     	LDA	TOTAL
001647  1  AC 5A 08     	LDY	TOTAL+1
00164A  1  60           	RTS			;RETURN TOTAL
00164B  1               ;GETSPACE
00164B  1  8D 55 08     GETS	STA	NBYTES
00164E  1  8C 56 08     	STY	NBYTES+1
001651  1  0D 56 08     	ORA	NBYTES+1
001654  1  D0 01        	BNE	*+3
001656  1  60           	RTS			;RETURN 0
001657  1  AD 55 08     	LDA	NBYTES		;GET A BACK (Y IS OK)
00165A  1  20 AC 15     	JSR	AVLL		;AVAILABLE(NBYTES)
00165D  1  85 22        	STA	DSPNT
00165F  1  84 23        	STY	DSPNT+1		;POINT:=
001661  1  A0 04        	LDY	#4		;LINK UP THE SPACE
001663  1  A9 01        	LDA	#1
001665  1  91 22        	STA	(DSPNT),Y	;SET SWITCH(4):=1
001667  1  18           	CLC
001668  1  AD 55 08     	LDA	NBYTES
00166B  1  AC 56 08     	LDY	NBYTES+1
00166E  1  69 05        	ADC	#5
001670  1  90 01        	BCC	*+3
001672  1  C8           	INY
001673  1  18           	CLC
001674  1  65 22        	ADC	DSPNT
001676  1  85 26        	STA	DSTMP1
001678  1  98           	TYA
001679  1  65 23        	ADC	DSPNT+1
00167B  1  85 27        	STA	DSTMP1+1	;TEMP1:=POINT+NBYTES+5
00167D  1  A0 00        	LDY	#0
00167F  1  B1 22        	LDA	(DSPNT),Y
001681  1  91 26        	STA	(DSTMP1),Y
001683  1  C8           	INY
001684  1  B1 22        	LDA	(DSPNT),Y
001686  1  91 26        	STA	(DSTMP1),Y	;ADR1:=HERE
001688  1  A0 00        	LDY	#0
00168A  1  B1 22        	LDA	(DSPNT),Y
00168C  1  48           	PHA
00168D  1  C8           	INY
00168E  1  B1 22        	LDA	(DSPNT),Y
001690  1  A8           	TAY
001691  1  68           	PLA			;AY:=HERE
001692  1  18           	CLC
001693  1  69 02        	ADC	#2
001695  1  90 01        	BCC	*+3
001697  1  C8           	INY
001698  1  85 28        	STA	DSTMP2
00169A  1  84 29        	STY	DSTMP2+1	;TEMP2:=HERE+2
00169C  1  A0 00        	LDY	#0
00169E  1  A5 26        	LDA	DSTMP1
0016A0  1  91 22        	STA	(DSPNT),Y
0016A2  1  91 28        	STA	(DSTMP2),Y
0016A4  1  C8           	INY
0016A5  1  A5 27        	LDA	DSTMP1+1
0016A7  1  91 22        	STA	(DSPNT),Y
0016A9  1  91 28        	STA	(DSTMP2),Y	;HERE,ADR2:=TEMP1
0016AB  1  A0 04        	LDY	#4
0016AD  1  A9 00        	LDA	#0
0016AF  1  91 26        	STA	(DSTMP1),Y	;SWITCH2(4):=0
0016B1  1  18           	CLC
0016B2  1  A5 26        	LDA	DSTMP1
0016B4  1  69 02        	ADC	#2
0016B6  1  85 26        	STA	DSTMP1
0016B8  1  90 02        	BCC	*+4
0016BA  1  E6 27        	INC	DSTMP1+1	;TEMP1:=TEMP1+2
0016BC  1  A0 00        	LDY	#0
0016BE  1  A5 22        	LDA	DSPNT
0016C0  1  91 26        	STA	(DSTMP1),Y
0016C2  1  C8           	INY
0016C3  1  A5 23        	LDA	DSPNT+1
0016C5  1  91 26        	STA	(DSTMP1),Y	;ADR1:=POINT
0016C7  1  AD 55 08     	LDA	NBYTES
0016CA  1  AC 56 08     	LDY	NBYTES+1
0016CD  1  85 36        	STA	FN
0016CF  1  84 37        	STY	FN+1		;FILL( , ,NBYTES)
0016D1  1  18           	CLC
0016D2  1  A5 22        	LDA	DSPNT
0016D4  1  69 05        	ADC	#5
0016D6  1  85 22        	STA	DSPNT
0016D8  1  90 02        	BCC	*+4
0016DA  1  E6 23        	INC	DSPNT+1		;POINT:=POINT+5
0016DC  1  A4 23        	LDY	DSPNT+1		;AY:=POINT
0016DE  1  A2 00        	LDX	#0
0016E0  1  20 B6 17     	JSR	FILL		;FILLE(POINT,0, )
0016E3  1  A5 22        	LDA	DSPNT
0016E5  1  A4 23        	LDY	DSPNT+1
0016E7  1  60           	RTS			;RETURN POINT
0016E8  1               ;RELEASE(SPACE)
0016E8  1  38           RELS	SEC
0016E9  1  E9 05        	SBC	#5
0016EB  1  85 20        	STA	SPACE
0016ED  1  8D 57 08     	STA	HOLD
0016F0  1  B0 01        	BCS	*+3
0016F2  1  88           	DEY
0016F3  1  84 21        	STY	SPACE+1
0016F5  1  8C 58 08     	STY	HOLD+1		;HOLD,SPACE:=SPACE-5
0016F8  1  A0 04        	LDY	#4
0016FA  1  A9 00        	LDA	#0
0016FC  1  91 20        	STA	(SPACE),Y	;SWITCH(4):=0
0016FE  1  20 34 17     	JSR	UNLINK		;COMBINE SPACE IF POSSIBLE
001701  1  18           	CLC
001702  1  A5 20        	LDA	SPACE
001704  1  69 02        	ADC	#2
001706  1  85 20        	STA	SPACE
001708  1  90 02        	BCC	*+4
00170A  1  E6 21        	INC	SPACE+1		;SPACE:=SPACE+2
00170C  1  A0 00        	LDY	#0
00170E  1  B1 20        	LDA	(SPACE),Y
001710  1  48           	PHA
001711  1  C8           	INY
001712  1  B1 20        	LDA	(SPACE),Y
001714  1  A8           	TAY
001715  1  68           	PLA
001716  1  85 20        	STA	SPACE
001718  1  84 21        	STY	SPACE+1		;SPACE:=HERE
00171A  1  05 21        	ORA	SPACE+1
00171C  1  D0 01        	BNE	*+3		;IF ( ) <> 0 THEN
00171E  1  60           	RTS
00171F  1  A0 04        	LDY	#4
001721  1  B1 20        	LDA	(SPACE),Y	;IF SWITCH(4)=0
001723  1  F0 01        	BEQ	*+3		;THEN
001725  1  60           	RTS
001726  1  20 34 17     	JSR	UNLINK		;UNLINK
001729  1  A5 20        	LDA	SPACE
00172B  1  A4 21        	LDY	SPACE+1
00172D  1  8D 57 08     	STA	HOLD
001730  1  8C 58 08     	STY	HOLD+1		;HOLD:=SPACE
001733  1  60           	RTS
001734  1               ;UNLINK
001734  1  A0 00        UNLINK	LDY	#0
001736  1  B1 20        	LDA	(SPACE),Y
001738  1  85 2A        	STA	DSTMP3
00173A  1  C8           	INY
00173B  1  B1 20        	LDA	(SPACE),Y
00173D  1  85 2B        	STA	DSTMP3+1	;TEMP:=HERE
00173F  1  B1 2A        	LDA	(DSTMP3),Y
001741  1  88           	DEY
001742  1  11 2A        	ORA	(DSTMP3),Y
001744  1  D0 01        	BNE	*+3		;IF ADRS<>0 THEN
001746  1  60           	RTS
001747  1  A0 04        	LDY	#4
001749  1  B1 2A        	LDA	(DSTMP3),Y
00174B  1  F0 01        	BEQ	*+3		;IF LOOK(4)=0 THEN
00174D  1  60           	RTS
00174E  1  A0 00        	LDY	#0
001750  1  B1 2A        	LDA	(DSTMP3),Y
001752  1  91 20        	STA	(SPACE),Y
001754  1  48           	PHA
001755  1  C8           	INY
001756  1  B1 2A        	LDA	(DSTMP3),Y
001758  1  91 20        	STA	(SPACE),Y	;HERE:=ADRS
00175A  1  A8           	TAY
00175B  1  68           	PLA
00175C  1  18           	CLC
00175D  1  69 02        	ADC	#2
00175F  1  85 2A        	STA	DSTMP3
001761  1  90 01        	BCC	*+3
001763  1  C8           	INY
001764  1  84 2B        	STY	DSTMP3+1	;TEMP:=HERE+2
001766  1  A0 00        	LDY	#0
001768  1  A5 20        	LDA	SPACE
00176A  1  91 2A        	STA	(DSTMP3),Y
00176C  1  C8           	INY
00176D  1  A5 21        	LDA	SPACE+1
00176F  1  91 2A        	STA	(DSTMP3),Y	;ADRS:=SPACE
001771  1  60           	RTS
001772  1               ;GENERAL PURPOSE INTERPRETER ROUTINES
001772  1               ;MOVE4(FROM,TO)
001772  1  A0 03        MOVE4	LDY	#3
001774  1  B1 2C        L080	LDA	(MFROM),Y
001776  1  91 2E        	STA	(MTO),Y
001778  1  88           	DEY
001779  1  10 F9        	BPL	L080
00177B  1  60           	RTS
00177C  1               ;MOVE
00177C  1               ;ASSUMES FROM AND TO POINTERS ARE PRESTORED BY CALLING ROUTINE AND THAT COUNT
00177C  1               ;IS IN AY AT ENTRY
00177C  1  8D 5F 08     MOVE	STA	MCOUNT
00177F  1  8C 60 08     	STY	MCOUNT+1
001782  1  A0 00        	LDY	#0
001784  1  AD 5F 08     MOVELP	LDA	MCOUNT
001787  1  0D 60 08     	ORA	MCOUNT+1
00178A  1  D0 01        	BNE	*+3		;IF COUNT<>0 THEN
00178C  1  60           	RTS			;ELSE DONE
00178D  1  AD 5F 08     	LDA	MCOUNT
001790  1  D0 03        	BNE	*+5
001792  1  CE 60 08     	DEC	MCOUNT+1
001795  1  CE 5F 08     	DEC	MCOUNT		;COUNT:=COUNT-1
001798  1  B1 2C        	LDA	(MFROM),Y
00179A  1  91 2E        	STA	(MTO),Y		;(TO):=(FROM)
00179C  1  E6 2C        	INC	MFROM
00179E  1  D0 02        	BNE	*+4
0017A0  1  E6 2D        	INC	MFROM+1		;FROM:=FROM+1
0017A2  1  E6 2E        	INC	MTO
0017A4  1  D0 DE        	BNE	MOVELP
0017A6  1  E6 2F        	INC	MTO+1
0017A8  1  4C 84 17     	JMP	MOVELP		;TO:=TO+1
0017AB  1               ;TIMES4(N)
0017AB  1  84 83        TIMES4	STY	TIME4T		;STORE HIGH
0017AD  1  0A           	ASL	A
0017AE  1  26 83        	ROL	TIME4T
0017B0  1  0A           	ASL	A
0017B1  1  26 83        	ROL	TIME4T
0017B3  1  A4 83        	LDY	TIME4T
0017B5  1  60           	RTS
0017B6  1               ;FILL
0017B6  1               ;ASSUMES NUMBER BYTES IS PRESTORED AT FN AND AY CONTAINS FIRST ADDRESS AND X
0017B6  1               ;CONTAINS FILL CHAR
0017B6  1  8D CE 17     FILL	STA	FILLIT+1
0017B9  1  8C CF 17     	STY	FILLIT+2	;SET ADDRESS
0017BC  1  A5 36        FILLLP	LDA	FN
0017BE  1  D0 02        	BNE	*+4
0017C0  1  C6 37        	DEC	FN+1
0017C2  1  C6 36        	DEC	FN		;N:=N-1
0017C4  1  A5 36        	LDA	FN
0017C6  1  25 37        	AND	FN+1
0017C8  1  C9 FF        	CMP	#$FF		;IF N <> $FFFF
0017CA  1  D0 01        	BNE	*+3		;THEN MORE
0017CC  1  60           	RTS			;ELSE DONE
0017CD  1  8E FF FF     FILLIT	STX	$FFFF		;D:=CHAR
0017D0  1  EE CE 17     	INC	FILLIT+1
0017D3  1  D0 E7        	BNE	FILLLP
0017D5  1  EE CF 17     	INC	FILLIT+2	;DEST:=DEST+1
0017D8  1  4C BC 17     	JMP	FILLLP		;AND LOOP
0017DB  1               ;OUTPUT$MSG
0017DB  1  0A           OUTMSG	ASL	A		;MULT # BU TWO
0017DC  1  AA           	TAX			;MAKE INDEX
0017DD  1  BD 22 2F     	LDA	ERMTBL,X
0017E0  1  BC 23 2F     	LDY	ERMTBL+1,X	;GET ADDRESS
0017E3  1  20 A7 15     	JSR	PRINT		;PRINT MESSAGE
0017E6  1  A5 6C        	LDA	CURLIN
0017E8  1  05 6D        	ORA	CURLIN+1
0017EA  1  F0 14        	BEQ	CCRLF		;IF CURRENTLINE=0 THEN
0017EC  1  A9 5B        	LDA	#<INLMSG
0017EE  1  A0 2B        	LDY	#>INLMSG
0017F0  1  20 A7 15     	JSR	PRINT		;PRINT(' IN LINE ')
0017F3  1  A5 6C        	LDA	CURLIN
0017F5  1  A4 6D        	LDY	CURLIN+1
0017F7  1  18           	CLC			;ADD ONE TO NUMBER
0017F8  1  69 01        	ADC	#1
0017FA  1  90 01        	BCC	*+3
0017FC  1  C8           	INY
0017FD  1  20 0D 18     	JSR	PRNDEC
001800  1  A9 0D        CCRLF	LDA	#CR
001802  1  20 40 15     	JSR	PRNCON
001805  1  A9 0A        	LDA	#LF
001807  1  4C 40 15     	JMP	PRNCON
00180A  1               ;PRINT AY AS DECIMAL NUMBER
00180A  1               DECOUT				;ACCUM
00180A  1  xx xx        	.res	2
00180C  1               LZFLAG				;LEADING ZERO FLAG
00180C  1  xx           	.res	1
00180D  1  8D 0A 18     PRNDEC	STA	DECOUT
001810  1  8C 0B 18     	STY	DECOUT+1	;SAVE NUMBER
001813  1  A9 00        	LDA	#FALSE
001815  1  8D 0C 18     	STA	LZFLAG		;CLEAR LEADING ZERO FLAG
001818  1  A2 2F        	LDX	#'0'-1		;SET DIGIT TO '0' MINUS ONE
00181A  1  38           	SEC
00181B  1  AD 0A 18     P10000	LDA	DECOUT
00181E  1  E9 10        	SBC	#(10000*256/256) & $FF
001820  1  8D 0A 18     	STA	DECOUT
001823  1  AD 0B 18     	LDA	DECOUT+1
001826  1  E9 27        	SBC	#10000/256
001828  1  8D 0B 18     	STA	DECOUT+1	;SUBTRACT 10000
00182B  1  E8           	INX			;BUMP DIGIT
00182C  1  B0 ED        	BCS	P10000		;LOOP IF NO BORROW
00182E  1  AD 0A 18     	LDA	DECOUT
001831  1  69 10        	ADC	#(10000*256/256) & $FF
001833  1  8D 0A 18     	STA	DECOUT
001836  1  AD 0B 18     	LDA	DECOUT+1
001839  1  69 27        	ADC	#10000/256
00183B  1  8D 0B 18     	STA	DECOUT+1	;ADD 10000 BACK IN
00183E  1  20 A0 18     	JSR	DIGOUT		;SEND DIGIT
001841  1  AD 0A 18     P1000	LDA	DECOUT
001844  1  E9 E8        	SBC	#(1000*256/256) & $FF
001846  1  8D 0A 18     	STA	DECOUT
001849  1  AD 0B 18     	LDA	DECOUT+1
00184C  1  E9 03        	SBC	#1000/256
00184E  1  8D 0B 18     	STA	DECOUT+1	;SUBTRACT 1000
001851  1  E8           	INX
001852  1  B0 ED        	BCS	P1000		;LOOP IF NO BORROW
001854  1  AD 0A 18     	LDA	DECOUT
001857  1  69 E8        	ADC	#(1000*256/256) & $FF
001859  1  8D 0A 18     	STA	DECOUT
00185C  1  AD 0B 18     	LDA	DECOUT+1
00185F  1  69 03        	ADC	#1000/256
001861  1  8D 0B 18     	STA	DECOUT+1	;ADD 1000 BACK IN
001864  1  20 A0 18     	JSR	DIGOUT		;SEND DIGIT
001867  1  AD 0A 18     P100	LDA	DECOUT
00186A  1  E9 64        	SBC	#100
00186C  1  8D 0A 18     	STA	DECOUT
00186F  1  AD 0B 18     	LDA	DECOUT+1
001872  1  E9 00        	SBC	#0
001874  1  8D 0B 18     	STA	DECOUT+1	;SUBTRACT 100
001877  1  E8           	INX			;BUMP DIGIT
001878  1  B0 ED        	BCS	P100		;LOOP IF NO BORROW
00187A  1  AD 0A 18     	LDA	DECOUT
00187D  1  69 64        	ADC	#100
00187F  1  8D 0A 18     	STA	DECOUT		;ADD 100 BACK IN
001882  1  20 A0 18     	JSR	DIGOUT		;SEND DIGIT
001885  1  AD 0A 18     P10	LDA	DECOUT
001888  1  E9 0A        	SBC	#10
00188A  1  8D 0A 18     	STA	DECOUT		;SUBTRACT 10
00188D  1  E8           	INX			;BUMP DIGIT
00188E  1  B0 F5        	BCS	P10		;LOOP IF NO BORROW
001890  1  69 0A        	ADC	#10
001892  1  8D 0A 18     	STA	DECOUT		;ADD 10 BACK IN
001895  1  20 A0 18     	JSR	DIGOUT		;OUTPUT DIGIT
001898  1  A9 30        	LDA	#'0'
00189A  1  0D 0A 18     	ORA	DECOUT		;MAKE ONE'S
00189D  1  4C 40 15     	JMP	PRNCON		;PRINT ONE'S ALWAYS
0018A0  1               ;SEND A SINGLE DIGIT IN X AND HANDLE LEADING ZEROS
0018A0  1  A9 20        DIGOUT	LDA	#' '		;PRESET FOR LEADING ZERO
0018A2  1  2C 0C 18     	BIT	LZFLAG		;TEST FLAG
0018A5  1  30 09        	BMI	D2		;BRANCH IF SET
0018A7  1  E0 30        	CPX	#'0'		;SEE IF DIGIT = 0
0018A9  1  F0 06        	BEQ	D3		;BRANCH IF IS
0018AB  1  A9 FF        	LDA	#TRUE
0018AD  1  8D 0C 18     	STA	LZFLAG		;SET FLAG
0018B0  1  8A           D2	TXA			;GET CHAR
0018B1  1  20 40 15     D3	JSR	PRNCON		;PRINT CHAR
0018B4  1  A2 2F        	LDX	#'0'-1		;PRESET DIGIT
0018B6  1  38           	SEC
0018B7  1  60           	RTS
0018B8  1               ;ERROR(AY)
0018B8  1  48           ERROR	PHA
0018B9  1  20 00 18     	JSR	CCRLF
0018BC  1  A9 47        	LDA	#<ERRMSG
0018BE  1  A0 2B        	LDY	#>ERRMSG
0018C0  1  20 A7 15     	JSR	PRINT
0018C3  1  68           	PLA
0018C4  1  20 DB 17     	JSR	OUTMSG
0018C7  1  4C 00 01     	JMP	BOOT
0018CA  1               ;WARNING(AY)
0018CA  1  48           WARNNG	PHA
0018CB  1  20 00 18     	JSR	CCRLF
0018CE  1  A9 50        	LDA	#<WRNMSG
0018D0  1  A0 2B        	LDY	#>WRNMSG
0018D2  1  20 A7 15     	JSR	PRINT		;PRINT('WARNING ')
0018D5  1  68           	PLA
0018D6  1  4C DB 17     	JMP	OUTMSG
0018D9  1               ;STACK MANIPULATION ROUTINES
0018D9  1               ;RA$NEGATIVE
0018D9  1  A0 01        RANEG	LDY	#1
0018DB  1  B1 5C        	LDA	(RA),Y		;GET BRA(1)
0018DD  1  30 03        	BMI	*+5
0018DF  1  A9 00        	LDA	#FALSE
0018E1  1  60           	RTS
0018E2  1  A9 FF        	LDA	#TRUE
0018E4  1  60           	RTS
0018E5  1               ;RB$NEGATIVE
0018E5  1  A0 01        RBNEG	LDY	#1
0018E7  1  B1 5E        	LDA	(RB),Y		;GET BRB(1)
0018E9  1  30 03        	BMI	*+5
0018EB  1  A9 00        	LDA	#FALSE
0018ED  1  60           	RTS
0018EE  1  A9 FF        	LDA	#TRUE
0018F0  1  60           	RTS
0018F1  1               ;FLAG$STRING$ADDR(A)
0018F1  1  A0 02        FLSTRA	LDY	#2
0018F3  1  29 01        	AND	#1		;ONLY DO LSB
0018F5  1  91 5C        	STA	(RA),Y		;BRA(2)=A
0018F7  1  60           	RTS
0018F8  1               ;MOVE$RB$RA
0018F8  1  A0 03        MVRBRA	LDY	#3
0018FA  1  B1 5E        MVBAL	LDA	(RB),Y
0018FC  1  91 5C        	STA	(RA),Y
0018FE  1  88           	DEY
0018FF  1  10 F9        	BPL	MVBAL
001901  1  60           	RTS
001902  1               ;MOVE$RA$RB
001902  1  A0 03        MVRARB	LDY	#3
001904  1  B1 5C        MVABL	LDA	(RA),Y
001906  1  91 5E        	STA	(RB),Y
001908  1  88           	DEY
001909  1  10 F9        	BPL	MVABL
00190B  1  60           	RTS
00190C  1               ;RA$ZERO
00190C  1  A0 00        RAZER	LDY	#0
00190E  1  B1 5C        	LDA	(RA),Y		;GET BRAZ
001910  1  F0 03        	BEQ	*+5
001912  1  A9 00        	LDA	#FALSE
001914  1  60           	RTS
001915  1  A9 FF        	LDA	#TRUE
001917  1  60           	RTS
001918  1               ;RB$ZERO
001918  1  A0 00        RBZER	LDY	#0
00191A  1  B1 5E        	LDA	(RB),Y		;GET BRBZ
00191C  1  F0 03        	BEQ	*+5
00191E  1  A9 00        	LDA	#FALSE
001920  1  60           	RTS
001921  1  A9 FF        	LDA	#TRUE
001923  1  60           	RTS
001924  1               ;RA$ZERO$ADDRESS
001924  1  A0 00        RAZERA	LDY	#0
001926  1  B1 5C        	LDA	(RA),Y		;GET LOW(ARA)
001928  1  C8           	INY
001929  1  11 5C        	ORA	(RA),Y		;OR WITH HIGH
00192B  1  F0 03        	BEQ	*+5
00192D  1  A9 00        	LDA	#FALSE
00192F  1  60           	RTS
001930  1  A9 FF        	LDA	#TRUE
001932  1  60           	RTS
001933  1               ;RB$ZERO$ADDRESS
001933  1  A0 00        RBZERA	LDY	#0
001935  1  B1 5E        	LDA	(RB),Y		;GET LOW(ARB)
001937  1  C8           	INY
001938  1  11 5E        	ORA	(RB),Y		;OR WITH HIGH
00193A  1  F0 03        	BEQ	*+5
00193C  1  A9 00        	LDA	#FALSE
00193E  1  60           	RTS
00193F  1  A9 FF        	LDA	#TRUE
001941  1  60           	RTS
001942  1               ;FLIP
001942  1  A0 03        FLIP	LDY	#3
001944  1  B1 5C        FLIPLP	LDA	(RA),Y
001946  1  AA           	TAX
001947  1  B1 5E        	LDA	(RB),Y
001949  1  91 5C        	STA	(RA),Y
00194B  1  8A           	TXA
00194C  1  91 5E        	STA	(RB),Y
00194E  1  88           	DEY
00194F  1  10 F3        	BPL	FLIPLP
001951  1  60           	RTS
001952  1               ;POP$STACK
001952  1  A5 5E        POPSTK	LDA	RB
001954  1  A4 5F        	LDY	RB+1
001956  1  85 5C        	STA	RA
001958  1  84 5D        	STY	RA+1		;RA:=RB
00195A  1  38           	SEC
00195B  1  E9 04        	SBC	#4
00195D  1  85 5E        	STA	RB
00195F  1  B0 02        	BCS	*+4
001961  1  C6 5F        	DEC	RB+1		;RB:=RB-4
001963  1  C5 62        	CMP	SB
001965  1  A5 5F        	LDA	RB+1
001967  1  E5 63        	SBC	SB+1
001969  1  90 01        	BCC	*+3		;IF RB<SB THEN
00196B  1  60           	RTS
00196C  1  38           	SEC			;RB:=ST-4
00196D  1  A5 64        	LDA	ST
00196F  1  E9 04        	SBC	#4
001971  1  85 5E        	STA	RB
001973  1  A4 65        	LDY	ST+1
001975  1  B0 01        	BCS	*+3
001977  1  88           	DEY
001978  1  84 5F        	STY	RB+1
00197A  1  60           	RTS
00197B  1               ;STEP$INS$CNT
00197B  1  E6 60        STINCN	INC	RC		;RC:=RC+1
00197D  1  D0 02        	BNE	*+4
00197F  1  E6 61        	INC	RC+1
001981  1  60           	RTS
001982  1               ;PUSH$STACK
001982  1  A5 5C        PSHSTK	LDA	RA
001984  1  A4 5D        	LDY	RA+1
001986  1  85 5E        	STA	RB
001988  1  84 5F        	STY	RB+1		;RB:=RA
00198A  1  18           	CLC
00198B  1  69 04        	ADC	#4
00198D  1  85 5C        	STA	RA
00198F  1  90 03        	BCC	*+5
001991  1  C8           	INY
001992  1  84 5D        	STY	RA+1		;RA:=RA+4
001994  1  C5 64        	CMP	ST
001996  1  98           	TYA
001997  1  E5 65        	SBC	ST+1		;IF (RA:=RA+4) >= ST
001999  1  B0 01        	BCS	*+3		;THEN
00199B  1  60           	RTS
00199C  1  A5 62        	LDA	SB
00199E  1  A4 63        	LDY	SB+1
0019A0  1  85 5C        	STA	RA
0019A2  1  84 5D        	STY	RA+1		;RA:=SB
0019A4  1  60           	RTS
0019A5  1               ;IN$FSA(LOCATION)
0019A5  1               ;RETURNS TRUE IF LOCATION IS IN FSA
0019A5  1  85 7B        INFSA	STA	INFSAT
0019A7  1  A5 64        	LDA	ST
0019A9  1  C5 7B        	CMP	INFSAT
0019AB  1  84 7B        	STY	INFSAT		;SAVE Y
0019AD  1  A5 65        	LDA	ST+1
0019AF  1  E5 7B        	SBC	INFSAT		;IF AY>ST
0019B1  1  A9 FF        	LDA	#TRUE
0019B3  1  90 02        	BCC	*+4		;THEN RETURN:=TRUE
0019B5  1  A9 00        	LDA	#FALSE		;ELSE RETURN:=FALSE
0019B7  1  60           	RTS
0019B8  1               ;SET$DATA$ADDR(PTR)
0019B8  1  85 7C        SEDAAD	STA	SEDPTR		;SAVE PTR
0019BA  1  84 7D        	STY	SEDPTR+1
0019BC  1  A0 00        	LDY	#0		;SET A
0019BE  1  B1 7C        	LDA	(SEDPTR),Y
0019C0  1  AA           	TAX			;SAVE LOW IN X
0019C1  1  C8           	INY
0019C2  1  B1 7C        	LDA	(SEDPTR),Y
0019C4  1  A8           	TAY
0019C5  1  8A           	TXA
0019C6  1  20 A5 19     	JSR	INFSA		;IF IN$FSA
0019C9  1  D0 1E        	BNE	E12		;THEN DONE
0019CB  1  A0 00        	LDY	#0
0019CD  1  B1 7C        	LDA	(SEDPTR),Y	;GET LOW
0019CF  1  85 7E        	STA	SEDAAT		;AND SAVE
0019D1  1  C8           	INY
0019D2  1  B1 7C        	LDA	(SEDPTR),Y
0019D4  1  88           	DEY
0019D5  1  06 7E        	ASL	SEDAAT
0019D7  1  2A           	ROL	A
0019D8  1  06 7E        	ASL	SEDAAT
0019DA  1  2A           	ROL	A		;TIMES4(A)
0019DB  1  AA           	TAX			;SAVE HIGH IN X
0019DC  1  18           	CLC
0019DD  1  A5 66        	LDA	MPR
0019DF  1  65 7E        	ADC	SEDAAT
0019E1  1  91 7C        	STA	(SEDPTR),Y
0019E3  1  C8           	INY
0019E4  1  8A           	TXA
0019E5  1  65 67        	ADC	MPR+1
0019E7  1  91 7C        	STA	(SEDPTR),Y	;A:=MPR+TIMES4(A)
0019E9  1  60           E12	RTS
0019EA  1               ;LOAD$RA
0019EA  1               ;(ARA) TO (RA)
0019EA  1  A5 5C        LOADRA	LDA	RA
0019EC  1  A4 5D        	LDY	RA+1
0019EE  1  20 B8 19     	JSR	SEDAAD		;SET$DATA$ADDR(RA)
0019F1  1  20 0E 1A     	JSR	ARA
0019F4  1  85 2C        	STA	MFROM
0019F6  1  84 2D        	STY	MFROM+1
0019F8  1  A5 5C        	LDA	RA
0019FA  1  A4 5D        	LDY	RA+1
0019FC  1  85 2E        	STA	MTO
0019FE  1  84 2F        	STY	MTO+1
001A00  1  4C 72 17     	JMP	MOVE4		;MOVE4(FROM,TO)
001A03  1               ;CALCULATE ARB
001A03  1  A0 00        ARB	LDY	#0
001A05  1  B1 5E        	LDA	(RB),Y
001A07  1  48           	PHA
001A08  1  C8           	INY
001A09  1  B1 5E        	LDA	(RB),Y
001A0B  1  A8           	TAY
001A0C  1  68           	PLA
001A0D  1  60           	RTS
001A0E  1               ;CALCULATE ARA
001A0E  1  A0 00        ARA	LDY	#0
001A10  1  B1 5C        	LDA	(RA),Y
001A12  1  48           	PHA
001A13  1  C8           	INY
001A14  1  B1 5C        	LDA	(RA),Y
001A16  1  A8           	TAY
001A17  1  68           	PLA
001A18  1  60           	RTS
001A19  1               ;CALCULATE TWOBYTEOPRND (ARC)
001A19  1  A0 00        ARC	LDY	#0
001A1B  1  B1 60        	LDA	(RC),Y
001A1D  1  48           	PHA
001A1E  1  C8           	INY
001A1F  1  B1 60        	LDA	(RC),Y
001A21  1  A8           	TAY
001A22  1  68           	PLA
001A23  1  60           	RTS
001A24  1               ;CONSOLE OUTPUT ROUTINES
001A24  1               ;DUMP$PRINT$BUFF
001A24  1  20 34 15     DMPPBF	JSR	CRLF		;DO CR AND LF
001A27  1               ;CLEAR$PRINT$BUFF
001A27  1  A9 00        CLRPBF	LDA	#0
001A29  1  85 74        	STA	PRBUFF		;PRINTBUFFR:=0
001A2B  1  60           	RTS
001A2C  1               ;NUMERIC$OUT
001A2C  1  20 71 1B     NUMOUT	JSR	FLODRA		;PRIM:=(RA)
001A2F  1  20 B3 21     	JSR	FLTOUT		;CONVERT TO ASCII
001A32  1  AD CF 2F     	LDA	PRNWRK		;GET FIRST
001A35  1  C9 20        	CMP	#' '		;SEE IF SPACE
001A37  1  D0 0B        	BNE	L091		;SKIP AHEAD IF NOT
001A39  1  A2 FF        	LDX	#255
001A3B  1  E8           L090	INX
001A3C  1  BD D0 2F     	LDA	PRNWRK+1,X	;MOVE EVERYTHING
001A3F  1  9D CF 2F     	STA	PRNWRK,X	;AHEAD ONE CHAR
001A42  1  D0 F7        	BNE	L090		;UNTIL HIT ZERO
001A44  1  A2 00        L091	LDX	#0
001A46  1  E8           L042	INX
001A47  1  BD CE 2F     	LDA	NUOWRK,X	;CALC STRING LENGTH
001A4A  1  D0 FA        	BNE	L042
001A4C  1  8E CE 2F     	STX	NUOWRK		;MAKE LENGTH FIRST BYTE
001A4F  1  A9 20        	LDA	#' '
001A51  1  9D CE 2F     	STA	NUOWRK,X	;INSERT A BLANK IN PLACE OF $00
001A54  1  A0 00        	LDY	#0
001A56  1  A9 CE        	LDA	#<NUOWRK
001A58  1  91 5C        	STA	(RA),Y
001A5A  1  C8           	INY
001A5B  1  A9 2F        	LDA	#>NUOWRK
001A5D  1  91 5C        	STA	(RA),Y		;ARA:=.NUMBEROUTWORKAREA
001A5F  1  60           	RTS
001A60  1               ;WRITE$TO$CONSOLE
001A60  1               WTCI				;INDEX
001A60  1  xx           	.res	1
001A61  1  A0 00        WRTTCN	LDY	#0
001A63  1  B1 5C        	LDA	(RA),Y
001A65  1  85 04        	STA	WTCHLD
001A67  1  C8           	INY
001A68  1  B1 5C        	LDA	(RA),Y
001A6A  1  85 05        	STA	WTCHLD+1	;HOLD:=ARA
001A6C  1  05 04        	ORA	WTCHLD
001A6E  1  F0 25        	BEQ	E13		;IF HOLD=0 THEN
001A70  1  8C 60 1A     	STY	WTCI		;INDEX:=1
001A73  1  A0 00        L048	LDY	#0
001A75  1  B1 04        	LDA	(WTCHLD),Y	;A:=H(0)
001A77  1  CD 60 1A     	CMP	WTCI
001A7A  1  90 19        	BCC	E13		;IF INDEX > H(0) THEN
001A7C  1  AC 60 1A     	LDY	WTCI
001A7F  1  B1 04        	LDA	(WTCHLD),Y
001A81  1  20 3B 15     	JSR	PRNCHR		;OUTPUT CHARACTER
001A84  1  E6 74        	INC	PRBUFF		;PRINTBUFFER:=PRINTBUFFER+1
001A86  1  A9 83        	LDA	#131
001A88  1  C5 74        	CMP	PRBUFF
001A8A  1  B0 03        	BCS	*+5		;IF PRINTBUFFER <= PRINTBUFFEND THEN
001A8C  1  20 24 1A     	JSR	DMPPBF		;ELSE DUMP$PRINT$BUFF
001A8F  1  EE 60 1A     	INC	WTCI
001A92  1  4C 73 1A     	JMP	L048		;LOOP
001A95  1  60           E13	RTS
001A96  1               ;FIXED POINT ROUTINES
001A96  1               ;MULTIPLY PRIMARY FIXED POINT ACCUM BY (AY) AND PUT RESULT IN AY
001A96  1  85 30        MXAP	STA	SX
001A98  1  84 31        	STY	SX+1		;SX:=AY
001A9A  1  A9 00        	LDA	#0		;CLEAR HIGH
001A9C  1  85 34        	STA	PX+2
001A9E  1  85 35        	STA	PX+3
001AA0  1  A0 10        	LDY	#16		;DO 16 BITS
001AA2  1  A5 32        MXAPL	LDA	PX
001AA4  1  4A           	LSR	A		;TEST LSB
001AA5  1  90 0D        	BCC	MXAPNA		;DON'T ADD IF CLEAR
001AA7  1  18           	CLC
001AA8  1  A5 34        	LDA	PX+2
001AAA  1  65 30        	ADC	SX
001AAC  1  85 34        	STA	PX+2
001AAE  1  A5 35        	LDA	PX+3
001AB0  1  65 31        	ADC	SX+1
001AB2  1  85 35        	STA	PX+3
001AB4  1  66 35        MXAPNA	ROR	PX+3		;SHIFT ALL RIGHT
001AB6  1  66 34        	ROR	PX+2
001AB8  1  66 33        	ROR	PX+1
001ABA  1  66 32        	ROR	PX
001ABC  1  88           	DEY
001ABD  1  D0 E3        	BNE	MXAPL		;LOOP IF MORE
001ABF  1  A5 32        	LDA	PX
001AC1  1  A4 33        	LDY	PX+1
001AC3  1  60           	RTS
001AC4  1               ;FLOATING POINT INTERFACE ROUTINES
001AC4  1               ;ROUND$CONV$BIN
001AC4  1  20 71 1B     RNCBRA	JSR	FLODRA		;GET @ RA
001AC7  1  A9 AE        	LDA	#<HALF
001AC9  1  A0 1B        	LDY	#>HALF
001ACB  1  20 0C 1E     	JSR	APA		;ADD .5
001ACE  1  20 78 1B     	JSR	FSTRRA		;STORE @ RA
001AD1  1  20 8D 1B     	JSR	CHKOVR		;CHECK FOR OVERFLOW AND FAAL THROUGH
001AD4  1               ;CONV$TO$BIN$ADDR
001AD4  1  20 EE 1A     CNVBAD	JSR	CNVBRA		;CONV$TO$BINARY(RA)
001AD7  1  A0 03        	LDY	#3
001AD9  1  B1 5C        	LDA	(RA),Y
001ADB  1  A0 00        	LDY	#0
001ADD  1  91 5C        	STA	(RA),Y		;BRA(0):=BRA(3)
001ADF  1  A0 02        	LDY	#2
001AE1  1  B1 5C        	LDA	(RA),Y
001AE3  1  88           	DEY
001AE4  1  91 5C        	STA	(RA),Y		;BRA(1):=BRA(2)
001AE6  1  60           	RTS
001AE7  1               ;CONV$TO$BINARY(RB)
001AE7  1  A5 5E        CNVBRB	LDA	RB
001AE9  1  A4 5F        	LDY	RB+1
001AEB  1  4C F2 1A     	JMP	CNVBIN
001AEE  1               ;CONV$TO$BINARY(RA)
001AEE  1  A5 5C        CNVBRA	LDA	RA
001AF0  1  A4 5D        	LDY	RA+1
001AF2  1               ;CONV$TO$BUNARY(AY)
001AF2  1               ;CONVERTS FLOATING POINT NUMBER @ AY TO 24 BIT TWO'S COMPLEMENT NUMBER AND
001AF2  1               ;RETURNS VALUE TO @ AY
001AF2  1  20 E4 1C     CNVBIN	JSR	LPA		;PRIM:=(AY)
001AF5  1  20 31 20     	JSR	FXU		;FIX IT
001AF8  1  A9 00        	LDA	#0
001AFA  1  85 51        	STA	PR
001AFC  1  85 4F        	STA	PS		;CLEAR ROUNDING AND SIGN
001AFE  1  A2 00        	LDX	#0		;PRESET FOR POSITIVE
001B00  1  24 4C        	BIT	PM		;NOW SIGN EXTEND INTO PE
001B02  1  10 01        	BPL	*+3
001B04  1  CA           	DEX
001B05  1  86 4B        	STX	PE
001B07  1  A5 40        	LDA	ME		;AY SAVED IN ME AND ME+1
001B09  1  A4 41        	LDY	ME+1
001B0B  1  20 C1 1C     	JSR	STP		;STORE IT
001B0E  1  A0 01        	LDY	#1		;REDO MANTISSA
001B10  1  A5 4C        	LDA	PM
001B12  1  91 42        	STA	(SL),Y		;SO SIGN IS OK
001B14  1  60           	RTS
001B15  1               ;CONV$TO$FP(RB)
001B15  1  A5 5E        CNVFRB	LDA	RB
001B17  1  A4 5F        	LDY	RB+1
001B19  1  4C 20 1B     	JMP	CNVFLT
001B1C  1               ;CONV$TO$FP(RA)
001B1C  1  A5 5C        CNVFRA	LDA	RA
001B1E  1  A4 5D        	LDY	RA+1
001B20  1               ;CONV$TO$FP(AY)
001B20  1               ;CONVERTS 24 BIT INTEGER @ AY TO FLOATING POINT NUMBER AND STORE @ AY
001B20  1  20 E4 1C     CNVFLT	JSR	LPA		;PRIM:=(AY)
001B23  1  A0 01        	LDY	#1
001B25  1  B1 40        	LDA	(ME),Y		;REDO FIRST MANTISSA
001B27  1  85 4C        	STA	PM		;SO SIGN BIT IS OK
001B29  1  A2 98        	LDX	#24+128
001B2B  1  86 4B        	STX	PE		;SET EXPONENT
001B2D  1  A5 4C        	LDA	PM
001B2F  1  49 FF        	EOR	#$FF
001B31  1  2A           	ROL	A		;SET CARRY TO -SIGN
001B32  1  A9 00        	LDA	#0
001B34  1  85 51        	STA	PR
001B36  1  85 4F        	STA	PS		;CLEAR SIGN AND ROUNDING
001B38  1  20 7C 1E     	JSR	CYENT		;NORMALIZE
001B3B  1  A5 40        	LDA	ME
001B3D  1  A4 41        	LDY	ME+1		;AY SAVED IN ME AND ME+1
001B3F  1  4C C1 1C     	JMP	STP		;STORE IT
001B42  1               ;FLOAT$ADDR(AY)
001B42  1  20 72 1C     FLTADR	JSR	FLT16		;FLOAT AY
001B45  1  4C 78 1B     	JMP	FSTRRA		;AND STORE
001B48  1               ;COMPARE$FP
001B48  1               ;RETURNS 1 IF (RB)<(RA); 2 IF (RB)>(RA); 3 IF (RB)=(RA)
001B48  1  20 71 1B     COMPFP	JSR	FLODRA		;LOAD (RA)
001B4B  1  A5 5E        	LDA	RB
001B4D  1  A4 5F        	LDY	RB+1
001B4F  1  20 5D 1D     	JSR	SPA		;PRIM:=(RB)-(RA)
001B52  1  20 78 1B     	JSR	FSTRRA		;STORE @ (RA)
001B55  1  20 0C 19     	JSR	RAZER
001B58  1  F0 06        	BEQ	L049		;IF NOT RA$ZERO THEN
001B5A  1  20 52 19     	JSR	POPSTK		;ELSE
001B5D  1  A9 03        	LDA	#3
001B5F  1  60           	RTS
001B60  1  20 D9 18     L049	JSR	RANEG
001B63  1  F0 06        	BEQ	L050		;IF NOT RA$NEGATIVE THEN
001B65  1  20 52 19     	JSR	POPSTK
001B68  1  A9 01        	LDA	#1
001B6A  1  60           	RTS
001B6B  1  20 52 19     L050	JSR	POPSTK
001B6E  1  A9 02        	LDA	#2
001B70  1  60           	RTS
001B71  1               ;LOAD (RA) INTO PRIMARY FLOATING POINT ACCUM
001B71  1  A5 5C        FLODRA	LDA	RA
001B73  1  A4 5D        	LDY	RA+1
001B75  1  4C E4 1C     	JMP	LPA		;PRIM:=(RA)
001B78  1               ;STORE PRIMARY FLOATING POINT ACCUM AT (RA)
001B78  1  A5 5C        FSTRRA	LDA	RA
001B7A  1  A4 5D        	LDY	RA+1
001B7C  1  4C C1 1C     	JMP	STP
001B7F  1               ;LOAD (RB) INTO PRIMARY FLOATING POINT ACCUM
001B7F  1  A5 5E        FLODRB	LDA	RB
001B81  1  A4 5F        	LDY	RB+1
001B83  1  4C E4 1C     	JMP	LPA
001B86  1               ;STORE PRIMARY FLOATING POINT ACCUM AT (RB)
001B86  1  A5 5E        FSTRRB	LDA	RB
001B88  1  A4 5F        	LDY	RB+1
001B8A  1  4C C1 1C     	JMP	STP
001B8D  1               ;CHECK$OVERFLOW
001B8D  1  24 3F        CHKOVR	BIT	OVERFL
001B8F  1  10 18        	BPL	E24		;IF NOT OVERFLOW THEN
001B91  1  A9 1A        	LDA	#26		;ELSE SEND OVERFLOW WARNING
001B93  1  20 CA 18     	JSR	WARNNG
001B96  1  A0 03        	LDY	#3
001B98  1  B9 AA 1B     L025	LDA	MAXNUM,Y
001B9B  1  91 5C        	STA	(RA),Y
001B9D  1  88           	DEY
001B9E  1  10 F8        	BPL	L025		;(RA):=MAXNUM
001BA0  1  C8           	INY
001BA1  1  84 3F        	STY	OVERFL		;OVERFLOW:=FALSE
001BA3  1  84 51        	STY	PR
001BA5  1  84 50        	STY	PC
001BA7  1  84 4F        	STY	PS		;CLEAR SIGN, CARRY, AND ROUNDING
001BA9  1  60           E24	RTS
001BAA  1               ;FLOATING POINT ROUTINES
001BAA  1               ;CONSTANTS
001BAA  1  FF 7F FF FF  MAXNUM	.BYTE	$FF,$7F,$FF,$FF
001BAE  1  80 00 00 00  HALF	.BYTE	$80,0,0,0	;(0.5)
001BB2  1  91 43 4F F8  FIVE9S	.BYTE	$91,$43,$4F,$F8	;(99999.9375)
001BB6  1  94 74 23 F7  SIX9S	.BYTE	$94,$74,$23,$F7	;(999999.4375)
001BBA  1  94 74 24 00  MILLON	.BYTE	$94,$74,$24,0	;(1000000)
001BBE  1  84 20 00 00  TEN	.BYTE	$84,$20,0,0	;(10)
001BC2  1  81 00 00 00  ONE	.BYTE	$81,0,0,0	;(1)
001BC6  1  81 49 0F DB  PI2	.BYTE	$81,$49,$0F,$DB	;(PI/2)
001BCA  1  81 35 04 F3  SQR2	.BYTE	$81,$35,$04,$F3	;(SQR(2))
001BCE  1  80 80 00 00  MHALF	.BYTE	$80,$80,0,0	;(-0.5)
001BD2  1  80 31 72 18  LN2	.BYTE	$80,$31,$72,$18	;(LN(2))
001BD6  1  81 38 AA 3B  LN2INV	.BYTE	$81,$38,$AA,$3B	;(1/LN(2))
001BDA  1  80 35 04 F3  SQR2D2	.BYTE	$80,$35,$04,$F3	;(SQR(2)/2)
001BDE  1  83 49 0F DB  TWOPI	.BYTE	$83,$49,$0F,$DB	;(2*PI)
001BE2  1  7F 00 00 00  QUARTR	.BYTE	$7F,0,0,0	;(0.25)
001BE6  1  81 80 00 00  MONE	.BYTE	$81,$80,0,0	;(-1)
001BEA  1  80 3F C7 52  RNDWRK	.BYTE	$80,$3F,$C7,$52
001BEE  1  98 35 44 7A  RNDMUL	.BYTE	$98,$35,$44,$7A
001BF2  1  68 28 B1 46  RNDADD	.BYTE	$68,$28,$B1,$46
001BF6  1               ;CONVERSION DATA TABLES
001BF6  1  FE 79 60     CNVTBL	.BYTE	$FE,$79,$60	;-100,000
001BF9  1  00 27 10     	.BYTE	0,$27,$10	;10,000
001BFC  1  FF FC 18     	.BYTE	$FF,$FC,$18	;-1000
001BFF  1  00 00 64     	.BYTE	0,0,100		;100
001C02  1  FF FF F6     	.BYTE	$FF,$FF,$F6	;-10
001C05  1  00 00 01     	.BYTE	0,0,1		;1
001C08  1               ;SERIES EVALUATION CHAINS
001C08  1  02           LOGCHN	.BYTE	2
001C09  1  80 19 56 AA  	.BYTE	$80,$19,$56,$AA
001C0D  1  80 76 22 F0  	.BYTE	$80,$76,$22,$F0
001C11  1  82 38 AA 40  	.BYTE	$82,$38,$AA,$40
001C15  1  07           EXPCHN	.BYTE	7
001C16  1  74 94 2E 40  	.BYTE	$74,$94,$2E,$40
001C1A  1  77 2E 4F 70  	.BYTE	$77,$2E,$4F,$70
001C1E  1  7A 88 02 6E  	.BYTE	$7A,$88,$02,$6E
001C22  1  7C 2A A0 E6  	.BYTE	$7C,$2A,$A0,$E6
001C26  1  7E AA AA 50  	.BYTE	$7E,$AA,$AA,$50
001C2A  1  7F 7F FF FF  	.BYTE	$7F,$7F,$FF,$FF
001C2E  1  81 80 00 00  	.BYTE	$81,$80,0,0
001C32  1  81 00 00 00  	.BYTE	$81,0,0,0
001C36  1  04           SINCHN	.BYTE	4
001C37  1  86 1E D7 BA  	.BYTE	$86,$1E,$D7,$BA
001C3B  1  87 99 26 64  	.BYTE	$87,$99,$26,$64
001C3F  1  87 23 34 58  	.BYTE	$87,$23,$34,$58
001C43  1  86 A5 5D E0  	.BYTE	$86,$A5,$5D,$E0
001C47  1  83 49 0F DA  	.BYTE	$83,$49,$0F,$DA
001C4B  1  08           ATNCHN	.BYTE	8
001C4C  1  78 3B D7 4A  	.BYTE	$78,$3B,$D7,$4A
001C50  1  7B 84 6E 02  	.BYTE	$7B,$84,$6E,$02
001C54  1  7C 2F C1 FE  	.BYTE	$7C,$2F,$C1,$FE
001C58  1  7D 9A 31 74  	.BYTE	$7D,$9A,$31,$74
001C5C  1  7D 5A 3D 84  	.BYTE	$7D,$5A,$3D,$84
001C60  1  7E 91 7F C8  	.BYTE	$7E,$91,$7F,$C8
001C64  1  7E 4C BB E4  	.BYTE	$7E,$4C,$BB,$E4
001C68  1  7F AA AA 6C  	.BYTE	$7F,$AA,$AA,$6C
001C6C  1  81 00 00 00  	.BYTE	$81,0,0,0
001C70  1               ;FLOAT 8 BIT VALUE IN A AS POSITIVE NUMBER
001C70  1  A0 00        FLT8	LDY	#0		;CLEAR MS BYTE
001C72  1               ;FLOAT 16 BIT VALUE IN AY AS POSITIVE NUMBER
001C72  1  85 4D        FLT16	STA	PM+1
001C74  1  84 4C        	STY	PM		;SET MANTISSA
001C76  1  A2 90        	LDX	#16+128		;EXPONENT:=16
001C78  1  38           	SEC
001C79  1  86 4B        	STX	PE
001C7B  1  A9 00        	LDA	#0
001C7D  1  85 4E        	STA	PM+2
001C7F  1  85 51        	STA	PR
001C81  1  85 4F        	STA	PS		;CLEAR SIGN, MANTISSA (HIGH), AND ROUNDING
001C83  1  4C 81 1E     	JMP	NORMLZ		;GO NORMALIZE
001C86  1               ;TWO'S COMPLEMENT OF PRIMARY ACCUMULATOR
001C86  1  A5 4F        TCP	LDA	PS		;COMPLEMENT SIGN
001C88  1  49 FF        	EOR	#$FF
001C8A  1  85 4F        	STA	PS
001C8C  1  A5 4C        TCPNS	LDA	PM		;THEN MANTISSA
001C8E  1  49 FF        	EOR	#$FF
001C90  1  85 4C        	STA	PM
001C92  1  A5 4D        	LDA	PM+1
001C94  1  49 FF        	EOR	#$FF
001C96  1  85 4D        	STA	PM+1
001C98  1  A5 4E        	LDA	PM+2
001C9A  1  49 FF        	EOR	#$FF
001C9C  1  85 4E        	STA	PM+2
001C9E  1  A5 51        	LDA	PR		;THEN ROUNDING BYTE
001CA0  1  49 FF        	EOR	#$FF
001CA2  1  85 51        	STA	PR
001CA4  1  E6 51        	INC	PR		;NOW ADD ONE TO ALL
001CA6  1  D0 0A        	BNE	E1
001CA8  1               ;INCREMENT PRIMARY MANTISSA
001CA8  1  E6 4E        INP	INC	PM+2		;BUMP MANTISSA
001CAA  1  D0 06        	BNE	E1
001CAC  1  E6 4D        	INC	PM+1
001CAE  1  D0 02        	BNE	E1
001CB0  1  E6 4C        	INC	PM
001CB2  1  60           E1	RTS
001CB3  1               ;EXTRACT SIGN OF PRIMARY ACCUMULATOR AND TEST PRIMARY ACCUMULATOR FOR ZERO.
001CB3  1               ;IF PRIMARY ZERO THEN Z=1 AND A=0 ELSE IF POSITIVE THEN Z=0 AND A=1 ELSE IF
001CB3  1               ;NEGATIVE THEN Z=0 AND A=$FF
001CB3  1  A5 4B        ESP	LDA	PE		;GET EXPONENT
001CB5  1  F0 09        	BEQ	E2		;EXIT IF ZERO
001CB7  1  A5 4F        ESPS	LDA	PS		;GET SIGN
001CB9  1  2A           ESPSRL	ROL	A		;MOVE TO CARRY
001CBA  1  A9 FF        	LDA	#$FF		;PRESET FOR MINUS
001CBC  1  B0 02        	BCS	E2		;BRANCH IF IS
001CBE  1  A9 01        	LDA	#1		;ELSE POSITIVE
001CC0  1  60           E2	RTS
001CC1  1               ;STORE PRIMARY ACCUMULATOR AT MEMORY AT (AY)
001CC1  1  85 42        STP	STA	SL
001CC3  1  84 43        	STY	SL+1		;SL:=AY
001CC5  1               ;STORE PRIMARY ACCUMULATOR AT (SL) AFTER ROUNDING
001CC5  1  20 F3 1E     SPM	JSR	RNP		;ROUND IT
001CC8  1  A0 03        	LDY	#3
001CCA  1  A5 4E        	LDA	PM+2
001CCC  1  91 42        	STA	(SL),Y
001CCE  1  88           	DEY
001CCF  1  A5 4D        	LDA	PM+1
001CD1  1  91 42        	STA	(SL),Y
001CD3  1  88           	DEY
001CD4  1  A5 4F        	LDA	PS		;NOW OR SIGN WITH PM
001CD6  1  09 7F        	ORA	#$7F
001CD8  1  25 4C        	AND	PM
001CDA  1  91 42        	STA	(SL),Y
001CDC  1  88           	DEY
001CDD  1  A5 4B        	LDA	PE
001CDF  1  91 42        	STA	(SL),Y
001CE1  1  84 51        	STY	PR		;CLEAR ROUNDING
001CE3  1  60           	RTS
001CE4  1               ;LOAD PRIMARY ACCUMULATOR FROM MEMORY AT (AY)
001CE4  1  85 40        LPA	STA	ME
001CE6  1  84 41        	STY	ME+1		;ME:=AY
001CE8  1               ;LOAD PRIMARY ACCUMULATOR FROM MEMORY AT (ME)
001CE8  1  A0 03        LPM	LDY	#3		;FOUR-ONE BYTES
001CEA  1  B1 40        	LDA	(ME),Y
001CEC  1  85 4E        	STA	PM+2
001CEE  1  88           	DEY
001CEF  1  B1 40        	LDA	(ME),Y
001CF1  1  85 4D        	STA	PM+1
001CF3  1  88           	DEY
001CF4  1  B1 40        	LDA	(ME),Y
001CF6  1  85 4F        	STA	PS
001CF8  1  09 80        	ORA	#$80
001CFA  1  85 4C        	STA	PM		;SET IMPLIED 1
001CFC  1  88           	DEY
001CFD  1  B1 40        	LDA	(ME),Y
001CFF  1  85 4B        	STA	PE
001D01  1  84 51        	STY	PR		;ROUNDING:=0
001D03  1  60           	RTS
001D04  1               ;LOAD SECONDARY ACCUMULATOR FROM (AY)
001D04  1  85 40        LSA	STA	ME
001D06  1  84 41        	STY	ME+1		;ME:=AY
001D08  1               ;LOAD SECONDARY ACCUMULATOR FROM (ME)
001D08  1  A0 03        LSM	LDY	#3
001D0A  1  B1 40        	LDA	(ME),Y
001D0C  1  85 55        	STA	SM+2
001D0E  1  88           	DEY
001D0F  1  B1 40        	LDA	(ME),Y
001D11  1  85 54        	STA	SM+1
001D13  1  88           	DEY
001D14  1  B1 40        	LDA	(ME),Y
001D16  1  85 56        	STA	SS
001D18  1  45 4F        	EOR	PS
001D1A  1  85 5B        	STA	SGNCMP
001D1C  1  A5 56        	LDA	SS
001D1E  1  09 80        	ORA	#$80
001D20  1  85 53        	STA	SM
001D22  1  88           	DEY
001D23  1  B1 40        	LDA	(ME),Y
001D25  1  85 52        	STA	SE
001D27  1  60           	RTS
001D28  1               ;TRANSFER SECONDARY ACCUMULATOR TO PRIMARY AND CLEAR ROUNDING
001D28  1  A5 56        TSP	LDA	SS
001D2A  1  85 4F        	STA	PS
001D2C  1  A5 55        	LDA	SM+2
001D2E  1  85 4E        	STA	PM+2
001D30  1  A5 54        	LDA	SM+1
001D32  1  85 4D        	STA	PM+1
001D34  1  A5 53        	LDA	SM
001D36  1  85 4C        	STA	PM
001D38  1  A5 52        	LDA	SE
001D3A  1  85 4B        	STA	PE
001D3C  1  A9 00        	LDA	#0
001D3E  1  85 51        	STA	PR
001D40  1  60           	RTS
001D41  1               ;TRANSFER PRIMARY ACCUMULATOR TO SECONDARY AFTER ROUNDING AND CLEAR ROUNDING
001D41  1  20 F3 1E     TPS	JSR	RNP		;ROUND PRIMARY
001D44  1  A5 4F        	LDA	PS
001D46  1  85 56        	STA	SS
001D48  1  A5 4E        	LDA	PM+2
001D4A  1  85 55        	STA	SM+2
001D4C  1  A5 4D        	LDA	PM+1
001D4E  1  85 54        	STA	SM+1
001D50  1  A5 4C        	LDA	PM
001D52  1  85 53        	STA	SM
001D54  1  A5 4B        	LDA	PE
001D56  1  85 52        	STA	SE
001D58  1  A9 00        	LDA	#0
001D5A  1  85 51        	STA	PR
001D5C  1  60           	RTS
001D5D  1               ;SUBTRACT PRIMARY ACCUMULATOR FROM MEMORY (AY)
001D5D  1               ;P:=(AY)-P
001D5D  1  20 04 1D     SPA	JSR	LSA		;MOVE MEMORY TO SECONDARY
001D60  1               ;SUBTRACT PRIMARY ACCUMULATOR FROM SECONDARY
001D60  1               ;P:=S-P
001D60  1  A5 4F        SPS	LDA	PS		;COMPLEMENT PRIMARY SIGN
001D62  1  49 FF        	EOR	#$FF
001D64  1  85 4F        	STA	PS
001D66  1  45 56        	EOR	SS
001D68  1  85 5B        	STA	SGNCMP		;SET COMPARE STATUS
001D6A  1  4C 0F 1E     	JMP	APS		;AND ADD
001D6D  1               ;ALTERNATE ENTRY TO SHIFT ROUTINE
001D6D  1  48           SXRYAL	PHA			;SAVE A
001D6E  1  4C 9B 1D     	JMP	SXRYE
001D71  1               ;SHIFT PRODUCT STAGING AREA RIGHT ONE BYTE
001D71  1  A2 57        SQR8	LDX	#QE
001D73  1               ;SHIFT NUMBER POINTED TO BY X RIGHT A TIMES. MUST BE AT LEAST 8 TIMES TO START
001D73  1               ;AS ENTIRE BYTES ARE SHIFTED
001D73  1  B4 03        SXR8	LDY	3,X		;MOVE WHOLE BYTES
001D75  1  84 51        	STY	PR
001D77  1  B4 02        	LDY	2,X
001D79  1  94 03        	STY	3,X
001D7B  1  B4 01        	LDY	1,X
001D7D  1  94 02        	STY	2,X
001D7F  1  A4 50        	LDY	PC
001D81  1  94 01        	STY	1,X
001D83  1               ;SHIFT NUMBER POINTED TO BY X RIGHT A TIMES
001D83  1  69 08        SXRA	ADC	#8		;ADD 8
001D85  1  30 EC        	BMI	SXR8		;LOOP IF AT LEAST A BYTE
001D87  1  F0 EA        	BEQ	SXR8
001D89  1  E9 08        	SBC	#8		;DROP BACK TO BITS
001D8B  1  A8           	TAY			;MOVE TO Y
001D8C  1  A5 51        	LDA	PR		;GET ROUNDING
001D8E  1  B0 14        	BCS	E4		;DONE IF CARRY
001D90  1  48           SXRY	PHA
001D91  1  B5 01        	LDA	1,X
001D93  1  29 80        	AND	#$80		;CLEAR ALL BUT MSB
001D95  1  56 01        	LSR	1,X		;SHIFT RIGHT AND CLEAR CY
001D97  1  15 01        	ORA	1,X
001D99  1  95 01        	STA	1,X
001D9B  1  76 02        SXRYE	ROR	2,X
001D9D  1  76 03        	ROR	3,X
001D9F  1  68           	PLA
001DA0  1  6A           	ROR	A
001DA1  1  C8           	INY
001DA2  1  D0 EC        	BNE	SXRY		;LOOP IF MORE
001DA4  1  18           E4	CLC			;ALWAYS CLEAR CARRY
001DA5  1  60           	RTS
001DA6  1               ;COMPARE NUMBER AT (AY) TO PRIMARY ACCUMULATOR
001DA6  1  85 42        CPA	STA	SL
001DA8  1  84 43        	STY	SL+1		;SL:=AY
001DAA  1               ;COMPARE PRIMARY ACCUMULATOR TO NUMBER AT (SL)
001DAA  1  A0 00        CPM	LDY	#0
001DAC  1  B1 42        	LDA	(SL),Y		;GET EXPONENT
001DAE  1  C8           	INY
001DAF  1  AA           	TAX			;TEST
001DB0  1  D0 03        	BNE	*+5		;CONTINUE IF N <> 0
001DB2  1  4C B3 1C     	JMP	ESP		;ELSE GO EXTRACT PRIMARY SIGN
001DB5  1  B1 42        	LDA	(SL),Y		;GET MANTISSA
001DB7  1  45 4F        	EOR	PS		;TEST SIGN PART
001DB9  1  10 03        	BPL	*+5		;BRANCH IF SAME
001DBB  1  4C B7 1C     	JMP	ESPS		;TEST PRIMARY
001DBE  1  E4 4B        	CPX	PE		;COMPARE EXPONENTS
001DC0  1  D0 1B        	BNE	CPMSGN		;TRY SIGNS IF DIFFERENT
001DC2  1  B1 42        	LDA	(SL),Y		;GET M AGAIN
001DC4  1  09 80        	ORA	#$80		;SET HIDDEN BIT
001DC6  1  C5 4C        	CMP	PM		;COMPARE TO PM
001DC8  1  D0 13        	BNE	CPMSGN
001DCA  1  C8           	INY
001DCB  1  B1 42        	LDA	(SL),Y		;GET NEXT
001DCD  1  C5 4D        	CMP	PM+1		;COMPARE
001DCF  1  D0 0C        	BNE	CPMSGN
001DD1  1  C8           	INY
001DD2  1  A9 7F        	LDA	#127
001DD4  1  C5 51        	CMP	PR		;SUBTRACT
001DD6  1  B1 42        	LDA	(SL),Y
001DD8  1  E5 4E        	SBC	PM+2
001DDA  1  D0 01        	BNE	CPMSGN
001DDC  1  60           	RTS
001DDD  1  A5 4F        CPMSGN	LDA	PS		;GET SIGN
001DDF  1  90 02        	BCC	*+4		;OK IF BORROW
001DE1  1  49 FF        	EOR	#$FF		;ELSE COMPLEMENT
001DE3  1  4C B9 1C     	JMP	ESPSRL		;NOW TEST
001DE6  1               ;ADD SINGLE BYTE IN A INTO PRIMARY ACCUMULATOR
001DE6  1  48           ADP	PHA			;SAVE DIGIT
001DE7  1  A9 DD        	LDA	#<T0
001DE9  1  A0 2F        	LDY	#>T0
001DEB  1  20 C1 1C     	JSR	STP		;T:=P
001DEE  1  68           	PLA			;GET DIGIT
001DEF  1  85 4C        	STA	PM
001DF1  1  49 FF        	EOR	#$FF
001DF3  1  2A           	ROL	A
001DF4  1  A2 88        	LDX	#8+128
001DF6  1  86 4B        	STX	PE		;EXP:=8
001DF8  1  A9 00        	LDA	#0
001DFA  1  85 4D        	STA	PM+1
001DFC  1  85 4E        	STA	PM+2
001DFE  1  85 51        	STA	PR
001E00  1  85 4F        	STA	PS
001E02  1  20 7C 1E     	JSR	CYENT		;NORMALIZE
001E05  1  A9 DD        	LDA	#<T0
001E07  1  A0 2F        	LDY	#>T0
001E09  1  4C 0C 1E     	JMP	APA		;P:=P+A
001E0C  1               ;ADD PRIMARY ACCUMULATOR TO MEMORY AT (AY)
001E0C  1               ;P:=(AY)+P
001E0C  1  20 04 1D     APA	JSR	LSA		;LOAD SECONDARY WITH MEMORY
001E0F  1               ;ADD PRIMARY ACCUMULATOR TO SECONDARY AND PUT RESULT IN PRIMARY
001E0F  1               ;P:=P+S
001E0F  1  A5 4B        APS	LDA	PE		;GET PRIM EXP
001E11  1  D0 03        	BNE	*+5		;USE IF P <> 0
001E13  1  4C 28 1D     	JMP	TSP		;ELSE JUST MOVE S TO P
001E16  1  A6 51        	LDX	PR		;GET ROUNDING
001E18  1  86 45        	STX	SAVPR		;SAVE IT
001E1A  1  A2 52        	LDX	#SE		;POINT TO SECONDARY
001E1C  1  A5 52        	LDA	SE		;GET SEC EXP
001E1E  1  A8           SPE	TAY
001E1F  1  D0 03        	BNE	E5S		;DONE IF ZERO
001E21  1  4C A3 1E     	JMP	E5
001E24  1               E5S:
001E24  1  38           	SEC
001E25  1  E5 4B        	SBC	PE		;A:=SE-PE
001E27  1  F0 2B        	BEQ	ENDALG		;BRANCH IF ALIGNED
001E29  1  90 13        	BCC	PEGTSE		;BRANCH IF PE>SE
001E2B  1  84 4B        	STY	PE		;MOVE SE TO PE
001E2D  1  A4 56        	LDY	SS		;GET SEC SIGN
001E2F  1  84 4F        	STY	PS		;MOVE TO PRIM SIGN
001E31  1  49 FF        	EOR	#$FF		;COMPLEMENT DIFFERENCE
001E33  1  69 00        	ADC	#0
001E35  1  A0 00        	LDY	#0		;CLEAR PRIM ROUNDING
001E37  1  84 45        	STY	SAVPR		;SAVE LOCATION
001E39  1  A2 4B        	LDX	#PE		;DO PRIMARY RATHER THAN SECONDARY
001E3B  1  4C 42 1E     	JMP	DOALGN		;GO ALIGN
001E3E  1  A0 00        PEGTSE	LDY	#0		;CLEAR REAL ROUNDING
001E40  1  84 51        	STY	PR
001E42  1  C9 F9        DOALGN	CMP	#$F9		;CHECK EXP DIFFERENCE
001E44  1  10 06        	BPL	ALGNP		;BRANCH IF LESS
001E46  1  20 83 1D     	JSR	SXRA		;ELSE SHIFT RIGHT
001E49  1  4C 54 1E     	JMP	ENDALG		;THEN GO AHEAD
001E4C  1  A8           ALGNP	TAY			;GET DIFFERENCE
001E4D  1  A5 51        	LDA	PR
001E4F  1  56 01        	LSR	1,X		;CLEAR MSB OF FIRST MANTISSA
001E51  1  20 6D 1D     	JSR	SXRYAL		;GO SHIFT
001E54  1  24 5B        ENDALG	BIT	SGNCMP		;TEST SIGN COMPARE
001E56  1  10 4C        	BPL	DOADD		;GO DO IF SIGNS SAME
001E58  1               ;SUBTRACT TWO VALUES
001E58  1  A0 4B        	LDY	#PE
001E5A  1  E0 52        	CPX	#SE
001E5C  1  F0 02        	BEQ	*+4		;JUMP IF SAME
001E5E  1  A0 52        	LDY	#SE		;ELSE POINT TO SE
001E60  1  38           	SEC
001E61  1  49 FF        	EOR	#$FF
001E63  1  65 45        	ADC	SAVPR
001E65  1  85 51        	STA	PR
001E67  1  B9 03 00     	LDA	3,Y		;START SUBTRACTION
001E6A  1  F5 03        	SBC	3,X
001E6C  1  85 4E        	STA	PM+2
001E6E  1  B9 02 00     	LDA	2,Y
001E71  1  F5 02        	SBC	2,X
001E73  1  85 4D        	STA	PM+1
001E75  1  B9 01 00     	LDA	1,Y
001E78  1  F5 01        	SBC	1,X
001E7A  1  85 4C        	STA	PM
001E7C  1  B0 03        CYENT	BCS	NORMLZ		;IF NO BORROW OK
001E7E  1  20 86 1C     	JSR	TCP		;ELSE COMPLEMENT
001E81  1  A0 00        NORMLZ	LDY	#0		;CLEAR A Y AND CY
001E83  1  98           	TYA
001E84  1  18           	CLC
001E85  1  A6 4C        SPLL	LDX	PM		;GET FIRST PART OF MANTISSA
001E87  1  D0 3E        	BNE	SHFBTL		;GO SHIFT BITS IF NOT ZERO
001E89  1  A6 4D        	LDX	PM+1		;ELSE SHIFT WHOLE BYTES
001E8B  1  86 4C        	STX	PM
001E8D  1  A6 4E        	LDX	PM+2
001E8F  1  86 4D        	STX	PM+1
001E91  1  A6 51        	LDX	PR
001E93  1  86 4E        	STX	PM+2
001E95  1  84 51        	STY	PR		;CLEAR ROUNDING
001E97  1  69 08        	ADC	#8		;BUMP EXPONENT
001E99  1  C9 20        	CMP	#32		;SEE IF TOO SMALL
001E9B  1  D0 E8        	BNE	SPLL		;BRANCH IF MORE
001E9D  1  A9 00        ZRORSL	LDA	#0		;UNDERFLOW THEREFORE = 0
001E9F  1  85 4B        	STA	PE
001EA1  1  85 4F        	STA	PS
001EA3  1  60           E5	RTS
001EA4  1               ;ADD TWO VALUES
001EA4  1  65 45        DOADD	ADC	SAVPR
001EA6  1  85 51        	STA	PR
001EA8  1  A5 4E        	LDA	PM+2
001EAA  1  65 55        	ADC	SM+2
001EAC  1  85 4E        	STA	PM+2
001EAE  1  A5 4D        	LDA	PM+1
001EB0  1  65 54        	ADC	SM+1
001EB2  1  85 4D        	STA	PM+1
001EB4  1  A5 4C        	LDA	PM
001EB6  1  65 53        	ADC	SM
001EB8  1  85 4C        	STA	PM
001EBA  1  4C D4 1E     	JMP	CHKCRY		;GO SEE IF CARRY AND THUS NORMALIZATION
001EBD  1  69 01        BITSL	ADC	#1		;BUMP EXPONENT
001EBF  1  06 51        	ASL	PR
001EC1  1  26 4E        	ROL	PM+2
001EC3  1  26 4D        	ROL	PM+1
001EC5  1  26 4C        	ROL	PM
001EC7  1  10 F4        SHFBTL	BPL	BITSL		;LOOP IF MSB NOT 1
001EC9  1  38           	SEC
001ECA  1  E5 4B        	SBC	PE
001ECC  1  B0 CF        	BCS	ZRORSL		;ZERO IF UNDERFLOW
001ECE  1  49 FF        	EOR	#$FF		;TWO'S COMPLEMENT
001ED0  1  69 01        	ADC	#1
001ED2  1  85 4B        	STA	PE
001ED4  1  90 0C        CHKCRY	BCC	E6		;DONE IF NO CARRY
001ED6  1  E6 4B        ADJPE	INC	PE		;BUMP EXPONENT
001ED8  1  F0 09        	BEQ	APSOVF		;OVERFLOW IF ZERO
001EDA  1  66 4C        	ROR	PM		;SHIFT ALL RIGHT
001EDC  1  66 4D        	ROR	PM+1
001EDE  1  66 4E        	ROR	PM+2
001EE0  1  66 51        	ROR	PR
001EE2  1  60           E6	RTS
001EE3  1               ;ADD OVERFLOW TRAP
001EE3  1  A9 FF        APSOVF	LDA	#TRUE
001EE5  1  85 3F        	STA	OVERFL		;OVERFLOW:=TRUE
001EE7  1  60           	RTS
001EE8  1               ;NEGATE PRIMARY ACCUMULATOR
001EE8  1  A5 4B        NEG	LDA	PE
001EEA  1  F0 06        	BEQ	E10		;DONE IF ZERO
001EEC  1  A5 4F        	LDA	PS
001EEE  1  49 FF        	EOR	#$FF
001EF0  1  85 4F        	STA	PS		;COMPLEMENT SIGN
001EF2  1  60           E10	RTS
001EF3  1               ;ROUND PRIMARY ACCUMULATOR
001EF3  1  A5 4B        RNP	LDA	PE		;GET EXP
001EF5  1  F0 0C        	BEQ	E3		;DONE IF ZERO
001EF7  1  06 51        	ASL	PR		;TEST MSB OF ROUNDING
001EF9  1  90 08        	BCC	E3		;DONE IF ZERO
001EFB  1  20 A8 1C     	JSR	INP		;ELSE BUMP PRIM
001EFE  1  D0 03        	BNE	E3		;DONE IF NOT ZERO
001F00  1  20 D6 1E     	JSR	ADJPE		;ADJUST EXPONENT
001F03  1  60           E3	RTS
001F04  1               ;SETUP MULTIPLICATION AND DIVISION
001F04  1  A5 52        SUPMD	LDA	SE		;IF S=0
001F06  1  F0 17        SUPMDX	BEQ	MDZRO		;THEN P:=0
001F08  1  18           	CLC
001F09  1  65 4B        	ADC	PE		;A:=PE+SE
001F0B  1  B0 04        	BCS	*+6		;BRANCH IF CARRY
001F0D  1  10 10        	BPL	MDZRO		;BRANCH IF 0 TO 7F
001F0F  1  30 02        	BMI	NZRO		;BRANCH IF 80 TO FF
001F11  1  30 0C        	BMI	MDZRO		;CARRY SET AND 80 TO FF
001F13  1               ;RESULT NOT NECESSARILY ZERO
001F13  1  18           NZRO	CLC
001F14  1  69 80        	ADC	#$80
001F16  1  85 4B        	STA	PE		;PE:=PE+SE+$80
001F18  1  F0 02        	BEQ	*+4
001F1A  1  A5 5B        	LDA	SGNCMP		;IF DIFFERENT SIGNS
001F1C  1  85 4F        	STA	PS		;THEN P < 0
001F1E  1  60           	RTS
001F1F  1               ;RESULT ZERO
001F1F  1  68           MDZRO	PLA
001F20  1  68           	PLA			;CLEAR STACK
001F21  1  A9 00        	LDA	#0
001F23  1  85 4B        	STA	PE		;PE:=0
001F25  1  85 4F        	STA	PS		;P POSITIVE
001F27  1  60           	RTS
001F28  1               ;MULTIPLY BY ONE BYTE
001F28  1  D0 03        MULNZB	BNE	*+5		;IF BYTE <> 0 THEN DO SLOW
001F2A  1  4C 71 1D     	JMP	SQR8		;ELSE JUST SHIFT WHOLE BYTES
001F2D  1  4A           MULBYT	LSR	A		;LSB TO CY
001F2E  1  09 80        	ORA	#%10000000	;SET MSB FOR COUNTER
001F30  1  A8           MULLPE	TAY			;SAVE COUNTER IN Y
001F31  1  90 13        	BCC	SHONLY		;SHIFT ONLY IF ZERO
001F33  1  18           	CLC			;ELSE Q:=Q+S
001F34  1  A5 5A        	LDA	QM+2
001F36  1  65 55        	ADC	SM+2
001F38  1  85 5A        	STA	QM+2
001F3A  1  A5 59        	LDA	QM+1
001F3C  1  65 54        	ADC	SM+1
001F3E  1  85 59        	STA	QM+1
001F40  1  A5 58        	LDA	QM
001F42  1  65 53        	ADC	SM
001F44  1  85 58        	STA	QM
001F46  1  66 58        SHONLY	ROR	QM		;SHIFT ALL RIGHT
001F48  1  66 59        	ROR	QM+1
001F4A  1  66 5A        	ROR	QM+2
001F4C  1  66 51        	ROR	PR
001F4E  1  98           	TYA			;GET COUNTER
001F4F  1  4A           	LSR	A		;SHIFT IT
001F50  1  D0 DE        	BNE	MULLPE		;LOOP IF MORE
001F52  1  60           	RTS
001F53  1               ;MULTIPLY PRIMARY ACCUMULATOR BY 10 BY SHIFTING (FOR NUMBER CONVERSION)
001F53  1  20 41 1D     MPT	JSR	TPS		;S:=P
001F56  1  A5 4B        	LDA	PE		;IF P=0
001F58  1  F0 10        	BEQ	E9		;THEN DONE
001F5A  1  18           	CLC
001F5B  1  69 02        	ADC	#2		;PE:=PE+2
001F5D  1  B0 0C        	BCS	MPTOVF		;ERROR
001F5F  1  A2 00        	LDX	#0
001F61  1  86 5B        	STX	SGNCMP		;CLEAR SIGN COMPARE
001F63  1  20 1E 1E     	JSR	SPE		;SHIFT PRIMARY
001F66  1  E6 4B        	INC	PE		;PE:=PE+1
001F68  1  F0 01        	BEQ	MPTOVF		;ERROR
001F6A  1  60           E9	RTS
001F6B  1  A9 FF        MPTOVF	LDA	#TRUE
001F6D  1  85 3F        	STA	OVERFL		;OVERFLOW:=TRUE
001F6F  1  60           	RTS
001F70  1               ;MULTIPLY PRIMARY ACCUMULATOR BY MEMORY AT (AY)
001F70  1               ;P:=P*(AY)
001F70  1  20 04 1D     MPA	JSR	LSA		;LOAD MEMORY INTO SECONDARY
001F73  1               ;MULTIPLY PRIMARY ACCUMULATOR BY SECONDARY
001F73  1               ;P:=P*S
001F73  1  A5 4B        MPS	LDA	PE		;TEST PRIMARY
001F75  1  F0 2E        	BEQ	E8		;DONE IF ZERO
001F77  1  20 04 1F     	JSR	SUPMD		;SET UP
001F7A  1  A9 00        	LDA	#0		;Q:=0
001F7C  1  85 58        	STA	QM
001F7E  1  85 59        	STA	QM+1
001F80  1  85 5A        	STA	QM+2
001F82  1  A5 51        	LDA	PR		;MULTIPLY BYTE AT A TIME
001F84  1  20 28 1F     	JSR	MULNZB
001F87  1  A5 4E        	LDA	PM+2
001F89  1  20 28 1F     	JSR	MULNZB
001F8C  1  A5 4D        	LDA	PM+1
001F8E  1  20 28 1F     	JSR	MULNZB
001F91  1  A5 4C        	LDA	PM
001F93  1  20 2D 1F     	JSR	MULBYT
001F96  1               ;TRANSFER QUOTIENT TO PRIMARY ACCUM AND NORMALIZE
001F96  1  A5 58        TQP	LDA	QM		;P:=Q
001F98  1  85 4C        	STA	PM
001F9A  1  A5 59        	LDA	QM+1
001F9C  1  85 4D        	STA	PM+1
001F9E  1  A5 5A        	LDA	QM+2
001FA0  1  85 4E        	STA	PM+2
001FA2  1  4C 81 1E     	JMP	NORMLZ		;GO NORMALIZE
001FA5  1  60           E8	RTS
001FA6  1               ;DIVIDE PRIMARY ACCUMULATOR BY 10
001FA6  1  20 41 1D     DPT	JSR	TPS		;S:=P
001FA9  1  A9 00        	LDA	#0
001FAB  1  85 5B        	STA	SGNCMP		;CLEAR SIGN COMPARISON
001FAD  1  A9 BE        	LDA	#<TEN
001FAF  1  A0 1B        	LDY	#>TEN
001FB1  1  20 E4 1C     	JSR	LPA		;P:=10
001FB4  1  4C BA 1F     	JMP	DSP		;P:=P/10
001FB7  1               ;DIVIDE MEMORY AT (AY) BY PRIMRY ACCUMULATOR
001FB7  1               ;P:=(AY)/P
001FB7  1  20 04 1D     DAP	JSR	LSA		;S:=(AY)
001FBA  1               ;DIVIDE SECONDARY ACCUMULATOR BY PRIMARY
001FBA  1  A5 4B        DSP	LDA	PE		;IF P=0
001FBC  1  F0 6E        	BEQ	DIVZRO		;THEN ERROR
001FBE  1  A9 00        	LDA	#0
001FC0  1  38           	SEC
001FC1  1  E5 4B        	SBC	PE
001FC3  1  85 4B        	STA	PE		;PE:=-PE
001FC5  1  20 04 1F     	JSR	SUPMD		;SETUP EVERYTHING
001FC8  1  E6 4B        	INC	PE
001FCA  1  F0 5B        	BEQ	DIVOVF		;OVERFLOW ERROR
001FCC  1  A2 FD        	LDX	#$FD		;X:=-3
001FCE  1  A9 01        	LDA	#1		;SET BIT COUNTER TO 1
001FD0  1  A4 53        CMPSP	LDY	SM		;IF S<>P
001FD2  1  C4 4C        	CPY	PM
001FD4  1  D0 0A        	BNE	SNEP		;THEN
001FD6  1  A4 54        	LDY	SM+1
001FD8  1  C4 4D        	CPY	PM+1
001FDA  1  D0 04        	BNE	SNEP
001FDC  1  A4 55        	LDY	SM+2
001FDE  1  C4 4E        	CPY	PM+2
001FE0  1  08           SNEP	PHP			;SAVE CARRY
001FE1  1  2A           	ROL	A		;BUMP COUNTER
001FE2  1  90 0D        	BCC	MORE		;BRANCH IF MORE
001FE4  1  E8           	INX			;ELSE BUMP INDEX
001FE5  1  95 5A        	STA	QM+2,X		;SET NEXT BYTE
001FE7  1  D0 04        	BNE	*+6		;BRANCH IF X<>0
001FE9  1  A9 40        	LDA	#64		;DO LAST BYTE
001FEB  1  D0 04        	BNE	MORE
001FED  1  10 2C        	BPL	DDONE		;EXIT IF LAST
001FEF  1  A9 01        	LDA	#1		;ELSE RESET BIT COUNTER
001FF1  1  28           MORE	PLP			;GET CARRY
001FF2  1  B0 0C        	BCS	NOBRW		;BRANCH IF NO BORROW
001FF4  1  06 55        SHFS	ASL	SM+2
001FF6  1  26 54        	ROL	SM+1
001FF8  1  26 53        	ROL	SM
001FFA  1  B0 E4        	BCS	SNEP
001FFC  1  30 D2        	BMI	CMPSP
001FFE  1  10 E0        	BPL	SNEP
002000  1  A8           NOBRW	TAY			;SAVE COUNTER IN Y
002001  1  A9 00        	LDA	#0
002003  1  E5 51        	SBC	PR		;S:=S-P
002005  1  A5 55        	LDA	SM+2
002007  1  E5 4E        	SBC	PM+2
002009  1  85 55        	STA	SM+2
00200B  1  A5 54        	LDA	SM+1
00200D  1  E5 4D        	SBC	PM+1
00200F  1  85 54        	STA	SM+1
002011  1  A5 53        	LDA	SM
002013  1  E5 4C        	SBC	PM
002015  1  85 53        	STA	SM
002017  1  98           	TYA			;GET COUNT
002018  1  4C F4 1F     	JMP	SHFS		;AND LOOP
00201B  1               ;EXIT FROM DIVISION
00201B  1  0A           DDONE	ASL	A
00201C  1  0A           	ASL	A
00201D  1  0A           	ASL	A
00201E  1  0A           	ASL	A
00201F  1  0A           	ASL	A
002020  1  0A           	ASL	A
002021  1  85 51        	STA	PR
002023  1  28           	PLP
002024  1               ;NOW DO P:=Q AND NORMALIZE
002024  1  4C 96 1F     	JMP	TQP
002027  1               ;DIVISION ERROR ROUTINES
002027  1  A9 FF        DIVOVF	LDA	#TRUE
002029  1  85 3F        	STA	OVERFL
00202B  1  60           	RTS
00202C  1  A9 FF        DIVZRO	LDA	#TRUE
00202E  1  85 3E        	STA	DVZERO
002030  1  60           	RTS
002031  1               ;CONVERT FLOATING TO FIXED UNSIGNED
002031  1  A5 4B        FXU	LDA	PE
002033  1  D0 08        	BNE	ISNTZ
002035  1  85 4C        	STA	PM		;IF P=0 CLEAR ALL
002037  1  85 4D        	STA	PM+1
002039  1  85 4E        	STA	PM+2
00203B  1  A8           	TAY			;AND Y
00203C  1  60           	RTS
00203D  1  38           ISNTZ	SEC
00203E  1  E9 98        	SBC	#24+128
002040  1  24 4F        	BIT	PS		;TEST SIGN
002042  1  10 09        	BPL	ISPOST		;IF POSITIVE
002044  1  AA           	TAX
002045  1  A9 FF        	LDA	#255
002047  1  85 50        	STA	PC		;SET CARRY
002049  1  20 8C 1C     	JSR	TCPNS		;COMPLEMENT
00204C  1  8A           	TXA
00204D  1  A2 4B        ISPOST	LDX	#PE		;POINT TO PRIM
00204F  1  C9 F9        	CMP	#$F9
002051  1  10 06        	BPL	NOSHFR
002053  1  20 83 1D     	JSR	SXRA		;SHIFT RIGHT
002056  1  84 50        	STY	PC		;CLEAR CARRY
002058  1  60           	RTS
002059  1  A8           NOSHFR	TAY			;SET COUNTER
00205A  1  A5 4F        	LDA	PS		;SET MSB OF PM TO PS
00205C  1  29 80        	AND	#$80
00205E  1  46 4C        	LSR	PM		;SET CARRY
002060  1  05 4C        	ORA	PM
002062  1  85 4C        	STA	PM
002064  1  20 6D 1D     	JSR	SXRYAL		;GO SHIFT
002067  1  84 50        	STY	PC		;CLEAR CARRY
002069  1  60           	RTS
00206A  1               ;CONVERT FLOATING TO SIGNED 24 BIT INTEGER
00206A  1  A5 4B        INT	LDA	PE
00206C  1  C9 98        	CMP	#24+128
00206E  1  B0 17        	BCS	E7		;DONE IF EXACT OR TOO BIG
002070  1  20 31 20     	JSR	FXU		;FIX IT
002073  1  84 51        	STY	PR		;CLEAR ROUNDING
002075  1  A5 4F        	LDA	PS		;GET SIGN
002077  1  84 4F        	STY	PS		;THEN CLEAR
002079  1  49 80        	EOR	#$80
00207B  1  2A           	ROL	A		;SET CARRY BY SIGN
00207C  1  A9 98        	LDA	#24+128		;SET EXPONENT
00207E  1  85 4B        	STA	PE
002080  1  A5 4E        	LDA	PM+2
002082  1  85 39        	STA	LSB		;SAVE LSB
002084  1  4C 7C 1E     	JMP	CYENT		;GO NORMALIZE
002087  1  60           E7	RTS
002088  1               ;SERIES EVALUATION FOR SQUARED ARGUMENTS WITH CHAIN AT (AY)
002088  1  85 3A        SRSAS	STA	SRPNT
00208A  1  84 3B        	STY	SRPNT+1
00208C  1               ;SERIES EVALUATION FOR SQUARED ARGUMENTS WITH CHAIN AT (SRPNT)
00208C  1  A9 DD        SRSS	LDA	#<T0
00208E  1  A0 2F        	LDY	#>T0
002090  1  20 C1 1C     	JSR	STP		;SAVE ACCUM IN TEMP 0
002093  1  A9 DD        	LDA	#<T0
002095  1  A0 2F        	LDY	#>T0
002097  1  20 70 1F     	JSR	MPA		;P:=X*X
00209A  1  20 A8 20     	JSR	SRS		;EVALUATE SERIES
00209D  1  A9 DD        	LDA	#<T0
00209F  1  A0 2F        	LDY	#>T0
0020A1  1  4C 70 1F     	JMP	MPA		;P:=P*X
0020A4  1               ;SERIES EVAUATION FOR ARGUMENTS WITH CHAIN AT (AY)
0020A4  1  85 3A        SRSA	STA	SRPNT
0020A6  1  84 3B        	STY	SRPNT+1
0020A8  1               ;SERIES EVAUATION FOR ARGUMENTS WITH CHAIN AT (SRPNT)
0020A8  1  A9 E1        SRS	LDA	#<T1
0020AA  1  A0 2F        	LDY	#>T1
0020AC  1  20 C1 1C     	JSR	STP		;T1:=X
0020AF  1  A0 00        	LDY	#0
0020B1  1  B1 3A        	LDA	(SRPNT),Y	;GET COUNT
0020B3  1  85 3C        	STA	SRCNT		;AND SAVE
0020B5  1  E6 3A        	INC	SRPNT
0020B7  1  D0 02        	BNE	*+4
0020B9  1  E6 3B        	INC	SRPNT+1		;SRPNT:=SRPNT+1
0020BB  1  A5 3A        	LDA	SRPNT
0020BD  1  A4 3B        	LDY	SRPNT+1		;GET DESTINATION
0020BF  1  20 70 1F     SRSLPE	JSR	MPA		;P:=P*(SRPNT)
0020C2  1  18           	CLC
0020C3  1  A5 3A        	LDA	SRPNT
0020C5  1  69 04        	ADC	#4
0020C7  1  85 3A        	STA	SRPNT
0020C9  1  90 02        	BCC	*+4
0020CB  1  E6 3A        	INC	SRPNT		;SRPNT:=SRPNT+4
0020CD  1  A4 3B        	LDY	SRPNT+1
0020CF  1  20 0C 1E     	JSR	APA		;P:=P+(SRPNT)
0020D2  1  A9 E1        	LDA	#<T1
0020D4  1  A0 2F        	LDY	#>T1
0020D6  1  C6 3C        	DEC	SRCNT
0020D8  1  D0 E5        	BNE	SRSLPE		;LOOP IF MORE
0020DA  1  60           	RTS
0020DB  1               ;GET NEXT CHAR FROM ACCUM, BUMP INDEX FOR NEXT ACCESS, AND TEST FOR NUMBER
0020DB  1  E6 44        GETTST	INC	CNVIND		;BUMP INDEX
0020DD  1  A6 44        	LDX	CNVIND		;GET INDEX
0020DF  1  BD 5C 2F     	LDA	ACCUM,X		;GET CHAR
0020E2  1               ;TEST FOR A NUMBER
0020E2  1               ;IF A NUMBER THEN C=0 ELSE C=1
0020E2  1  C9 3A        TSTNUM	CMP	#'9'+1		;IF <= '9'
0020E4  1  90 01        	BCC	*+3		;MAY BE A NUMBER
0020E6  1  60           	RTS			;ELSE ISN'T
0020E7  1  C9 30        	CMP	#'0'		;IF <0
0020E9  1  90 02        	BCC	*+4		;ISN'T
0020EB  1  18           	CLC
0020EC  1  60           	RTS			;ELSE IS
0020ED  1  38           	SEC
0020EE  1  60           	RTS
0020EF  1               ;ADD CHAR AT ACCUM(CNVIND) TO INPUT CONVERSION EXPONENT
0020EF  1  A5 46        ACE	LDA	NE
0020F1  1  0A           	ASL	A
0020F2  1  0A           	ASL	A		;A:=4*EXP
0020F3  1  18           	CLC
0020F4  1  65 46        	ADC	NE		;A:=5*EXP
0020F6  1  0A           	ASL	A		;A:=10*EXP
0020F7  1  18           	CLC
0020F8  1  A4 44        	LDY	CNVIND
0020FA  1  79 5C 2F     	ADC	ACCUM,Y		;A:=ACCUM(CNVIND)
0020FD  1  38           	SEC
0020FE  1  E9 30        	SBC	#'0'
002100  1  85 46        	STA	NE		;NE:=10*NE+ACCUM(CNVIND)
002102  1  60           	RTS
002103  1               ;MOVE ASCII STRING AT (AY) TO ACCUM AND CONVERT X CHARACTERS TO FLOATING
002103  1  8D 13 21     FLTINP	STA	GFLTIC+1
002106  1  8C 14 21     	STY	GFLTIC+2	;SET ADDRESS
002109  1  E0 00        	CPX	#0		;IF 1 OR MORE
00210B  1  D0 03        	BNE	*+5		;GO DO
00210D  1  4C 9D 1E     	JMP	ZRORSL		;ELSE JUST CLEAR ACCUM
002110  1  A0 00        	LDY	#0		;CLEAR INDEX
002112  1  B9 FF FF     GFLTIC	LDA	$FFFF,Y		;GET CHAR
002115  1  99 5C 2F     	STA	ACCUM,Y		;PUT IN ACCUM
002118  1  C8           	INY
002119  1  CA           	DEX
00211A  1  D0 F6        	BNE	GFLTIC		;LOOP IF MORE
00211C  1  8A           	TXA
00211D  1  99 5C 2F     	STA	ACCUM,Y		;INSERT TERMINAL CHAR
002120  1  A2 09        	LDX	#9
002122  1  95 46        CLRN	STA	NE,X
002124  1  CA           	DEX
002125  1  10 FB        	BPL	CLRN		;LOOP FOR MORE
002127  1  86 44        	STX	CNVIND		;SET INDEX TO -1
002129  1  20 DB 20     	JSR	GETTST		;GET AND TEST
00212C  1  90 11        	BCC	NOSIGN		;BRANCH IF IS
00212E  1  C9 2B        	CMP	#'+'		;IF A +
002130  1  F0 08        	BEQ	GNNC		;GET NEXT CHAR
002132  1  C9 2D        	CMP	#'-'		;IF NOT A -
002134  1  D0 1C        	BNE	NOTDIG		;TRY E AND .
002136  1  A2 FF        	LDX	#$FF
002138  1  86 4A        	STX	NS		;SET SIGN TO NEG
00213A  1  20 DB 20     GNNC	JSR	GETTST		;GET AND TEST
00213D  1  B0 13        	BCS	NOTDIG		;BRANCH IF NOT NUMBER
00213F  1  48           NOSIGN	PHA			;SAVE CHAR
002140  1  24 47        	BIT	DPFLG		;TEST FOR PRIOR DEC POINT
002142  1  10 02        	BPL	*+4		;BRANCH IF NONE
002144  1  E6 48        	INC	DPOFF		;BUMP OFFSET
002146  1  20 53 1F     	JSR	MPT		;P:=P*10
002149  1  68           	PLA
00214A  1  29 0F        	AND	#$0F
00214C  1  20 E6 1D     	JSR	ADP		;P:=P+NUM
00214F  1  4C 3A 21     	JMP	GNNC		;LOOP FOR MORE
002152  1  C9 2E        NOTDIG	CMP	#'.'		;IF A .
002154  1  F0 2C        	BEQ	DPHNDL		;GO HANDLE IT
002156  1  C9 45        	CMP	#'E'		;IF NOT E
002158  1  D0 2E        	BNE	NESSET		;GO AHEAD
00215A  1  20 DB 20     	JSR	GETTST		;GET NEXT CHAR
00215D  1  90 11        	BCC	DOEN		;NUMBER SO IS EXPONENT
00215F  1  C9 2D        	CMP	#'-'		;IF -
002161  1  F0 06        	BEQ	EXPMIN		;EXP IS MINUS
002163  1  C9 2B        	CMP	#'+'
002165  1  F0 04        	BEQ	GNEC		;IF PLUS GET EXP
002167  1  D0 0D        	BNE	ENDEXP		;ELSE END
002169  1  66 49        EXPMIN	ROR	NESFLG		;SHIFT CY INTO FLAG
00216B  1  20 DB 20     GNEC	JSR	GETTST		;GET AND TEST
00216E  1  B0 06        	BCS	ENDEXP		;DONE IF NOT NUMBER
002170  1  20 EF 20     DOEN	JSR	ACE		;ADD TO EXPONENT
002173  1  4C 6B 21     	JMP	GNEC		;AND LOOP
002176  1  24 49        ENDEXP	BIT	NESFLG		;TEST NEG EXP FLAG
002178  1  10 0E        	BPL	NESSET		;BRANCH IF POS
00217A  1  A9 00        	LDA	#0
00217C  1  38           	SEC
00217D  1  E5 46        	SBC	NE		;-NE
00217F  1  4C 8A 21     	JMP	NESSUB
002182  1  66 47        DPHNDL	ROR	DPFLG		;SET DEC PT FLAG
002184  1  24 47        	BIT	DPFLG		;TEST FOR TWO
002186  1  50 B2        	BVC	GNNC		;BRANCH IF NONE
002188  1  A5 46        NESSET	LDA	NE
00218A  1  38           NESSUB	SEC
00218B  1  E5 48        	SBC	DPOFF		;NE-DPOFFSET
00218D  1  85 46        	STA	NE
00218F  1  F0 13        	BEQ	SETSGN		;DONE IF ZERO
002191  1  10 0A        	BPL	MUL10		;MUKLT IF +
002193  1  20 A6 1F     DIV10	JSR	DPT		;ELSE DIVIDE BY TEN
002196  1  E6 46        	INC	NE
002198  1  D0 F9        	BNE	DIV10		;UNTIL DONE
00219A  1  4C A4 21     	JMP	SETSGN
00219D  1  20 53 1F     MUL10	JSR	MPT		;MULT BY 10
0021A0  1  C6 46        	DEC	NE
0021A2  1  D0 F9        	BNE	MUL10
0021A4  1  A5 4A        SETSGN	LDA	NS		;GET SIGN
0021A6  1  10 0A        	BPL	E11		;DONE IF POS
0021A8  1  A5 4B        	LDA	PE
0021AA  1  F0 06        	BEQ	E11		;OR IF P=0
0021AC  1  A5 4F        	LDA	PS
0021AE  1  49 FF        	EOR	#$FF
0021B0  1  85 4F        	STA	PS		;ELSE COMPLEMENT SIGN
0021B2  1  60           E11	RTS
0021B3  1               ;CONVERT CONTENTS OF PRIMARY ACCUMULATOR TO 12 DIGIT NUMBER AT PRINTWORKAREA
0021B3  1               ;CAUTION: PRIMARY ACCUMULATOR CONTENTS DESTROYED
0021B3  1  A0 01        FLTOUT	LDY	#1
0021B5  1  A9 20        	LDA	#' '		;PRESET FOR POSITIVE
0021B7  1  24 4F        	BIT	PS		;TEST SIGN
0021B9  1  10 02        	BPL	*+4		;BRANCH IF POS
0021BB  1  A9 2D        	LDA	#'-'		;ELSE GET -
0021BD  1  99 CE 2F     	STA	PRNWRK-1,Y	;PUT IN BUFFER
0021C0  1  85 4F        	STA	PS		;MAKE SIGN POSITIVE
0021C2  1  84 44        	STY	CNVIND		;SAVE INDEX
0021C4  1  C8           	INY
0021C5  1  A9 30        	LDA	#'0'
0021C7  1  A6 4B        	LDX	PE		;GET EXPONENT
0021C9  1  D0 03        	BNE	*+5		;OK IF NOT ZERO
0021CB  1  4C D1 22     	JMP	ONEZRO		;ELSE IS ZERO
0021CE  1  A9 00        	LDA	#0
0021D0  1  E0 80        	CPX	#128		;SEE IF >= 0
0021D2  1  F0 02        	BEQ	*+4		;BRANCH IF =
0021D4  1  B0 09        	BCS	SVEDOF		;BRANCH IF > 0
0021D6  1  A9 BA        	LDA	#<MILLON	;MULT BY MILLION
0021D8  1  A0 1B        	LDY	#>MILLON
0021DA  1  20 70 1F     	JSR	MPA
0021DD  1  A9 FA        	LDA	#$FA		;OFFSET = -6
0021DF  1  85 48        SVEDOF	STA	DPOFF		;SAVE OFFSET
0021E1  1  A9 B6        TRY69S	LDA	#<SIX9S		;POINT TO 999999.4375
0021E3  1  A0 1B        	LDY	#>SIX9S
0021E5  1  20 A6 1D     	JSR	CPA		;AND COMPARE
0021E8  1  F0 02        	BEQ	TRY59S		;BRANCH
0021EA  1  10 12        	BPL	MUSTDV		;MUST DIVIDE
0021EC  1  A9 B2        TRY59S	LDA	#<FIVE9S	;POINT TO 99999.9375
0021EE  1  A0 1B        	LDY	#>FIVE9S
0021F0  1  20 A6 1D     	JSR	CPA		;AND COMPARE
0021F3  1  F0 02        	BEQ	*+4		;MULT IF =
0021F5  1  10 0E        	BPL	EXTMDP		;EXIT
0021F7  1  20 53 1F     	JSR	MPT		;MULTIPLY BY 10
0021FA  1  C6 48        	DEC	DPOFF		;DROP OFFSET
0021FC  1  D0 EE        	BNE	TRY59S		;LOOP IF MORE
0021FE  1  20 A6 1F     MUSTDV	JSR	DPT		;DIVIDE PRI BY 10
002201  1  E6 48        	INC	DPOFF		;BUMP OFFSET
002203  1  D0 DC        	BNE	TRY69S		;LOOP IF MORE
002205  1  A9 AE        EXTMDP	LDA	#<HALF		;ROUND
002207  1  A0 1B        	LDY	#>HALF
002209  1  20 0C 1E     	JSR	APA
00220C  1  20 31 20     	JSR	FXU		;AND MAKE INTEGER
00220F  1  A2 01        	LDX	#1
002211  1  A5 48        	LDA	DPOFF		;GET OFFSET
002213  1  18           	CLC
002214  1  69 07        	ADC	#7		;ADD SEVEN
002216  1  30 09        	BMI	JUSTS		;SUBTRACT IF MINUS
002218  1  C9 08        	CMP	#8
00221A  1  B0 05        	BCS	JUSTS		;OR IF >= 8
00221C  1  69 FF        	ADC	#255		;ELSE ADD -1
00221E  1  AA           	TAX			;SAVE
00221F  1  A9 02        	LDA	#2		;A:=2
002221  1  38           JUSTS	SEC
002222  1  E9 02        	SBC	#2
002224  1  85 46        	STA	NE		;SAVE EXPONENT
002226  1  86 48        	STX	DPOFF		;SAVE OFFSET
002228  1  8A           	TXA
002229  1  F0 02        	BEQ	*+4
00222B  1  10 13        	BPL	NODP		;BRANCH IF NO DP
00222D  1  A4 44        	LDY	CNVIND		;GET INDEX
00222F  1  A9 2E        	LDA	#'.'		;GET PERIOD
002231  1  C8           	INY
002232  1  99 CE 2F     	STA	PRNWRK-1,Y	;PUT IN
002235  1  8A           	TXA
002236  1  F0 06        	BEQ	NZYET
002238  1  A9 30        	LDA	#'0'		;PUT IN A ZERO
00223A  1  C8           	INY
00223B  1  99 CE 2F     	STA	PRNWRK-1,Y
00223E  1  84 44        NZYET	STY	CNVIND		;SAVE INDEX
002240  1  A0 00        NODP	LDY	#0		;CLEAR ADD/SUB INDEX
002242  1  A2 80        	LDX	#128
002244  1  18           PRIOLP	CLC
002245  1  A5 4E        	LDA	PM+2
002247  1  79 F8 1B     	ADC	CNVTBL+2,Y
00224A  1  85 4E        	STA	PM+2
00224C  1  A5 4D        	LDA	PM+1
00224E  1  79 F7 1B     	ADC	CNVTBL+1,Y
002251  1  85 4D        	STA	PM+1
002253  1  A5 4C        	LDA	PM
002255  1  79 F6 1B     	ADC	CNVTBL,Y
002258  1  85 4C        	STA	PM
00225A  1  E8           	INX
00225B  1  B0 04        	BCS	*+6
00225D  1  10 E5        	BPL	PRIOLP		;LOOP IF NO OVERFLOW
00225F  1  30 02        	BMI	*+4		;ELSE GOT DIGIT
002261  1  30 E1        	BMI	PRIOLP		;ALSO LOOP
002263  1  8A           	TXA			;MOVE COUNT TO A
002264  1  90 04        	BCC	*+6
002266  1  49 FF        	EOR	#$FF
002268  1  69 0A        	ADC	#10
00226A  1  69 2F        	ADC	#'0'-1		;MAKE ASCII
00226C  1  C8           	INY
00226D  1  C8           	INY
00226E  1  C8           	INY			;ADJUST INDEX
00226F  1  84 3D        	STY	TY		;SAVE IT
002271  1  A4 44        	LDY	CNVIND		;GET INDEX
002273  1  C8           	INY			;BUMP
002274  1  AA           	TAX
002275  1  29 7F        	AND	#$7F		;CLEAR MSB
002277  1  99 CE 2F     	STA	PRNWRK-1,Y	;INSERT CHAR
00227A  1  C6 48        	DEC	DPOFF		;DROP OFFSET-
00227C  1  D0 06        	BNE	STLNDP		;BRANCH IF STILL NO DP
00227E  1  A9 2E        	LDA	#'.'
002280  1  C8           	INY
002281  1  99 CE 2F     	STA	PRNWRK-1,Y	;INSERT .
002284  1  84 44        STLNDP	STY	CNVIND		;SAVE INDEX
002286  1  A4 3D        	LDY	TY		;GET Y BACK
002288  1  8A           	TXA
002289  1  49 FF        	EOR	#$FF
00228B  1  29 80        	AND	#$80
00228D  1  AA           	TAX
00228E  1  C0 12        	CPY	#18		;SEE IF Y AT MAX
002290  1  D0 B2        	BNE	PRIOLP		;LOOP IF NOT
002292  1  A4 44        	LDY	CNVIND
002294  1  B9 CE 2F     SKPZRO	LDA	PRNWRK-1,Y	;GET CHAR
002297  1  88           	DEY			;AND BACKUP PAST LEADING ZEROS
002298  1  C9 30        	CMP	#'0'
00229A  1  F0 F8        	BEQ	SKPZRO
00229C  1  C9 2E        	CMP	#'.'		;IF DP
00229E  1  F0 01        	BEQ	*+3		;OK
0022A0  1  C8           	INY			;ELSE FORWARD
0022A1  1  A9 2B        	LDA	#'+'		;PRESET FOR EXP SIGN
0022A3  1  A6 46        	LDX	NE		;GET EXPONENT
0022A5  1  F0 2D        	BEQ	PUTSTP		;DONE IF NONE
0022A7  1  10 08        	BPL	EXPPOS		;IF POS GO
0022A9  1  38           	SEC
0022AA  1  A9 00        	LDA	#0
0022AC  1  E5 46        	SBC	NE
0022AE  1  AA           	TAX			;ADJUST EXPONENT
0022AF  1  A9 2D        	LDA	#'-'
0022B1  1  99 D0 2F     EXPPOS	STA	PRNWRK+1,Y	;PUT IN SIGN
0022B4  1  A9 45        	LDA	#'E'		;THEN E
0022B6  1  99 CF 2F     	STA	PRNWRK,Y
0022B9  1  8A           	TXA
0022BA  1  A2 2F        	LDX	#'0'-1		;PRESET 10S
0022BC  1  38           	SEC
0022BD  1  E8           CLC10S	INX
0022BE  1  E9 0A        	SBC	#10
0022C0  1  B0 FB        	BCS	CLC10S
0022C2  1  69 3A        	ADC	#'0'+10		;CALC ONES
0022C4  1  99 D2 2F     	STA	PRNWRK+3,Y	;INSERT IT
0022C7  1  8A           	TXA
0022C8  1  99 D1 2F     	STA	PRNWRK+2,Y	;THEN 10S
0022CB  1  A9 00        	LDA	#0
0022CD  1  99 D3 2F     	STA	PRNWRK+4,Y	;INSERT STOPPER
0022D0  1  60           	RTS
0022D1  1  99 CE 2F     ONEZRO	STA	PRNWRK-1,Y	;INSERT CHAR
0022D4  1  A9 00        PUTSTP	LDA	#0
0022D6  1  99 CF 2F     	STA	PRNWRK,Y
0022D9  1  60           	RTS
0022DA  1               ;TRANSCENDENTAL ROUTINES
0022DA  1               ;GENERATE RANDOM NUMBER AND LEAVE IN PRIM ACCUMULATOR
0022DA  1  A9 EA        RND	LDA	#<RNDWRK
0022DC  1  A0 1B        	LDY	#>RNDWRK
0022DE  1  20 E4 1C     	JSR	LPA		;MOVE OLD TO ACCUM
0022E1  1  A9 EE        	LDA	#<RNDMUL
0022E3  1  A0 1B        	LDY	#>RNDMUL
0022E5  1  20 70 1F     	JSR	MPA		;MULTIPLY MY SCALE
0022E8  1  A9 F2        	LDA	#<RNDADD
0022EA  1  A0 1B        	LDY	#>RNDADD
0022EC  1  20 0C 1E     	JSR	APA		;ADD OFFSET
0022EF  1  A6 4E        NEWRND	LDX	PM+2		;SHUFFLE THINGS AROUND
0022F1  1  A5 4C        	LDA	PM
0022F3  1  85 4E        	STA	PM+2
0022F5  1  86 4C        	STX	PM
0022F7  1  A9 00        	LDA	#0
0022F9  1  85 4F        	STA	PS		;MUST BE POSITIVE
0022FB  1  A5 4B        	LDA	PE
0022FD  1  85 51        	STA	PR
0022FF  1  A9 80        	LDA	#0+128
002301  1  85 4B        	STA	PE		;< 1
002303  1  20 81 1E     	JSR	NORMLZ		;NORMALIZE IT
002306  1  A9 EA        	LDA	#<RNDWRK
002308  1  A0 1B        	LDY	#>RNDWRK
00230A  1  4C C1 1C     	JMP	STP		;SAVE NEW RANDOM NUMBER
00230D  1               ;NATURAL LOG OF PRIMARY ACCUMULATOR
00230D  1  20 B3 1C     LOG	JSR	ESP		;TEST SIGN OF PRIMARY
002310  1  F0 55        	BEQ	LOGOVF		;ERROR IF ZERO
002312  1  30 53        	BMI	LOGOVF		;ERROR IF MINUS
002314  1  A5 51        	LDA	PR
002316  1  05 4E        	ORA	PM+2
002318  1  05 4D        	ORA	PM+1
00231A  1  D0 13        	BNE	DOLOG		;CAN'T BE 1.000000
00231C  1  A5 4C        	LDA	PM
00231E  1  29 7F        	AND	#$7F		;SEE IF ONLY 1
002320  1  D0 0D        	BNE	DOLOG		;ISN'T
002322  1  A5 4B        	LDA	PE
002324  1  C9 81        	CMP	#1+128		;MUST BE 1*2
002326  1  D0 07        	BNE	DOLOG		;ISN'T
002328  1  A9 00        	LDA	#0		;RESULT
00232A  1  85 4B        	STA	PE		;EXACTLY ZERO
00232C  1  85 4C        	STA	PM
00232E  1  60           	RTS
00232F  1  38           DOLOG	SEC
002330  1  A5 4B        	LDA	PE
002332  1  E9 80        	SBC	#128		;GET FOR EXP*LOG(2)
002334  1  48           	PHA			;SAVE FOR LATER
002335  1  A9 80        	LDA	#0+128		;SET TO <1
002337  1  85 4B        	STA	PE
002339  1  A9 DA        	LDA	#<SQR2D2
00233B  1  A0 1B        	LDY	#>SQR2D2
00233D  1  20 0C 1E     	JSR	APA		;ADD SQR(2)/2
002340  1  A9 CA        	LDA	#<SQR2
002342  1  A0 1B        	LDY	#>SQR2
002344  1  20 B7 1F     	JSR	DAP		;SQR(2)/P
002347  1  A9 C2        	LDA	#<ONE
002349  1  A0 1B        	LDY	#>ONE
00234B  1  20 5D 1D     	JSR	SPA		;1-P
00234E  1  A9 08        	LDA	#<LOGCHN
002350  1  A0 1C        	LDY	#>LOGCHN
002352  1  20 88 20     	JSR	SRSAS		;DO SERIES FOR X*X
002355  1  A9 CE        	LDA	#<MHALF
002357  1  A0 1B        	LDY	#>MHALF
002359  1  20 0C 1E     	JSR	APA		;-.5+P
00235C  1  68           	PLA			;GET EXP
00235D  1  20 E6 1D     	JSR	ADP		;ADD DIGIT
002360  1  A9 D2        	LDA	#<LN2
002362  1  A0 1B        	LDY	#>LN2
002364  1  4C 70 1F     	JMP	MPA		;MULTIPLY BY LN 2
002367  1               ;ILLEGAL LOG (I.E. NEG OR ZERO ARGUMENT)
002367  1  A9 FF        LOGOVF	LDA	#TRUE
002369  1  85 3F        	STA	OVERFL
00236B  1  60           	RTS
00236C  1               ;E TO THE PRIMARY ACCUMULATOR
00236C  1  A9 DD        EXP	LDA	#<T0
00236E  1  A0 2F        	LDY	#>T0
002370  1  20 C1 1C     	JSR	STP		;T0:=P
002373  1  A9 D6        	LDA	#<LN2INV
002375  1  A0 1B        	LDY	#>LN2INV
002377  1  20 70 1F     	JSR	MPA		;P:=P/(LN(2))
00237A  1  A5 4B        	LDA	PE
00237C  1  C9 88        	CMP	#8+128		;IF PE < 8
00237E  1  90 0B        	BCC	EXPOK		;THEN OK
002380  1  24 4F        	BIT	PS		;ELSE TEST SIGN
002382  1  10 3A        	BPL	EXPOVF		;OVERFLOW IF POSITIVE
002384  1  A9 00        	LDA	#0
002386  1  85 4B        	STA	PE
002388  1  85 4F        	STA	PS		;ELSE SET P TO 0
00238A  1  60           	RTS
00238B  1  20 6A 20     EXPOK	JSR	INT		;FIND INTEGER PART
00238E  1  18           	CLC
00238F  1  A5 39        	LDA	LSB
002391  1  69 81        	ADC	#1+128		;ADD TO CHECK FOR OVERFLOW
002393  1  F0 29        	BEQ	EXPOVF		;ERROR IF RESULT 127
002395  1  48           	PHA			;ELSE SAVE
002396  1  A9 C2        	LDA	#<ONE
002398  1  A0 1B        	LDY	#>ONE
00239A  1  20 0C 1E     	JSR	APA		;P:=P+1
00239D  1  A9 D2        	LDA	#<LN2
00239F  1  A0 1B        	LDY	#>LN2
0023A1  1  20 70 1F     	JSR	MPA		;P:=P*LN(2)
0023A4  1  A9 DD        	LDA	#<T0
0023A6  1  A0 2F        	LDY	#>T0
0023A8  1  20 5D 1D     	JSR	SPA		;P:=X-P
0023AB  1  20 E8 1E     	JSR	NEG		;P:=-P
0023AE  1  A9 15        	LDA	#<EXPCHN
0023B0  1  A0 1C        	LDY	#>EXPCHN
0023B2  1  20 A4 20     	JSR	SRSA		;DO SERIES
0023B5  1  A9 00        	LDA	#0
0023B7  1  85 5B        	STA	SGNCMP		;CLEAR COMPARISON
0023B9  1  68           	PLA			;GET INTEGER PART
0023BA  1  20 06 1F     	JSR	SUPMDX		;HANDLE IT
0023BD  1  60           	RTS
0023BE  1               ;ILLEGAL EXPONENT ARGUMENT
0023BE  1  A9 FF        EXPOVF	LDA	#TRUE
0023C0  1  85 3F        	STA	OVERFL		;SET OVERFLOW TO TRUE
0023C2  1  60           	RTS
0023C3  1               ;COS OF PRIMARY ACCUMULATOR
0023C3  1  A9 C6        COS	LDA	#<PI2
0023C5  1  A0 1B        	LDY	#>PI2
0023C7  1  20 0C 1E     	JSR	APA		;ADD PI/2
0023CA  1               ;SIN OF PRIMARY ACCUMULATOR
0023CA  1  20 41 1D     SIN	JSR	TPS		;MOVE TO SECONDARY
0023CD  1  A5 56        	LDA	SS
0023CF  1  85 5B        	STA	SGNCMP		;SET COMPARISON TO SECONDARY SIGN
0023D1  1  A9 DE        	LDA	#<TWOPI
0023D3  1  A0 1B        	LDY	#>TWOPI
0023D5  1  20 E4 1C     	JSR	LPA		;P:=2*PI
0023D8  1  20 BA 1F     	JSR	DSP		;DIVIDE TO GET REVOLUTIONS
0023DB  1  20 41 1D     	JSR	TPS		;S:=P
0023DE  1  20 6A 20     	JSR	INT		;GET WHOLE REVS
0023E1  1  A9 00        	LDA	#0
0023E3  1  85 5B        	STA	SGNCMP		;CLEAR SIGN COMPARISON
0023E5  1  20 60 1D     	JSR	SPS		;P:=REV-INT(REV)
0023E8  1  A9 E2        	LDA	#<QUARTR
0023EA  1  A0 1B        	LDY	#>QUARTR
0023EC  1  20 5D 1D     	JSR	SPA		;P:=P-.25
0023EF  1  A5 4F        	LDA	PS
0023F1  1  48           	PHA			;SAVE PS
0023F2  1  10 11        	BPL	SINPPS		;BRANCH IF POSITIVE
0023F4  1  A9 AE        	LDA	#<HALF
0023F6  1  A0 1B        	LDY	#>HALF
0023F8  1  20 0C 1E     	JSR	APA		;P:=P+.5
0023FB  1  A5 4F        	LDA	PS
0023FD  1  30 09        	BMI	SINSSM		;BRANCH IF STILL NEG
0023FF  1  A5 38        	LDA	TRIGS
002401  1  49 FF        	EOR	#$FF
002403  1  85 38        	STA	TRIGS		;COMPLEMENT TRIG SIGN
002405  1  20 E8 1E     SINPPS	JSR	NEG		;P:=-P
002408  1  A9 E2        SINSSM	LDA	#<QUARTR
00240A  1  A0 1B        	LDY	#>QUARTR
00240C  1  20 0C 1E     	JSR	APA		;P:=P+.25
00240F  1  68           	PLA			;GET PS BACK
002410  1  10 03        	BPL	*+5		;SKIP IF POS
002412  1  20 E8 1E     	JSR	NEG		;ELSE NEGATE
002415  1  A9 36        	LDA	#<SINCHN
002417  1  A0 1C        	LDY	#>SINCHN
002419  1  4C 88 20     	JMP	SRSAS		;DO SQUARED SERIES
00241C  1               ;ARCTANGENT OF PRIMARY ACCUMULATOR
00241C  1  A5 4F        ATN	LDA	PS
00241E  1  48           	PHA			;SAVE PS
00241F  1  10 03        	BPL	*+5		;OK IF POS
002421  1  20 E8 1E     	JSR	NEG		;ELSE P:=-P
002424  1  A5 4B        	LDA	PE
002426  1  48           	PHA			;SAVE PE
002427  1  C9 81        	CMP	#1+128		;IF < 1
002429  1  90 07        	BCC	ATNEL1		;THEN SKIP AHEAD
00242B  1  A9 C2        	LDA	#<ONE
00242D  1  A0 1B        	LDY	#>ONE
00242F  1  20 B7 1F     	JSR	DAP		;P:=1/P
002432  1  A9 4B        ATNEL1	LDA	#<ATNCHN
002434  1  A0 1C        	LDY	#>ATNCHN
002436  1  20 88 20     	JSR	SRSAS		;DO SERIES
002439  1  68           	PLA			;GET EXP
00243A  1  C9 81        	CMP	#1+128		;IF LESS THAN 1
00243C  1  90 07        	BCC	NOMPI2		;SKIP AHEAD
00243E  1  A9 C6        	LDA	#<PI2
002440  1  A0 1B        	LDY	#>PI2
002442  1  20 5D 1D     	JSR	SPA		;ELSE P:=PI/2-P
002445  1  68           NOMPI2	PLA			;GET SIGN
002446  1  10 03        	BPL	*+5		;DONE IF POS
002448  1  4C E8 1E     	JMP	NEG		;ELSE P:=-P
00244B  1  60           	RTS
00244C  1               ;PSEUDO MACHINE OPCODE EXECUTION ROUTINE
00244C  1  A0 00        EXECUT	LDY	#0
00244E  1  B1 60        	LDA	(RC),Y
002450  1  10 23        	BPL	L060		;IF MSB=0 THEN NOT LIT OR LI-LOD
002452  1  20 82 19     	JSR	PSHSTK		;PUSH$STACK
002455  1  A0 01        	LDY	#1
002457  1  B1 60        	LDA	(RC),Y
002459  1  88           	DEY
00245A  1  91 5C        	STA	(RA),Y		;BRA(0):=CV(1)
00245C  1  B1 60        	LDA	(RC),Y
00245E  1  29 3F        	AND	#$3F
002460  1  C8           	INY
002461  1  91 5C        	STA	(RA),Y		;BRA(1):=C AND $3F
002463  1  88           	DEY
002464  1  B1 60        	LDA	(RC),Y
002466  1  0A           	ASL	A
002467  1  10 03        	BPL	*+5		;IF NOT ROL(C,2) THEN
002469  1  20 EA 19     	JSR	LOADRA		;LOAD$RA
00246C  1  20 7B 19     	JSR	STINCN		;STEP$INS$CNT
00246F  1  20 7B 19     	JSR	STINCN
002472  1  4C 4C 24     	JMP	EXECUT		;DO FOREVER
002475  1  0A           L060	ASL	A
002476  1  AA           	TAX			;MAKE AN INDEX
002477  1  BD 8F 24     	LDA	EXTBL,X
00247A  1  8D 8D 24     	STA	DOOP+1
00247D  1  BD 90 24     	LDA	EXTBL+1,X
002480  1  8D 8E 24     	STA	DOOP+2		;SET ADDRESS
002483  1  20 8C 24     	JSR	DOOP		;DO OP
002486  1  20 7B 19     	JSR	STINCN		;STEP$INS$CNT
002489  1  4C 4C 24     	JMP	EXECUT		;DO FOREVER
00248C  1  4C FF FF     DOOP	JMP	$FFFF		;DUMMY
00248F  1               ;EXECUTE VECTOR TABLE
00248F  1  52 25 65 25  EXTBL	.WORD	EX0,EX1,EX2,EX3,EX4,EX5,EX6,EX7
002493  1  78 25 8B 25  
002497  1  A8 25 E1 25  
00249F  1  04 26 0D 26  	.WORD	EX8,EX9,EX10,EX11,EX12,EX13,LOADRA,EX15
0024A3  1  16 26 1F 26  
0024A7  1  30 26 47 26  
0024AF  1  69 26 52 19  	.WORD	EX16,POPSTK,EX18,FLIP,EX20,EX21,EX22,EX23
0024B3  1  6C 26 42 19  
0024B7  1  72 26 7D 26  
0024BF  1  A0 26 A9 26  	.WORD	EX24,EX25,EX26,EX27,EX28,CONCAT,EX30,EX31
0024C3  1  B2 26 BB 26  
0024C7  1  C6 26 07 13  
0024CF  1  1C 11 0A 12  	.WORD	CLCROW,CLCSUB,EX34,EX35,EX36,EX37,EX38,EX39
0024D3  1  1D 27 28 27  
0024D7  1  31 27 3A 27  
0024DF  1  55 27 6B 27  	.WORD	EX40,EX41,EX42,EX43,EX44,DSKOPN,EX46,EX47
0024E3  1  73 27 7B 27  
0024E7  1  80 27 96 0D  
0024EF  1  B1 27 BD 27  	.WORD	EX48,EX49,EXNOP,EXNOP,DMPPBF,EX53,ABSBRA,EX55
0024F3  1  51 25 51 25  
0024F7  1  24 1A C8 27  
0024FF  1  AD 12 96 12  	.WORD	CNDBRA,UNCBRA,CNVBRA,EX59,EX60,EX61,EX62,EX63
002503  1  EE 1A FB 27  
002507  1  0D 28 15 28  
00250F  1  68 28 84 28  	.WORD	EX64,EX65,EX66,EX67,EX68,EX69,EX70,EX71
002513  1  8D 28 99 28  
002517  1  A2 28 B5 28  
00251F  1  D9 28 FB 28  	.WORD	EX72,EX73,EX74,EX75,EX76,EX77,EX78,EX79
002523  1  1A 29 66 29  
002527  1  72 29 7E 29  
00252F  1  A4 29 B8 29  	.WORD	EX80,EX81,EX82,EX83,EX84,EX85,EX86,EX87
002533  1  DC 29 03 2A  
002537  1  08 2A 18 2A  
00253F  1  51 2A 6A 2A  	.WORD	EX88,EX89,EX90,RNCBRA,EX92,EX93,EX94,EX95
002543  1  7C 2A C4 1A  
002547  1  BA 2A EC 2A  
00254F  1  25 2B        	.WORD	EX96
002551  1               ; OPCODE EXECUTION ROUTINES
002551  1               ;DO NOTHING
002551  1  60           EXNOP	RTS
002552  1               ;0	FAD:	RB:=RA+RB
002552  1  20 71 1B     EX0	JSR	FLODRA
002555  1  A5 5E        	LDA	RB
002557  1  A4 5F        	LDY	RB+1
002559  1  20 0C 1E     	JSR	APA
00255C  1  20 86 1B     	JSR	FSTRRB
00255F  1  20 52 19     	JSR	POPSTK
002562  1  4C 8D 1B     	JMP	CHKOVR
002565  1               ;1	FMI:	RB:=RB-RA
002565  1  20 71 1B     EX1	JSR	FLODRA
002568  1  A5 5E        	LDA	RB
00256A  1  A4 5F        	LDY	RB+1
00256C  1  20 5D 1D     	JSR	SPA
00256F  1  20 86 1B     	JSR	FSTRRB
002572  1  20 52 19     	JSR	POPSTK
002575  1  4C 8D 1B     	JMP	CHKOVR
002578  1               ;2	FMU:	RB:=RB*RA
002578  1  20 71 1B     EX2	JSR	FLODRA
00257B  1  A5 5E        	LDA	RB
00257D  1  A4 5F        	LDY	RB+1
00257F  1  20 70 1F     	JSR	MPA
002582  1  20 86 1B     	JSR	FSTRRB
002585  1  20 52 19     	JSR	POPSTK
002588  1  4C 8D 1B     	JMP	CHKOVR
00258B  1               ;3	FDI:	RB:=RB/RA
00258B  1  20 0C 19     EX3	JSR	RAZER		;IF NOT RA$ZERO
00258E  1  F0 05        	BEQ	*+7		;THEN
002590  1  A9 04        	LDA	#4		;ELSE DIV BY ZERO WARNING
002592  1  20 CA 18     	JSR	WARNNG
002595  1  20 71 1B     EX3A	JSR	FLODRA
002598  1  A5 5E        	LDA	RB
00259A  1  A4 5F        	LDY	RB+1
00259C  1  20 B7 1F     	JSR	DAP
00259F  1  20 86 1B     	JSR	FSTRRB
0025A2  1  20 52 19     	JSR	POPSTK
0025A5  1  4C 8D 1B     	JMP	CHKOVR
0025A8  1               ;4	EXP:	RB:=RB**RA
0025A8  1  20 18 19     EX4	JSR	RBZER		;IF NOT RB$ZERO THEN
0025AB  1  F0 11        	BEQ	EX4B
0025AD  1  20 0C 19     	JSR	RAZER		;IF NOT RA$ZERO THEN
0025B0  1  F0 29        	BEQ	EX4C
0025B2  1  A0 03        	LDY	#3
0025B4  1  B9 C2 1B     EX4A	LDA	ONE,Y
0025B7  1  91 5E        	STA	(RB),Y
0025B9  1  88           	DEY
0025BA  1  10 F8        	BPL	EX4A		;ELSE MOVE4(.PLUSONE,RB)
0025BC  1  30 1D        	BMI	EX4C		;DONE
0025BE  1  20 E5 18     EX4B	JSR	RBNEG		;IF NOT RB$NEGATIVE
0025C1  1  F0 05        	BEQ	*+7		;THEN OK
0025C3  1  A9 0C        	LDA	#12		;ELSE ATTEMPT TO RAISE NEG NUMBER TO POWER
0025C5  1  4C B8 18     	JMP	ERROR
0025C8  1  20 7F 1B     	JSR	FLODRB
0025CB  1  20 0D 23     	JSR	LOG
0025CE  1  A5 5C        	LDA	RA
0025D0  1  A4 5D        	LDY	RA+1
0025D2  1  20 70 1F     	JSR	MPA
0025D5  1  20 6C 23     	JSR	EXP
0025D8  1  20 86 1B     	JSR	FSTRRB
0025DB  1  20 52 19     EX4C	JSR	POPSTK
0025DE  1  4C 8D 1B     	JMP	CHKOVR
0025E1  1               ;5  LSS
0025E1  1  20 48 1B     EX5	JSR	COMPFP
0025E4  1  C9 01        	CMP	#1
0025E6  1  F0 05        	BEQ	EX5T
0025E8  1  A9 00        EX5F	LDA	#FALSE
0025EA  1  4C EC 12     	JMP	COMFIX
0025ED  1  A9 FF        EX5T	LDA	#TRUE
0025EF  1  4C EC 12     	JMP	COMFIX
0025F2  1               ;6  GTR
0025F2  1  20 48 1B     EX6	JSR	COMPFP
0025F5  1  C9 02        	CMP	#2
0025F7  1  F0 F4        	BEQ	EX5T
0025F9  1  D0 ED        	BNE	EX5F
0025FB  1               ;7  EQU
0025FB  1  20 48 1B     EX7	JSR	COMPFP
0025FE  1  C9 03        	CMP	#3
002600  1  F0 EB        	BEQ	EX5T
002602  1  D0 E4        	BNE	EX5F
002604  1               ;8  NEQ
002604  1  20 48 1B     EX8	JSR	COMPFP
002607  1  C9 03        	CMP	#3
002609  1  D0 E2        	BNE	EX5T
00260B  1  F0 DB        	BEQ	EX5F
00260D  1               ;9  GEQ
00260D  1  20 48 1B     EX9	JSR	COMPFP
002610  1  C9 01        	CMP	#1
002612  1  D0 D9        	BNE	EX5T
002614  1  F0 D2        	BEQ	EX5F
002616  1               ;10 LEQ
002616  1  20 48 1B     EX10	JSR	COMPFP
002619  1  C9 02        	CMP	#2
00261B  1  D0 D0        	BNE	EX5T
00261D  1  F0 C9        	BEQ	EX5F
00261F  1               ;11 NOT
00261F  1  20 EE 1A     EX11	JSR	CNVBRA		;CONV$TO$BINARY(RA)
002622  1  A0 03        	LDY	#3
002624  1  B1 5C        EX11A	LDA	(RA),Y
002626  1  49 FF        	EOR	#$FF
002628  1  91 5C        	STA	(RA),Y
00262A  1  88           	DEY
00262B  1  D0 F7        	BNE	EX11A		;(RA):=NOT (RA)
00262D  1  4C 1C 1B     	JMP	CNVFRA		;CONV$TO$FLOATING(RA)
002630  1               ;12 AND
002630  1  20 EE 1A     EX12	JSR	CNVBRA		;CONV$TO$BINARY(RA)
002633  1  20 E7 1A     	JSR	CNVBRB		;RB
002636  1  A0 03        	LDY	#3
002638  1  B1 5C        EX12A	LDA	(RA),Y
00263A  1  31 5E        	AND	(RB),Y
00263C  1  91 5E        	STA	(RB),Y
00263E  1  88           	DEY
00263F  1  D0 F7        	BNE	EX12A		;(RB):=(RB) AND (RA)
002641  1  20 52 19     	JSR	POPSTK		;POP$STACK
002644  1  4C 1C 1B     	JMP	CNVFRA		;CONV$TO$FLOATING(RA)
002647  1               ;13 OR
002647  1  20 EE 1A     EX13	JSR	CNVBRA
00264A  1  20 E7 1A     	JSR	CNVBRB
00264D  1  A0 03        	LDY	#3		;SET INDEX
00264F  1  B1 5C        EX13A	LDA	(RA),Y
002651  1  11 5E        	ORA	(RB),Y
002653  1  91 5E        	STA	(RB),Y
002655  1  88           	DEY
002656  1  D0 F7        	BNE	EX13A		;(RB):=(RB) OR (RA)
002658  1  20 52 19     	JSR	POPSTK
00265B  1  4C 1C 1B     	JMP	CNVFRA
00265E  1               ;15 STO
00265E  1  A9 00        EX15	LDA	#0
002660  1  20 52 10     	JSR	STORE		;STORE(0)
002663  1  20 02 19     	JSR	MVRARB		;MOVE$RA$RB
002666  1  4C 52 19     	JMP	POPSTK		;POP$STACK
002669  1               ;16 XIT
002669  1  68           EX16	PLA
00266A  1  68           	PLA			;CLEAR STACK
00266B  1  60           	RTS			;AND RETURN TO OUTER LOOP
00266C  1               ;18 DUP
00266C  1  20 82 19     EX18	JSR	PSHSTK
00266F  1  4C F8 18     	JMP	MVRBRA
002672  1               ;20 STD
002672  1  A9 00        EX20	LDA	#0
002674  1  20 52 10     	JSR	STORE
002677  1  20 52 19     	JSR	POPSTK
00267A  1  4C 52 19     	JMP	POPSTK
00267D  1               ;21 SLT
00267D  1  20 B7 13     EX21	JSR	CMPSTR
002680  1  C9 01        	CMP	#1
002682  1  F0 05        	BEQ	EX21T
002684  1  A9 00        EX21F	LDA	#FALSE
002686  1  4C EC 12     	JMP	COMFIX
002689  1  A9 FF        EX21T	LDA	#TRUE
00268B  1  4C EC 12     	JMP	COMFIX
00268E  1               ;22 SGT
00268E  1  20 B7 13     EX22	JSR	CMPSTR
002691  1  C9 02        	CMP	#2
002693  1  F0 F4        	BEQ	EX21T
002695  1  D0 ED        	BNE	EX21F
002697  1               ;23 SEQ
002697  1  20 B7 13     EX23	JSR	CMPSTR
00269A  1  C9 03        	CMP	#3
00269C  1  F0 EB        	BEQ	EX21T
00269E  1  D0 E4        	BNE	EX21F
0026A0  1               ;24 SNE
0026A0  1  20 B7 13     EX24	JSR	CMPSTR
0026A3  1  C9 03        	CMP	#3
0026A5  1  D0 E2        	BNE	EX21T
0026A7  1  F0 DB        	BEQ	EX21F
0026A9  1               ;25 SGE
0026A9  1  20 B7 13     EX25	JSR	CMPSTR
0026AC  1  C9 01        	CMP	#1
0026AE  1  D0 D9        	BNE	EX21T
0026B0  1  F0 D2        	BEQ	EX21F
0026B2  1               ;26 SLE
0026B2  1  20 B7 13     EX26	JSR	CMPSTR
0026B5  1  C9 02        	CMP	#2
0026B7  1  D0 D0        	BNE	EX21T
0026B9  1  F0 C9        	BEQ	EX21F
0026BB  1               ;27 STS
0026BB  1  A9 01        EX27	LDA	#1
0026BD  1  20 52 10     	JSR	STORE
0026C0  1  20 52 19     	JSR	POPSTK
0026C3  1  4C 52 19     	JMP	POPSTK
0026C6  1               ;28 ILS
0026C6  1  20 82 19     EX28	JSR	PSHSTK
0026C9  1  20 7B 19     	JSR	STINCN
0026CC  1  A0 00        	LDY	#0
0026CE  1  A5 60        	LDA	RC
0026D0  1  91 5C        	STA	(RA),Y
0026D2  1  C8           	INY
0026D3  1  A5 61        	LDA	RC+1
0026D5  1  91 5C        	STA	(RA),Y		;ARA:=RC
0026D7  1  88           	DEY
0026D8  1  B1 60        	LDA	(RC),Y		;A:=C
0026DA  1  18           	CLC
0026DB  1  65 60        	ADC	RC
0026DD  1  85 60        	STA	RC
0026DF  1  90 02        	BCC	*+4
0026E1  1  E6 61        	INC	RC+1		;RC:=RC+C
0026E3  1  A9 00        	LDA	#FALSE
0026E5  1  4C F1 18     	JMP	FLSTRA		;FLAG$STRING$ADDRESS(FALSE)
0026E8  1               ;30 PRO
0026E8  1  20 7B 19     EX30	JSR	STINCN
0026EB  1  20 82 19     	JSR	PSHSTK
0026EE  1  18           	CLC
0026EF  1  A5 60        	LDA	RC
0026F1  1  A4 61        	LDY	RC+1
0026F3  1  69 02        	ADC	#2
0026F5  1  48           	PHA
0026F6  1  90 01        	BCC	*+3
0026F8  1  C8           	INY
0026F9  1  98           	TYA
0026FA  1  A0 01        	LDY	#1
0026FC  1  91 5C        	STA	(RA),Y
0026FE  1  68           	PLA
0026FF  1  88           	DEY
002700  1  91 5C        	STA	(RA),Y		;ARA:=RC+1+1
002702  1  B1 60        	LDA	(RC),Y
002704  1  AA           	TAX
002705  1  C8           	INY
002706  1  B1 60        	LDA	(RC),Y
002708  1  85 61        	STA	RC+1
00270A  1  86 60        	STX	RC		;RC:=TWOBYTEOPRAND
00270C  1  60           	RTS
00270D  1               ;31 RTN
00270D  1  20 0E 1A     EX31	JSR	ARA
002710  1  38           	SEC
002711  1  E9 01        	SBC	#1
002713  1  B0 01        	BCS	*+3
002715  1  88           	DEY
002716  1  85 60        	STA	RC
002718  1  84 61        	STY	RC+1
00271A  1  4C 52 19     	JMP	POPSTK
00271D  1               ;34 RDV	READS A NUMBER FROM CONSOLE
00271D  1  20 AA 09     EX34	JSR	MRECIN
002720  1  D0 03        	BNE	*+5
002722  1  20 BA 09     	JSR	CONIER
002725  1  4C 0F 0B     	JMP	GTNMFL		;GET$NUMERIC$FIELD
002728  1               ;35 WRV	PRINTS THE NUMBER ON THE TOP OF THE STACK
002728  1  20 2C 1A     EX35	JSR	NUMOUT		;NUMERIC$OUT
00272B  1  20 61 1A     	JSR	WRTTCN		;WRITE$TO$CONSOLE
00272E  1  4C 52 19     	JMP	POPSTK
002731  1               ;36 WST PRINTS THE STRING WHOSE ADDRESS IS ON TOP OF STACK
002731  1  20 61 1A     EX36	JSR	WRTTCN		;WRITE$TO$CONSOLE
002734  1  20 CE 12     	JSR	STRFRE		;STRING$FREE
002737  1  4C 52 19     	JMP	POPSTK
00273A  1               ;37 RDF READY A RANDOM BLOCK
00273A  1  20 A9 0E     EX37	JSR	SUDSIO		;SETUP$DISK$IO
00273D  1  20 C0 0E     	JSR	RANSTU		;RANDOM$SETUP
002740  1  4C 94 0E     	JMP	STEFST		;SET$EOF$STACK
002743  1               ;38 RDB READY NEXT SEQUENTIAL BLOCK
002743  1  20 A9 0E     EX38	JSR	SUDSIO
002746  1  4C 94 0E     	JMP	STEFST
002749  1               ;39 ECR
002749  1  20 AA 09     EX39	JSR	MRECIN		;IF NOT MORE$CON$INPUT
00274C  1  F0 06        	BEQ	EX39A		;THEN
00274E  1  20 82 19     	JSR	PSHSTK
002751  1  4C BA 09     	JMP	CONIER		;CONSOLE$INPUT$ERROR
002754  1  60           EX39A	RTS
002755  1               ;40 OUT	ACTUALLY POKE
002755  1  20 0E 1A     EX40	JSR	ARA
002758  1  8D 63 27     	STA	POKE+1
00275B  1  8C 64 27     	STY	POKE+2		;LOCATION IS ARA
00275E  1  A0 00        	LDY	#0
002760  1  B1 5E        	LDA	(RB),Y		;A:=BRAZ
002762  1  8D FF FF     POKE	STA	$FFFF
002765  1  20 52 19     	JSR	POPSTK
002768  1  4C 52 19     	JMP	POPSTK
00276B  1               ;41 RDN	READ A NUMBER FROM DISK
00276B  1  A9 00        EX41	LDA	#0
00276D  1  8D 43 08     	STA	INPTYP
002770  1  4C 0F 0B     	JMP	GTNMFL		;GET$NUMERIC$FIELD
002773  1               ;42 RDS READ A STRING FROM DISK
002773  1  A9 00        EX42	LDA	#0
002775  1  8D 43 08     	STA	INPTYP
002778  1  4C C9 0A     	JMP	GTSTFL		;GET$STRING$FIELD
00277B  1               ;43 WRN WRITE A NUMBER TO DISK
00277B  1  A9 00        EX43	LDA	#0
00277D  1  4C 96 0F     	JMP	WRTOFL		;WRITE$TO$FILE(0)
002780  1               ;44 WRS WRITE A STRING TO DISK
002780  1  A9 01        EX44	LDA	#1
002782  1  4C 96 0F     	JMP	WRTOFL		;WRITE$TO$FILE(1)
002785  1               ;46 CON
002785  1  20 82 19     EX46	JSR	PSHSTK
002788  1  20 7B 19     	JSR	STINCN		;STEP$INS$CNT
00278B  1  A0 00        	LDY	#0
00278D  1  B1 60        	LDA	(RC),Y
00278F  1  85 2C        	STA	MFROM
002791  1  C8           	INY
002792  1  B1 60        	LDA	(RC),Y
002794  1  85 2D        	STA	MFROM+1
002796  1  A5 5C        	LDA	RA
002798  1  A4 5D        	LDY	RA+1
00279A  1  85 2E        	STA	MTO
00279C  1  84 2F        	STY	MTO+1
00279E  1  20 72 17     	JSR	MOVE4
0027A1  1  4C 7B 19     	JMP	STINCN
0027A4  1               ;47 RST RESET POINTER TO BEGINNING OF DATA AREA
0027A4  1  A4 69        EX47	LDY	MDA+1
0027A6  1  A6 68        	LDX	MDA
0027A8  1  D0 01        	BNE	*+3
0027AA  1  88           	DEY
0027AB  1  CA           	DEX
0027AC  1  86 6E        	STX	DTARPT
0027AE  1  84 6F        	STY	DTARPT+1	;DATA$AREA$PTR:=MDA-1
0027B0  1  60           	RTS
0027B1  1               ;48 NEG
0027B1  1  20 71 1B     EX48	JSR	FLODRA		;PRIM:=(RA)
0027B4  1  20 E8 1E     	JSR	NEG		;PRIM:=-PRIM
0027B7  1  20 78 1B     	JSR	FSTRRA		;(RA):=PRIM
0027BA  1  4C 8D 1B     	JMP	CHKOVR		;CHECK$OVERFLOW
0027BD  1               ;49 RES READ STRING
0027BD  1  20 AA 09     EX49	JSR	MRECIN		;IF MORE$CON$INPUT
0027C0  1  D0 03        	BNE	*+5		;THEN
0027C2  1  20 BA 09     	JSR	CONIER		;ELSE CONSOLE$INPUT$ERROR
0027C5  1  4C C9 0A     	JMP	GTSTFL		;GET$STRING$FIELD
0027C8  1               ;53 NSP
0027C8  1  A5 74        EX53	LDA	PRBUFF		;GET CURRENT POSITION
0027CA  1  C9 70        	CMP	#112		;IF UNDER 112 THEN OK
0027CC  1  90 03        	BCC	*+5
0027CE  1  4C 24 1A     	JMP	DMPPBF		;ELSE DO A CR AND LF
0027D1  1  A9 20        EX53A	LDA	#' '		;SEND A SPACE
0027D3  1  20 3B 15     	JSR	PRNCHR
0027D6  1  E6 74        	INC	PRBUFF		;AND BUMP INDEX
0027D8  1  38           	SEC
0027D9  1  A5 74        	LDA	PRBUFF		;GET INDEX
0027DB  1  E9 0E        EX53B	SBC	#14		;SUBTRACT 14
0027DD  1  90 F2        	BCC	EX53A		;IF BORROW THEN NOT THERE
0027DF  1  D0 FA        	BNE	EX53B		;IF NOT ZERO MAY BE MORE
0027E1  1  60           	RTS			;ELSE DONE
0027E2  1               ;55 BRC
0027E2  1  20 0C 19     EX55	JSR	RAZER		;IF RA$ZERO
0027E5  1  D0 0E        	BNE	EX55A		;THEN
0027E7  1  18           	CLC
0027E8  1  A5 60        	LDA	RC
0027EA  1  69 02        	ADC	#2
0027EC  1  85 60        	STA	RC
0027EE  1  90 02        	BCC	*+4
0027F0  1  E6 61        	INC	RC+1		;ELSE RC:=RC+2
0027F2  1  4C 52 19     	JMP	POPSTK
0027F5  1  20 BE 12     EX55A	JSR	ABSBRA		;ABSOLUTE$BRANCH
0027F8  1  4C 52 19     	JMP	POPSTK
0027FB  1               ;59 RCH
0027FB  1  A9 01        EX59	LDA	#1
0027FD  1  8D 43 08     	STA	INPTYP		;INPUTTYPE:=1
002800  1  A5 60        	LDA	RC
002802  1  A4 61        	LDY	RC+1
002804  1  8D 41 08     	STA	RERDAD
002807  1  8C 42 08     	STY	RERDAD+1	;REREADADDR:=RC
00280A  1  4C 7A 09     	JMP	CONRDE		;CONSOLE$READ
00280D  1               ;60 DRS READ STRING FROM DATA AREA
00280D  1  A9 02        EX60	LDA	#2
00280F  1  8D 43 08     	STA	INPTYP		;INPUTTYPE:=2
002812  1  4C C9 0A     	JMP	GTSTFL		;GET$STRING$FIELD
002815  1               ;61 DRF READ FLOATING POINT NUMBER FROM DATA AREA
002815  1  A9 02        EX61	LDA	#2
002817  1  8D 43 08     	STA	INPTYP
00281A  1  4C 0F 0B     	JMP	GTNMFL		;GET$NUMERIC$FIELD
00281D  1               ;62 EDR END OF RECORD FOR READ
00281D  1  20 5D 0C     EX62	JSR	VARBSZ
002820  1  F0 07        	BEQ	EX62B		;IF NOT VAR$BLOCK$SIZE THEN
002822  1  20 69 0F     EX62A	JSR	GTDSCH		;ELSE
002825  1  C9 0A        	CMP	#LF
002827  1  D0 F9        	BNE	EX62A		;DO WHILE GET$DISK$CHAR <> LF
002829  1  4C 8B 0B     EX62B	JMP	STRRPT		;STORE$REC$PTR
00282C  1               ;63 EDW END OF RECORD FOR WRITE
00282C  1               EX63BS				;BLOCKSIZE-2
00282C  1  xx xx        	.res	2
00282E  1  20 5D 0C     EX63	JSR	VARBSZ
002831  1  F0 28        	BEQ	EX63B		;IF NOT VAR$BLOCK$SIZE THEN
002833  1  38           	SEC
002834  1  AD 3A 08     	LDA	BLKSZE
002837  1  AC 3B 08     	LDY	BLKSZE+1
00283A  1  E9 02        	SBC	#2
00283C  1  8D 2C 28     	STA	EX63BS
00283F  1  B0 01        	BCS	*+3
002841  1  88           	DEY
002842  1  8C 2D 28     	STY	EX63BS+1	;CALCULATE BLOCKSIZE-2
002845  1  AD 3C 08     EX63A	LDA	BYTSWR
002848  1  CD 2C 28     	CMP	EX63BS
00284B  1  AD 3D 08     	LDA	BYTSWR+1
00284E  1  ED 2D 28     	SBC	EX63BS+1
002851  1  B0 08        	BCS	EX63B		;IF BYTES$WRITTEN >= BLOCKSIZE-2 THEN
002853  1  A9 20        	LDA	#' '		;ELSE
002855  1  20 6B 0C     	JSR	WRABYT		;WRITE$A$BYTE(BLANK)
002858  1  4C 45 28     	JMP	EX63A
00285B  1  A9 0D        EX63B	LDA	#CR
00285D  1  20 6B 0C     	JSR	WRABYT
002860  1  A9 0A        	LDA	#LF
002862  1  20 6B 0C     	JSR	WRABYT
002865  1  4C 8B 0B     	JMP	STRRPT		;STORE$REC$PTR
002868  1               ;64 CLS CLOSE A FILE
002868  1  20 C2 0C     EX64	JSR	STFLAD		;SET$FILE$ADDR
00286B  1  20 0B 10     	JSR	DSKCLS		;DISK$CLOSE
00286E  1  A0 00        	LDY	#0
002870  1  B1 5C        	LDA	(RA),Y
002872  1  0A           	ASL	A
002873  1  AA           	TAX			;X:=2*BRAZ
002874  1  98           	TYA
002875  1  9D ED 2F     	STA	FILES,X
002878  1  9D EE 2F     	STA	FILES+1,X
00287B  1  9D 15 30     	STA	EOFBRN,X
00287E  1  9D 16 30     	STA	EOFBRN+1,X	;FILES(BRAZ),EOFBRANCH(BRAZ):=0
002881  1  4C 52 19     	JMP	POPSTK
002884  1               ;65 ABSOLUTE
002884  1  A0 01        EX65	LDY	#1
002886  1  B1 5C        	LDA	(RA),Y
002888  1  29 7F        	AND	#$7F
00288A  1  91 5C        	STA	(RA),Y		;BRA(1):=BRA(1) AND $7F
00288C  1  60           	RTS
00288D  1               ;66 INTEGER
00288D  1  20 71 1B     EX66	JSR	FLODRA		;PRIM:=(RA)
002890  1  20 6A 20     	JSR	INT
002893  1  20 78 1B     	JSR	FSTRRA		;(RA):=INT(PRIM)
002896  1  4C 8D 1B     	JMP	CHKOVR		;CHECK$OVERFLOW
002899  1               ;67 RANDOM NUMBER GENERATOR
002899  1  20 DA 22     EX67	JSR	RND		;CALCULATE NUMBER
00289C  1  20 82 19     	JSR	PSHSTK		;MAKE ROOM FOR NUMBER
00289F  1  4C 78 1B     	JMP	FSTRRA		;PUT ON STACK
0028A2  1               ;68 SGN
0028A2  1  20 D9 18     EX68	JSR	RANEG
0028A5  1  48           	PHA
0028A6  1  20 0C 19     	JSR	RAZER
0028A9  1  49 FF        	EOR	#$FF
0028AB  1  20 EC 12     	JSR	COMFIX		;COMP$FIX(NOT RA$ZERO)
0028AE  1  68           	PLA
0028AF  1  D0 03        	BNE	*+5		;IF RA$NEGATIVE THEN
0028B1  1  4C B1 27     	JMP	EX48		;ELSE CHANGE SIGN
0028B4  1  60           	RTS
0028B5  1               ;69 SIN
0028B5  1  20 71 1B     EX69	JSR	FLODRA
0028B8  1  20 CA 23     	JSR	SIN
0028BB  1  20 78 1B     	JSR	FSTRRA
0028BE  1  4C 8D 1B     	JMP	CHKOVR
0028C1  1               ;70 COS
0028C1  1  20 71 1B     EX70	JSR	FLODRA
0028C4  1  20 C3 23     	JSR	COS
0028C7  1  20 78 1B     	JSR	FSTRRA
0028CA  1  4C 8D 1B     	JMP	CHKOVR
0028CD  1               ;71 ATN
0028CD  1  20 71 1B     EX71	JSR	FLODRA
0028D0  1  20 1C 24     	JSR	ATN
0028D3  1  20 78 1B     	JSR	FSTRRA
0028D6  1  4C 8D 1B     	JMP	CHKOVR
0028D9  1               ;72 TAN
0028D9  1  20 82 19     EX72	JSR	PSHSTK		;EXTEND STACK
0028DC  1  20 F8 18     	JSR	MVRBRA		;DUPLICATE PARAM
0028DF  1  20 B5 28     	JSR	EX69		;CALCULATE SIN
0028E2  1  20 52 19     	JSR	POPSTK
0028E5  1  20 C1 28     	JSR	EX70		;NOW DO COS
0028E8  1  20 82 19     	JSR	PSHSTK		;SIN STILL THERE
0028EB  1  20 18 19     	JSR	RBZER
0028EE  1  F0 05        	BEQ	*+7		;IF COS NOT ZERO THEN
0028F0  1  A9 16        	LDA	#22		;ELSE TAN(PI/2) ERROR
0028F2  1  4C B8 18     	JMP	ERROR
0028F5  1  20 42 19     	JSR	FLIP
0028F8  1  4C 95 25     	JMP	EX3A		;DIVIDE
0028FB  1               ;73 SGR
0028FB  1  20 71 1B     EX73	JSR	FLODRA
0028FE  1  24 4F        	BIT	PS
002900  1  10 05        	BPL	*+7		;OK IF POSITIVE
002902  1  A9 0C        	LDA	#12		;ELSE NEGATIVE NUMBER TO POWER ERROR
002904  1  4C B8 18     	JMP	ERROR
002907  1  20 0D 23     	JSR	LOG
00290A  1  A9 AE        	LDA	#<HALF
00290C  1  A0 1B        	LDY	#>HALF
00290E  1  20 70 1F     	JSR	MPA		;1/2 * LOG()
002911  1  20 6C 23     	JSR	EXP		;EXP()
002914  1  20 78 1B     	JSR	FSTRRA
002917  1  4C 8D 1B     	JMP	CHKOVR
00291A  1               ;74 TAB
00291A  1  20 D4 1A     EX74	JSR	CNVBAD		;CONV$TO$BIN$ADDR
00291D  1  A0 00        	LDY	#0
00291F  1  B1 5C        	LDA	(RA),Y		;GET LOW
002921  1  C9 85        	CMP	#133		;SEE IF TOO BIG
002923  1  B0 3C        	BCS	EX74E		;ERROR IF IS
002925  1  C8           	INY
002926  1  B1 5C        	LDA	(RA),Y		;IF ANYTHING IN HIGH
002928  1  D0 37        	BNE	EX74E		;IS ERROR
00292A  1  88           	DEY
00292B  1  38           	SEC
00292C  1  B1 5C        	LDA	(RA),Y
00292E  1  F0 27        	BEQ	EX74Z		;SPECIAL CASE IF ZERO
002930  1  E9 01        	SBC	#1
002932  1  91 5C        	STA	(RA),Y		;ARA:=ARA-1  (LOW ONLY)
002934  1  A5 74        	LDA	PRBUFF
002936  1  D1 5C        	CMP	(RA),Y
002938  1  90 0B        	BCC	EX74D		;IF ARA > PRINTBUFFER THEN
00293A  1  F0 18        	BEQ	EX74X		;BUT IF SAME DONE
00293C  1  20 24 1A     	JSR	DMPPBF		;DUMP$PRINT$BUFFER
00293F  1  A0 00        	LDY	#0		;GET DEST AGAIN
002941  1  B1 5C        	LDA	(RA),Y
002943  1  F0 0F        	BEQ	EX74X		;DONE IF ZERO
002945  1  A9 20        EX74D	LDA	#' '		;SEND A BLANK
002947  1  20 3B 15     	JSR	PRNCHR		;TO CONSOLE
00294A  1  E6 74        	INC	PRBUFF		;AND BUMP INDEX
00294C  1  A0 00        	LDY	#0
00294E  1  B1 5C        	LDA	(RA),Y		;GET END POSITION BACK
002950  1  C5 74        	CMP	PRBUFF		;SEE IF THERE
002952  1  D0 F1        	BNE	EX74D		;LOOP IF NOT
002954  1  4C 52 19     EX74X	JMP	POPSTK
002957  1  85 74        EX74Z	STA	PRBUFF		;CLEAR POINTER
002959  1  A9 0D        	LDA	#CR		;THEN SEND CARRIAGE RETURN
00295B  1  20 3B 15     	JSR	PRNCHR
00295E  1  4C 52 19     	JMP	POPSTK		;AND POP STACK POINTER
002961  1  A9 1B        EX74E	LDA	#27		;ILLEGAL ARGUMENT
002963  1  4C B8 18     	JMP	ERROR
002966  1               ;75 EXP
002966  1  20 71 1B     EX75	JSR	FLODRA
002969  1  20 6C 23     	JSR	EXP
00296C  1  20 78 1B     	JSR	FSTRRA
00296F  1  4C 8D 1B     	JMP	CHKOVR
002972  1               ;76 FREE AREA IN FSA
002972  1  20 82 19     EX76	JSR	PSHSTK
002975  1  A9 00        	LDA	#0
002977  1  A8           	TAY
002978  1  20 AC 15     	JSR	AVLL		;AVAILABLE(0)
00297B  1  4C 42 1B     	JMP	FLTADR		;FLOAT$ADDR()
00297E  1               ;77 IRN RANDOMIZE
00297E  1  A5 84        EX77	LDA	LCLSED
002980  1  A4 84        	LDY	LCLSED
002982  1  8D EB 1B     	STA	RNDWRK+1
002985  1  8C EC 1B     	STY	RNDWRK+2
002988  1  4C DA 22     	JMP	RND
00298B  1               ;78 LOG
00298B  1  20 71 1B     EX78	JSR	FLODRA
00298E  1  20 0D 23     	JSR	LOG
002991  1  20 78 1B     	JSR	FSTRRA
002994  1  4C 8D 1B     	JMP	CHKOVR
002997  1               ;79 POSITION OF PRINT BUFFER PTR
002997  1  20 82 19     EX79	JSR	PSHSTK
00299A  1  A5 74        	LDA	PRBUFF
00299C  1  18           	CLC
00299D  1  69 01        	ADC	#1
00299F  1  A0 00        	LDY	#0
0029A1  1  4C 42 1B     	JMP	FLTADR		;FLOAT$ADDR(PRINTBUFFER-PRINTBUFFERLOC+1)
0029A4  1               ;80 INP [ACTUALLY PEEK]
0029A4  1  20 C4 1A     EX80	JSR	RNCBRA
0029A7  1  20 0E 1A     	JSR	ARA
0029AA  1  8D B1 29     	STA	PEEK+1
0029AD  1  8C B2 29     	STY	PEEK+2
0029B0  1  AD FF FF     PEEK	LDA	$FFFF
0029B3  1  A0 00        	LDY	#0
0029B5  1  4C 42 1B     	JMP	FLTADR
0029B8  1               ;81 ASCII CONVERSION
0029B8  1  20 0E 1A     EX81	JSR	ARA
0029BB  1  85 02        	STA	EXH
0029BD  1  84 03        	STY	EXH+1		;HOLD:=ARA
0029BF  1  05 03        	ORA	EXH+1		;IF = 0
0029C1  1  F0 06        	BEQ	EX81A		;THEN ERROR
0029C3  1  A0 00        	LDY	#0
0029C5  1  B1 02        	LDA	(EXH),Y
0029C7  1  D0 05        	BNE	*+7		;IF H(0) <> 0 THEN OK
0029C9  1  A9 00        EX81A	LDA	#0		;ELSE NULL STRING ERROR
0029CB  1  4C B8 18     	JMP	ERROR
0029CE  1  A0 01        	LDY	#1
0029D0  1  B1 02        	LDA	(EXH),Y		;A:=H(1)
0029D2  1  48           	PHA
0029D3  1  20 CE 12     	JSR	STRFRE		;STRING$FREE
0029D6  1  68           	PLA
0029D7  1  A0 00        	LDY	#0
0029D9  1  4C 42 1B     	JMP	FLTADR		;FLOAT$ADDR(TEMP)
0029DC  1               ;82 CHR CONVERTS TO ASCII
0029DC  1  20 D4 1A     EX82	JSR	CNVBAD		;CONV$TO$BIN$ADDR
0029DF  1  A9 02        	LDA	#2
0029E1  1  A0 00        	LDY	#0
0029E3  1  20 4B 16     	JSR	GETS		;GETSPACE(2)
0029E6  1  85 02        	STA	EXH
0029E8  1  84 03        	STY	EXH+1		;HOLD:=
0029EA  1  A0 00        	LDY	#0
0029EC  1  A9 01        	LDA	#1
0029EE  1  91 02        	STA	(EXH),Y		;LOC(0):=1
0029F0  1  B1 5C        	LDA	(RA),Y
0029F2  1  C8           	INY
0029F3  1  91 02        	STA	(EXH),Y		;LOC(1):=BRA(0)
0029F5  1  A5 03        	LDA	EXH+1
0029F7  1  91 5C        	STA	(RA),Y
0029F9  1  88           	DEY
0029FA  1  A5 02        	LDA	EXH
0029FC  1  91 5C        	STA	(RA),Y		;ARA:=HOLD
0029FE  1  A9 FF        	LDA	#TRUE
002A00  1  4C F1 18     	JMP	FLSTRA		;FLAG$STRING$ADDR(TRUE)
002A03  1               ;83 LEFT END OF STRING
002A03  1  A9 00        EX83	LDA	#0
002A05  1  4C 32 14     	JMP	STRSEG		;STRING$SEGMENT(0)
002A08  1               ;84 LENGTH OF STRING
002A08  1  20 0E 1A     EX84	JSR	ARA
002A0B  1  20 DC 12     	JSR	GETSLN		;GET$STRING$LEN(ARA)
002A0E  1  48           	PHA
002A0F  1  20 CE 12     	JSR	STRFRE
002A12  1  68           	PLA
002A13  1  A0 00        	LDY	#0
002A15  1  4C 42 1B     	JMP	FLTADR		;FLOAT$ADDR(LENGTH)
002A18  1               ;85 MIDDLE OF STRING
002A18  1  A9 02        EX85	LDA	#2
002A1A  1  4C 32 14     	JMP	STRSEG		;STRING$SEGMENT(2)
002A1D  1               ;86 RIGHT END OF STRING
002A1D  1  A9 01        EX86	LDA	#1
002A1F  1  4C 32 14     	JMP	STRSEG		;STRING$SEGMENT(1)
002A22  1               ;87 CONVERSION TO STRING
002A22  1  20 2C 1A     EX87	JSR	NUMOUT
002A25  1  18           	CLC
002A26  1  AD CE 2F     	LDA	NUOWRK
002A29  1  69 01        	ADC	#1
002A2B  1  48           	PHA
002A2C  1  A0 00        	LDY	#0
002A2E  1  20 4B 16     	JSR	GETS		;GET$SPACE()
002A31  1  85 2E        	STA	MTO
002A33  1  84 2F        	STY	MTO+1
002A35  1  A0 00        	LDY	#0
002A37  1  91 5C        	STA	(RA),Y
002A39  1  C8           	INY
002A3A  1  A5 2F        	LDA	MTO+1
002A3C  1  91 5C        	STA	(RA),Y		;ARA:=
002A3E  1  A9 CE        	LDA	#<NUOWRK
002A40  1  A0 2F        	LDY	#>NUOWRK
002A42  1  85 2C        	STA	MFROM
002A44  1  84 2D        	STY	MFROM+1
002A46  1  68           	PLA
002A47  1  A0 00        	LDY	#0
002A49  1  20 7C 17     	JSR	MOVE		;MOVE(FROM,TO,AY)
002A4C  1  A9 FF        	LDA	#TRUE
002A4E  1  4C F1 18     	JMP	FLSTRA		;FLAG$STRING$ADDR(TRUE)
002A51  1               ;88 VALUE
002A51  1  20 0E 1A     EX88	JSR	ARA
002A54  1  20 DC 12     	JSR	GETSLN		;GET$STRING$LEN(ARA)
002A57  1  AA           	TAX
002A58  1  20 0E 1A     	JSR	ARA
002A5B  1  18           	CLC
002A5C  1  69 01        	ADC	#1
002A5E  1  90 01        	BCC	*+3
002A60  1  C8           	INY
002A61  1  20 03 21     	JSR	FLTINP
002A64  1  20 CE 12     	JSR	STRFRE		;STRING$FREE
002A67  1  4C 78 1B     	JMP	FSTRRA		;(RA):=PRIM
002A6A  1               ;89 CALL
002A6A  1  20 D4 1A     EX89	JSR	CNVBAD		;CONVERT TO ADDRESS
002A6D  1  20 0E 1A     	JSR	ARA
002A70  1  8D 77 2A     	STA	CALL+1
002A73  1  8C 78 2A     	STY	CALL+2
002A76  1  20 FF FF     CALL	JSR	$FFFF		;DO CALL
002A79  1  4C 42 1B     	JMP	FLTADR		;FLOAT AND RETURN
002A7C  1               ;90 SINH
002A7C  1  20 71 1B     EX90	JSR	FLODRA
002A7F  1  A5 4B        	LDA	PE		;TEST FOR ZERO
002A81  1  D0 01        	BNE	*+3		;CONTINUE IF NOT
002A83  1  60           	RTS			;ELSE DONE
002A84  1  A9 E5        	LDA	#<T2
002A86  1  A0 2F        	LDY	#>T2
002A88  1  20 C1 1C     	JSR	STP		;SAVE IN T2
002A8B  1  20 6C 23     	JSR	EXP
002A8E  1  A9 E9        	LDA	#<T3
002A90  1  A0 2F        	LDY	#>T3
002A92  1  20 C1 1C     	JSR	STP		;SAVE EXP(X) IN T3
002A95  1  A9 E5        	LDA	#<T2
002A97  1  A0 2F        	LDY	#>T2
002A99  1  20 E4 1C     	JSR	LPA		;GET X BACK
002A9C  1  20 E8 1E     	JSR	NEG		;-X
002A9F  1  20 6C 23     	JSR	EXP		;LOG(-X)
002AA2  1  20 E8 1E     	JSR	NEG		;-LOG(-X)
002AA5  1  A9 E9        	LDA	#<T3
002AA7  1  A0 2F        	LDY	#>T3
002AA9  1  20 0C 1E     	JSR	APA		;LOG(X)-LOG(-X)
002AAC  1  A9 AE        	LDA	#<HALF
002AAE  1  A0 1B        	LDY	#>HALF
002AB0  1  20 70 1F     	JSR	MPA		;SINH(X)
002AB3  1  20 78 1B     	JSR	FSTRRA		;STORE AT RA
002AB6  1  4C 8D 1B     	JMP	CHKOVR		;CHECKOVERFLOW
002AB9  1               ;92 CKO
002AB9  1               ;RA CONTAINS MAX NUMBER LABELS IN THE ON STATEMENT
002AB9  1               ;RB CONTAINS SELECTED LABEL
002AB9  1               ;CHECKS TO INSURE THAT SLECTED LABEL EXISTS. IF NOT AN ERROR IS NOTED
002AB9  1               EX92T
002AB9  1  xx           	.res	1
002ABA  1  A0 00        EX92	LDY	#0
002ABC  1  B1 5E        	LDA	(RB),Y
002ABE  1  38           	SEC
002ABF  1  E9 01        	SBC	#1
002AC1  1  91 5E        	STA	(RB),Y		;BRBZ:=BRBZ-1
002AC3  1  8D B9 2A     	STA	EX92T		;SAVE FOR COMPARISON
002AC6  1  38           	SEC
002AC7  1  B1 5C        	LDA	(RA),Y
002AC9  1  E9 01        	SBC	#1		;BRAZ-1
002ACB  1  CD B9 2A     	CMP	EX92T
002ACE  1  B0 05        	BCS	*+7		;IF BRAZ-1 >= BRBZ THEN OK
002AD0  1  A9 10        	LDA	#16		;ELSE INDEX IN ON STATEMENT OUT OF BOUNDS
002AD2  1  4C B8 18     	JMP	ERROR
002AD5  1  20 52 19     	JSR	POPSTK		;POP$STACK
002AD8  1  A0 00        	LDY	#0
002ADA  1  B1 5C        	LDA	(RA),Y
002ADC  1  18           	CLC
002ADD  1  69 01        	ADC	#1
002ADF  1  8D B9 2A     	STA	EX92T		;SAVE
002AE2  1  B1 5C        	LDA	(RA),Y
002AE4  1  0A           	ASL	A
002AE5  1  18           	CLC
002AE6  1  6D B9 2A     	ADC	EX92T
002AE9  1  91 5C        	STA	(RA),Y		;BRAZ:=
002AEB  1  60           	RTS
002AEC  1               ;93 EXR
002AEC  1  20 EE 1A     EX93	JSR	CNVBRA
002AEF  1  20 E7 1A     	JSR	CNVBRB
002AF2  1  A0 03        	LDY	#3
002AF4  1  B1 5C        EX93A	LDA	(RA),Y
002AF6  1  51 5E        	EOR	(RB),Y
002AF8  1  91 5E        	STA	(RB),Y
002AFA  1  88           	DEY
002AFB  1  10 F7        	BPL	EX93A
002AFD  1  20 52 19     	JSR	POPSTK		;POP$STACK
002B00  1  4C 1C 1B     	JMP	CNVFRA
002B03  1               ;94 DEF
002B03  1  20 7B 19     EX94	JSR	STINCN		;STEP$INS$CNT
002B06  1  20 B2 0C     	JSR	GTFLNU		;GET$FILE$NUMBER
002B09  1  0A           	ASL	A
002B0A  1  AA           	TAX
002B0B  1  20 19 1A     	JSR	ARC		;TWOBYTEOPRAND
002B0E  1  9D 15 30     	STA	EOFBRN,X
002B11  1  98           	TYA
002B12  1  9D 16 30     	STA	EOFBRN+1,X	;EOFBRANCH():=
002B15  1  20 7B 19     	JSR	STINCN		;STEP$INS$CNT
002B18  1  4C 52 19     	JMP	POPSTK		;POP$STACK
002B1B  1               ;95 BOL
002B1B  1  20 0E 1A     EX95	JSR	ARA
002B1E  1  85 6C        	STA	CURLIN
002B20  1  84 6D        	STY	CURLIN+1	;CURRENTLINE:=ARA
002B22  1  4C 52 19     	JMP	POPSTK		;POP$STACK
002B25  1               ;96 ADJ
002B25  1  20 0E 1A     EX96	JSR	ARA
002B28  1  18           	CLC
002B29  1  65 6A        	ADC	MCD
002B2B  1  48           	PHA
002B2C  1  98           	TYA
002B2D  1  65 6B        	ADC	MCD+1		;ARA+MCD
002B2F  1  A0 01        	LDY	#1
002B31  1  91 5C        	STA	(RA),Y
002B33  1  88           	DEY
002B34  1  68           	PLA
002B35  1  91 5C        	STA	(RA),Y		;ARA:=
002B37  1  60           	RTS
002B38  1               ;MAIN PROGRAM
002B38  1  20 34 15     MAIN	JSR	CRLF
002B3B  1  20 67 09     	JSR	INTLEX		;INITIALIZE$EXECUTE
002B3E  1               EOFEXT
002B3E  1  A2 FF        ERREXT	LDX	#$FF
002B40  1  9A           	TXS			;RESET STACK
002B41  1  20 4C 24     	JSR	EXECUT		;EXECUTE
002B44  1  4C 46 10     	JMP	EXTINT		;EXIT INTERPRETER
002B47  1               ;MESSAGES
002B47  1  45 52 52 4F  ERRMSG	.BYTE	"ERROR - $"
002B4B  1  52 20 2D 20  
002B4F  1  24           
002B50  1  57 41 52 4E  WRNMSG	.BYTE	"WARNING - $"
002B54  1  49 4E 47 20  
002B58  1  2D 20 24     
002B5B  1  20 49 4E 20  INLMSG	.BYTE	" IN LINE $"
002B5F  1  4C 49 4E 45  
002B63  1  20 24        
002B65  1               ;ERROR MESSAGES
002B65  1  4E 55 4C 4C  ERM0	.BYTE	"NULL STRING PASSED AS "
002B69  1  20 53 54 52  
002B6D  1  49 4E 47 20  
002B7B  1  50 41 52 41  	.BYTE	"PARAMETER TO ASC FUNCTION$"
002B7F  1  4D 45 54 45  
002B83  1  52 20 54 4F  
002B95  1  45 52 52 4F  ERM1	.BYTE	"ERROR WHILE CLOSING A FILE$"
002B99  1  52 20 57 48  
002B9D  1  49 4C 45 20  
002BB0  1  44 49 53 4B  ERM2	.BYTE	"DISK READ ERROR - UNWRITTEN"
002BB4  1  20 52 45 41  
002BB8  1  44 20 45 52  
002BCB  1  20 44 41 54  	.BYTE	" DATA IN RANDOM ACCESS$"
002BCF  1  41 20 49 4E  
002BD3  1  20 52 41 4E  
002BE2  1  44 49 53 4B  ERM3	.BYTE	"DISK WRITE ERROR$"
002BE6  1  20 57 52 49  
002BEA  1  54 45 20 45  
002BF3  1  44 49 56 49  ERM4	.BYTE	"DIVISION BY ZERO$"
002BF7  1  53 49 4F 4E  
002BFB  1  20 42 59 20  
002C04  1  45 4F 46 20  ERM5	.BYTE	"EOF FOR DISK FILE AND"
002C08  1  46 4F 52 20  
002C0C  1  44 49 53 4B  
002C19  1  20 4E 4F 20  	.BYTE	" NO ACTION SPECIFIED$"
002C1D  1  41 43 54 49  
002C21  1  4F 4E 20 53  
002C2E  1  52 45 43 4F  ERM6	.BYTE	"RECORD SIZE EXCEEDED "
002C32  1  52 44 20 53  
002C36  1  49 5A 45 20  
002C43  1  46 4F 52 20  	.BYTE	"FOR BLOCKED FILE$"
002C47  1  42 4C 4F 43  
002C4B  1  4B 45 44 20  
002C54  1  49 4E 56 41  ERM7	.BYTE	"INVALID INPUT FROM CONSOLE$"
002C58  1  4C 49 44 20  
002C5C  1  49 4E 50 55  
002C6F  1  49 4E 56 41  ERM8	.BYTE	"INVALID RECORD IN RANDOM "
002C73  1  4C 49 44 20  
002C77  1  52 45 43 4F  
002C88  1  41 43 43 45  	.BYTE	"ACCESS$"
002C8C  1  53 53 24     
002C8F  1  41 43 43 45  ERM9	.BYTE	"ACCESSING AN UNOPENED FILE$"
002C93  1  53 53 49 4E  
002C97  1  47 20 41 4E  
002CAA  1  45 52 52 4F  ERM10	.BYTE	"ERROR WHILE CREATING FILE$"
002CAE  1  52 20 57 48  
002CB2  1  49 4C 45 20  
002CC4  1  46 49 4C 45  ERM11	.BYTE	"FILE IDENTIFIER TOO LARGE "
002CC8  1  20 49 44 45  
002CCC  1  4E 54 49 46  
002CDE  1  4F 52 20 5A  	.BYTE	"OR ZERO$"
002CE2  1  45 52 4F 24  
002CE6  1  41 54 54 45  ERM12	.BYTE	"ATTEMPT TO RAISE A NEGATIVE "
002CEA  1  4D 50 54 20  
002CEE  1  54 4F 20 52  
002D02  1  4E 55 4D 42  	.BYTE	"NUMBER TO A POWER$"
002D06  1  45 52 20 54  
002D0A  1  4F 20 41 20  
002D14  1  4E 4F 20 49  ERM13	.BYTE	"NO INT FILE FOUND IN "
002D18  1  4E 54 20 46  
002D1C  1  49 4C 45 20  
002D29  1  44 49 52 45  	.BYTE	"DIRECTORY$"
002D2D  1  43 54 4F 52  
002D31  1  59 24        
002D33  1  41 54 54 45  ERM14	.BYTE	"ATTEMPT TO READ PAST END "
002D37  1  4D 50 54 20  
002D3B  1  54 4F 20 52  
002D4C  1  4F 46 20 44  	.BYTE	"OF DATA AREA$"
002D50  1  41 54 41 20  
002D54  1  41 52 45 41  
002D59  1  45 52 52 4F  ERM15	.BYTE	"ERROR WHILE OPENING A FILE$"
002D5D  1  52 20 57 48  
002D61  1  49 4C 45 20  
002D74  1  49 4E 44 45  ERM16	.BYTE	"INDEX IN ON STATEMENT OUT "
002D78  1  58 20 49 4E  
002D7C  1  20 4F 4E 20  
002D8E  1  4F 46 20 42  	.BYTE	"OF BOUNDS$"
002D92  1  4F 55 4E 44  
002D96  1  53 24        
002D98  1  41 54 54 45  ERM17	.BYTE	"ATTEMPT TO READ PAST END OF"
002D9C  1  4D 50 54 20  
002DA0  1  54 4F 20 52  
002DB3  1  20 52 45 43  	.BYTE	" RECORD ON BLOCKED FILE$"
002DB7  1  4F 52 44 20  
002DBB  1  4F 4E 20 42  
002DCB  1  55 4E 42 4C  ERM18	.BYTE	"UNBLOCKED FILE USED WITH "
002DCF  1  4F 43 4B 45  
002DD3  1  44 20 46 49  
002DE4  1  52 41 4E 44  	.BYTE	"RANDOM ACCESS$"
002DE8  1  4F 4D 20 41  
002DEC  1  43 43 45 53  
002DF2  1  41 52 52 41  ERM19	.BYTE	"ARRAY SUBSCRIPT OUT OF "
002DF6  1  59 20 53 55  
002DFA  1  42 53 43 52  
002E09  1  42 4F 55 4E  	.BYTE	"BOUNDS$"
002E0D  1  44 53 24     
002E10  1  53 54 52 49  ERM20	.BYTE	"STRING LENGTH EXCEEDS 255$"
002E14  1  4E 47 20 4C  
002E18  1  45 4E 47 54  
002E2A  1  53 45 43 4F  ERM21	.BYTE	"SECOND PARAMETER OF MID IS "
002E2E  1  4E 44 20 50  
002E32  1  41 52 41 4D  
002E45  1  4E 45 47 41  	.BYTE	"NEGATIVE$"
002E49  1  54 49 56 45  
002E4D  1  24           
002E4E  1  41 54 54 45  ERM22	.BYTE	"ATTEMPT TO EVALUATE TANGENT "
002E52  1  4D 50 54 20  
002E56  1  54 4F 20 45  
002E6A  1  4F 46 20 50  	.BYTE	"OF PI OVER TWO$"
002E6E  1  49 20 4F 56  
002E72  1  45 52 20 54  
002E79  1  4F 55 54 20  ERM23	.BYTE	"OUT OF MEMORY$"
002E7D  1  4F 46 20 4D  
002E81  1  45 4D 4F 52  
002E87  1  41 54 54 45  ERM24	.BYTE	"ATTEMPT TO WRITE A QUOTE "
002E8B  1  4D 50 54 20  
002E8F  1  54 4F 20 57  
002EA0  1  54 4F 20 44  	.BYTE	"TO DISK$"
002EA4  1  49 53 4B 24  
002EA8  1  44 49 53 4B  ERM25	.BYTE	"DISK DATA FIELD TOO LONG "
002EAC  1  20 44 41 54  
002EB0  1  41 20 46 49  
002EC1  1  44 55 52 49  	.BYTE	"DURING READ$"
002EC5  1  4E 47 20 52  
002EC9  1  45 41 44 24  
002ECD  1  4F 56 45 52  ERM26	.BYTE	"OVERFLOW IN ARITHMETIC "
002ED1  1  46 4C 4F 57  
002ED5  1  20 49 4E 20  
002EE4  1  4F 50 45 52  	.BYTE	"OPERATION$"
002EE8  1  41 54 49 4F  
002EEC  1  4E 24        
002EEE  1  49 4C 4C 45  ERM27	.BYTE	"ILLEGAL TAB ARGUMENT$"
002EF2  1  47 41 4C 20  
002EF6  1  54 41 42 20  
002F03  1  49 4C 4C 45  ERM28	.BYTE	"ILLEGAL CHARACTER IN "
002F07  1  47 41 4C 20  
002F0B  1  43 48 41 52  
002F18  1  46 49 4C 45  	.BYTE	"FILE NAME$"
002F1C  1  20 4E 41 4D  
002F20  1  45 24        
002F22  1               ;ERROR TABLE
002F22  1  65 2B 95 2B  ERMTBL	.WORD	ERM0,ERM1,ERM2,ERM3,ERM4,ERM5,ERM6,ERM7
002F26  1  B0 2B E2 2B  
002F2A  1  F3 2B 04 2C  
002F32  1  6F 2C 8F 2C  	.WORD	ERM8,ERM9,ERM10,ERM11,ERM12,ERM13,ERM14,ERM15
002F36  1  AA 2C C4 2C  
002F3A  1  E6 2C 14 2D  
002F42  1  74 2D 98 2D  	.WORD	ERM16,ERM17,ERM18,ERM19,ERM20,ERM21,ERM22,ERM23
002F46  1  CB 2D F2 2D  
002F4A  1  10 2E 2A 2E  
002F52  1  87 2E A8 2E  	.WORD	ERM24,ERM25,ERM26,ERM27,ERM28
002F56  1  CD 2E EE 2E  
002F5A  1  03 2F        
002F5C  1               ;STRING ACCUMULATOR
002F5C  1               ACCUM
002F5C  1  xx xx xx xx  	.res	32
002F60  1  xx xx xx xx  
002F64  1  xx xx xx xx  
002F7C  1               ;INPUT BUFFER
002F7C  1  50           INPBUF	.BYTE	80
002F7D  1               INPSPC
002F7D  1  xx xx xx xx  	.res	81
002F81  1  xx xx xx xx  
002F85  1  xx xx xx xx  
002FCE  1               ;NUMERIC OUT WORK AREA
002FCE  1  00           NUOWRK	.BYTE	0
002FCF  1               ;PRINT WORK AREA
002FCF  1               PRNWRK
002FCF  1  xx xx xx xx  	.res	14
002FD3  1  xx xx xx xx  
002FD7  1  xx xx xx xx  
002FDD  1               ;TEMP NUMBER STORAGE LOCATIONS
002FDD  1               T0
002FDD  1  xx xx xx xx  	.res	4
002FE1  1               T1
002FE1  1  xx xx xx xx  	.res	4
002FE5  1               T2
002FE5  1  xx xx xx xx  	.res	4
002FE9  1               T3
002FE9  1  xx xx xx xx  	.res	4
002FED  1               ;FCB POINTER ARRAYS
002FED  1  xx xx xx xx  FILES	.res	NUMFIL*2
002FF1  1  xx xx xx xx  
002FF5  1  xx xx xx xx  
003015  1               EOFBRN			;EOFBRANCH(NUMFILES)
003015  1  xx xx xx xx  	.res	NUMFIL*2
003019  1  xx xx xx xx  
00301D  1  xx xx xx xx  
00303D  1               MEMORY
00303D  1               ;BUILD
00303D  1               ;THE BUILD ROUTINE GAINS CONTROL AT INITIAL EXECUTION OF RUN.COM.  IT
00303D  1               ;INITIALIZES PAGE ZERO STORAGE AND THEN OPENS THE .INT FILE AND BUILDS
00303D  1               ;THE BASIC-E/65 MACHINE IN THE FOLLOWING ORDER.
00303D  1               ;	(1)	NUMERIC CONSTANTS ARE READ FROM THE .INT FILE, CONVERTED TO
00303D  1               ;		INTERNAL REPRESENTATION (I.E. FOUR BYTE FLOATING POINT) AND
00303D  1               ;		STORED IN THE FSA.
00303D  1               ;	(2)	THE SIZE OF THE CODE AREA, DATA AREA, AND NUMBER OF PRT ENTRIES
00303D  1               ;		ARE READ FROM THE .INT FILE.  BUILD THEN DETERMINES THE
00303D  1               ;		ABSOLUTE ADDRESS OF EACH SECTION OF THE BASIC-E/65 MACHINE.
00303D  1               ;		THESE ADDRESSES ARE PASSED TO THE MAIN INTERPRETER VIA FIXED
00303D  1               ;		PAGE ZERO LOCATIONS.
00303D  1               ;	(3)	FINALLY INSTRUCTIONS ARE READ FROM THE FILE AND PLACED IN
00303D  1               ;		EITHER THE DATA AREA OR THE CODE AREA.  IN THE CASE OF BRS,
00303D  1               ;		BRC, PRO, CON, AND DEF OPERATORS THE ADDRESS FOLLOWING THE
00303D  1               ;		INSTRUCTION IS RELOCATED TO REFLECT ACTUAL MACHINE ADDRESSES
00303D  1               ;		(MINUS 1 BECAUSE PROGRAM COUNTER GETS INCREMENTED PRIOR TO USE
00303D  1               ;		(EXCEPT FOR CON) !!) AFTER (REAPEAT AFTER) THE MACHINE HAS BEEN
00303D  1               ;		REPOSITIONED BY THE MAIN INTERPRETER.  THE END OF THE .INT FILE
00303D  1               ;		IS INDICATED BY A MACHINE INSTRUCTION OF $7F.
00303D  1               ;OPEN$INT$FILE
00303D  1  A9 49        OPNINT	LDA	#'I'		;SET EXTENSION TO INT
00303F  1  8D 10 01     	STA	DFLFCB+9
003042  1  A9 4E        	LDA	#'N'
003044  1  8D 11 01     	STA	DFLFCB+10
003047  1  A9 54        	LDA	#'T'
003049  1  8D 12 01     	STA	DFLFCB+11
00304C  1  A9 07        	LDA	#<DFLFCB
00304E  1  A0 01        	LDY	#>DFLFCB
003050  1  A2 0F        	LDX	#15
003052  1  20 03 01     	JSR	PEM		;TRY TO OPEN
003055  1  30 01        	BMI	*+3		;IF ERROR
003057  1  60           	RTS
003058  1  A9 0D        	LDA	#13		;NO INT FILE ERROR
00305A  1  4C B8 18     	JMP	ERROR
00305D  1               ;READ$INT$FILE
00305D  1               ;NEXT RECORD IS READ FROM INT FILE
00305D  1               ;RETURNS 0 IF OK OR A 1 IF EOF
00305D  1  A9 07        RDEINT	LDA	#<DFLFCB
00305F  1  A0 01        	LDY	#>DFLFCB
003061  1  A2 14        	LDX	#20
003063  1  4C 03 01     	JMP	PEM
003066  1               ;
003066  1  EE 62 08     INCBUF	INC	BUFF		;BUMP INDEX
003069  1  10 0F        	BPL	BE1		;DONE OF < 128
00306B  1  A9 00        	LDA	#0
00306D  1  8D 62 08     	STA	BUFF		;ELSE CLEAR INDEX
003070  1  20 5D 30     	JSR	RDEINT		;READ RECORD
003073  1  F0 05        	BEQ	BE1		;DONE IF OK
003075  1  A9 7F        	LDA	#$7F
003077  1  8D 28 01     	STA	BUF		;ELSE CHAR:=$7F
00307A  1  60           BE1	RTS
00307B  1               ;STO$CHAR$INC
00307B  1               ;GET NEXT CHAR FROM INT FILE AND PLACE IN CODE AREA THEN INCREMENT PTR INTO
00307B  1               ;CODE AREA
00307B  1  AC 62 08     STOINC	LDY	BUFF
00307E  1  B9 28 01     	LDA	BUF,Y
003081  1  A0 00        	LDY	#0
003083  1  91 86        	STA	(BASE),Y	;B:=CHAR
003085  1  E6 86        	INC	BASE
003087  1  D0 02        	BNE	*+4
003089  1  E6 87        	INC	BASE+1		;BASE:=BASE+1
00308B  1  60           	RTS
00308C  1               ;NEXT$CHAR
00308C  1  20 66 30     NXTCHR	JSR	INCBUF
00308F  1  AC 62 08     	LDY	BUFF
003092  1  B9 28 01     	LDA	BUF,Y
003095  1  8D 61 08     	STA	CURCHR		;CURCHR:=CHAR
003098  1  60           	RTS
003099  1               ;GET$TWO$BYTES
003099  1               ;GET NEXT TWO BYTES FROM THE INT FILE AND PLACE IN THE CODE AREA IN REVERSE
003099  1               ;ORDER
003099  1  20 8C 30     GETTWO	JSR	NXTCHR
00309C  1  A0 01        	LDY	#1
00309E  1  91 86        	STA	(BASE),Y	;BV(1)=NEXT$CHAR
0030A0  1  20 8C 30     	JSR	NXTCHR
0030A3  1  A0 00        	LDY	#0
0030A5  1  91 86        	STA	(BASE),Y	;BV(0)=NEXT$CHAR
0030A7  1  60           	RTS
0030A8  1               ;INC$BASE$TWO
0030A8  1  18           INCB2	CLC
0030A9  1  A5 86        	LDA	BASE
0030AB  1  69 02        	ADC	#2
0030AD  1  85 86        	STA	BASE
0030AF  1  90 02        	BCC	*+4
0030B1  1  E6 87        	INC	BASE+1		;BASE:=BASE+1+1
0030B3  1  60           	RTS
0030B4  1               ;GETPARM
0030B4  1               ;READ A 16 BIT PARAMETER FROM INT FILE AND CONVERT IT TO A 6502 ADDRESS
0030B4  1               ;QUANTITY
0030B4  1  20 8C 30     GETPRM	JSR	NXTCHR		;HIGH
0030B7  1  48           	PHA			;SAVE
0030B8  1  20 8C 30     	JSR	NXTCHR		;LOW
0030BB  1  AA           	TAX			;SAVE IN X AS TEMP
0030BC  1  68           	PLA
0030BD  1  A8           	TAY			;GET HIGH
0030BE  1  8A           	TXA			;AND LOW
0030BF  1  60           	RTS
0030C0  1               ;MAIN BUILD ROUTINE
0030C0  1               BUILD
0030C0  1               ;CLEAR ALL OF PAGE ZERO
0030C0  1  A2 02        	LDX	#2
0030C2  1  A9 00        	LDA	#0
0030C4  1  95 00        CLRZP	STA	0,X
0030C6  1  E8           	INX			;BUMP INDEX
0030C7  1  E0 8B        	CPX	#LZ		;SEE IF AT END
0030C9  1  D0 F9        	BNE	CLRZP
0030CB  1  A9 7F        	LDA	#127
0030CD  1  8D 62 08     	STA	BUFF		;SET BUFF TO ILLEGAL
0030D0  1  A2 19        	LDX	#25
0030D2  1  20 03 01     	JSR	PEM		;READ DEFAULT DRIVE
0030D5  1  8D 40 08     	STA	DFLDRV		;AND SAVE
0030D8  1  A9 68        	LDA	#<OPNMSG
0030DA  1  A0 32        	LDY	#>OPNMSG
0030DC  1  20 A7 15     	JSR	PRINT		;PRINT OPENING
0030DF  1  20 34 15     	JSR	CRLF
0030E2  1  20 3D 30     	JSR	OPNINT		;OPEN INT FILE
0030E5  1  A2 32        	LDX	#>BMEM
0030E7  1  E8           	INX
0030E8  1  86 87        	STX	BASE+1		;BASE:=(.MEMORY+$100) AND $FF00
0030EA  1  38           	SEC
0030EB  1  A5 86        	LDA	BASE
0030ED  1  E9 3D        	SBC	#<MEMORY
0030EF  1  8D 63 08     	STA	OFFSET
0030F2  1  A5 87        	LDA	BASE+1
0030F4  1  E9 30        	SBC	#>MEMORY
0030F6  1  8D 64 08     	STA	OFFSET+1	;OFFSET:=BASE-.MEMORY
0030F9  1               ;INITIALIZE FLOATING POINT PACKAGE - PAGE ZERO CLEAR DID IT
0030F9  1               ;PROCESS CONSTANTS - EACH CONSTANT IS TERMINATED BY AN  $ AND THE LAST IS
0030F9  1               ;FOLLOWED BY A *
0030F9  1  20 8C 30     BLDCON	JSR	NXTCHR
0030FC  1  8D 5C 2F     	STA	ACCUM		;ACCUM(0):=NEXT$CHAR
0030FF  1  C9 2A        	CMP	#'*'
003101  1  F0 30        	BEQ	ENDCON		;DONE IF *
003103  1  A9 00        	LDA	#0
003105  1  85 88        	STA	AP		;AP:=0
003107  1               ;DO ONE CONSTANT
003107  1  E6 88        BLD1C	INC	AP		;AP:=AP+1
003109  1  20 8C 30     	JSR	NXTCHR
00310C  1  A4 88        	LDY	AP
00310E  1  99 5C 2F     	STA	ACCUM,Y		;ACCUM(AP:=AP+1):=NEXT$CHAR
003111  1  C9 24        	CMP	#'$'
003113  1  D0 F2        	BNE	BLD1C		;DO WHILE <> $
003115  1  A9 5C        	LDA	#<ACCUM	;(ACTUALLY MOVES DATA FROM ACCUM TO ACCUM)
003117  1  A0 2F        	LDY	#>ACCUM
003119  1  A6 88        	LDX	AP
00311B  1  20 03 21     	JSR	FLTINP		;CONVERT TO FLOATING
00311E  1  A5 86        	LDA	BASE
003120  1  A4 87        	LDY	BASE+1
003122  1  20 C1 1C     	JSR	STP		;STORE AT (BASE)
003125  1  18           	CLC
003126  1  A5 86        	LDA	BASE
003128  1  69 04        	ADC	#4
00312A  1  85 86        	STA	BASE
00312C  1  90 CB        	BCC	BLDCON
00312E  1  E6 87        	INC	BASE+1		;BASE:=BASE+4
003130  1  4C F9 30     	JMP	BLDCON
003133  1               ;SETUP MACHINE ADDRESS
003133  1               ;BASE WILL NOW BE NEXT POSITION IN CODE AREA
003133  1               ;MBASE WILL BE NEXT POSITION IN DATA AREA
003133  1  20 B4 30     ENDCON	JSR	GETPRM
003136  1  18           	CLC
003137  1  65 86        	ADC	BASE
003139  1  85 70        	STA	MBASE
00313B  1  98           	TYA
00313C  1  65 87        	ADC	BASE+1
00313E  1  85 71        	STA	MBASE+1		;MBASE:=GETPARM+BASE
003140  1               ;ACTUAL DATA AREA ADDR
003140  1  38           	SEC
003141  1  A5 70        	LDA	MBASE
003143  1  ED 63 08     	SBC	OFFSET
003146  1  85 68        	STA	MDA
003148  1  A5 71        	LDA	MBASE+1
00314A  1  ED 64 08     	SBC	OFFSET+1
00314D  1  85 69        	STA	MDA+1		;MDA:=MBASE-OFFSET
00314F  1               ;ACTUAL CODE AREA ADDR
00314F  1  38           	SEC
003150  1  A5 86        	LDA	BASE
003152  1  ED 63 08     	SBC	OFFSET
003155  1  85 6A        	STA	MCD
003157  1  A5 87        	LDA	BASE+1
003159  1  ED 64 08     	SBC	OFFSET+1
00315C  1  85 6B        	STA	MCD+1		;MCD:=BASE-OFFSET
00315E  1               ;ACTUAL BEGINNING OF PRT
00315E  1  20 B4 30     	JSR	GETPRM
003161  1  18           	CLC
003162  1  65 68        	ADC	MDA
003164  1  85 66        	STA	MPR
003166  1  98           	TYA
003167  1  65 69        	ADC	MDA+1
003169  1  85 67        	STA	MPR+1		;MPR:=GETPARM+MDA
00316B  1               ;ENSURE THERE IS ENOUGH MEMORY
00316B  1  A5 66        	LDA	MPR
00316D  1  CD 04 01     	CMP	PEM+1
003170  1  A5 67        	LDA	MPR+1
003172  1  ED 05 01     	SBC	PEM+2
003175  1  90 05        	BCC	*+7		;OK IF MPR<MAX
003177  1  A9 17        	LDA	#23
003179  1  4C B8 18     	JMP	ERROR		;OUT OF MEMORY ERROR
00317C  1  20 B4 30     	JSR	GETPRM
00317F  1  85 62        	STA	SB
003181  1  84 63        	STY	SB+1
003183  1  06 62        	ASL	SB
003185  1  26 63        	ROL	SB+1
003187  1  06 62        	ASL	SB
003189  1  26 63        	ROL	SB+1		;SHL(GETPARM,2)
00318B  1  18           	CLC
00318C  1  A5 62        	LDA	SB
00318E  1  65 66        	ADC	MPR
003190  1  85 62        	STA	SB
003192  1  A5 63        	LDA	SB+1
003194  1  65 67        	ADC	MPR+1
003196  1  85 63        	STA	SB+1		;SB:=SHL(GETPARM,2)+MPR
003198  1               ;BUILD MACHINE AT LAST
003198  1               ;AS OPCODES ARE READ THEY MAY BE:
003198  1               ;	(1)	DAT-WHICH MEANS ALL CHARACTERS FOLLOWING DAT GO INTO DATA AREA
003198  1               ;		UNTIL A BINARY ZERO IS ENCOUNTERED
003198  1               ;	(2)	GREATER THAN 127 - WHICH IS A LIT OR LID.  TREAT THIS AS A 16
003198  1               ;		OPCODE AN PUT IN CODE AREA IN ORDER THEY ARE IN INT FILE
003198  1               ;	(3)	IRS - WHICH MEANS ALL CHARACTERS FOLLOWING GO INTO CODE AREA
003198  1               ;		UNTIL A BINARY ZERO IS ENCOUNTERED - BUT FIRST PUT AN ILS IN
003198  1               ;		CODE AREA AND THE NEXT BYTE IS SET TO ZERO AND INCREMENTED
003198  1               ;		FOR EACH CHARCETR IN THE STRING.  THUS A STRING CONSTANT IS AN
003198  1               ;		ILS OPCODE, A LENGTH, AND A STRING
003198  1               ;	(4)	A NORMAL OPCODE - PUT IN CODE AREA - BUT IF IT IS A BRS, BRC,
003198  1               ;		DEF, OR PRO THEN THE NEXT TWO BYTES ARE AN ADDRESS WHICH MUST
003198  1               ;		BE RELOCATED TO THE ACTUAL CODE AREA MINUS 1 - IT COULD ALSO
003198  1               ;		BE A CON WHICH IS RELOCATED TO THE FDA.
003198  1  20 8C 30     BLDMCH	JSR	NXTCHR
00319B  1  C9 7F        	CMP	#$7F
00319D  1  D0 03        	BNE	*+5		;DO WHILE NEXT$CHAR <> $7F
00319F  1  4C 38 2B     	JMP	MAIN		;ELSE GO TO MAIN
0031A2  1               ;SEE IF DAT
0031A2  1  C9 33        	CMP	#DAT		;IF CURCHAR <> DAT
0031A4  1  D0 14        	BNE	NOTDAT		;THEN
0031A6  1  20 8C 30     BLDDAT	JSR	NXTCHR
0031A9  1  A0 00        	LDY	#0
0031AB  1  91 70        	STA	(MBASE),Y	;MF:=NEXT$CHAR
0031AD  1  C9 00        	CMP	#0		;DO WHILE () <> 0
0031AF  1  F0 E7        	BEQ	BLDMCH		;START OVER IF IS 0
0031B1  1  E6 70        	INC	MBASE
0031B3  1  D0 F1        	BNE	BLDDAT
0031B5  1  E6 71        	INC	MBASE+1		;MBASE:=MBASE+1
0031B7  1  4C A6 31     	JMP	BLDDAT
0031BA  1               ;SEE IF LIT OR LID
0031BA  1  C9 80        NOTDAT	CMP	#128		;IF CURCHAR < 128
0031BC  1  90 0C        	BCC	NOTLIT		;THEN
0031BE  1  20 7B 30     	JSR	STOINC		;ELSE STO$CHAR$INC
0031C1  1  20 66 30     	JSR	INCBUF
0031C4  1  20 7B 30     	JSR	STOINC
0031C7  1  4C 98 31     	JMP	BLDMCH		;AND LOOP
0031CA  1               ;SEE IF ILS
0031CA  1  C9 1C        NOTLIT	CMP	#ILS
0031CC  1  D0 2A        	BNE	NOTILS
0031CE  1  20 7B 30     	JSR	STOINC		;STO$CHAR$INC
0031D1  1  A5 86        	LDA	BASE
0031D3  1  A4 87        	LDY	BASE+1
0031D5  1  85 89        	STA	TBASE
0031D7  1  84 8A        	STY	TBASE+1		;TEMP:=BASE
0031D9  1  AC 62 08     	LDY	BUFF
0031DC  1  A9 00        	LDA	#0
0031DE  1  99 28 01     	STA	BUF,Y		;CHAR:=0
0031E1  1  20 7B 30     	JSR	STOINC		;STO$CHAR$INC
0031E4  1  20 8C 30     BLDILS	JSR	NXTCHR		;DO WHILE NEXT$CHAR <> 0
0031E7  1  F0 AF        	BEQ	BLDMCH
0031E9  1  20 7B 30     	JSR	STOINC		;STO$CHAR$INC
0031EC  1  A0 00        	LDY	#0
0031EE  1  B1 89        	LDA	(TBASE),Y	;T:=T+1
0031F0  1  18           	CLC
0031F1  1  69 01        	ADC	#1
0031F3  1  91 89        	STA	(TBASE),Y
0031F5  1  4C E4 31     	JMP	BLDILS		;LOOP FOR MORE
0031F8  1               ;IS AN OPCODE
0031F8  1  20 7B 30     NOTILS	JSR	STOINC		;STO$CHAR$INC
0031FB  1  AD 61 08     	LDA	CURCHR
0031FE  1  C9 36        	CMP	#BRS
003200  1  F0 0C        	BEQ	DOADDR
003202  1  C9 37        	CMP	#BRC
003204  1  F0 08        	BEQ	DOADDR
003206  1  C9 5E        	CMP	#DEF
003208  1  F0 04        	BEQ	DOADDR
00320A  1  C9 1E        	CMP	#PRO
00320C  1  D0 29        	BNE	TRYCON		;IF BRS OR BRC OR DEF OR PRO THEN ELSE
00320E  1  20 99 30     DOADDR	JSR	GETTWO
003211  1  A0 00        	LDY	#0
003213  1  B1 86        	LDA	(BASE),Y	;LOW
003215  1  AA           	TAX
003216  1  C8           	INY
003217  1  B1 86        	LDA	(BASE),Y
003219  1  A8           	TAY
00321A  1  8A           	TXA
00321B  1  18           	CLC			;ADD MCD
00321C  1  65 6A        	ADC	MCD
00321E  1  AA           	TAX
00321F  1  98           	TYA
003220  1  65 6B        	ADC	MCD+1
003222  1  A8           	TAY
003223  1  8A           	TXA			;TEST LOW
003224  1  D0 01        	BNE	*+3
003226  1  88           	DEY
003227  1  CA           	DEX			;DROP BY ONE
003228  1  98           	TYA			;HIGH TO A
003229  1  A0 01        	LDY	#1
00322B  1  91 86        	STA	(BASE),Y
00322D  1  88           	DEY
00322E  1  8A           	TXA
00322F  1  91 86        	STA	(BASE),Y	;SET
003231  1  20 A8 30     	JSR	INCB2		;INC$BASE$TWO
003234  1  4C 98 31     	JMP	BLDMCH
003237  1               ;MAY BE CON
003237  1  C9 2E        TRYCON	CMP	#CON
003239  1  F0 03        	BEQ	*+5		;CONTINUE IF IS
00323B  1  4C 98 31     	JMP	BLDMCH		;ELSE GET NEXT
00323E  1  20 99 30     	JSR	GETTWO		;GET$TWO$BYTES
003241  1  A0 00        	LDY	#0
003243  1  B1 86        	LDA	(BASE),Y
003245  1  0A           	ASL	A		;LOW * 2
003246  1  AA           	TAX
003247  1  C8           	INY
003248  1  B1 86        	LDA	(BASE),Y
00324A  1  2A           	ROL	A
00324B  1  A8           	TAY
00324C  1  8A           	TXA
00324D  1  0A           	ASL	A
00324E  1  AA           	TAX
00324F  1  98           	TYA
003250  1  2A           	ROL	A
003251  1  A8           	TAY
003252  1  18           	CLC
003253  1  8A           	TXA
003254  1  69 3D        	ADC	#<MEMORY	;ADD OFFSET
003256  1  AA           	TAX
003257  1  98           	TYA
003258  1  69 30        	ADC	#>MEMORY
00325A  1  A0 01        	LDY	#1
00325C  1  91 86        	STA	(BASE),Y
00325E  1  88           	DEY
00325F  1  8A           	TXA
003260  1  91 86        	STA	(BASE),Y
003262  1  20 A8 30     	JSR	INCB2		;INC$BASE$TWO
003265  1  4C 98 31     	JMP	BLDMCH		;AND LOOP
003268  1               ;BUILD MESSAGES
003268  1  42 41 53 49  OPNMSG	.BYTE	"BASIC-E/65 INTERPRETER"
00326C  1  43 2D 45 2F  
003270  1  36 35 20 49  
00327E  1  20 2D 20 56  	.BYTE	" - VERSION 2.05-A$"
003282  1  45 52 53 49  
003286  1  4F 4E 20 32  
003290  1               ;BUILD MEMORY
003290  1               BMEM
003290  1               	.END
