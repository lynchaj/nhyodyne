;__TEST_PPP_______________________________________________________________________________________________________________________
;
; 	Test ParPortProp 6502
;
;	Entry points:
;		
;________________________________________________________________________________________________________________________________
;
;*
;* HARDWARE I/O ADDRESSES
;*


COLOSSUS6X0X	.EQU	1		; USE COLOSSUS 6X0X HARDWARE
ORIGINAL6X0X	.EQU	0		; USE ORIGINAL 6X0X HARDWARE

M6X0X_IOSPACE		.EQU	$E000
M6X0X_SHADOW_ROM 	.EQU	$F000



	  .IF ORIGINAL6X0X=1
DDRA		.EQU 	$F013
DDRB		.EQU 	$F012
DDRC		.EQU 	$F023
PIOA		.EQU 	$F01F
PIOB		.EQU 	$F010
PIOC		.EQU 	$F02F
	.ENDIF


	  .IF COLOSSUS6X0X=1
PIOA		.EQU 	M6X0X_IOSPACE+$EFC
CNTA		.EQU 	M6X0X_IOSPACE+$EFD
PIOB		.EQU 	M6X0X_IOSPACE+$EFE
CNTB		.EQU 	M6X0X_IOSPACE+$EFF
	.ENDIF	
	
	
CPUFREQ	.EQU	1


SECBUF		.EQU	0A000H
SAVBUF		.EQU	0B000H
BUFSIZ		.EQU	00200H

OUTMSG_W	.EQU	$30

PRINTVEC	.EQU	$FFF0
INPVEC		.EQU	$FFF2
INPWVEC		.EQU	$FFF4


;
		.ORG	$300
; SAVE PREVIOUS STACK POINTER, AND SWITCH TO OUR STACK
	
		LDA	#PPPSTR_BANNER &$FF
		LDY #PPPSTR_BANNER>>8 & $FF
		JSR	WRITESTR

		LDA	#PPPSTR_INTRO &$FF
		LDY #PPPSTR_INTRO>>8 & $FF
		JSR	WRITESTR

		LDA	#PPPSTR_CONFIRM &$FF
		LDY #PPPSTR_CONFIRM>>8 & $FF
		JSR	WRITESTR
	
CONF:
		JSR	CIN
		CMP	#$1B
		BEQ EXIT
		CMP	#$0D
		BNE CONF
	
; INITIALIZATION
		JSR	INIT
	
; PERFORM TESTS
		JSR	RUNTESTS

EXIT:	
; CLEAN UP AND RETURN TO OS
		JSR	NEWLINE
		JSR	NEWLINE
		BRK
	
			
INIT:
		LDA	#PPPSTR_INIT &$FF
		LDY #PPPSTR_INIT>>8 & $FF
		JSR	WRITESTR
		
		  .IF ORIGINAL6X0X=1
		LDA	#$00		; SET ALL PINS INPUT
		STA	DDRA		;
		LDA	#01101111B	; SET CONTROL PINS 
						; PC0=>CMD/DATA	[O]
						; PC1=> X  		[O]						
						; PC2=> RESET 	[O]
						; PC3=> X   	[O]
						; PC4=> STB 	[I]
						; PC5=> IBF 	[0]
						; PC6=> ACK 	[O]
						; PC7=> OBF 	[I]
						;
		STA	DDRC		;
		LDA	#$00		; SET ALL PINS INPUT
		STA	DDRB		;
		.ENDIF

		.IF COLOSSUS6X0X=1
		LDA	#$00		; SELECT DDR
		STA	CNTA
		LDA	#$00		; SET ALL PINS INPUT
		STA	PIOA		;
		LDA	#$00		; SELECT DDR
		STA	CNTB
		
		LDA	#01101111B	; SET CONTROL PINS 
						; PB0=>CMD/DATA	[O]
						; PB1=> X  		[O]						
						; PB2=> RESET 	[O]
						; PB3=> X   	[O]
						; PB4=> STB 	[I]
						; PB5=> IBF 	[0]
						; PB6=> ACK 	[O]
						; PB7=> OBF 	[I]
						;
		STA	PIOB		;

		LDA	#$04		; SELECT PIO
		STA	CNTA
		STA	CNTB

		.ENDIF
		
		
		
		JSR	PC_PERIOD
	
		JSR DELAY		; PROBABLY NOT NEEDED
	
		
		LDA	#00000100B	; ASSERT RESET  
		STA	PIOB
		JSR	PC_PERIOD
		JSR	DELAY		; PROBABLY NOT NEEDED
		
		LDA #00000001B	; DEASSERT RESET,  DATA
		STA	PIOB
		JSR	PC_PERIOD
		JSR	DELAY		; PROBABLY NOT NEEDED
		JSR	NEWLINE
INIT0:
		LDA	#$FF
		STA COUNTER &$FF
		STA COUNTER>>8 & $FF
		
		LDA PIOB		; BRING ACK HIGH
		ORA #01000000B
		STA PIOB	
		
INIT1:
						; WAIT FOR STB LOW (OUTPUT BUFFER READY)
		LDA PIOB		;
		AND	#00010000B	;
		BEQ	INIT2		;
INIT1A:
		JSR	DELAY
		JSR	DELAY
		JSR	DELAY
		JSR	DELAY
	
		DEC COUNTER &$FF
		LDA	COUNTER &$FF
		CMP #$FF
		BNE INIT1
		DEC COUNTER>>8 & $FF
		LDA COUNTER>>8 & $FF
		CMP #$FF
		BNE INIT1
	
	
		LDA	#PPPSTR_TIMEOUT &$FF
		LDY	#PPPSTR_TIMEOUT>>8 & $FF
		JSR	WRITESTR
		JSR	PC_SPACE
		LDA #$01
		JSR	PRINT_BYTE
		JSR	NEWLINE
		BRK
		RTS

INIT2:
		LDA PIOA		;IS $AA?
		CMP #$AA
		BNE	INIT1A		; NO, STILL INIT IN PROCESS
		
		LDA PIOB		; YES, BRING ACK LOW
		AND #10111111B
		STA PIOB
INIT3:					; WAIT FOR STB HIGH
		LDA PIOB
		AND #00010000B
		BEQ	INIT3
		LDA PIOB		; BRING ACK HIGH
		ORA #01000000B
		STA PIOB
		
		JSR	NEWLINE
		LDA	#PPPSTR_OK &$FF
		LDY #PPPSTR_OK>>8 & $FF
		JSR	WRITESTR
	
		LDA #$00
		RTS
	
RUNTESTS:
		JSR	TEST1
		BCS	ABORT_RUNTESTS	

		JSR	TEST2
		BCS	ABORT_RUNTESTS	
	
		JSR	TEST3
		BCS	ABORT_RUNTESTS	
	
		JSR	TEST4
		BCS	ABORT_RUNTESTS	
	
		JSR	TEST5
		BCS	ABORT_RUNTESTS	
	
		JSR	TEST6
		BCS	ABORT_RUNTESTS	
	
		JSR	TEST7
		BCS	ABORT_RUNTESTS	
;	
;		JSR	TEST8
;		BCS	ABORT_RUNTESTS	
;	
;		JSR	TEST9
	
ABORT_RUNTESTS:
		RTS
	
TEST1:
		LDA	#PPPSTR_BYTEECHO &$FF
		LDY	#PPPSTR_BYTEECHO>>8 & $FF
		JSR	WRITESTR

		LDA	#$10
		STA COUNTER
		LDY #$AA
TEST1A:
		JSR	PC_PERIOD
		JSR	DOECHO
		BNE TEST1_ERR
		TYA
		EOR	#$FF
		TAY
		DEC COUNTER
		LDA	COUNTER		
		CMP #$00
		BNE TEST1A
		
		LDA	#PPPSTR_OK &$FF
		LDY	#PPPSTR_OK>>8 & $FF
		JSR	WRITESTR

		CLC
		RTS

TEST1_ERR:
		LDA	#PPPSTR_CMPERR &$FF
		LDY	#PPPSTR_CMPERR>>8 & $FF
		JSR	WRITESTR

		SEC
		RTS

; ECHO BYTE Y=BYTE			
DOECHO:
		LDA #$01		; CMD=ECHOBYTE
		JSR	SENDCMD
		
		TYA			
		JSR	PUTBYTE
		JSR	GETBYTE
		STA TEMP
		TYA
		EOR #$FF
		CMP TEMP
		RTS

		
TEST2:
		LDA	#PPPSTR_BUFECHO &$FF
		LDY	#PPPSTR_BUFECHO>>8 & $FF
		JSR	WRITESTR
	
TEST2A:
		JSR	PC_PERIOD
		JSR	DOBUFECHO
		BCS TEST2_ERR


		LDA	#PPPSTR_OK &$FF
		LDY	#PPPSTR_OK>>8 & $FF
		JSR	WRITESTR

		CLC
		RTS
	
TEST2_ERR:

		LDA	#PPPSTR_CMPERR &$FF
		LDY	#PPPSTR_CMPERR>>8 & $FF
		JSR	WRITESTR
		JSR NEWLINE
		SEC
		RTS

	
DOBUFECHO:
		LDA #$02		; CMD=ECHOBUF
		JSR	SENDCMD
	
		JSR	PAT_BUFFER
		JSR	SAVE_BUFFER
		JSR	PUTBUF
		JSR	FILL_BUFFER
		JSR	GETBUF
		JSR	CMP_BUFFER
		RTS
	
PUTBUF:
		LDX #$00
PUTBUF1:
		LDA SECBUF,X
		JSR	PUTBYTE
		INX
		CPX #$00
		BNE PUTBUF1
PUTBUF2:
		LDA SECBUF+256,X
		JSR	PUTBYTE
		INX
		CPX #$00
		BNE PUTBUF2
		RTS		
	
GETBUF:
		LDX #$00
GETBUF1:		
		JSR	GETBYTE
		STA SECBUF,X
		INX
		CPX #$00
		BNE GETBUF1
GETBUF2:
		JSR	GETBYTE
		STA SECBUF+256,X
		INX
		CPX #$00
		BNE GETBUF2
		RTS		
		
TEST3:
		LDA	#PPPSTR_ABTTST &$FF
		LDY	#PPPSTR_ABTTST>>8 & $FF
		JSR	WRITESTR

		
		LDA	#$12
		JSR	SENDCMD
		LDX #$50			; UNDERFLOW ON PUTBUF
		JSR	PUTBUF1
		LDA	#$00
		JSR	SENDCMD
		JSR	PC_PERIOD
	
		LDA	#$12
		JSR	SENDCMD
		JSR PUTBUF
		LDX #$E0			; UNDERFLOW ON PUTBUF
		JSR	PUTBUF2

		LDA	#$00
		JSR	SENDCMD
		JSR	PC_PERIOD

		LDA	#$13
		JSR	SENDCMD
		LDX #$50			; UNDERFLOW ON GETBUF
		JSR	GETBUF1
		LDA	#$00
		JSR	SENDCMD
		JSR	PC_PERIOD
	
		LDA	#PPPSTR_OK &$FF
		LDY	#PPPSTR_OK>>8 & $FF
		JSR	WRITESTR

		CLC
		RTS

TEST4:
		LDA	#PPPSTR_DISKRW &$FF
		LDY	#PPPSTR_DISKRW>>8 & $FF
		JSR	WRITESTR

		JSR DSKRESET
		BCS TEST4_IOERR
		JSR	PC_PERIOD

		JSR	PAT_BUFFER
		JSR	SAVE_BUFFER

		LDA #$10
		STA COUNTER
TEST4A:

		LDA #$00
		STA	PPP_LBAHI
		LDA #$00
		STA	PPP_LBAHI+1
		LDA $6713
		STA	PPP_LBALO
		LDA $542A
		STA	PPP_LBALO+1
		JSR	DSKRW
		BCS TEST4_IOERR
		JSR	CMP_BUFFER
		BCS TEST4_CMPERR

		JSR	PC_PERIOD
	
		DEC COUNTER
		LDA	COUNTER		
		CMP #$00
		BNE TEST4A

	
		LDA	#PPPSTR_OK &$FF
		LDY	#PPPSTR_OK>>8 & $FF
		JSR	WRITESTR

		CLC
		RTS


TEST4_IOERR:
		LDA	#PPPSTR_IOERR &$FF
		LDY	#PPPSTR_IOERR>>8 & $FF
		JSR	WRITESTR

		LDA	#PPPSTR_DSKSTAT &$FF
		LDY	#PPPSTR_DSKSTAT>>8 & $FF
		JSR	WRITESTR

		JSR	DSKSTAT
		LDA	PPP_DSKSTHI
		JSR	PRINT_BYTE
		LDA	PPP_DSKSTHI+1
		JSR	PRINT_BYTE
		LDA PPP_DSKSTLO
		JSR	PRINT_BYTE
		LDA PPP_DSKSTLO+1
		JSR	PRINT_BYTE
		SEC
		RTS
	
TEST4_CMPERR:
		LDA	#PPPSTR_CMPERR &$FF
		LDY	#PPPSTR_CMPERR>>8 & $FF
		JSR	WRITESTR
		JSR NEWLINE
		SEC
		RTS

DSKRW:
		JSR	FILL_BUFFER
		JSR	DSKWRITE
		BCS DSKRW_ABORT
	

		JSR FILL_BUFFER
		JSR	DSKREAD
		BCS DSKRW_ABORT
	
		JSR	PAT_BUFFER
		JSR	DSKWRITE
		BCS DSKRW_ABORT

		JSR	FILL_BUFFER
		JSR	DSKREAD
		BCS DSKRW_ABORT

		CLC
		RTS
		
DSKRW_ABORT:
		SEC
		RTS		

		
DSKRESET:
	; RESET & STATUS DISK
		LDA #$10
		JSR	SENDCMD
		JSR	GETBYTE
		CMP #$00
		BEQ DSKRESET1
		SEC
		RTS		
DSKRESET1:
		CLC
		RTS	


DSKSTAT:	
		LDA	#$11		; COMMAND = DSKSTAT
		JSR	SENDCMD
		LDX #$00
		JSR	GETBYTE
		STA PPP_DSKSTAT,X
		INX
		JSR	GETBYTE
		STA PPP_DSKSTAT,X
		INX
		JSR	GETBYTE
		STA PPP_DSKSTAT,X
		INX
		JSR	GETBYTE
		STA PPP_DSKSTAT,X
		INX
		RTS	


DSKREAD:	
		; READ A SECTOR
		LDA #$14		; COMMAND = DSKRD
		JSR	SENDCMD
		LDX #$00
		LDA	PPP_LBA,X
		JSR PUTBYTE
		INX
		LDA	PPP_LBA,X
		JSR PUTBYTE
		INX
		LDA	PPP_LBA,X
		JSR PUTBYTE
		INX
		LDA	PPP_LBA,X
		JSR PUTBYTE

		JSR	GETBYTE		; GET RESULT
		CMP #$00
		BNE	DSKREAD_ERROR
	
		LDA	#$13		; COMMAND = DSKGET
		JSR	SENDCMD
		JSR GETBUF
		CLC
		RTS
		
DSKREAD_ERROR:
		SEC
		RTS		
	
DSKWRITE:	
				; WRITE A SECTOR
		LDA #$12				
		JSR SENDCMD
		JSR PUTBUF

		LDA #$15
		JSR SENDCMD

		LDX #$00
		LDA	PPP_LBA,X
		JSR PUTBYTE
		INX
		LDA	PPP_LBA,X
		JSR PUTBYTE
		INX
		LDA	PPP_LBA,X
		JSR PUTBYTE
		INX
		LDA	PPP_LBA,X
		JSR PUTBYTE
		
		JSR	GETBYTE		; GET RESULT
		CMP #$00
		BNE	DSKWRITE_ERROR	
		CLC
		RTS
		
DSKWRITE_ERROR:
		SEC
		RTS		
		

TEST5:

		LDA	#PPPSTR_VIDEO &$FF
		LDY	#PPPSTR_VIDEO>>8 & $FF
		JSR	WRITESTR

	
		LDA	#CHR_CR
		JSR	VIDOUT
		LDA	#CHR_LF
		JSR	VIDOUT
		LDX #26
		LDY	#'A'-1
		
TEST5A:
		INY
		TYA	
		JSR	VIDOUT
		JSR	PC_PERIOD
		DEX
		CPX #$00
		BNE TEST5A
		
		LDA	#CHR_CR
		JSR	VIDOUT
		LDA	#CHR_LF
		JSR	VIDOUT
	
		LDA	#PPPSTR_OK &$FF
		LDY	#PPPSTR_OK>>8 & $FF
		JSR	WRITESTR

		CLC
		RTS
		
VIDOUT:
		PHA
		LDA	#$20
		JSR	SENDCMD
		PLA

		JSR	PUTBYTE
		RTS

		
	
	
TEST6:
		LDA	#PPPSTR_KEYBOARD &$FF
		LDY	#PPPSTR_KEYBOARD>>8 & $FF
		JSR	WRITESTR

		LDX #$00		
TEST6X:
		LDA	(PPSTR_KBDPRMPT),X
		INX
		CMP	#'$'
		BEQ TEST6A
		JSR VIDOUT
		JMP	TEST6X

TEST6A:	
		JSR	KBDIN
		CMP #$1B
		BEQ TEST6B
		JSR	PC_PERIOD
		JSR	VIDOUT
		JMP	TEST6A

TEST6B:
		LDA	#CHR_CR
		JSR	VIDOUT
		LDA #CHR_LF
		JSR	VIDOUT

		LDA	#PPPSTR_OK &$FF
		LDY	#PPPSTR_OK>>8 & $FF
		JSR	WRITESTR

		CLC	
		RTS
	
TEST7:
	
		LDA	#PPPSTR_SPEAKER &$FF
		LDY	#PPPSTR_SPEAKER>>8 & $FF
		JSR	WRITESTR
	
		LDX	#16
TEST7A:
		DEX
		CPX	#$00
		BNE	TEST7B
		JMP TEST7C
TEST7B:
	
		LDA #$40	; SPEAKER TONE
		JSR SENDCMD
		TXA
		ROL
		ROL
		ROL
		ROL

		JSR	PUTBYTE
		LDA #16	; DURATION = 16/256 = 1/16 SEC
		JSR	PUTBYTE
		JSR	PC_PERIOD
		JMP TEST7A
	
TEST7C:
		LDA	#PPPSTR_OK &$FF
		LDY	#PPPSTR_OK>>8 & $FF
		JSR	WRITESTR
		CLC
		RTS
			
KBDIN:
		LDA #$31
		JSR	SENDCMD
		JSR	GETBYTE
		RTS

			

	
		  .IF ORIGINAL6X0X=1	
		  ; SEND COMMAND (A=COMMAND)	
SENDCMD:
		STA TEMP		
SENDCMD1:
		LDA PIOC		;
		AND	#11111110B	; SET CMD FLAG
		STA PIOC		; SEND IT
		LDA TEMP
		JSR	PUTBYTE		; SEND THE COMMAND BYTE
						; TURN OFF CMD
		LDA PIOC		;
		ORA	#00000001B	; CLEAR CMD FLAG
		STA PIOC		; SEND IT	
		LDA	TEMP
		RTS
		  	
PUTBYTE:
		PHA
		LDA	#$FF		; SET ALL PINS OUTPUT
		STA	DDRA		;
		LDA PIOC		; BRING ACK HIGH
		ORA #01000000B
		STA PIOC
PUTWAIT1:
						; WAIT FOR OBF HIGH 
		LDA PIOC		;
		AND	#10000000B	;
		BEQ	PUTWAIT1	;
		PLA
		STA	PIOA
		LDA PIOC		; BRING ACK LOW
		AND #10111111B
		STA PIOC
PUTWAIT2:
						; WAIT FOR OBF LOW
		LDA PIOC		;
		AND	#10000000B	;
		BNE	PUTWAIT2	;
		LDA PIOC		; BRING ACK HIGH
		ORA #01000000B
		STA PIOC	
		RTS	
		
	
GETBYTE:
		LDA	#$00		; SET ALL PINS INPUT
		STA	DDRA		;
		LDA PIOC		; BRING ACK HIGH
		ORA #01000000B
		STA PIOC
GETWAIT1:
						; WAIT FOR STB LOW 
		LDA PIOC		;
		AND	#00010000B	;
		BNE	GETWAIT1	;
		LDA PIOA
		PHA
		LDA PIOC		; BRING ACK LOW
		AND #10111111B
		STA PIOC
GETWAIT2:
						; WAIT FOR STB HIGH
		LDA PIOC		;
		AND	#00010000B	;
		BEQ	GETWAIT2	;
		LDA PIOC		; BRING ACK HIGH
		ORA #01000000B
		STA PIOC
		PLA		
		RTS
		.ENDIF

		
	  .IF COLOSSUS6X0X=1
	  
; SEND COMMAND (A=COMMAND)	
SENDCMD:
		STA TEMP		
SENDCMD1:
		LDA PIOB		;
		AND	#11111110B	; SET CMD FLAG
		STA PIOB		; SEND IT
		LDA TEMP
		JSR	PUTBYTE		; SEND THE COMMAND BYTE
						; TURN OFF CMD
		LDA PIOB		;
		ORA	#00000001B	; CLEAR CMD FLAG
		STA PIOB		; SEND IT	
		LDA	TEMP
		RTS
	  	  
PUTBYTE:
		PHA
		LDA	#$00
		STA	CNTA
		LDA	#$FF		; SET ALL PINS OUTPUT
		STA	PIOA		;
		LDA 	#$04
		STA	CNTA
		LDA PIOB		; BRING ACK HIGH
		ORA #01000000B
		STA PIOB
PUTWAIT1:
						; WAIT FOR OBF HIGH 
		LDA PIOB		;
		AND	#10000000B	;
		BEQ	PUTWAIT1	;
		PLA
		STA	PIOA
		LDA PIOB		; BRING ACK LOW
		AND #10111111B
		STA PIOB
PUTWAIT2:
						; WAIT FOR OBF LOW
		LDA PIOB		;
		AND	#10000000B	;
		BNE	PUTWAIT2	;
		LDA PIOB		; BRING ACK HIGH
		ORA #01000000B
		STA PIOB	
		RTS	
		
	
GETBYTE:
		LDA	#$00
		STA	CNTA
		LDA	#$00		; SET ALL PINS INPUT
		STA	PIOA		;
		LDA	#$04
		STA	CNTA		
		LDA PIOB		; BRING ACK HIGH
		ORA #01000000B
		STA PIOB
GETWAIT1:
						; WAIT FOR STB LOW 
		LDA PIOB		;
		AND	#00010000B	;
		BNE	GETWAIT1	;
		LDA PIOA
		PHA
		LDA PIOB		; BRING ACK LOW
		AND #10111111B
		STA PIOB
GETWAIT2:
						; WAIT FOR STB HIGH
		LDA PIOB		;
		AND	#00010000B	;
		BEQ	GETWAIT2	;
		LDA PIOB		; BRING ACK HIGH
		ORA #01000000B
		STA PIOB
		PLA		
		RTS
		.ENDIF
		
				
;
;
;
TEMP			.DB	0
PPP_LBA:
PPP_LBALO		.DW	0
PPP_LBAHI		.DW	0
PPP_DSKSTAT:
PPP_DSKSTLO		.DW	0
PPP_DSKSTHI		.DW	0
;
PPPSTR_INIT		.TEXT	"\r\nInitializing$"
PPPSTR_BYTEECHO	.TEXT	"\r\nByte echo$"
PPPSTR_BUFECHO	.TEXT	"\r\nBuffer echo$"
PPPSTR_ABTTST	.TEXT	"\r\nAbort command test$"
PPPSTR_DISKRW	.TEXT	"\r\nDisk Read/Write$"
PPPSTR_VIDEO	.TEXT	"\r\nVideo$"
PPPSTR_KEYBOARD	.TEXT	"\r\nKeyboard$"
PPPSTR_SPEAKER	.TEXT	"\r\nSpeaker$"
PPPSTR_SIOLOOP	.TEXT	"\r\nSerial Port Loopback$"
PPPSTR_SIOBUF	.TEXT	"\r\nSerial Port Buffer$"
PPPSTR_CMPERR	.TEXT	"\r\n*COMPARE ERROR*$"
PPPSTR_IOERR	.TEXT	"\r\n*IO ERROR*$"
PPPSTR_DSKSTAT	.TEXT	"\r\nDISK STATUS=$"
PPPSTR_OK		.TEXT	"OK$"
PPPSTR_TIMEOUT	.TEXT	"TIMEOUT!$"
PPPSTR_CMD		.TEXT	"CMD=$"
PPPSTR_RSP		.TEXT	"RESP=$"
PPSTR_KBDPRMPT	.TEXT	"\r\nPress keys on keyboard, <esc> to exit\r\n$"
PPSTR_SIOPRMPT	.TEXT	"\r\nPress keys on serial terminal, <esc> to exit\r\n$"
PPPSTR_BANNER	.TEXT	"\r\nParPortProp Hardware Validation v0.9\r\n\r\n$"
PPPSTR_INTRO	.TEXT	"Instructions:\r\n"
				.TEXT	"  - Program ParPortProp \r\n"
				.TEXT	"  - Insert SD Card (EXISTING DATA WILL BE DESTROYED!!!)\r\n"
				.TEXT	"  - Attach a VGA monitor and PS/2 keyboard\r\n"
				.TEXT	"  - Cross connect pins 2 & 3 of DE-9 serial port\r\n"
				.TEXT	"  - Press <Esc> on kbd to end kbd test\r\n$"
PPPSTR_CONFIRM	.TEXT	"\r\nPress <Enter> to continue, <Esc> to abort$"

;
;==================================================================================================
; UTILITY FUNCTIONS
;==================================================================================================
;
;
CHR_CR		.EQU	0DH
CHR_LF		.EQU	0AH
CHR_BS		.EQU	08H
CHR_ESC		.EQU	1BH
;
;__________________________________________________________________________________________________
;
; UTILITY PROCS TO PRINT SINGLE CHARACTERS WITHOUT TRASHING ANY REGISTERS
;
PC_SPACE:
		PHA
		LDA #' '
		JSR COUT	  		; PRINT CHAR IN ACC
		PLA
		RTS

PC_PERIOD:
		PHA
		LDA #'.'
		JSR COUT	  		; PRINT CHAR IN ACC
		PLA
		RTS

PC_COLON:
		PHA
		LDA #':'
		JSR COUT	  		; PRINT CHAR IN ACC
		PLA
		RTS

PC_LBKT:
		PHA
		LDA #'['
		JSR COUT	  		; PRINT CHAR IN ACC
		PLA
		RTS

PC_RBKT:
		PHA
		LDA #']'
		JSR COUT	  		; PRINT CHAR IN ACC
		PLA
		RTS

PC_CR:
		PHA
		LDA #CHR_CR
		JSR COUT	  		; PRINT CHAR IN ACC
		PLA
		RTS

PC_LF:
		PHA
		LDA	#CHR_LF
		JSR COUT	  		; PRINT CHAR IN ACC
		PLA
		RTS

PC_STROBELOW:
		PHA
		LDA	#'S'
		JSR COUT	  		; PRINT CHAR IN ACC
		LDA	#'v'
		JSR COUT	  		; PRINT CHAR IN ACC
		PLA
		RTS


PC_STROBEHIGH:
		PHA
		LDA	#'S'
		JSR COUT	  		; PRINT CHAR IN ACC
		LDA	#'^'
		JSR COUT	  		; PRINT CHAR IN ACC
		PLA
		RTS

NEWLINE:
	JSR	PC_CR
	JSR	PC_LF
	RTS

	
;__PRINT_BYTE__________________________________________________
;
; PRINT OUT ACCUMULATOR AS HEX NUMBER 
;
;______________________________________________________________
PRINT_BYTE:     
               TAX					; SAVE A REGISTER
               LSR A				; SHIFT HIGH NIBBLE TO LOW NIBBLE
               LSR A				;
               LSR A				;
               LSR A				;
               CLC               	; CLEAR CARRY
               JSR PRINT_DIGIT		; PRINT LOW NIBBLE
               TXA					; RESTORE ACCUMULATOR
               JMP PRINT_DIGIT		; PRINT LOW NIBBLE

;__PRINT_DIGIT_________________________________________________
;
; PRINT OUT LOW NIBBLE OF ACCUMULATOR IN HEX  
;
;______________________________________________________________
PRINT_DIGIT:
               AND #$0F				; STRIP OFF HIGH NIBBLE				
               ORA #$30				; ADD $30 TO PRODUCE ASCII
               CMP #$3A             ; IS GREATER THAN 9
               BMI PRINT_DIGIT_OUT	; NO, SKIP ADD
               CLC					; CLEAR CARRY
               ADC #$07				; ADD ON FOR LETTER VALUES
PRINT_DIGIT_OUT:					;	
               JMP COUT	            ; PRINT OUT CHAR

;
; OUTPUT A '$' TERMINATED STRING
;
WRITESTR:
		STA OUTMSG_W 
		STY OUTMSG_W+1
		LDY #$00
WRITESTR1:
       	LDA (OUTMSG_W),Y 	; LOAD NEXT CHAR FROM STRING INTO ACC
       	CMP #'$'			; IS END?
       	BEQ ENDOUTSTR		; YES, END PRINT OUT
       	JSR COUT	  		; PRINT CHAR IN ACC
       	INY 	     		; Y=Y+1 (BUMP INDEX)
       	JMP WRITESTR1		; DO NEXT CHAR
ENDOUTSTR:
       	RTS					; RETURN
       	

       	       	
COUT:
		JMP (PRINTVEC)
		
CIN:
		JMP (INPVEC)

		
;
; INITIALIZE BUFFER WITH FILLER BYTE $FF
;
FILL_BUFFER:
		LDX #$00
FILL_BUFFER1:
		LDA #$FF
		STA SECBUF,X
		INX
		CPX #$00
		BNE FILL_BUFFER1
FILL_BUFFER2:
		LDA #$FF
		STA SECBUF+256,X
		INX
		CPX #$00
		BNE FILL_BUFFER2
		RTS		

;
; INITIALIZE BUFFER WITH PATTERN 00-FF
;
PAT_BUFFER:
		LDX #$00
		LDA #$00
		STA COUNTER1
PAT_BUFFER1:
		INC COUNTER1
		LDA COUNTER1
		STA SECBUF,X
		INX
		CPX #$00
		BNE PAT_BUFFER1
PAT_BUFFER2:
		INC COUNTER1
		LDA COUNTER1
		STA SECBUF+256,X
		INX
		CPX #$00
		BNE PAT_BUFFER2
		RTS		
;
; SAVE_BUFFER
;	
SAVE_BUFFER:
		LDX #$00
SAVE_BUFFER1:
		LDA SECBUF,X
		STA SAVBUF,X
		INX
		CPX #$00
		BNE SAVE_BUFFER1
SAVE_BUFFER2:
		LDA SECBUF+256,X
		STA SAVBUF+256,X
		INX
		CPX #$00
		BNE SAVE_BUFFER2
		RTS		

;
; CMP_BUFFER
;   HL = ADDRESS OF SOURCE BUFFER
;   DE = ADDRESS OF DESTINATION BUFFER
;   BC = SIZE OF BUFFER
;   RETURNS Z IF EQUAL, NZ IF DIFFERENT
;
CMP_BUFFER:
		LDX #$00
CMP_BUFFER1:
		LDA SECBUF,X
		STA TEMP
		LDA SAVBUF,X
		CMP TEMP
		BNE CMP_BUFFER_MISMATCH
		INX
		CPX #$00
		BNE CMP_BUFFER1
CMP_BUFFER2:
		LDA SECBUF+256,X
		STA TEMP
		LDA SAVBUF+256,X
		CMP TEMP
		BNE CMP_BUFFER_MISMATCH
		INX
		CPX #$00
		BNE CMP_BUFFER2
		CLC
		RTS

CMP_BUFFER_MISMATCH:
		SEC
		RTS

					
		       	
;
; PANIC: TRY TO DUMP MACHINE STATE AND HALT
;
PANIC:
	BRK

	
;
; DELAY 
;
DELAY:
	PHA
	LDA #$00
DELAY1:
	DEC
	PHA
	PLA
	PHA
	PLA
	PHA
	PLA
	PHA
	PLA
	PHA
	PLA
	PHA
	PLA
	PHA
	PLA
	PHA
	PLA
	PHA
	PLA
	PHA
	PLA
	PHA
	PLA
	PHA
	PLA
	PHA
	PLA
	PHA
	PLA
	PHA
	PLA	
	CMP #00
	BNE DELAY1	
	PLA
	RTS

;
;
;
STR_EMPTY		.TEXT	"<EMPTY>$"
HEXSTRBUF		.TEXT	"XX$"
STR_SRC			.TEXT	"SOURCE: $"
STR_DEST		.TEXT	"DESTINATION: $"
STR_BEFORE		.TEXT	"BEFORE:$"
STR_AFTER		.TEXT	"AFTER:$"
STR_REGS		.TEXT	"REGISTERS: $"
STR_MISMATCH	.TEXT	"\r\n\r\n*** DATA MISMATCH AT $"
STR_IDENTITY	.TEXT	"\r\n\r\nDEVICE IDENTITY DATA:\r\n$"
STR_FILLTEST	.TEXT	"\r\n\r\nPERFORMING FILL TEST...$"
STR_PATTEST		.TEXT	"\r\n\r\nPERFORMING PATTERN TEST...$"
STR_RNDTEST		.TEXT	"\r\n\r\nPERFORMING RANDOM TEST...$"
STR_PROBTEST	.TEXT	"\r\n\r\nPERFORMING PROBLEM BUFFER TEST...$"
STR_SUCCESS		.TEXT	"\r\n\r\nALL TESTS COMPLETED -- NO ERRORS\r\n$"
STR_FAILURE		.TEXT	"\r\n\r\nTEST FAILURE -- REVIEW ERRORS\r\n$"
STR_SAR			.TEXT	" SAR=$"
STR_DAR			.TEXT	" DAR=$"
STR_BCR			.TEXT	" BCR=$"
STR_DSTAT		.TEXT	" DSTAT=$"
STR_DMODE		.TEXT	" DMODE=$"
STR_DCNTL		.TEXT	" DCNTL=$"


COUNTER		.DW	0
COUNTER1	.DW	0


	.END
	