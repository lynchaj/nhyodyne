ca65 V2.18 - Ubuntu 2.18-1
Main file   : DOS65.ASM
Current file: DOS65.ASM

000000r 1               ;sysgen
000000r 1               ;version 2.15-a
000000r 1               ;released:	30 november 1985 (2.10)
000000r 1               ;last revised:	2 may 1996 (2.11)
000000r 1               ;			eliminated word mode for 1024 blocks
000000r 1               ;			made extent a single byte
000000r 1               ;		3 may 1996 (2.12)
000000r 1               ;			added initial exm related code
000000r 1               ;		11 may 1996 (2.13)
000000r 1               ;			added use of exm in getblk
000000r 1               ;			added code to set exm & cexm1f
000000r 1               ;			corrected errors
000000r 1               ;		19 may 1996 (2.14)
000000r 1               ;			changed ccm ren to "to from" syntax
000000r 1               ;			allowed _ in file names
000000r 1               ;		13 march 2008 (2.15)
000000r 1               ;			reformatted for TASM & ASM210+
000000r 1               ;			eliminated dependence on "IBM" format
000000r 1               ;			  by reading first sector # using SIM+51
000000r 1               ;			  TRANSLATE code. If translate
000000r 1               ;			  does not have first physical sector in first
000000r 1               ;			  position this approach may not work.
000000r 1               ;			  SIM can also perform no translation at all.
000000r 1               ;			  Also assumes BOOT & SIM both know correct
000000r 1               ;			  starting sector for cold & warm boot. It
000000r 1               ;			  should work regardless of physical sector
000000r 1               ;			  size as long as existing SIM is configured
000000r 1               ;			  correctly for destination drive. BOOT
000000r 1               ;			  must correctly handle sectors > 128 bytes
000000r 1               ;			  as must WARM BOOT in SIM.
000000r 1               ;			  In any case BOOT and WARM BOOT must
000000r 1               ;			  read sectors in sequential order, i.e.,
000000r 1               ;			  no interleave.
000000r 1               ;this program contains the complete dos/65 operating
000000r 1               ;system except for the boot and sim.
000000r 1               ;when used by the system operator this program
000000r 1               ;provides the capability to construct a new
000000r 1               ;operating system including the users boot and sim.
000000r 1               ;the system is relocated to fit the memory size
000000r 1               ;specified by the user and is written onto
000000r 1               ;the system tracks of the specified drive.
000000r 1               ;improvements over version 2.0 include:
000000r 1               ;	use of "from to" syntax for ren
000000r 1               ;	addition of go command
000000r 1               ;	addition of load command
000000r 1               ;	ability to enter numbers as decimal or hex
000000r 1               ;	address parameter added to save
000000r 1               ;	error checking in sysgen (write)
000000r 1               ;	write type for deblocking added
000000r 1               ;	page zero 0 & 1 not used
000000r 1               ;	allow _ in file names
000000r 1               ;base addresses and definitions
000000r 1               btejmp	=	$100		;warm boot jump
000000r 1               pemjmp	=	$103		;jump to pem
000000r 1               iostat	=	$106		;i/o status
000000r 1               dflfcb	=	$107		;default fcb
000000r 1               dflbuf	=	$128		;default buffer
000000r 1               tea	=	$800		;tea start
000000r 1               ccmlng	=	2048		;ccm length
000000r 1               pemlng	=	3072		;pem length
000000r 1               ;zero page for setup
000000r 1               trknum	=	$02		;current track
000000r 1               dcbadd	=	$04			;dcb address
000000r 1               nmsstr	=	$06			;number system tracks
000000r 1               nsectr	=	$08			;number sectors per track
000000r 1               ttlsec	=	$0A			;total sectors to write
000000r 1               trkcnt	=	ttlsec
000000r 1               size	=	$0B			;ascii size
000000r 1               lokim	=	$0D			;low kim limit
000000r 1               hikim	=	$0F			;high kim limit
000000r 1               offset	=	$11			;relocation offset
000000r 1               kimcnt	=	$13			;kim counter
000000r 1               pointr	=	$14			;pointer
000000r 1               lengt	=	$16			;inst length
000000r 1               point	=	$17			;relocate pointer
000000r 1               adjust	=	$19			;relocate distance
000000r 1               kimpnt	=	$1B			;kim file index
000000r 1               savex	=	$1C			;save for x
000000r 1               savey	=	$1D			;save for y
000000r 1               number	=	$1E			;input pack buffer
000000r 1               dstdrv	=	$20			;destination drive
000000r 1               defalt	=	$21			;default drive
000000r 1               seccnt	=	$22			;sector count
000000r 1               secnum	=	$24			;sector number
000000r 1               curccm	=	$26			;start of current ccm
000000r 1               simlng	=	$28			;length of sim
000000r 1               room	=	$2A			;memory needed for sysgen
000000r 1               stksav	=	$2C			;save stack register
000000r 1               frstsc	=	$2D			;first sector number of disk
000000r 1               lastzp	=	$2E
000000r 1               ;fixed parameters
000000r 1               lf	=	$a		;linefeeed
000000r 1               cr	=	$d		;return
000000r 1               eof	=	$1a		;end of file
000000r 1               null	=	0		;null
000000r 1               ctlc	=	3		;abort
000000r 1               ctle	=	5		;physical cr lf
000000r 1               ctli	=	9		;tab character
000000r 1               ctlp	=	$10		;toggle printer
000000r 1               ctlr	=	$12		;repeat line
000000r 1               ctls	=	$13		;freeze
000000r 1               ctlx	=	$18		;cancel
000000r 1               semico	=	$3b		;semicolon
000000r 1               delete	=	$08		;delete character
000000r 1               numcmd	=	36		;number commands
000000r 1               
000000r 1               DEBUG	=	1		; assemble with debug information on
000000r 1               
000000r 1                		.segment "LOADER"
000000r 1  F3           		.BYTE 		$F3 			;DI - DISABLE INTERRUPTS
000001r 1  01 00 49     		.BYTE 		$01,$00,$49    		;LD	BC,$4900 -BYTES TO MOVE
000004r 1  11 00 37     		.BYTE 		$11,$00,$37    		;LD	DE,$3700 -DESTINATION ADDRESS (6502 IS !A15)
000007r 1  21 20 01     		.BYTE 		$21,$20,$01	    	;LD	HL,$0120 -SOURCE ADDRESS
00000Ar 1  ED B0        		.BYTE 		$ED,$B0       		;LDIR  		 -COPY RAM
00000Cr 1  DB FF        		.BYTE		$DB,$FF       		;IN 	A,$FF    -ENABLE 6502
00000Er 1  0E 00        		.BYTE		$0E,$00       		;LD	C,00H    -CP/M SYSTEM RESET CALL
000010r 1  CD 05 00     		.BYTE		$CD,$05,$00		;CALL	0005H	 -RETURN TO PROMPT
000013r 1  4C rr rr     		JMP 	boot
000016r 1               ;
000016r 1               ;
000016r 1               		.PC02
000016r 1                               .segment "OS"
000000r 1               		.include "CCM215.ASM"
000000r 2               
000000r 2               ;-------------------------------
000000r 2               ;dos/65 console command module
000000r 2               ;-------------------------------
000000r 2               ;ccm unique definitions
000000r 2               nbuilt	=	7		;number built in commands
000000r 2               ;main program
000000r 2  D8           ccm:	cld			;set binary mode
000001r 2  48           	pha			;save drive number
000002r 2  20 rr rr     	jsr	rstdsk		;initialize system
000005r 2  68           	pla			;restore drive num
000006r 2  20 rr rr     	jsr	slctds		;select drive
000009r 2  AD rr rr     	lda	sysdef+6	;get line length
00000Cr 2  4A           	lsr	a		;divide
00000Dr 2  4A           	lsr	a		;by
00000Er 2  4A           	lsr	a		;16
00000Fr 2  4A           	lsr	a		;for dir
000010r 2  8D rr rr     	sta	sixten		;and save
000013r 2  AD rr rr     	lda	cnslng		;get buffer length
000016r 2  D0 3C        	bne	mrecmd		;if more handle it
000018r 2  A2 FF        ccmlpe:	ldx	#$ff		;set
00001Ar 2  9A           	txs			;stack
00001Br 2  D8           	cld			;set binary mode
00001Cr 2  A9 11        	lda	#17		; SEND A XON
00001Er 2  20 rr rr     	jsr	chrout		; ----------
000021r 2  20 rr rr     	jsr	hdrout		;send header
000024r 2  A9 3E        	lda	#'>'		;then print
000026r 2  20 rr rr     	jsr	chrout		;prompt
000029r 2  AD rr rr     	lda	cnsbvc		;point to start
00002Cr 2  AC rr rr     	ldy	cnsbvc+1	;of buffer
00002Fr 2  20 rr rr     	jsr	rdebuf		;do buffer read
000032r 2  A0 00        	ldy	#0		;clear index
000034r 2  AE rr rr     	ldx	cnslng		;get length
000037r 2  F0 DF        	beq	ccmlpe		;loop if empty
000039r 2  B9 rr rr     lwrupr:	lda	cnstxt,y	;else get char
00003Cr 2  C9 61        	cmp	#'a'		;if less than a
00003Er 2  90 09        	bcc	nxtchg		;skip convert
000040r 2  C9 7B        	cmp	#'z'+1		;if over z
000042r 2  B0 05        	bcs	nxtchg		;skip convert
000044r 2  29 5F        	and	#%01011111	;else convert
000046r 2  99 rr rr     	sta	cnstxt,y	;put back in buffer
000049r 2  C8           nxtchg:	iny			;bump index
00004Ar 2  CA           	dex			;count down
00004Br 2  D0 EC        	bne	lwrupr		;loop if more
00004Dr 2  8A           	txa			;set a to zero
00004Er 2  99 rr rr     	sta	cnstxt,y	;insert stopper
000051r 2  8D rr rr     	sta	cnbfpt		;initialize pointer
000054r 2  20 rr rr     mrecmd:	jsr	stdflb		;set default buffer
000057r 2  20 rr rr     	jsr	intdsk		;get drive number
00005Ar 2  8D rr rr     	sta	dfldsk		;store as default
00005Dr 2  20 rr rr     	jsr	prslin		;parse command
000060r 2  D0 64        	bne	cmderr		;error if afn
000062r 2  AD rr rr     	lda	tmpdsk		;get temporary
000065r 2  F0 04        	beq	nodrch		;if zero ok
000067r 2  A9 15        	lda	#nbuilt*3	;else set and
000069r 2  D0 2E        	bne	dotrns		;do transient
00006Br 2  A9 00        nodrch:	lda	#0		;clear
00006Dr 2  AA           	tax			;table index
00006Er 2  8D rr rr     	sta	ccmcount		;and count
000071r 2  A0 01        tsnxfn:	ldy	#1		;set fcb index
000073r 2  BD rr rr     tsnxch:	lda	fnctbl,x	;get table entry
000076r 2  F0 1A        	beq	gotcmd		;if zero got it
000078r 2  D9 rr rr     	cmp	fcbone,y	;else test
00007Br 2  D0 04        	bne	nocmpr		;no good if not =
00007Dr 2  E8           	inx			;bump
00007Er 2  C8           	iny			;pointers
00007Fr 2  D0 F2        	bne	tsnxch		;and loop
000081r 2  E8           nocmpr:	inx			;go to end
000082r 2  BD rr rr     	lda	fnctbl,x	;of table
000085r 2  D0 FA        	bne	nocmpr		;entry
000087r 2  E8           	inx			;point to next
000088r 2  EE rr rr     	inc	ccmcount		;bump count
00008Br 2  AD rr rr     	lda	ccmcount		;and if not
00008Er 2  C9 07        	cmp	#nbuilt		;limit then
000090r 2  D0 DF        	bne	tsnxfn		;try next
000092r 2  AD rr rr     gotcmd:	lda	ccmcount		;get count
000095r 2  0A           	asl	a		;multiply by two
000096r 2  6D rr rr     	adc	ccmcount		;then add for x3
000099r 2  AA           dotrns:	tax			;use as index
00009Ar 2  E8           	inx			;bump to pass jmp
00009Br 2  BD rr rr     	lda	xqfntb,x	;to get
00009Er 2  BC rr rr     	ldy	xqfntb+1,x	;entry address
0000A1r 2  8D rr rr     	sta	vector		;then set
0000A4r 2  8C rr rr     	sty	vector+1	;vector
0000A7r 2  AD rr rr     	lda	extcvc+1	;save
0000AAr 2  48           	pha			;return
0000ABr 2  AD rr rr     	lda	extcvc		;address
0000AEr 2  48           	pha			;on stack
0000AFr 2  6C rr rr     	jmp	(vector)	;execute
0000B2r 2  20 rr rr     extcmd:	jsr	rstddr		;restore default
0000B5r 2  20 rr rr     extwod:	jsr	prslin		;parse more
0000B8r 2  AD rr rr     	lda	fcbone+1	;if first
0000BBr 2  38           	sec			;character
0000BCr 2  E9 20        	sbc	#' '		;not a space
0000BEr 2  0D rr rr     	ora	tmpdsk		;or if temporary
0000C1r 2  D0 03        	bne	cmderr		;then an error
0000C3r 2  4C rr rr     	jmp	ccmlpe		;else loop
0000C6r 2               ;command error syntax handler
0000C6r 2  20 rr rr     cmderr:	jsr	ccrlf		;do a cr lf
0000C9r 2  AC rr rr     	ldy	curpnt		;get command pointer
0000CCr 2  B9 rr rr     cmerlp:	lda	cnstxt,y	;get char
0000CFr 2  F0 0A        	beq	cmerex		;if null then done
0000D1r 2  C9 20        	cmp	#' '		;if space
0000D3r 2  F0 06        	beq	cmerex		;then done
0000D5r 2  20 rr rr     	jsr	cotsxy		;output with save
0000D8r 2  C8           	iny			;point to next
0000D9r 2  D0 F1        	bne	cmerlp		;and loop
0000DBr 2  A9 3F        cmerex:	lda	#'?'		;send a
0000DDr 2  20 rr rr     	jsr	chrout		;question mark
0000E0r 2  4C rr rr     	jmp	ccmlpe		;and start over
0000E3r 2               ;execute dir command
0000E3r 2               ; dir <afn>
0000E3r 2  20 rr rr     dir:	jsr	prslin		;find object file
0000E6r 2  20 rr rr     	jsr	clrslt		;clear auto and select
0000E9r 2  A9 20        	lda	#' '		;if name
0000EBr 2  CD rr rr     	cmp	fcbone+1	;and
0000EEr 2  D0 0F        	bne	findfr		;type are
0000F0r 2  CD rr rr     	cmp	fcbone+9	;not empty
0000F3r 2  D0 0A        	bne	findfr		;then use it
0000F5r 2  A9 3F        	lda	#'?'		;else
0000F7r 2  A0 0B        	ldy	#11		;fill
0000F9r 2  99 rr rr     fillqu:	sta	fcbone,y	;fcb
0000FCr 2  88           	dey			;with
0000FDr 2  D0 FA        	bne	fillqu		;question marks
0000FFr 2  20 rr rr     findfr:	jsr	srchf1		;search for first match
000102r 2  30 56        	bmi	notfnd		;error if none
000104r 2  AD rr rr     fnddir:	lda	sixten		;set across
000107r 2  8D rr rr     	sta	across		;to four
00010Ar 2  20 rr rr     	jsr	ccrlf		;do a crlf
00010Dr 2  20 rr rr     dirl:	jsr	hdr		;do header
000110r 2  A9 3A        	lda	#':'		;then a
000112r 2  20 rr rr     	jsr	chrout		;colon
000115r 2  AD rr rr     	lda	diradd		;get number
000118r 2  0A           	asl	a		;and
000119r 2  0A           	asl	a		;multiply
00011Ar 2  0A           	asl	a		;by
00011Br 2  0A           	asl	a		;thirty two
00011Cr 2  0A           	asl	a		;then
00011Dr 2  29 60        	and	#%01100000	;mask out insignificant
00011Fr 2  A8           	tay			;make a pointer
000120r 2  C8           	iny			;and bump
000121r 2  A2 01        	ldx	#1		;set counter
000123r 2  B9 28 01     nmelpe:	lda	dflbuf,y	;get name
000126r 2  20 rr rr     	jsr	cotsxy		;else send to console
000129r 2  C8           noname:	iny			;bump index
00012Ar 2  E8           	inx			;and count
00012Br 2  E0 0C        	cpx	#12		;if count is 12
00012Dr 2  F0 0C        	beq	endnme		;then done
00012Fr 2  E0 09        	cpx	#9		;or if not 9
000131r 2  D0 F0        	bne	nmelpe		;then loop
000133r 2  A9 2E        	lda	#'.'		;else send
000135r 2  20 rr rr     	jsr	cotsxy		;a period
000138r 2  4C rr rr     	jmp	nmelpe		;and loop
00013Br 2  20 rr rr     endnme:	jsr	chkcst		;check console status
00013Er 2  D0 19        	bne	extdir		;if key down quit
000140r 2  20 rr rr     	jsr	setone		;else point to fcb
000143r 2  20 rr rr     	jsr	srchnx		;else search for next
000146r 2  8D rr rr     	sta	diradd		;save number
000149r 2  30 0E        	bmi	extdir		;quit if not found
00014Br 2  CE rr rr     	dec	across		;drop count
00014Er 2  F0 B4        	beq	fnddir		;new line if 0
000150r 2  20 rr rr     	jsr	spcout		;send
000153r 2  20 rr rr     	jsr	spcout		;two spaces
000156r 2  4C rr rr     	jmp	dirl		;and stay
000159r 2  60           extdir:	rts			;else done
00015Ar 2               ;not found error handler
00015Ar 2  A0 34        notfnd:	ldy	#ntfnms		;point to message
00015Cr 2  4C rr rr     	jmp	sndmsg		;send and exit
00015Fr 2               ;execute ren command
00015Fr 2               ; ren <ufn> <ufn>
00015Fr 2               ;where first ufn is from name and second is to name
00015Fr 2  20 rr rr     ren:	jsr	prslin		;get old name
000162r 2  D0 57        	bne	renerr		;error if afn
000164r 2  20 rr rr     	jsr	tmpold		;save drive
000167r 2  20 rr rr     	jsr	clrslt		;clear auto and select
00016Ar 2  20 rr rr     	jsr	srchf1		;if file does not exist
00016Dr 2  30 4F        	bmi	fntfnd		;then an error
00016Fr 2  20 rr rr     	jsr	frssec		;move name to second half
000172r 2  AC rr rr     	ldy	cnbfpt		;get pointer
000175r 2  B9 rr rr     	lda	cnstxt,y	;and then char
000178r 2  C9 20        	cmp	#' '		;if not a space
00017Ar 2  D0 3C        	bne	rensyn		;then error
00017Cr 2  20 rr rr     	jsr	prslin		;get new name
00017Fr 2  D0 37        	bne	rensyn		;error if afn
000181r 2  AD rr rr     	lda	tmpdsk		;get new drive
000184r 2  F0 12        	beq	nonwdr		;if zero ok
000186r 2  CD rr rr     	cmp	oldtmp		;compare to old
000189r 2  F0 0D        	beq	nonwdr		;ok if same
00018Br 2  38           	sec			;drop for default check
00018Cr 2  E9 01        	sbc	#1
00018Er 2  CD rr rr     	cmp	dfldsk		;if not default
000191r 2  D0 25        	bne	rensyn		;is error
000193r 2  AD rr rr     	lda	oldtmp		;and then if from not
000196r 2  D0 20        	bne	rensyn		;default is error
000198r 2  AD rr rr     nonwdr:	lda	oldtmp		;else get old
00019Br 2  8D rr rr     	sta	tmpdsk		;and save
00019Er 2  A9 00        	lda	#0		;clear
0001A0r 2  8D rr rr     	sta	fcbone+16
0001A3r 2  20 rr rr     	jsr	clrslt		;reselect
0001A6r 2  20 rr rr     	jsr	srchf1		;search for old
0001A9r 2  10 09        	bpl	filexs		;error if found
0001ABr 2  20 rr rr     	jsr	frssec		;swap names
0001AEr 2  20 rr rr     	jsr	setone		;point to fcb
0001B1r 2  4C rr rr     	jmp	renmfl		;and do it
0001B4r 2               ;ren file exists error handler
0001B4r 2  A0 3E        filexs:	ldy	#flexms		;point to
0001B6r 2  D0 08        	bne	remsg		;and send
0001B8r 2               ;ren syntax error handler
0001B8r 2  20 rr rr     rensyn:	jsr	rstddr		;restore default
0001BBr 2  4C rr rr     renerr:	jmp	cmderr		;do error
0001BEr 2               ;ren source file not found error handler
0001BEr 2  A0 34        fntfnd:	ldy	#ntfnms		;point to
0001C0r 2  4C rr rr     remsg:	jmp	sndmsg		;and send
0001C3r 2               ;execute save command
0001C3r 2               ; save <length> <drive:>ufn (<address>)
0001C3r 2  A9 00        save:	lda	#<tea		;set start address to tea start
0001C5r 2  A0 08        	ldy	#>tea
0001C7r 2  8D rr rr     	sta	sadr
0001CAr 2  8C rr rr     	sty	sadr+1
0001CDr 2  20 rr rr     	jsr	bldnum		;calculate length
0001D0r 2  D0 7A        	bne	saverr		;error if > 255 pages
0001D2r 2  8D rr rr     	sta	length		;else save low
0001D5r 2  0D rr rr     	ora	length		;test for zero length
0001D8r 2  F0 72        	beq	saverr		;error if is
0001DAr 2  20 rr rr     	jsr	prslin		;get file name
0001DDr 2  D0 6D        	bne	saverr		;error if afn
0001DFr 2  20 rr rr     	jsr	frssec		;move name to second half
0001E2r 2  20 rr rr     	jsr	tmpold		;save drive
0001E5r 2  20 rr rr     	jsr	bldnum		;it is so find value
0001E8r 2  AE rr rr     	ldx	fcbone+1	;see if there
0001EBr 2  E0 20        	cpx	#' '
0001EDr 2  F0 0A        	beq	nosadr		;it is not
0001EFr 2  8D rr rr     	sta	sadr		;and set address
0001F2r 2  8C rr rr     	sty	sadr+1
0001F5r 2  C0 02        	cpy	#2		;make sure is high enough
0001F7r 2  90 53        	bcc	saverr		;error if not
0001F9r 2  20 rr rr     nosadr:	jsr	secfrs		;move name back
0001FCr 2  20 rr rr     	jsr	clrslt		;clear auto and select
0001FFr 2  20 rr rr     	jsr	dlt1		;delete
000202r 2  20 rr rr     	jsr	setone		;then create
000205r 2  20 rr rr     	jsr	cratfl		;new file
000208r 2  30 45        	bmi	noroom		;say no room if error
00020Ar 2  20 rr rr     	jsr	open1		;open file
00020Dr 2  30 44        	bmi	noopen		;if error
00020Fr 2  18           	clc			;now find end page
000210r 2  AD rr rr     	lda	sadr+1
000213r 2  6D rr rr     	adc	length
000216r 2  8D rr rr     	sta	length
000219r 2  AD rr rr     	lda	sadr		;get start address
00021Cr 2  AC rr rr     	ldy	sadr+1
00021Fr 2  8D rr rr     wrtmre:	sta	dskbuf		;set
000222r 2  8C rr rr     	sty	dskbuf+1	;buffer
000225r 2  20 rr rr     	jsr	mv128		;move data to buffer
000228r 2  20 rr rr     	jsr	setone		;point to fcb
00022Br 2  20 rr rr     	jsr	wrrcrd		;write record
00022Er 2  D0 27        	bne	wrterr		;exit if error
000230r 2  18           	clc			;else
000231r 2  AD rr rr     	lda	dskbuf		;get old
000234r 2  AC rr rr     	ldy	dskbuf+1	;buffer
000237r 2  69 80        	adc	#128		;add 128
000239r 2  90 03        	bcc	donotc		;if carry
00023Br 2  C8           	iny			;bump upper
00023Cr 2  F0 05        	beq	clssav		;done if page zero
00023Er 2  CC rr rr     donotc:	cpy	length		;loop if upper
000241r 2  D0 DC        	bne	wrtmre		;not at limit
000243r 2  20 rr rr     clssav:	jsr	setone		;else point to
000246r 2  20 rr rr     	jsr	clsefl		;and close file
000249r 2  30 10        	bmi	cantcl		;say so if error
00024Br 2  60           extera:	rts
00024Cr 2               ;save error handler
00024Cr 2  4C rr rr     saverr:	jmp	cmderr		;do error
00024Fr 2               ;save no room error handler
00024Fr 2  A0 01        noroom:	ldy	#nospms		;point to
000251r 2  D0 0A        	bne	semsg		;and send
000253r 2               ;save can not open error handler
000253r 2  A0 55        noopen:	ldy	#cnnoms		;point to
000255r 2  D0 06        	bne	semsg		;and send
000257r 2               ;save write error handler
000257r 2  A0 62        wrterr:	ldy	#wrerms		;point
000259r 2  D0 02        	bne	semsg		;to and send
00025Br 2               ;save can not close error
00025Br 2  A0 0A        cantcl:	ldy	#ntclms		;point to
00025Dr 2  4C rr rr     semsg:	jmp	sndmsg		;and send
000260r 2               ;execute era command
000260r 2               ; era <afn>
000260r 2  20 rr rr     era:	jsr	prslin		;get file name
000263r 2  C9 0B        	cmp	#11		;if not all ?
000265r 2  D0 13        	bne	nteral		;then skip verify
000267r 2  A0 18        	ldy	#alflms		;else point to
000269r 2  20 rr rr     	jsr	sndmsg		;and send all files
00026Cr 2  20 rr rr     	jsr	cnsrde		;get an input
00026Fr 2  48           	pha			;and save
000270r 2  20 rr rr     	jsr	ccrlf		;do a cr lf
000273r 2  68           	pla			;restore char
000274r 2  29 5F        	and	#$5f		;convert to upper case
000276r 2  C9 59        	cmp	#'Y'		;if not y
000278r 2  D0 D1        	bne	extera		;then quit
00027Ar 2  20 rr rr     nteral:	jsr	clrslt		;clear auto and select
00027Dr 2  4C rr rr     	jmp	dlt1		;delete first
000280r 2               ;execute type command
000280r 2               ; type d:ufn
000280r 2  20 rr rr     type:	jsr	prslin		;get file
000283r 2  D0 30        	bne	typafn		;error if afn
000285r 2  20 rr rr     	jsr	casdo1		;clear - select - open file 1
000288r 2  30 32        	bmi	notype		;error if not found
00028Ar 2  20 rr rr     	jsr	ccrlf		;else do cr lf
00028Dr 2  20 rr rr     typmre:	jsr	read1		;read record
000290r 2  F0 04        	beq	okread		;if ok continue
000292r 2  10 20        	bpl	exttyp		;exit if just end
000294r 2  30 22        	bmi	typerr		;else error
000296r 2  A2 00        okread:	ldx	#0		;clear index
000298r 2  BD 28 01     typlpe:	lda	dflbuf,x	;get char
00029Br 2  C9 1A        	cmp	#eof		;if eof
00029Dr 2  F0 15        	beq	exttyp		;then exit
00029Fr 2  20 rr rr     	jsr	cotsxy		;else send
0002A2r 2  20 rr rr     	jsr	chkcst		;if key down
0002A5r 2  D0 08        	bne	exttok		;then exit
0002A7r 2  AE rr rr     	ldx	savx		;else get index
0002AAr 2  E8           	inx			;bump it
0002ABr 2  10 EB        	bpl	typlpe		;and loop if < 128
0002ADr 2  30 DE        	bmi	typmre		;else read more
0002AFr 2  A2 06        exttok:	ldx	#6		;clear console
0002B1r 2  20 03 01     	jsr	pemjmp		;with no echo
0002B4r 2  60           exttyp:	rts
0002B5r 2               ;type syntax error handler
0002B5r 2  4C rr rr     typafn:	jmp	cmderr		;error return
0002B8r 2               ;type read error handler
0002B8r 2  A0 29        typerr:	ldy	#rderms		;point to
0002BAr 2  D0 02        	bne	temsg		;and send
0002BCr 2               ;type not found error handler
0002BCr 2  A0 34        notype:	ldy	#ntfnms		;point to
0002BEr 2  4C rr rr     temsg:	jmp	sndmsg		;and send
0002C1r 2               ;execute load command
0002C1r 2               ; load <ufn> (<address>)
0002C1r 2  20 rr rr     load:	jsr	setddb		;set load start to tea start
0002C4r 2  20 rr rr     	jsr	prslin		;build fcb
0002C7r 2  D0 EC        	bne	typafn		;error if afn
0002C9r 2  20 rr rr     	jsr	frssec		;save in second half
0002CCr 2  20 rr rr     	jsr	tmpold		;save file
0002CFr 2  20 rr rr     	jsr	bldnum		;find start address
0002D2r 2  AE rr rr     	ldx	fcbone+1	;see if number
0002D5r 2  E0 20        	cpx	#' '
0002D7r 2  F0 03        	beq	usedfl		;if none use default
0002D9r 2  20 rr rr     	jsr	setdb		;and set
0002DCr 2  20 rr rr     usedfl:	jsr	secfrs		;move name back
0002DFr 2  20 rr rr     	jsr	casdo1		;clear - select - open file 1
0002E2r 2  30 D8        	bmi	notype		;exit if not found
0002E4r 2  AD rr rr     	lda	dskbuf		;get load start
0002E7r 2  AC rr rr     	ldy	dskbuf+1
0002EAr 2  20 rr rr     lcmdlp:	jsr	setbuf		;set as disk buffer
0002EDr 2  20 rr rr     	jsr	read1		;read record
0002F0r 2  D0 06        	bne	loadnd		;done if not zero
0002F2r 2  20 rr rr     	jsr	adjdb		;bump address
0002F5r 2  4C rr rr     	jmp	lcmdlp		;and loop
0002F8r 2  30 BE        loadnd:	bmi	typerr		;if error say so
0002FAr 2  4C rr rr     	jmp	stdflb		;back to default buffer
0002FDr 2               ;execute go command
0002FDr 2               ; go (<address>)
0002FDr 2  20 rr rr     go:	jsr	bldnum		;get address
000300r 2  AE rr rr     	ldx	fcbone+1	;get first char
000303r 2  E0 20        	cpx	#' '		;see if nothing
000305r 2  F0 03        	beq	nolnum		;nothing so use tea
000307r 2  4C rr rr     	jmp	godoit		;then execute
00030Ar 2  4C rr rr     nolnum:	jmp	gotea
00030Dr 2               ;execute trns (transient) command
00030Dr 2               ; <ufn> (<fn>) (<fn>)
00030Dr 2  AD rr rr     trns:	lda	fcbone+1	;get first char
000310r 2  C9 20        	cmp	#' '		;if not space
000312r 2  D0 11        	bne	chktyp		;check type
000314r 2  AD rr rr     	lda	tmpdsk		;else test temp
000317r 2  F0 09        	beq	skpdrv		;if none skip
000319r 2  38           	sec			;else convert
00031Ar 2  E9 01        	sbc	#1		;to number
00031Cr 2  8D rr rr     	sta	dfldsk		;set default
00031Fr 2  20 rr rr     	jsr	slctds		;and select
000322r 2  4C rr rr     skpdrv:	jmp	extwod		;return
000325r 2  AD rr rr     chktyp:	lda	fcbone+9	;get type
000328r 2  C9 20        	cmp	#' '		;if space
00032Ar 2  F0 03        	beq	typemp		;then ok
00032Cr 2  4C rr rr     	jmp	trnerr		;else error
00032Fr 2  A2 02        typemp:	ldx	#2		;make
000331r 2  BD rr rr     setcom:	lda	typcom,x	;type
000334r 2  9D rr rr     	sta	fcbone+9,x	;com
000337r 2  CA           	dex			;then
000338r 2  10 F7        	bpl	setcom		;continue
00033Ar 2  20 rr rr     	jsr	casdo1		;clear - select - open file one
00033Dr 2  10 03        	bpl	gottrn		;jump if ok
00033Fr 2  4C rr rr     	jmp	topner		;else do error
000342r 2  20 rr rr     gottrn:	jsr	setddb		;set start to tea
000345r 2  20 rr rr     nxtrcr:	jsr	setbuf		;set address
000348r 2  20 rr rr     	jsr	read1		;read fcb 1
00034Br 2  D0 1E        	bne	endlde		;branch if error or eof
00034Dr 2  20 rr rr     	jsr	adjdb		;adjust address up by 128
000350r 2  CD rr rr     	cmp	ccmvc		;if new low
000353r 2  90 07        	bcc	tryhig		;ok try high
000355r 2  CC rr rr     	cpy	ccmvc+1		;else if high
000358r 2  90 EB        	bcc	nxtrcr		;ok do more
00035Ar 2  B0 07        	bcs	chklnd		;else check for end
00035Cr 2  CC rr rr     tryhig:	cpy	ccmvc+1		;if high less
00035Fr 2  90 E4        	bcc	nxtrcr		;then ok
000361r 2  F0 E2        	beq	nxtrcr		;or ok if same
000363r 2  20 rr rr     chklnd:	jsr	stdflb		;set buffer to default
000366r 2  20 rr rr     	jsr	read1		;read (should be eof)
000369r 2  F0 6C        	beq	tlderr		;error if more
00036Br 2  30 6A        endlde:	bmi	tlderr		;do error
00036Dr 2  A9 00        gotea:	lda	#<tea		;set go address to tea start
00036Fr 2  A0 08        	ldy	#>tea
000371r 2  8D rr rr     godoit:	sta	do+1		;set to ay
000374r 2  8C rr rr     	sty	do+2
000377r 2  20 rr rr     	jsr	rstddr		;else restore default
00037Ar 2  20 rr rr     	jsr	prslin		;parse file
00037Dr 2  AD rr rr     	lda	tmpdsk		;set auto
000380r 2  8D rr rr     	sta	fcbone		;select position
000383r 2  A2 10        	ldx	#16		;do a second
000385r 2  20 rr rr     	jsr	prsmre		;fcb if there
000388r 2  AD rr rr     	lda	tmpdsk		;set auto select
00038Br 2  8D rr rr     	sta	fcbone+16	;again
00038Er 2  A0 00        	ldy	#0		;clear record
000390r 2  8C rr rr     	sty	fcbone+32	;counter
000393r 2  A2 20        	ldx	#32		;move
000395r 2  BD rr rr     movfcb:	lda	fcbone,x	;all
000398r 2  9D 07 01     	sta	dflfcb,x	;to
00039Br 2  CA           	dex			;default
00039Cr 2  10 F7        	bpl	movfcb		;fcb
00039Er 2  E8           	inx			;set x to zero
00039Fr 2  B9 rr rr     tstbuf:	lda	cnstxt,y	;get char
0003A2r 2  F0 07        	beq	isnull		;if null jump
0003A4r 2  C9 20        	cmp	#' '		;or if space
0003A6r 2  F0 03        	beq	isnull		;jump
0003A8r 2  C8           	iny			;else bump pointer
0003A9r 2  D0 F4        	bne	tstbuf		;and loop
0003ABr 2  A9 00        isnull:	lda	#0		;clear
0003ADr 2  8D 28 01     	sta	dflbuf		;count
0003B0r 2  B9 rr rr     movbuf:	lda	cnstxt,y	;get char
0003B3r 2  9D 29 01     	sta	dflbuf+1,x	;and move
0003B6r 2  F0 07        	beq	fillov		;exit if null
0003B8r 2  E8           	inx			;increment
0003B9r 2  C8           	iny			;counters
0003BAr 2  EE 28 01     	inc	dflbuf		;and length
0003BDr 2  D0 F1        	bne	movbuf		;and loop
0003BFr 2  20 rr rr     fillov:	jsr	ccrlf		;do a cr lf
0003C2r 2  20 rr rr     	jsr	stdflb		;set default
0003C5r 2  20 00 08     do:	jsr	tea		;execute
0003C8r 2  AD rr rr     	lda	dfldsk		;get default
0003CBr 2  20 rr rr     	jsr	slctds		;and set
0003CEr 2  4C rr rr     	jmp	ccmlpe		;then loop
0003D1r 2               ;trns syntax error handler
0003D1r 2  20 rr rr     topner:	jsr	rstddr		;restore default
0003D4r 2  4C rr rr     trnerr:	jmp	cmderr		;do error
0003D7r 2               ;trns load error
0003D7r 2  A0 4A        tlderr:	ldy	#lderms		;point to
0003D9r 2  4C rr rr     	jmp	sndmsg		;and send
0003DCr 2               ;carriage return and linefeed
0003DCr 2  A9 0D        ccrlf:	lda	#cr		;get a cr
0003DEr 2  20 rr rr     	jsr	chrout		;send
0003E1r 2  A9 0A        	lda	#lf		;get a lf
0003E3r 2  D0 06        	bne	chrout		;and send
0003E5r 2               ;pem entry routines
0003E5r 2  A2 01        cnsrde:	ldx	#1		;console read
0003E7r 2  D0 43        	bne	pemgo
0003E9r 2  A9 20        spcout:	lda	#' '		;output space
0003EBr 2  A2 02        chrout:	ldx	#2		;console output
0003EDr 2  D0 3D        	bne	pemgo
0003EFr 2  A2 0A        rdebuf:	ldx	#10		;buffered input
0003F1r 2  D0 39        	bne	pemgo
0003F3r 2  A2 0B        chkcst:	ldx	#11		;check console
0003F5r 2  D0 35        	bne	pemgo
0003F7r 2  A2 0D        rstdsk:	ldx	#13		;initialize system
0003F9r 2  D0 31        	bne	pemgo
0003FBr 2  A2 0E        slctds:	ldx	#14		;select drive
0003FDr 2  D0 2D        	bne	pemgo
0003FFr 2  A2 0F        openfl:	ldx	#15		;open file
000401r 2  D0 29        	bne	pemgo
000403r 2  A2 10        clsefl:	ldx	#16		;close file
000405r 2  D0 25        	bne	pemgo
000407r 2  A2 11        srchfr:	ldx	#17		;first match
000409r 2  D0 21        	bne	pemgo
00040Br 2  A2 12        srchnx:	ldx	#18		;next match
00040Dr 2  D0 1D        	bne	pemgo
00040Fr 2               ;delete file one
00040Fr 2  20 rr rr     dlt1:	jsr	setone		;point to fcb
000412r 2  A2 13        dltfil:	ldx	#19		;delete file
000414r 2  D0 16        	bne	pemgo
000416r 2  A2 14        rdrcrd:	ldx	#20		;read record
000418r 2  D0 12        	bne	pemgo
00041Ar 2  A2 15        wrrcrd:	ldx	#21		;write record
00041Cr 2  D0 0E        	bne	pemgo
00041Er 2  A2 16        cratfl:	ldx	#22		;create file
000420r 2  D0 0A        	bne	pemgo
000422r 2  A2 17        renmfl:	ldx	#23		;rename file
000424r 2  D0 06        	bne	pemgo
000426r 2  A2 19        intdsk:	ldx	#25		;read drive num
000428r 2  D0 02        	bne	pemgo
00042Ar 2  A2 1A        setbuf:	ldx	#26		;set buffer add
00042Cr 2  4C 03 01     pemgo:	jmp	pemjmp		;go to pem
00042Fr 2               ;restore default drive
00042Fr 2  AD rr rr     rstddr:	lda	tmpdsk		;if temp drive
000432r 2  F0 1F        	beq	extddr		;zero then exit
000434r 2  38           	sec			;else
000435r 2  E9 01        	sbc	#1		;subtract one
000437r 2  CD rr rr     	cmp	dfldsk		;compare to default
00043Ar 2  F0 17        	beq	extddr		;exit if same
00043Cr 2  AD rr rr     seldfl:	lda	dfldsk		;else get default
00043Fr 2  4C rr rr     	jmp	slctds		;select
000442r 2               ;clear auto - select disk - open file at fcbone
000442r 2  20 rr rr     casdo1:	jsr	clrslt		;clear auto and select
000445r 2               ;open file one
000445r 2               ; returns:n=1 if not found
000445r 2  A9 00        open1:	lda	#0		;clear
000447r 2  8D rr rr     	sta	fcbone+32	;record number
00044Ar 2  20 rr rr     	jsr	setone		;point to fcb
00044Dr 2  20 rr rr     	jsr	openfl		;open it
000450r 2  8D rr rr     	sta	diradd		;save number
000453r 2  60           extddr:	rts
000454r 2               ;read file one
000454r 2  20 rr rr     read1:	jsr	setone		;point to fcb
000457r 2  4C rr rr     	jmp	rdrcrd		;do read
00045Ar 2               ;search for first file one
00045Ar 2               ; returns:n=1 if not found
00045Ar 2  20 rr rr     srchf1:	jsr	setone		;point to fcb
00045Dr 2  20 rr rr     	jsr	srchfr		;search for first
000460r 2  8D rr rr     	sta	diradd		;save number
000463r 2  60           	rts
000464r 2               ;header output
000464r 2  20 rr rr     hdrout:	jsr	ccrlf		;do cr lf
000467r 2  20 rr rr     hdr:	jsr	intdsk		;get drive number
00046Ar 2  18           	clc			;make
00046Br 2  69 41        	adc	#'A'		;a letter
00046Dr 2               ;output with save of x and y
00046Dr 2               ;this routine calls the pem resident routine
00046Dr 2               ;tstchr to see if a char is a printing char.
00046Dr 2               ;if it is then c=1 upon return from tstchr.
00046Dr 2  8E rr rr     cotsxy:	stx	savx		;save x
000470r 2  8C rr rr     	sty	savy		;and y
000473r 2  20 rr rr     	jsr	tstchr		;see if printing
000476r 2  B0 10        	bcs	isprnt		;jump if is
000478r 2  48           	pha			;else save
000479r 2  AD rr rr     	lda	sysdef+4	;get invert
00047Cr 2  20 rr rr     	jsr	chrout		;send it
00047Fr 2  68           	pla			;get char
000480r 2  09 40        	ora	#'@'		;make printing
000482r 2  20 rr rr     	jsr	chrout		;send it
000485r 2  AD rr rr     	lda	sysdef+3	;get normal
000488r 2  20 rr rr     isprnt:	jsr	chrout		;do output
00048Br 2  AC rr rr     	ldy	savy		;get y
00048Er 2  AE rr rr     	ldx	savx		;and x
000491r 2  60           	rts
000492r 2               ;set up fcb one pointer
000492r 2  AD rr rr     setone:	lda	fcb1vc		;low
000495r 2  AC rr rr     	ldy	fcb1vc+1	;and high
000498r 2  60           	rts
000499r 2               ;save tmpdsk in oldtmp
000499r 2  AD rr rr     tmpold:	lda	tmpdsk
00049Cr 2  8D rr rr     	sta	oldtmp
00049Fr 2  60           	rts
0004A0r 2               ;parse command line
0004A0r 2  A2 00        prslin:	ldx	#0		;clear index
0004A2r 2  8A           prsmre:	txa			;save
0004A3r 2  48           	pha			;index
0004A4r 2  A9 00        	lda	#0		;clear temp
0004A6r 2  8D rr rr     	sta	tmpdsk		;drive flag
0004A9r 2  AC rr rr     	ldy	cnbfpt		;get buffer pointer
0004ACr 2  20 rr rr     	jsr	skpspc		;find first non-space
0004AFr 2  8C rr rr     	sty	curpnt		;save index
0004B2r 2  F0 0D        	beq	nulchr		;jump if null
0004B4r 2  29 0F        	and	#%00001111	;else look at 4 lsbs
0004B6r 2  48           	pha			;and save
0004B7r 2  C8           	iny			;point to next char
0004B8r 2  B9 rr rr     	lda	cnstxt,y	;and get it
0004BBr 2  C9 3A        	cmp	#':'		;if a colon
0004BDr 2  F0 0A        	beq	drvinp		;jump and set drive
0004BFr 2  68           	pla			;else clear stack
0004C0r 2  88           	dey			;backup index
0004C1r 2  AD rr rr     nulchr:	lda	dfldsk		;set automatic
0004C4r 2  9D rr rr     	sta	fcbone,x	;to default
0004C7r 2  10 08        	bpl	trynme		;then parse name
0004C9r 2  68           drvinp:	pla			;get number
0004CAr 2  8D rr rr     	sta	tmpdsk		;set temp flag
0004CDr 2  9D rr rr     	sta	fcbone,x	;and fcb
0004D0r 2  C8           	iny			;point past colon
0004D1r 2  A9 08        trynme:	lda	#8		;set name count
0004D3r 2  8D rr rr     	sta	ccmcount		;to eight
0004D6r 2  20 rr rr     tstnme:	jsr	tstlgl		;test for illegal
0004D9r 2  F0 1D        	beq	flnmsp		;if illegal jump
0004DBr 2  E8           	inx			;bump pointer
0004DCr 2  C9 2A        	cmp	#'*'		;if not *
0004DEr 2  D0 07        	bne	notafn		;skip ? fill
0004E0r 2  A9 3F        	lda	#'?'		;get a ?
0004E2r 2  9D rr rr     	sta	fcbone,x	;store
0004E5r 2  D0 04        	bne	nxtout		;and jump
0004E7r 2  9D rr rr     notafn:	sta	fcbone,x	;store char
0004EAr 2  C8           	iny			;bump source
0004EBr 2  CE rr rr     nxtout:	dec	ccmcount		;drop counter down
0004EEr 2  D0 E6        	bne	tstnme		;and loop
0004F0r 2  20 rr rr     skpmre:	jsr	tstlgl		;if illegal
0004F3r 2  F0 11        	beq	trytyp		;try type
0004F5r 2  C8           	iny			;else bump index
0004F6r 2  D0 F8        	bne	skpmre		;and loop
0004F8r 2  E8           flnmsp:	inx			;next position
0004F9r 2  A9 20        	lda	#' '		;get a space
0004FBr 2  9D rr rr     	sta	fcbone,x	;store
0004FEr 2  CE rr rr     	dec	ccmcount		;count down
000501r 2  D0 F5        	bne	flnmsp		;and loop
000503r 2  B9 rr rr     	lda	cnstxt,y	;get char again
000506r 2  48           trytyp:	pha			;save char
000507r 2  A9 03        	lda	#3		;set count
000509r 2  8D rr rr     	sta	ccmcount		;to three
00050Cr 2  68           	pla			;get char
00050Dr 2  C9 2E        	cmp	#'.'		;if not .
00050Fr 2  D0 23        	bne	fltysp		;then fill spaces
000511r 2  C8           	iny			;else bump source
000512r 2  20 rr rr     tsttyp:	jsr	tstlgl		;if not legal
000515r 2  F0 1D        	beq	fltysp		;then fill spaces
000517r 2  E8           	inx			;else bump index
000518r 2  C9 2A        	cmp	#'*'		;if not *
00051Ar 2  D0 07        	bne	notaft		;then skip fill
00051Cr 2  A9 3F        	lda	#'?'		;else get ?
00051Er 2  9D rr rr     	sta	fcbone,x	;move to fcb
000521r 2  D0 04        	bne	mrtyfl		;and loop
000523r 2  9D rr rr     notaft:	sta	fcbone,x	;move char to fcb
000526r 2  C8           	iny			;bump source
000527r 2  CE rr rr     mrtyfl:	dec	ccmcount		;count down
00052Ar 2  D0 E6        	bne	tsttyp		;and loop
00052Cr 2  20 rr rr     nttype:	jsr	tstlgl		;if illegal
00052Fr 2  F0 0E        	beq	filnul		;fill out nulls
000531r 2  C8           	iny			;else bump source
000532r 2  D0 F8        	bne	nttype		;and loop
000534r 2  E8           fltysp:	inx			;bump fcb pointer
000535r 2  A9 20        	lda	#' '		;get space
000537r 2  9D rr rr     	sta	fcbone,x	;put in fcb
00053Ar 2  CE rr rr     	dec	ccmcount		;count down
00053Dr 2  D0 F5        	bne	fltysp		;and continue
00053Fr 2  A9 03        filnul:	lda	#3		;clear
000541r 2  8D rr rr     	sta	ccmcount		;three
000544r 2  E8           mrnlty:	inx			;bump fcb pointer
000545r 2  A9 00        	lda	#0		;get a zero
000547r 2  9D rr rr     	sta	fcbone,x	;move to fcb
00054Ar 2  CE rr rr     	dec	ccmcount		;count down
00054Dr 2  D0 F5        	bne	mrnlty		;loop until done
00054Fr 2  8C rr rr     	sty	cnbfpt		;update start pointer
000552r 2  A9 00        	lda	#0		;clear
000554r 2  8D rr rr     	sta	ccmcount		;count
000557r 2  68           	pla			;restore stack
000558r 2  A8           	tay			;move to index
000559r 2  A2 0B        	ldx	#11		;counter to 11
00055Br 2  C8           tstqus:	iny			;point to
00055Cr 2  B9 rr rr     	lda	fcbone,y	;and get char
00055Fr 2  C9 3F        	cmp	#'?'		;if not a ?
000561r 2  D0 03        	bne	nxtqus		;then jump
000563r 2  EE rr rr     	inc	ccmcount		;else bump count
000566r 2  CA           nxtqus:	dex			;loop until
000567r 2  D0 F2        	bne	tstqus		;11 tested
000569r 2  AD rr rr     	lda	ccmcount		;get count
00056Cr 2  60           	rts			;and return
00056Dr 2               ;skip space
00056Dr 2  B9 rr rr     skpspc:	lda	cnstxt,y	;get char
000570r 2  F0 07        	beq	extskp		;jump if null
000572r 2  C9 20        	cmp	#' '		;if not space
000574r 2  D0 03        	bne	extskp		;then exit
000576r 2  C8           	iny			;else go to next
000577r 2  D0 F4        	bne	skpspc		;and test
000579r 2  60           extskp:	rts
00057Ar 2               ;test legal
00057Ar 2  B9 rr rr     tstlgl:	lda	cnstxt,y	;get char
00057Dr 2  F0 1C        	beq	extlgl
00057Fr 2  C9 20        	cmp	#' '		;if space
000581r 2  90 19        	bcc	badinp		;ok - less is error
000583r 2  F0 16        	beq	extlgl
000585r 2  C9 3D        	cmp	#'='
000587r 2  F0 12        	beq	extlgl
000589r 2  C9 2E        	cmp	#'.'
00058Br 2  F0 0E        	beq	extlgl
00058Dr 2  C9 3A        	cmp	#':'
00058Fr 2  F0 0A        	beq	extlgl
000591r 2  C9 3B        	cmp	#semico
000593r 2  F0 06        	beq	extlgl
000595r 2  C9 3C        	cmp	#'<'
000597r 2  F0 02        	beq	extlgl
000599r 2  C9 3E        	cmp	#'>'
00059Br 2  60           extlgl:	rts
00059Cr 2  4C rr rr     badinp:	jmp	cmderr
00059Fr 2               ;set default buffer address
00059Fr 2  A9 28        stdflb:	lda	#<dflbuf 	;point to
0005A1r 2  A0 01        	ldy	#>dflbuf	;location
0005A3r 2  4C rr rr     	jmp	setbuf		;and set
0005A6r 2               ;clear automatic and select
0005A6r 2  A9 00        clrslt:	lda	#0		;clear auto
0005A8r 2  8D rr rr     	sta	fcbone		;select
0005ABr 2  AD rr rr     slttmp:	lda	tmpdsk		;get temp
0005AEr 2  F0 1F        	beq	extsnd		;if zero exit
0005B0r 2  38           	sec			;else subtract
0005B1r 2  E9 01        	sbc	#1		;one
0005B3r 2  CD rr rr     	cmp	dfldsk		;if same as default
0005B6r 2  F0 17        	beq	extsnd		;then quit
0005B8r 2  4C rr rr     	jmp	slctds		;else set
0005BBr 2               ;send message
0005BBr 2  8C rr rr     sndmsg:	sty	savy		;save index
0005BEr 2  20 rr rr     	jsr	ccrlf		;do cr and lf
0005C1r 2  AC rr rr     	ldy	savy		;get index
0005C4r 2  B9 rr rr     lpesnd:	lda	msgtbl,y	;get char
0005C7r 2  F0 06        	beq	extsnd		;if null quit
0005C9r 2  20 rr rr     	jsr	cotsxy		;else send
0005CCr 2  C8           	iny			;point to next
0005CDr 2  D0 F5        	bne	lpesnd		;and loop
0005CFr 2  60           extsnd:	rts
0005D0r 2               ;set load start address
0005D0r 2  A9 00        setddb:	lda	#<tea		;to tea start
0005D2r 2  A0 08        	ldy	#>tea
0005D4r 2  8D rr rr     setdb:	sta	dskbuf		;to ay
0005D7r 2  8C rr rr     	sty	dskbuf+1
0005DAr 2  60           	rts
0005DBr 2               ;move first part of fcb to second half
0005DBr 2               ;and move second part to first part.
0005DBr 2               ;only ren depends upon this routine to actually
0005DBr 2               ;swap fcb halves.
0005DBr 2               ;alters:a,x,p
0005DBr 2               ;returns:x=$ff
0005DBr 2  A2 0F        frssec:	ldx	#15		;set index to last
0005DDr 2  BD rr rr     frsclp:	lda	fcbone,x	;get byte
0005E0r 2  BC rr rr     	ldy	fcbone+16,x
0005E3r 2  9D rr rr     	sta	fcbone+16,x	;move it
0005E6r 2  98           	tya
0005E7r 2  9D rr rr     	sta	fcbone,x
0005EAr 2  CA           	dex
0005EBr 2  10 F0        	bpl	frsclp		;until 16 moved
0005EDr 2  60           	rts
0005EEr 2               ;move second part of fcb to first half
0005EEr 2               ;restore tmpdsk from save location
0005EEr 2               ;alters:a,x,p
0005EEr 2               ;returns:x=$ff
0005EEr 2  A2 0F        secfrs:	ldx	#15		;set index to last
0005F0r 2  BD rr rr     scfrlp:	lda	fcbone+16,x	;get byte
0005F3r 2  9D rr rr     	sta	fcbone,x	;move it
0005F6r 2  CA           	dex
0005F7r 2  10 F7        	bpl	scfrlp		;loop until done
0005F9r 2  AD rr rr     	lda	oldtmp		;get old flag
0005FCr 2  8D rr rr     	sta	tmpdsk		;and set
0005FFr 2  60           	rts
000600r 2               ;build a number from command line and leave in num
000600r 2               ;will handle either decimal (e.g., 578) or hexadecimal (e.g., $3f2)
000600r 2               ;move parse index past number
000600r 2               ;modifies:all
000600r 2               ;returns:a,y set to low and high of number
000600r 2               ;	 flags set according to y which is high part of number
000600r 2  A9 09        bldnum:	lda	#9		;preset to decimal
000602r 2  8D rr rr     	sta	moduls
000605r 2  20 rr rr     	jsr	prslin		;put in fcb
000608r 2  AD rr rr     	lda	tmpdsk		;if temp
00060Br 2  D0 67        	bne	numerr		;is error
00060Dr 2  8D rr rr     	sta	num		;else clear num
000610r 2  8D rr rr     	sta	num+1
000613r 2  A8           	tay			;and index
000614r 2  B9 rr rr     	lda	fcbone+1,y	;get first char
000617r 2  C9 24        	cmp	#'$'		;see if hex signal
000619r 2  D0 06        	bne	bnumlp		;skip if not
00061Br 2  A9 0F        	lda	#15		;set for modulus
00061Dr 2  8D rr rr     	sta	moduls
000620r 2  C8           	iny			;bump past $
000621r 2  C8           bnumlp:	iny			;next char
000622r 2  B9 rr rr     	lda	fcbone,y	;get digit
000625r 2  C9 20        	cmp	#' '		;see if space
000627r 2  F0 4E        	beq	endnlp		;done if is
000629r 2  20 rr rr     	jsr	tstdec		;see if decimal
00062Cr 2  90 0E        	bcc	usedig		;use if is
00062Er 2  20 rr rr     	jsr	tsthex		;see if hex
000631r 2  B0 41        	bcs	numerr		;error if not
000633r 2  E9 06        	sbc	#6		;remove offset
000635r 2  A2 0F        	ldx	#15		;test for hex modulus
000637r 2  EC rr rr     	cpx	moduls
00063Ar 2  D0 38        	bne	numerr		;error if not
00063Cr 2  29 0F        usedig:	and	#%00001111	;eliminate ascii bias
00063Er 2  48           	pha			;save result
00063Fr 2  AD rr rr     	lda	num		;move number to temp
000642r 2  8D rr rr     	sta	tnum
000645r 2  AD rr rr     	lda	num+1
000648r 2  8D rr rr     	sta	tnum+1
00064Br 2  AE rr rr     	ldx	moduls		;get modulus
00064Er 2  18           	clc
00064Fr 2  AD rr rr     addlpe:	lda	num		;add number to itself
000652r 2  6D rr rr     	adc	tnum
000655r 2  8D rr rr     	sta	num
000658r 2  AD rr rr     	lda	num+1		;modulus times
00065Br 2  6D rr rr     	adc	tnum+1
00065Er 2  8D rr rr     	sta	num+1
000661r 2  B0 11        	bcs	numerr		;error if carry out
000663r 2  CA           	dex
000664r 2  D0 E9        	bne	addlpe		;loop if more
000666r 2  68           	pla			;get input back
000667r 2  6D rr rr     	adc	num		;add in
00066Ar 2  8D rr rr     	sta	num
00066Dr 2  90 B2        	bcc	bnumlp		;loop if no carry
00066Fr 2  EE rr rr     	inc	num+1		;else bump high
000672r 2  D0 AD        	bne	bnumlp		;and loop for more
000674r 2               ;error in bldnum - handle and quit
000674r 2  4C rr rr     numerr:	jmp	cmderr		;do general error
000677r 2               ;end of use of name part - check type
000677r 2  AD rr rr     endnlp:	lda	fcbone+9	;get first
00067Ar 2  C9 20        	cmp	#' '		;see if space
00067Cr 2  D0 F6        	bne	numerr		;error if not
00067Er 2  AD rr rr     	lda	num		;return with result
000681r 2  AC rr rr     	ldy	num+1
000684r 2  60           	rts
000685r 2               ;relocatable vectors
000685r 2  4C           	.byte	$4c
000686r 2  rr rr        cnsbvc:	.word	cnsbuf
000688r 2  4C           	.byte	$4c
000689r 2  rr rr        extcvc:	.word	extcmd-1
00068Br 2  4C           	.byte	$4c
00068Cr 2  rr rr        ccmvc:	.word	ccm
00068Er 2  4C           	.byte	$4c
00068Fr 2  rr rr        fcb1vc:	.word	fcbone
000691r 2               ;function entry vector
000691r 2  4C rr rr     xqfntb:	jmp	dir
000694r 2  4C rr rr     	jmp	save
000697r 2  4C rr rr     	jmp	era
00069Ar 2  4C rr rr     	jmp	type
00069Dr 2  4C rr rr     	jmp	ren
0006A0r 2  4C rr rr     	jmp	go
0006A3r 2  4C rr rr     	jmp	load
0006A6r 2  4C rr rr     	jmp	trns
0006A9r 2               ;terminator for relocation
0006A9r 2  FF           	.byte	$ff
0006AAr 2               ;messages
0006AAr 2               msgtbl:
0006AAr 2  00           	.byte 0
0006ABr 2               nospms	=	*-msgtbl
0006ABr 2  4E 4F 20 53  	.byte	"NO SPACE",0
0006AFr 2  50 41 43 45  
0006B3r 2  00           
0006B4r 2               ntclms	=	*-msgtbl
0006B4r 2  43 41 4E 20  	.byte "CAN NOT CLOSE",0
0006B8r 2  4E 4F 54 20  
0006BCr 2  43 4C 4F 53  
0006C2r 2               alflms	=	*-msgtbl
0006C2r 2  41 4C 4C 20  	.byte "ALL FILES (Y/N)?",0
0006C6r 2  46 49 4C 45  
0006CAr 2  53 20 28 59  
0006D3r 2               rderms	=	*-msgtbl
0006D3r 2  52 45 41 44  	.byte	"READ ERROR",0
0006D7r 2  20 45 52 52  
0006DBr 2  4F 52 00     
0006DEr 2               ntfnms	=	*-msgtbl
0006DEr 2  4E 4F 54 20  	.byte	"NOT FOUND",0
0006E2r 2  46 4F 55 4E  
0006E6r 2  44 00        
0006E8r 2               flexms	=	*-msgtbl
0006E8r 2  46 49 4C 45  	.byte "FILE EXISTS",0
0006ECr 2  20 45 58 49  
0006F0r 2  53 54 53 00  
0006F4r 2               lderms	=	*-msgtbl
0006F4r 2  4C 4F 41 44  	.byte "LOAD ERROR",0
0006F8r 2  20 45 52 52  
0006FCr 2  4F 52 00     
0006FFr 2               cnnoms	=	*-msgtbl
0006FFr 2  43 41 4E 20  	.byte "CAN NOT OPEN",0
000703r 2  4E 4F 54 20  
000707r 2  4F 50 45 4E  
00070Cr 2               wrerms	=	*-msgtbl
00070Cr 2  57 52 49 54  	.byte "WRITE ERROR",0
000710r 2  45 20 45 52  
000714r 2  52 4F 52 00  
000718r 2               ;function name table
000718r 2  44 49 52 20  fnctbl:	.byte	"DIR ",0
00071Cr 2  00           
00071Dr 2  53 41 56 45  	.byte	"SAVE ",0
000721r 2  20 00        
000723r 2  45 52 41 20  	.byte	"ERA ",0
000727r 2  00           
000728r 2  54 59 50 45  	.byte	"TYPE ",0
00072Cr 2  20 00        
00072Er 2  52 45 4E 20  	.byte	"REN ",0
000732r 2  00           
000733r 2  47 4F 20 00  	.byte	"GO ",0
000737r 2  4C 4F 41 44  	.byte	"LOAD ",0
00073Br 2  20 00        
00073Dr 2               ;input buffer
00073Dr 2               cnsbuf:
00073Dr 2  7F           cnsmax: .byte 127
00073Er 2  00           cnslng: .byte 0
00073Fr 2               cnstxt:
00073Fr 2  xx xx xx xx  	.res 127
000743r 2  xx xx xx xx  
000747r 2  xx xx xx xx  
0007BEr 2               ;fcb one
0007BEr 2               fcbone:
0007BEr 2  xx xx xx xx  	.res 33
0007C2r 2  xx xx xx xx  
0007C6r 2  xx xx xx xx  
0007DFr 2               ;com type field
0007DFr 2  43 4F 4D     typcom:	.byte	"COM"
0007E2r 2               ;variable storage
0007E2r 2  00           cnbfpt:	.byte	0		;buffer index
0007E3r 2  00           dfldsk:	.byte	0		;default drive
0007E4r 2  00           tmpdsk:	.byte	0		;temporary dvive
0007E5r 2               ;align vector on word boundary
0007E5r 2  xx           	.align 2
0007E6r 2  00 00        vector:	.word	0		;execution vector
0007E8r 2  00           ccmcount:	.byte	0		;counter
0007E9r 2  00           curpnt:	.byte	0		;input parse start
0007EAr 2  00           diradd:	.byte	0		;directory number
0007EBr 2  00           savx:	.byte	0		;save x location
0007ECr 2  00           savy:	.byte	0		;save y location
0007EDr 2  00           length:	.byte	0		;number tages to save
0007EEr 2  00           oldtmp:	.byte	0		;temp drive in ren
0007EFr 2  00 08        dskbuf:	.word	tea		;disk buffer start
0007F1r 2  00           across:	.byte	0		;dir count on line
0007F2r 2  00           sixten:	.byte	0		;line length div 16
0007F3r 2  09           moduls:	.byte	9		;modulus-1 for number input
0007F4r 2  00 00        num:	.word	0		;input number
0007F6r 2  00 00        tnum:	.word	0		;temp in bldnum
0007F8r 2  00 08        sadr:	.word	tea		;save start address
0007FAr 2               
0007FAr 1               		.include "PEM215.ASM"
0007FAr 2               ;-------------------------------
0007FAr 2               ;dos/65 primitive execution module (pem)
0007FAr 2               ;-------------------------------
0007FAr 2               ;zero page data storage
0007FAr 2               addinp	=	$02		;initialized to a,y
0007FAr 2               bufadd	=	$04		;buffer address
0007FAr 2               alcpnt	=	$06		;allocation map pointer
0007FAr 2               chkpnt	=	$08		;checksum map pointer
0007FAr 2               numvar	=	8		;eight bytes
0007FAr 2               ;main program
0007FAr 2               ; input:x=command,a=value,a&y=address
0007FAr 2               ; returns:a=value,a&y=address
0007FAr 2               ; alters:all
0007FAr 2               pem:
0007FAr 2  D8           	cld			;set binary mode
0007FBr 2  8D rr rr     	sta	bytinp		;save input
0007FEr 2  8D rr rr     	sta	lowin		;value and
000801r 2  8C rr rr     	sty	bytinp+1	;save high
000804r 2  8C rr rr     	sty	lowin+1		;address
000807r 2  8E rr rr     	stx	cmdinp		;and command
00080Ar 2  E0 24        	cpx	#numcmd		;if invalid
00080Cr 2  B0 50        	bcs	extpem		;then exit
00080Er 2  BD rr rr     	lda	swctbl,x	;if flag zero
000811r 2  F0 08        	beq	noswin		;skip switch
000813r 2  A9 FF        	lda	#255		;else set
000815r 2  8D rr rr     	sta	swcflg		;memory switch flag
000818r 2  20 rr rr     	jsr	switch		;move data to page zero
00081Br 2  A9 00        noswin:	lda	#0		;clear drive
00081Dr 2  8D rr rr     	sta	tmpdrv		;switch flag
000820r 2  AD rr rr     	lda	cmdinp		;get command
000823r 2  0A           	asl	a		;multiply by two
000824r 2  6D rr rr     	adc	cmdinp		;then add to get x3
000827r 2  AA           	tax			;and make a pointer
000828r 2  E8           	inx			;bump to pass jmp
000829r 2  BD rr rr     	lda	cmdtbl,x	;get command
00082Cr 2  BC rr rr     	ldy	cmdtbl+1,x	;address
00082Fr 2  8D rr rr     	sta	xqtvec		;and put
000832r 2  8C rr rr     	sty	xqtvec+1	;in vector
000835r 2  AD rr rr     	lda	extevc+1	;get return
000838r 2  48           	pha			;address
000839r 2  AD rr rr     	lda	extevc		;and push
00083Cr 2  48           	pha			;as return
00083Dr 2  AD rr rr     	lda	bytinp		;get input value
000840r 2  AC rr rr     	ldy	bytinp+1
000843r 2  6C rr rr     	jmp	(xqtvec)	;then execute
000846r 2  8D rr rr     extexq:	sta	bytout		;save value
000849r 2  8C rr rr     	sty	addout+1	;and address
00084Cr 2  AD rr rr     	lda	tmpdrv		;get temp drive
00084Fr 2  F0 0D        	beq	extpem		;if zero skip switch
000851r 2  A0 00        	ldy	#0		;else
000853r 2  91 02        	sta	(addinp),y	;put back in fcb
000855r 2  AD rr rr     	lda	olddrv		;get old drive number
000858r 2  8D rr rr     	sta	bytinp		;set input value
00085Br 2  20 rr rr     	jsr	chgdrv		;then switch back
00085Er 2  2C rr rr     extpem:	bit	swcflg		;test memory switch
000861r 2  10 08        	bpl	noswot		;if not set skip
000863r 2  20 rr rr     	jsr	switch		;else do memory switch
000866r 2  A9 00        	lda	#0		;clear
000868r 2  8D rr rr     	sta	swcflg		;flag
00086Br 2  AC rr rr     noswot:	ldy	addout+1	;get address
00086Er 2  AD rr rr     	lda	bytout		;and value (address low)
000871r 2  60           	rts
000872r 2               ;command vector table
000872r 2  4C rr rr     cmdtbl:	jmp	xwboot		;warm boot
000875r 2  4C rr rr     	jmp	xcnsin		;console input with echo
000878r 2  4C rr rr     	jmp	sndchr		;console output
00087Br 2  4C rr rr     	jmp	sim+21		;tape reader
00087Er 2  4C rr rr     	jmp	sim+18		;tape punch
000881r 2  4C rr rr     	jmp	sim+15		;printer output
000884r 2  4C rr rr     	jmp	getcon		;console input w/o echo
000887r 2  4C rr rr     	jmp	xgtios		;read i/o status
00088Ar 2  4C rr rr     	jmp	xstios		;set i/o status
00088Dr 2  4C rr rr     	jmp	sndstr		;print buffer
000890r 2  4C rr rr     	jmp	bufinp		;read buffer
000893r 2  4C rr rr     	jmp	kbdsts		;test console ready
000896r 2  4C rr rr     	jmp	sim+45		;read list status
000899r 2  4C rr rr     	jmp	xintds		;initialize system
00089Cr 2  4C rr rr     	jmp	chgdrv		;log in drive
00089Fr 2  4C rr rr     	jmp	xopen		;open file
0008A2r 2  4C rr rr     	jmp	xclose		;close file
0008A5r 2  4C rr rr     	jmp	xfndfr		;find first match
0008A8r 2  4C rr rr     	jmp	xfndnx		;find next match
0008ABr 2  4C rr rr     	jmp	xdltfl		;delete file
0008AEr 2  4C rr rr     	jmp	xread		;read record
0008B1r 2  4C rr rr     	jmp	xwrite		;write record
0008B4r 2  4C rr rr     	jmp	xmake		;create file
0008B7r 2  4C rr rr     	jmp	xrenme		;rename file
0008BAr 2  4C rr rr     	jmp	xintlg		;interrogate log in status
0008BDr 2  4C rr rr     	jmp	xintdr		;interrogate current drive
0008C0r 2  4C rr rr     	jmp	chgdma		;set buffer address
0008C3r 2  4C rr rr     	jmp	xrdalv		;read allocation map start
0008C6r 2  4C rr rr     	jmp	setron		;set r/w status
0008C9r 2  4C rr rr     	jmp	xrdros		;read r/w status
0008CCr 2  4C rr rr     	jmp	setlst		;set list echo status
0008CFr 2  4C rr rr     	jmp	lststs		;read list echo status
0008D2r 2  4C rr rr     	jmp	xrtclo		;read low clock
0008D5r 2  4C rr rr     	jmp	xrtchi		;read high clock
0008D8r 2  4C rr rr     	jmp	xrddcb		;read dcb address
0008DBr 2  4C rr rr     	jmp	sim+51		;translate sector
0008DEr 2               ;set list echo status
0008DEr 2  8D rr rr     setlst:	sta	lstflg		;set flag
0008E1r 2  60           	rts
0008E2r 2               ;read list echo status
0008E2r 2  AD rr rr     lststs:	lda	lstflg		;read flag
0008E5r 2  60           	rts
0008E6r 2               ;execute warm boot
0008E6r 2               ; ***this command does not return to pem***
0008E6r 2               ; ***instead it jumps to sim, resets	***
0008E6r 2               ; ***system and stack and jumps to ccm. ***
0008E6r 2  2C rr rr     xwboot:	bit	swcflg		;test memory switch flag
0008E9r 2  10 08        	bpl	dowmbt		;if clear do not
0008EBr 2  20 rr rr     	jsr	switch		;switch memory
0008EEr 2  A9 00        	lda	#0		;clear
0008F0r 2  8D rr rr     	sta	swcflg		;flag
0008F3r 2  4C rr rr     dowmbt:	jmp	sim+3		;go to sim
0008F6r 2               
0008F6r 2               ;execute read real time clock
0008F6r 2  20 rr rr     xrtclo:	jsr	sim+48		;read clock
0008F9r 2               
0008F9r 2  8D rr rr     	sta	rtclk		;save low
0008FCr 2  8C rr rr     	sty	rtclk+1		;middle
0008FFr 2  8E rr rr     	stx	rtclk+2		;high
000902r 2  8A           	txa
000903r 2  29 80        	and	#%10000000	;test for valid
000905r 2  A8           	tay
000906r 2  AD rr rr     	lda	rtclk		;get low
000909r 2  60           	rts
00090Ar 2               ;execute read real time clock high
00090Ar 2  AD rr rr     xrtchi:	lda	rtclk+2		;get high
00090Dr 2  29 7F        	and	#%01111111	;clear status
00090Fr 2  A8           	tay
000910r 2  AD rr rr     	lda	rtclk+1		;get middle
000913r 2  60           	rts
000914r 2               ;execute read dcb address
000914r 2  AD rr rr     xrddcb:	lda	cptdcb+1	;get address
000917r 2  AC rr rr     	ldy	cptdcb+2
00091Ar 2  60           	rts
00091Br 2               ;execute read i/o status
00091Br 2  AD 06 01     xgtios:	lda	iostat		;get status byte
00091Er 2  60           	rts
00091Fr 2               ;execute read allocation map starting address
00091Fr 2  AD rr rr     xrdalv:	lda	alcmap		;get
000922r 2  AC rr rr     	ldy	alcmap+1	;starting address
000925r 2  60           	rts			;then return
000926r 2               ;execute set i/o status
000926r 2  8D 06 01     xstios:	sta	iostat		;set status
000929r 2  60           	rts
00092Ar 2               ;execute interrogate current drive
00092Ar 2  AD rr rr     xintdr:	lda	curdrv		;get number
00092Dr 2  60           	rts
00092Er 2               ;execute read log in status
00092Er 2  AD rr rr     xintlg:	lda	lginvc		;get status
000931r 2  60           	rts
000932r 2               ;execute read read/write status
000932r 2  AD rr rr     xrdros:	lda	ronlst		;get status
000935r 2  60           	rts
000936r 2               ;execute find next match
000936r 2  20 rr rr     xfndnx:	jsr	autodr		;auto drive select
000939r 2  A9 0D        	lda	#13		;match including
00093Br 2  4C rr rr     	jmp	search		;extent
00093Er 2               ;execute read next record
00093Er 2  20 rr rr     xread:	jsr	autodr		;auto drive select
000941r 2  20 rr rr     	jsr	inrcct		;initialize record counters
000944r 2  AD rr rr     	lda	nxtrec		;if next record less
000947r 2  CD rr rr     	cmp	numrec		;then number records
00094Ar 2  90 13        	bcc	tryrde		;then try to read
00094Cr 2  C9 80        	cmp	#128		;but if not and
00094Er 2  F0 03        	beq	tryext		;is max try to extend
000950r 2  A9 01        rdeeof:	lda	#1		;else set eof
000952r 2  60           	rts			;code and return
000953r 2  A2 01        tryext:	ldx	#1		;try for a read
000955r 2  20 rr rr     	jsr	extend		;file extension
000958r 2  C9 00        	cmp	#0		;if not ok exit eof
00095Ar 2  D0 F4        	bne	rdeeof		;with jump back
00095Cr 2  8D rr rr     	sta	nxtrec		;clear next record
00095Fr 2  20 rr rr     tryrde:	jsr	getblk		;and get block
000962r 2  AD rr rr     	lda	blknum		;if block not zero
000965r 2  0D rr rr     	ora	blknum+1
000968r 2  D0 03        	bne	dorde		;do the read
00096Ar 2  A9 02        	lda	#2		;else set unwritten
00096Cr 2  60           	rts			;code and exit
00096Dr 2  20 rr rr     dorde:	jsr	calrcn		;calculate record number
000970r 2  20 rr rr     	jsr	sttrsc		;set track and sector
000973r 2  20 rr rr     	jsr	rdesec		;do sector read
000976r 2  20 rr rr     	jsr	updtrc		;update counters
000979r 2  A9 00        	lda	#0		;return w/o error
00097Br 2  60           extrde:	rts
00097Cr 2               ;execute file rename
00097Cr 2  20 rr rr     xrenme:	jsr	autodr		;automatic drive select
00097Fr 2  20 rr rr     	jsr	tstron		;test for r/o
000982r 2  A9 0C        	lda	#12		;match name
000984r 2  20 rr rr     	jsr	frstsr		;and type
000987r 2  30 14        	bmi	extren		;exit if not found
000989r 2  A9 00        doren:	lda	#0		;clear drive select
00098Br 2  A0 10        	ldy	#16		;in new name
00098Dr 2  91 02        	sta	(addinp),y	;part of fcb
00098Fr 2  A9 0C        	lda	#12		;then move
000991r 2  A2 10        	ldx	#16		;new name
000993r 2  20 rr rr     	jsr	dirchg		;to directory
000996r 2  A9 0C        	lda	#12		;see if
000998r 2  20 rr rr     	jsr	search		;another match
00099Br 2  10 EC        	bpl	doren		;loop if found
00099Dr 2  60           extren:	rts			;number
00099Er 2               ;execute delete file
00099Er 2  20 rr rr     xdltfl:	jsr	autodr		;automatic drive select
0009A1r 2  20 rr rr     	jsr	tstron		;test for r/o
0009A4r 2  A9 0C        	lda	#12		;match name
0009A6r 2  20 rr rr     	jsr	frstsr		;and type
0009A9r 2  30 17        	bmi	extdlt		;done if not found
0009ABr 2  A2 00        dodlt:	ldx	#0		;else do a
0009ADr 2  20 rr rr     	jsr	mapdir		;delete
0009B0r 2  AC rr rr     	ldy	subrec		;then change
0009B3r 2  AD rr rr     	lda	empty		;byte zero to
0009B6r 2  91 04        	sta	(bufadd),y	;empty code
0009B8r 2  20 rr rr     	jsr	updtck		;then update directory
0009BBr 2  A9 0C        	lda	#12		;search
0009BDr 2  20 rr rr     	jsr	search		;for next
0009C0r 2  10 E9        	bpl	dodlt		;loop if found
0009C2r 2  60           extdlt:	rts			;exit
0009C3r 2               ;execute write next record
0009C3r 2  20 rr rr     xwrite:	jsr	autodr		;automatic drive select
0009C6r 2  20 rr rr     	jsr	tstron		;test for r/o
0009C9r 2  20 rr rr     	jsr	inrcct		;initialize counters
0009CCr 2  AD rr rr     	lda	nxtrec		;get next record
0009CFr 2  C9 80        	cmp	#128		;compare to max
0009D1r 2  90 03        	bcc	ntexte		;continue if less
0009D3r 2  A9 01        	lda	#1		;else flag as extend
0009D5r 2  60           	rts			;error and exit
0009D6r 2  20 rr rr     ntexte:	jsr	getblk		;calculate block num
0009D9r 2  A9 00        	lda	#0		;say normal write
0009DBr 2  8D rr rr     	sta	pemwrtype		;for now
0009DEr 2  AD rr rr     	lda	blknum		;get it and if
0009E1r 2  0D rr rr     	ora	blknum+1
0009E4r 2  F0 03        	beq	*+5		;zero then get number
0009E6r 2  4C rr rr     	jmp	blkopn		;else go write
0009E9r 2  A9 02        	lda	#2		;say unalloc write
0009EBr 2  8D rr rr     	sta	pemwrtype
0009EEr 2  AD rr rr     	lda	fcbind		;get index from prior
0009F1r 2  48           	pha			;and save
0009F2r 2  C9 10        	cmp	#16		;if first block
0009F4r 2  F0 1A        	beq	isfrst		;then don't change
0009F6r 2  A8           	tay			;else make an index
0009F7r 2  88           	dey			;point to last
0009F8r 2  2C rr rr     	bit	blmode		;test mode
0009FBr 2  10 01        	bpl	*+3		;done if byte
0009FDr 2  88           	dey			;else drop for word
0009FEr 2  B1 02        	lda	(addinp),y	;and get that number
000A00r 2  8D rr rr     	sta	blknum		;store as starting
000A03r 2  C8           	iny			;bump for word
000A04r 2  A9 00        	lda	#0		;preset for byte
000A06r 2  2C rr rr     	bit	blmode		;test mode
000A09r 2  10 02        	bpl	*+4		;done if byte
000A0Br 2  B1 02        	lda	(addinp),y	;else get high
000A0Dr 2  8D rr rr     	sta	blknum+1	;then set high
000A10r 2  AD rr rr     isfrst:	lda	blknum		;get block
000A13r 2  8D rr rr     	sta	lkdown		;set lower and
000A16r 2  8D rr rr     	sta	lookup		;upper pointers
000A19r 2  AD rr rr     	lda	blknum+1	;now set high part
000A1Cr 2  8D rr rr     	sta	lkdown+1
000A1Fr 2  8D rr rr     	sta	lookup+1
000A22r 2  AD rr rr     srblag:	lda	lookup		;if upper pointer
000A25r 2  CD rr rr     	cmp	maxblk		;not at max
000A28r 2  D0 08        	bne	upnemx		;then keep going
000A2Ar 2  AC rr rr     	ldy	lookup+1	;now check high
000A2Dr 2  CC rr rr     	cpy	maxblk+1
000A30r 2  F0 12        	beq	tstdwn		;go test down
000A32r 2  EE rr rr     upnemx:	inc	lookup		;else bump upper
000A35r 2  D0 03        	bne	*+5
000A37r 2  EE rr rr     	inc	lookup+1
000A3Ar 2  AD rr rr     	lda	lkdown		;then if lower
000A3Dr 2  0D rr rr     	ora	lkdown+1
000A40r 2  F0 18        	beq	dotest		;is zero start test
000A42r 2  D0 0B        	bne	dcdown		;else drop lower
000A44r 2  AD rr rr     tstdwn:	lda	lkdown		;if upper & lower at
000A47r 2  0D rr rr     	ora	lkdown+1
000A4Ar 2  D0 03        	bne	dcdown		;drop if not zero
000A4Cr 2  A8           	tay			;also set y
000A4Dr 2  F0 30        	beq	extsbl		;then exit
000A4Fr 2  AD rr rr     dcdown:	lda	lkdown		;drop lower
000A52r 2  D0 03        	bne	*+5
000A54r 2  CE rr rr     	dec	lkdown+1
000A57r 2  CE rr rr     	dec	lkdown
000A5Ar 2  AD rr rr     dotest:	lda	lkdown		;get lower
000A5Dr 2  AC rr rr     	ldy	lkdown+1
000A60r 2  20 rr rr     	jsr	tstblk		;and test
000A63r 2  D0 09        	bne	trylup		;if full try upper
000A65r 2  AD rr rr     	lda	lkdown		;else use lower
000A68r 2  AC rr rr     	ldy	lkdown+1
000A6Br 2  4C rr rr     	jmp	extsbl		;as result
000A6Er 2  AD rr rr     trylup:	lda	lookup		;get upper
000A71r 2  AC rr rr     	ldy	lookup+1
000A74r 2  20 rr rr     	jsr	tstblk		;if full
000A77r 2  D0 A9        	bne	srblag		;then loop
000A79r 2  AD rr rr     	lda	lookup		;else use upper
000A7Cr 2  AC rr rr     	ldy	lookup+1
000A7Fr 2  8D rr rr     extsbl:	sta	blknum		;then save number
000A82r 2  8C rr rr     	sty	blknum+1
000A85r 2  0D rr rr     	ora	blknum+1	;see if zero
000A88r 2  D0 04        	bne	gtgood		;then proceed
000A8Ar 2  68           	pla			;clear stack
000A8Br 2  A9 02        	lda	#2		;set end
000A8Dr 2  60           	rts			;of data return
000A8Er 2  AD rr rr     gtgood:	lda	blknum		;get low again
000A91r 2  20 rr rr     	jsr	setblk		;set allocation map
000A94r 2  68           	pla			;get block
000A95r 2  A8           	tay			;pointer back
000A96r 2  AD rr rr     	lda	blknum		;get number
000A99r 2  91 02        	sta	(addinp),y	;and put in fcb
000A9Br 2  AD rr rr     	lda	blknum+1	;get high
000A9Er 2  C8           	iny
000A9Fr 2  2C rr rr     	bit	blmode		;test mode
000AA2r 2  10 02        	bpl	*+4		;done if byte
000AA4r 2  91 02        	sta	(addinp),y	;else set high
000AA6r 2  20 rr rr     blkopn:	jsr	calrcn		;calculate record num
000AA9r 2  20 rr rr     	jsr	sttrsc		;set track and sector
000AACr 2  20 rr rr     	jsr	wrtsec		;do write
000AAFr 2  AE rr rr     	ldx	nxtrec		;get next record
000AB2r 2  EC rr rr     	cpx	numrec		;if less than max
000AB5r 2  90 05        	bcc	notful		;then ok
000AB7r 2  E8           	inx			;else bump count
000AB8r 2  8E rr rr     	stx	numrec		;and save
000ABBr 2  CA           	dex			;back down
000ABCr 2  E0 7F        notful:	cpx	#127		;if not at max
000ABEr 2  D0 11        	bne	noawex		;skip extending
000AC0r 2  20 rr rr     	jsr	updtrc		;update record counters
000AC3r 2  A2 00        	ldx	#0		;do write
000AC5r 2  20 rr rr     	jsr	extend		;file extension
000AC8r 2  C9 00        	cmp	#0		;if not ok
000ACAr 2  D0 0A        	bne	extwrt		;exit
000ACCr 2  A9 FF        	lda	#255		;else start counter
000ACEr 2  8D rr rr     	sta	nxtrec		;at one short
000AD1r 2  20 rr rr     noawex:	jsr	updtrc		;then update counters
000AD4r 2  A9 00        	lda	#0		;good return
000AD6r 2  60           extwrt:	rts			;exit
000AD7r 2               ;execute console input
000AD7r 2  20 rr rr     xcnsin:	jsr	getcon		;get input
000ADAr 2  20 rr rr     	jsr	tstchr		;test it and
000ADDr 2  90 05        	bcc	extxci		;if control exit
000ADFr 2  48           	pha			;else save
000AE0r 2  20 rr rr     	jsr	sndchr		;echo
000AE3r 2  68           	pla			;restore
000AE4r 2  60           extxci:	rts			;return
000AE5r 2               ;switch memory
000AE5r 2               ;page zero block begins at $02 and is numvar bytes long.
000AE5r 2  A2 07        switch:	ldx	#numvar-1	;get number to switch
000AE7r 2  B5 02        nxtswh:	lda	2,x		;get zero page
000AE9r 2  BC rr rr     	ldy	varblk,x	;and save area
000AECr 2  9D rr rr     	sta	varblk,x	;save zero
000AEFr 2  94 02        	sty	2,x		;and high
000AF1r 2  CA           	dex			;count down
000AF2r 2  10 F3        	bpl	nxtswh		;and loop until done
000AF4r 2  60           drvsme:	rts			;then return
000AF5r 2               ;change dma address
000AF5r 2               ; input:addinp=address
000AF5r 2               ; returns:none
000AF5r 2               ; alters:all
000AF5r 2  A5 02        chgdma:	lda	addinp		;get low
000AF7r 2  A4 03        	ldy	addinp+1	;and high address
000AF9r 2  85 04        	sta	bufadd		;then store
000AFBr 2  84 05        	sty	bufadd+1	;in address
000AFDr 2  4C rr rr     	jmp	sim+36		;then go to sim
000B00r 2               
000B00r 2               ;change drive
000B00r 2               ; input:bytinp
000B00r 2               ; returns:none
000B00r 2               ; alters:all
000B00r 2  AD rr rr     chgdrv:	lda	bytinp		;get input
000B03r 2  CD rr rr     	cmp	curdrv		;if same as current
000B06r 2  F0 EC        	beq	drvsme		;do nothing
000B08r 2  8D rr rr     	sta	curdrv		;else change current
000B0Br 2  4C rr rr     	jmp	mapdrv		;then log it in
000B0Er 2               ;automatic drive select
000B0Er 2               ; input:(addinp) 0=no change
000B0Er 2               ; 1-8 or 'A'-'H' = change
000B0Er 2               ; returns:none
000B0Er 2               ; alters:all
000B0Er 2  A0 00        autodr:	ldy	#0		;get
000B10r 2  B1 02        	lda	(addinp),y	;first byte of fcb
000B12r 2  F0 19        	beq	qtatdr		;if zero quit
000B14r 2  38           	sec			;set carry for
000B15r 2  E9 01        	sbc	#1		;subtract one
000B17r 2  29 07        	and	#%00000111	;look at three lsbs
000B19r 2  8D rr rr     	sta	bytinp		;make parameter
000B1Cr 2  AD rr rr     	lda	curdrv		;get current
000B1Fr 2  8D rr rr     	sta	olddrv		;and save
000B22r 2  B1 02        	lda	(addinp),y	;get fcb entry
000B24r 2  8D rr rr     	sta	tmpdrv		;and save as flag
000B27r 2  98           	tya			;set a to 0
000B28r 2  91 02        	sta	(addinp),y	;clear byte zero in fcb
000B2Ar 2  20 rr rr     	jsr	chgdrv		;then select new drive
000B2Dr 2  60           qtatdr:	rts			;and return
000B2Er 2               ;execute initialize system
000B2Er 2               ; input:none
000B2Er 2               ; returns:none
000B2Er 2               ; alters:all,curdrv,lginvc,bufadd
000B2Er 2  A9 02        xintds:	lda	#DEFDRV		;set current
000B30r 2  8D rr rr     	sta	curdrv		;drive to a
000B33r 2  8D rr rr     	sta	lginvc		;clear log in status
000B36r 2  A9 28        	lda	#<dflbuf	;get default buffer
000B38r 2  A0 01        	ldy	#>dflbuf	;address
000B3Ar 2  85 02        	sta	addinp		;and set up
000B3Cr 2  84 03        	sty	addinp+1	;parameters
000B3Er 2  20 rr rr     	jsr	chgdma		;change address
000B41r 2               
000B41r 2               ;log in drive and set pointers and maps
000B41r 2               ; input:curdrv
000B41r 2               ; returns:none
000B41r 2               ; alters:all
000B41r 2  AD rr rr     mapdrv:	lda	curdrv		;if current drive
000B44r 2  C9 08        	cmp	#8		;is 0 to 7
000B46r 2  90 0F        	bcc	vlddrv		;then log it in
000B48r 2  20 rr rr     drserr:	jsr	errout		;send error message
000B4Br 2  AD rr rr     	lda	sltmvc		;point to
000B4Er 2  AC rr rr     	ldy	sltmvc+1	;select message
000B51r 2  20 rr rr     	jsr	sndstr		;and send it
000B54r 2               
000B54r 2  4C rr rr     	jmp	xwboot		;and abort
000B57r 2               
000B57r 2  20 rr rr     vlddrv:	jsr	sim+27		;go to sim to set
000B5Ar 2  8D rr rr     	sta	cptdcb+1	;save
000B5Dr 2  8C rr rr     	sty	cptdcb+2
000B60r 2  0D rr rr     	ora	cptdcb+2	;see if invalid
000B63r 2  F0 E3        	beq	drserr		;error if is
000B65r 2               ;capture dcb
000B65r 2  A0 0D        	ldy	#14-1		;do 14 bytes
000B67r 2  B9 FF FF     cptdcb:	lda	$ffff,y		;get value from sim
000B6Ar 2  99 rr rr     	sta	dcb,y		;store it
000B6Dr 2  88           	dey
000B6Er 2  10 F7        	bpl	cptdcb		;loop for more
000B70r 2  AD rr rr     	lda	blkscd		;get block size code
000B73r 2  A8           	tay			;save in y
000B74r 2  18           	clc
000B75r 2  69 03        	adc	#3		;convert to sxb
000B77r 2  8D rr rr     	sta	sxb		;and save
000B7Ar 2  B9 rr rr     	lda	sabtbl,y	;get sab
000B7Dr 2  8D rr rr     	sta	sab		;and set
000B80r 2  AD rr rr     	lda	maxdir		;get max dir
000B83r 2  8D rr rr     	sta	maxdrc		;set max dir record
000B86r 2  AD rr rr     	lda	maxdir+1
000B89r 2  4A           	lsr	a		;divide by 4
000B8Ar 2  6E rr rr     	ror	maxdrc
000B8Dr 2  4A           	lsr	a
000B8Er 2  6E rr rr     	ror	maxdrc
000B91r 2  8D rr rr     	sta	maxdrc+1	;then save high
000B94r 2  A9 00        	lda	#0		;set mode to byte
000B96r 2  8D rr rr     	sta	blmode
000B99r 2  AD rr rr     	lda	maxblk+1	;branch if max block
000B9Cr 2  F0 05        	beq	ntm255		;not over 255
000B9Er 2               ;if y=0 when the following line is executed it means
000B9Er 2               ;that the user has put an illegal combination into
000B9Er 2               ;the disk definition table. may want to consider
000B9Er 2               ;putting some error checking here in the future if
000B9Er 2               ;there is space in pem.
000B9Er 2  88           	dey			;back up index
000B9Fr 2  38           	sec			;else set mode to word
000BA0r 2  6E rr rr     	ror	blmode
000BA3r 2  B9 rr rr     ntm255:	lda	exmtbl,y	;get extent mask
000BA6r 2  8D rr rr     	sta	exm
000BA9r 2               
000BA9r 2  38           	sec			;now calculate cexm1f
000BAAr 2  A9 1F        	lda	#31
000BACr 2  F9 rr rr     	sbc	exmtbl,y
000BAFr 2  8D rr rr     	sta	cexm1f
000BB2r 2  AE rr rr     	ldx	curdrv		;get drive as pointer
000BB5r 2  BD rr rr     	lda	bitmap,x	;get bit
000BB8r 2  2D rr rr     	and	lginvc		;if logged in
000BBBr 2  D0 0C        	bne	extstm		;then exit
000BBDr 2  BD rr rr     	lda	bitmap,x	;get bit back
000BC0r 2  0D rr rr     	ora	lginvc		;set in log-in
000BC3r 2  8D rr rr     	sta	lginvc		;and update
000BC6r 2  4C rr rr     	jmp	flinal		;then fill in maps
000BC9r 2               
000BC9r 2  60           extstm:	rts			;and return
000BCAr 2               ;fill in allocation map
000BCAr 2  20 rr rr     flinal:	jsr	setrw		;set to read/write
000BCDr 2  AD rr rr     	lda	maxblk		;divide max block by
000BD0r 2  8D rr rr     	sta	gpcnt		;eight to get max
000BD3r 2  AD rr rr     	lda	maxblk+1
000BD6r 2  A2 03        	ldx	#3
000BD8r 2  4A           clcnab:	lsr	a		;use a for speed
000BD9r 2  6E rr rr     	ror	gpcnt
000BDCr 2  CA           	dex
000BDDr 2  D0 F9        	bne	clcnab		;loop if more
000BDFr 2  8D rr rr     	sta	gpcnt+1		;save high
000BE2r 2  EE rr rr     	inc	gpcnt		;bump by one
000BE5r 2  D0 03        	bne	*+5
000BE7r 2  EE rr rr     	inc	gpcnt+1		;with carry
000BEAr 2  AD rr rr     	lda	alcmap		;get map start
000BEDr 2  AC rr rr     	ldy	alcmap+1
000BF0r 2  85 06        	sta	alcpnt		;set pointer to start
000BF2r 2  84 07        	sty	alcpnt+1
000BF4r 2  A0 00        	ldy	#0		;clear index
000BF6r 2  A9 00        clraml:	lda	#0		;clear byte
000BF8r 2  91 06        	sta	(alcpnt),y	;put in map
000BFAr 2  E6 06        	inc	alcpnt		;bump pointer
000BFCr 2  D0 02        	bne	*+4
000BFEr 2  E6 07        	inc	alcpnt+1	;with carry
000C00r 2  AD rr rr     	lda	gpcnt		;get low of count
000C03r 2  D0 03        	bne	*+5		;skip if not zero
000C05r 2  CE rr rr     	dec	gpcnt+1		;else drop high
000C08r 2  CE rr rr     	dec	gpcnt		;always drop low
000C0Br 2  AD rr rr     	lda	gpcnt		;test for zero
000C0Er 2  0D rr rr     	ora	gpcnt+1
000C11r 2  D0 E3        	bne	clraml		;loop if more
000C13r 2               ;at this point complete map is cleared
000C13r 2  AD rr rr     	lda	maxdrc		;get low of max dir record
000C16r 2  8D rr rr     	sta	gpcnt
000C19r 2  AD rr rr     	lda	maxdrc+1	;high in a
000C1Cr 2  AE rr rr     	ldx	sxb		;set x according to block size
000C1Fr 2  4A           clcmdb:	lsr	a		;do division
000C20r 2  6E rr rr     	ror	gpcnt
000C23r 2  CA           	dex
000C24r 2  D0 F9        	bne	clcmdb		;until x is zero
000C26r 2  8D rr rr     	sta	gpcnt+1		;set high
000C29r 2  EE rr rr     	inc	gpcnt		;then bump by one
000C2Cr 2  D0 03        	bne	*+5
000C2Er 2  EE rr rr     	inc	gpcnt+1
000C31r 2  8E rr rr     	stx	blknum		;clear block number
000C34r 2  8E rr rr     	stx	blknum+1
000C37r 2  AD rr rr     fildal:	lda	blknum		;get block number
000C3Ar 2  AC rr rr     	ldy	blknum+1
000C3Dr 2  20 rr rr     	jsr	setblk		;set bit
000C40r 2  EE rr rr     	inc	blknum		;bump block number
000C43r 2  D0 03        	bne	*+5
000C45r 2  EE rr rr     	inc	blknum+1
000C48r 2  AD rr rr     	lda	gpcnt		;get low of count
000C4Br 2  D0 03        	bne	*+5		;skip if not zero
000C4Dr 2  CE rr rr     	dec	gpcnt+1		;else drop high
000C50r 2  CE rr rr     	dec	gpcnt		;always do low
000C53r 2  AD rr rr     	lda	gpcnt		;test for zero
000C56r 2  0D rr rr     	ora	gpcnt+1
000C59r 2  D0 DC        	bne	fildal		;loop if more
000C5Br 2               ;at this point directory space is mapped
000C5Br 2  20 rr rr     	jsr	intdrv		;initialize drive
000C5Er 2  20 rr rr     	jsr	cldrnm		;clear directory number
000C61r 2  A2 01        fillpe:	ldx	#1		;parameter for fill
000C63r 2  20 rr rr     	jsr	nxtdir		;execute for next directory
000C66r 2  30 11        	bmi	extfil		;done if invalid
000C68r 2  AC rr rr     	ldy	subrec		;get offset
000C6Br 2  B1 04        	lda	(bufadd),y	;get empty/valid flag
000C6Dr 2  C9 E5        	cmp	#$e5		;if empty
000C6Fr 2  F0 F0        	beq	fillpe		;try next
000C71r 2  A2 01        	ldx	#1		;parameter for fill in
000C73r 2  20 rr rr     	jsr	mapdir		;do directory map
000C76r 2  4C rr rr     	jmp	fillpe		;then loop
000C79r 2  60           extfil:	rts			;return
000C7Ar 2               ;initialize drive
000C7Ar 2               ; input:nsystr
000C7Ar 2               ; returns:none
000C7Ar 2               ; alters:all
000C7Ar 2  20 rr rr     intdrv:	jsr	sim+24		;home then
000C7Dr 2               
000C7Dr 2  AD rr rr     	lda	nsystr		;get number of system tracks
000C80r 2  AC rr rr     	ldy	nsystr+1
000C83r 2  4C rr rr     	jmp	sim+30		;and set in sim
000C86r 2               
000C86r 2               ;directory record set up
000C86r 2               ; input:dirnum
000C86r 2               ; returns:none
000C86r 2               ; alters:all,recnum,dirrec
000C86r 2  AD rr rr     drrcsu:	lda	dirnum+1	;move high dir number
000C89r 2  8D rr rr     	sta	recnum+1	;to record number
000C8Cr 2  AD rr rr     	lda	dirnum		;divide
000C8Fr 2  4E rr rr     	lsr	recnum+1	;directory by four
000C92r 2  6A           	ror	a
000C93r 2  4E rr rr     	lsr	recnum+1
000C96r 2  6A           	ror	a
000C97r 2  8D rr rr     	sta	dirrec		;and save
000C9Ar 2  8D rr rr     	sta	recnum		;set low record number
000C9Dr 2  AD rr rr     	lda	recnum+1	;get high
000CA0r 2  8D rr rr     	sta	dirrec+1	;and set
000CA3r 2  A9 00        	lda	#0		;clear top byte
000CA5r 2  8D rr rr     	sta	recnum+2
000CA8r 2               ;set track and sector
000CA8r 2               ; input:recnum
000CA8r 2               ; returns:none
000CA8r 2               ; alters:all,countr,trkctr
000CA8r 2  A2 00        sttrsc:	ldx	#0		;clear track counter
000CAAr 2  8E rr rr     	stx	trkctr
000CADr 2  8E rr rr     	stx	countr		;and record
000CB0r 2  8E rr rr     	stx	countr+1	;counter
000CB3r 2  8E rr rr     	stx	countr+2
000CB6r 2  AD rr rr     trnxtr:	lda	recnum		;from
000CB9r 2  CD rr rr     	cmp	countr		;record number
000CBCr 2  AD rr rr     	lda	recnum+1	;and if a
000CBFr 2  ED rr rr     	sbc	countr+1	;borrow then
000CC2r 2  AD rr rr     	lda	recnum+2
000CC5r 2  ED rr rr     	sbc	countr+2
000CC8r 2  90 21        	bcc	higher		;gone too far
000CCAr 2  18           	clc			;else
000CCBr 2  AD rr rr     	lda	countr		;get counter
000CCEr 2  6D rr rr     	adc	sectrk		;add sectors per track
000CD1r 2  8D rr rr     	sta	countr		;sectors per track
000CD4r 2  AD rr rr     	lda	countr+1
000CD7r 2  6D rr rr     	adc	sectrk+1
000CDAr 2  8D rr rr     	sta	countr+1
000CDDr 2  90 03        	bcc	bumptr		;done if no carry
000CDFr 2  EE rr rr     	inc	countr+2	;else bump high
000CE2r 2  E8           bumptr:	inx			;increase track count
000CE3r 2  D0 D1        	bne	trnxtr		;with carry
000CE5r 2  EE rr rr     	inc	trkctr
000CE8r 2  4C rr rr     	jmp	trnxtr		;then loop
000CEBr 2  CA           higher:	dex			;back up track
000CECr 2  E0 FF        	cpx	#$ff		;see if wrap around
000CEEr 2  D0 03        	bne	*+5		;wasn't
000CF0r 2  CE rr rr     	dec	trkctr		;else drop high
000CF3r 2  8A           	txa			;move to a
000CF4r 2  18           	clc			;add starting track
000CF5r 2  6D rr rr     	adc	nsystr
000CF8r 2  AA           	tax			;save in x
000CF9r 2  AD rr rr     	lda	trkctr
000CFCr 2  6D rr rr     	adc	nsystr+1
000CFFr 2  A8           	tay			;move to correct registers
000D00r 2  8A           	txa
000D01r 2  20 rr rr     	jsr	sim+30		;then set in sim
000D04r 2               
000D04r 2  38           	sec			;back
000D05r 2  AD rr rr     	lda	countr		;counter down
000D08r 2  ED rr rr     	sbc	sectrk		;by sectors per track
000D0Br 2  8D rr rr     	sta	countr		;and save
000D0Er 2  AD rr rr     	lda	countr+1
000D11r 2  ED rr rr     	sbc	sectrk+1
000D14r 2  8D rr rr     	sta	countr+1
000D17r 2  38           	sec			;now
000D18r 2  AD rr rr     	lda	recnum		;find difference
000D1Br 2  ED rr rr     	sbc	countr		;as sector
000D1Er 2  AA           	tax			;save in x
000D1Fr 2  AD rr rr     	lda	recnum+1
000D22r 2  ED rr rr     	sbc	countr+1
000D25r 2  A8           	tay			;move to correct registers
000D26r 2  8A           	txa
000D27r 2  20 rr rr     	jsr	sim+51		;translate
000D2Ar 2               
000D2Ar 2  4C rr rr     	jmp	sim+33		;and set through sim
000D2Dr 2               
000D2Dr 2               ;get block bit mask and index
000D2Dr 2               ; input:a&y=block number
000D2Dr 2               ; returns:a=bit mask and y=0
000D2Dr 2               ; alters:all and alcpnt
000D2Dr 2  48           blkmsk:	pha			;save block number
000D2Er 2  84 07        	sty	alcpnt+1	;including high
000D30r 2  A0 03        	ldy	#3		;divide by eight
000D32r 2  46 07        blkmlp:	lsr	alcpnt+1	;shift high
000D34r 2  6A           	ror	a
000D35r 2  88           	dey			;loop until done
000D36r 2  D0 FA        	bne	blkmlp
000D38r 2  18           	clc			;now add map start
000D39r 2  6D rr rr     	adc	alcmap
000D3Cr 2  85 06        	sta	alcpnt
000D3Er 2  A5 07        	lda	alcpnt+1
000D40r 2  6D rr rr     	adc	alcmap+1
000D43r 2  85 07        	sta	alcpnt+1
000D45r 2  68           	pla			;get number back
000D46r 2  29 07        	and	#%00000111	;look at 3 lsbs
000D48r 2  AA           	tax			;get
000D49r 2  BD rr rr     	lda	bitmsk,x	;mask
000D4Cr 2  60           	rts			;and return
000D4Dr 2               ;test block
000D4Dr 2               ; input:a&y=block number
000D4Dr 2               ; returns:z=1 if unassigned
000D4Dr 2               ; 	   =0 if assigned and bit in a is set
000D4Dr 2               ; alters:all
000D4Dr 2  20 rr rr     tstblk:	jsr	blkmsk		;get mask and index
000D50r 2  31 06        	and	(alcpnt),y	;mask with map entry
000D52r 2  60           	rts			;then return
000D53r 2               ;alter block status
000D53r 2               ; input:a&y=block number,x=1 if set
000D53r 2               ;		   	  =0 if reset
000D53r 2               ; returns:none
000D53r 2               ; alters:all and allocation map
000D53r 2  E0 01        altalc:	cpx	#1		;if set
000D55r 2  F0 0A        	beq	setblk		;go do it
000D57r 2  20 rr rr     clrblk:	jsr	blkmsk		;else get mask
000D5Ar 2  49 FF        	eor	#$ff		;and complement
000D5Cr 2  31 06        	and	(alcpnt),y	;preserve others
000D5Er 2  91 06        	sta	(alcpnt),y	;and save
000D60r 2  60           	rts			;then return
000D61r 2  20 rr rr     setblk:	jsr	blkmsk		;get mask
000D64r 2  11 06        	ora	(alcpnt),y	;set bit
000D66r 2  91 06        	sta	(alcpnt),y	;and put back
000D68r 2  60           	rts			;then return
000D69r 2               ;set current drive to read only
000D69r 2               ; input:curdrv,ronlst,bitmap
000D69r 2               ; returns:none
000D69r 2               ; alters:a,x,p and ronlst
000D69r 2  AE rr rr     setron:	ldx	curdrv		;get number
000D6Cr 2  BD rr rr     	lda	bitmap,x	;and get mask
000D6Fr 2  0D rr rr     	ora	ronlst		;or with status
000D72r 2  8D rr rr     	sta	ronlst		;and put back
000D75r 2  60           	rts			;then return
000D76r 2               ;calculate checksum of buffer @ bufadd
000D76r 2               ; input: buffer@(bufadd)
000D76r 2               ; returns:a=checksum
000D76r 2               ; alters:a,y,p
000D76r 2  A9 00        clcchk:	lda	#0		;clear accumulator
000D78r 2  A0 7F        	ldy	#127		;start at end
000D7Ar 2  18           chkmre:	clc			;no carry
000D7Br 2  71 04        	adc	(bufadd),y	;add byte
000D7Dr 2  88           	dey			;count down
000D7Er 2  10 FA        	bpl	chkmre		;and loop until done
000D80r 2  60           	rts			;then return
000D81r 2               ;check read/write status
000D81r 2               ; input:curdrv,ronlst
000D81r 2               ; returns:z=0 if r/o or z=1 if r/w
000D81r 2               ; alters:a,x,p
000D81r 2  AE rr rr     chkron:	ldx	curdrv		;get current drive
000D84r 2  BD rr rr     	lda	bitmap,x	;get mask
000D87r 2  2D rr rr     	and	ronlst		;and test status
000D8Ar 2  60           	rts
000D8Br 2               ;initialize record counters from fcb
000D8Br 2               ; input:fcb@(addinp)
000D8Br 2               ; returns:none
000D8Br 2               ; alters:a,y,p,nxtrec,numrec
000D8Br 2  A0 20        inrcct:	ldy	#32		;next record offset
000D8Dr 2  B1 02        	lda	(addinp),y	;get next record
000D8Fr 2  8D rr rr     	sta	nxtrec		;and save
000D92r 2  A0 0F        	ldy	#15		;number records offset
000D94r 2  B1 02        	lda	(addinp),y	;get number
000D96r 2  8D rr rr     	sta	numrec		;and save
000D99r 2  60           	rts			;and return
000D9Ar 2               ;update record counters in fcb
000D9Ar 2               ; input:nxtrec,numrec
000D9Ar 2               ; returns:none
000D9Ar 2               ; alters:all,fcb@(addinp)
000D9Ar 2  AE rr rr     updtrc:	ldx	nxtrec		;get next record
000D9Dr 2  E8           	inx			;bump it
000D9Er 2  8A           	txa			;transfer
000D9Fr 2  A0 20        	ldy	#32		;set offset
000DA1r 2  91 02        	sta	(addinp),y	;and store in fcb
000DA3r 2  AD rr rr     	lda	numrec		;get number
000DA6r 2  A0 0F        	ldy	#15		;and its offset
000DA8r 2  91 02        	sta	(addinp),y	;and store
000DAAr 2  60           	rts			;then return
000DABr 2               ;execute open file
000DABr 2  20 rr rr     xopen:	jsr	autodr		;auto drive select
000DAEr 2               ;open file
000DAEr 2               ; input:fcb @ (addinp)
000DAEr 2               ; returns:n=1 if not found,a=dirmod (255 if not found)
000DAEr 2               ; alters:all
000DAEr 2  20 rr rr     opnfle:	jsr	fndf13		;match all including extent
000DB1r 2  30 32        	bmi	extopn		;done if not found
000DB3r 2  A9 0C        	lda	#12		;point to first char
000DB5r 2  0D rr rr     	ora	subrec		;add offset
000DB8r 2  A8           	tay			;make it a pointer
000DB9r 2  B1 04        nxopmv:	lda	(bufadd),y	;get buffer contents
000DBBr 2  AA           	tax			;and save
000DBCr 2  98           	tya			;save index
000DBDr 2  29 1F        	and	#%00011111	;remove offset
000DBFr 2  A8           	tay			;back to index
000DC0r 2  8A           	txa			;get byte back
000DC1r 2  91 02        	sta	(addinp),y	;and store in fcb
000DC3r 2  98           	tya			;get index
000DC4r 2  0D rr rr     	ora	subrec		;add offset back
000DC7r 2  A8           	tay			;and make index again
000DC8r 2  C8           	iny			;next position
000DC9r 2  98           	tya			;if index
000DCAr 2  29 1F        	and	#%00011111	;not gone past
000DCCr 2  D0 EB        	bne	nxopmv		;end then loop
000DCEr 2               ;now correct extent and max records
000DCEr 2  A0 0C        	ldy	#12		;point at extent in fcb
000DD0r 2  AD rr rr     	lda	savext		;get save from search
000DD3r 2  D1 02        	cmp	(addinp),y	;compare
000DD5r 2  F0 0B        	beq	extsme		;jump ahead if same
000DD7r 2  91 02        	sta	(addinp),y	;else change extent
000DD9r 2  A9 80        	lda	#128		;assume fcb ext < dir ext
000DDBr 2  90 01        	bcc	fcbxls		;jump ahead if true
000DDDr 2  0A           	asl	a		;clear a
000DDEr 2  A0 0F        fcbxls:	ldy	#15		;point to max
000DE0r 2  91 02        	sta	(addinp),y	;and set
000DE2r 2  AD rr rr     extsme:	lda	dirmod		;else get number
000DE5r 2  60           extopn:	rts			;and return
000DE6r 2               ;execute close file
000DE6r 2  20 rr rr     xclose:	jsr	autodr		;auto drive select
000DE9r 2               ;close file
000DE9r 2               ;if file is r/o then no actual close
000DE9r 2               ;operation is performed.
000DE9r 2               ; input:fcb @ (addinp)
000DE9r 2               ; returns:n=1 if not valid,a=dirmod (255 if invalid)
000DE9r 2               ; alters:all
000DE9r 2  20 rr rr     clsfle:	jsr	fndf13		;match including extent
000DECr 2  30 1B        	bmi	extcls		;exit if not found
000DEEr 2  20 rr rr     	jsr	chkron		;see if r/o
000DF1r 2  D0 13        	bne	noclse		;branch if is
000DF3r 2               ;now set flag to ensure directory extent and number of
000DF3r 2               ;records fields are only changed if necessary.
000DF3r 2               ;The decision to change is determined by whether or
000DF3r 2               ;not the system is closing an extent less than the
000DF3r 2               ;maximum extent in the directory entry. If that is
000DF3r 2               ;the case, the directory extent and number of record
000DF3r 2               ;fields are not changed.
000DF3r 2  A0 0C        	ldy	#12		;get extent
000DF5r 2  B1 02        	lda	(addinp),y
000DF7r 2  48           	pha			;save it
000DF8r 2  98           	tya			;now look in directory
000DF9r 2  0D rr rr     	ora	subrec
000DFCr 2  A8           	tay
000DFDr 2  68           	pla			;get extent back
000DFEr 2  D1 04        	cmp	(bufadd),y
000E00r 2  6E rr rr     	ror	skpdir		;save result
000E03r 2               ;now go do it
000E03r 2  20 rr rr     	jsr	updtdr		;update directory
000E06r 2  AD rr rr     noclse:	lda	dirmod		;get directory number
000E09r 2  60           extcls:	rts			;and return
000E0Ar 2               ;execute find first match
000E0Ar 2  20 rr rr     xfndfr:	jsr	autodr		;auto drive select
000E0Dr 2  A9 0D        fndf13:	lda	#13		;match including extent
000E0Fr 2               ;search for first match
000E0Fr 2               ; input:a=number char to match
000E0Fr 2               ; returns:n=1 if invalid,a=dirmod (255 if invalid)
000E0Fr 2               ; alters:all
000E0Fr 2  48           frstsr:	pha			;save number to match
000E10r 2  20 rr rr     	jsr	cldrnm		;clear directory number to -1
000E13r 2  20 rr rr     	jsr	intdrv		;and drive
000E16r 2  68           	pla			;get number to match
000E17r 2               ;search for directory match
000E17r 2               ; input:a=number char to match
000E17r 2               ; returns:n=1 if not found,a=dirmod (255 if invalid)
000E17r 2               ; alters:all
000E17r 2  8D rr rr     search:	sta	chrcnt		;save number
000E1Ar 2  A2 00        newtry:	ldx	#0		;set for search
000E1Cr 2  8E rr rr     	stx	cmppnt		;clear pointer
000E1Fr 2  20 rr rr     	jsr	nxtdir		;get next entry
000E22r 2  30 37        	bmi	exitsr		;exit if not found
000E24r 2  AE rr rr     	ldx	chrcnt		;get count
000E27r 2  AC rr rr     mremch:	ldy	cmppnt		;get pointer
000E2Ar 2  EE rr rr     	inc	cmppnt		;and bump
000E2Dr 2  B1 02        	lda	(addinp),y	;get fcb entry
000E2Fr 2  C0 0C        	cpy	#12		;see if at extent
000E31r 2  D0 13        	bne	notaex		;jump if not
000E33r 2  8D rr rr     	sta	savext		;save for later use
000E36r 2  48           	pha			;save extent
000E37r 2  98           	tya			;change to directory
000E38r 2  0D rr rr     	ora	subrec		;coordinates
000E3Br 2  A8           	tay
000E3Cr 2  68           	pla			;get extent back
000E3Dr 2  51 04        	eor	(bufadd),y	;exclusive or with dir
000E3Fr 2  2D rr rr     	and	cexm1f		;and with exm complement + 1f
000E42r 2  F0 11        	beq	trynxt		;ok if zero
000E44r 2  D0 D4        	bne	newtry		;else get next directory
000E46r 2  C9 3F        notaex:	cmp	#'?'		;if a ? then
000E48r 2  F0 0B        	beq	trynxt		;is a match
000E4Ar 2  48           	pha			;save char
000E4Br 2  98           	tya			;then add
000E4Cr 2  0D rr rr     	ora	subrec		;offset to
000E4Fr 2  A8           	tay			;make pointer
000E50r 2  68           	pla			;get char back
000E51r 2  D1 04        	cmp	(bufadd),y	;if not same
000E53r 2  D0 C5        	bne	newtry		;try next directory
000E55r 2  CA           trynxt:	dex			;else count number down
000E56r 2  D0 CF        	bne	mremch		;and loop if more
000E58r 2  AD rr rr     	lda	dirmod		;return with directory
000E5Br 2  60           exitsr:	rts			;number mod 4
000E5Cr 2               ;calculate logical record number
000E5Cr 2               ; input:blknum
000E5Cr 2               ; returns:none
000E5Cr 2               ; alters:a,x,p,recnum
000E5Cr 2  AE rr rr     calrcn:	ldx	sxb		;set x according to blkscd
000E5Fr 2  0E rr rr     mulmre:	asl	blknum		;multiply block
000E62r 2  2E rr rr     	rol	blknum+1	;number
000E65r 2  2E rr rr     	rol	blknum+2
000E68r 2  CA           	dex			;by code
000E69r 2  D0 F4        	bne	mulmre
000E6Br 2  AD rr rr     	lda	sab		;set mask in a
000E6Er 2  2D rr rr     	and	nxtrec		;and with next record
000E71r 2  0D rr rr     	ora	recnum		;or with number
000E74r 2  8D rr rr     	sta	recnum		;and save
000E77r 2  60           	rts
000E78r 2               ;update directory
000E78r 2  A9 20        updtdr:	lda	#32		;change all
000E7Ar 2  A2 00        	ldx	#0		;from start
000E7Cr 2               ;change directory entry
000E7Cr 2               ; input:a=number char to change,x=starting position,fcb@(addinp)
000E7Cr 2               ; returns:none
000E7Cr 2               ; alters:all,directory,checksums
000E7Cr 2  8D rr rr     dirchg:	sta	chrcnt		;save count
000E7Fr 2  CE rr rr     	dec	chrcnt		;back up
000E82r 2  18           mrechg:	clc			;clear carry
000E83r 2  8A           	txa			;get offset
000E84r 2  6D rr rr     	adc	chrcnt		;compute index
000E87r 2  A8           	tay			;and set
000E88r 2  C0 0C        	cpy	#12		;see if at extent
000E8Ar 2  F0 04        	beq	docare		;if so do special
000E8Cr 2  C0 0F        	cpy	#15		;see if at number rec
000E8Er 2  D0 05        	bne	dntcar		;if not skip
000E90r 2  2C rr rr     docare:	bit	skpdir		;check flag
000E93r 2  10 0D        	bpl	nochng		;skip if ok
000E95r 2  B1 02        dntcar:	lda	(addinp),y	;get char
000E97r 2  48           	pha			;save it
000E98r 2  AD rr rr     	lda	chrcnt		;get count
000E9Br 2  0D rr rr     	ora	subrec		;add offset
000E9Er 2  A8           	tay			;make an index
000E9Fr 2  68           	pla			;get char back
000EA0r 2  91 04        	sta	(bufadd),y	;and put in buffer
000EA2r 2  CE rr rr     nochng:	dec	chrcnt		;count down
000EA5r 2  10 DB        	bpl	mrechg		;and loop
000EA7r 2  20 rr rr     	jsr	drrcsu		;set it up
000EAAr 2  4C rr rr     	jmp	updtck		;and do change
000EADr 2               ;execute create file
000EADr 2  20 rr rr     xmake:	jsr	autodr		;auto drive select
000EB0r 2               ;create file
000EB0r 2               ; input:fcb@(addinp)
000EB0r 2               ; returns:n=1 if not valid,a=dirmod (255 if not valid)
000EB0r 2               ; alters:dirnum,dirmod,fcb@(addinp)
000EB0r 2  20 rr rr     mkefle:	jsr	tstron		;test for r/o
000EB3r 2  A5 02        	lda	addinp		;save fcb
000EB5r 2  48           	pha			;address
000EB6r 2  A5 03        	lda	addinp+1	;on
000EB8r 2  48           	pha			;stack
000EB9r 2  AD rr rr     	lda	empdvc		;then point
000EBCr 2  AC rr rr     	ldy	empdvc+1	;to empty
000EBFr 2  85 02        	sta	addinp		;dummy
000EC1r 2  84 03        	sty	addinp+1	;fcb
000EC3r 2  A9 01        	lda	#1		;match only
000EC5r 2  20 rr rr     	jsr	frstsr		;first char
000EC8r 2  68           	pla			;restore
000EC9r 2  85 03        	sta	addinp+1	;fcb
000ECBr 2  68           	pla			;address
000ECCr 2  85 02        	sta	addinp		;from stack
000ECEr 2  AD rr rr     	lda	dirmod		;get number mod 4
000ED1r 2  30 15        	bmi	extmke		;quit if not found
000ED3r 2  A0 0D        	ldy	#13		;else set up
000ED5r 2  A9 00        	lda	#0		;to clear
000ED7r 2  91 02        mkeagn:	sta	(addinp),y	;rest of
000ED9r 2  C8           	iny			;fcb
000EDAr 2  C0 21        	cpy	#33		;including next
000EDCr 2  D0 F9        	bne	mkeagn		;record
000EDEr 2               ;the next two lines ensure that the extent and
000EDEr 2               ;number of records fields are updated
000EDEr 2  38           	sec
000EDFr 2  6E rr rr     	ror	skpdir
000EE2r 2  20 rr rr     	jsr	updtdr		;update directory
000EE5r 2  AD rr rr     	lda	dirmod		;get number
000EE8r 2  60           extmke:	rts			;and quit
000EE9r 2               ;extend file
000EE9r 2               ; input:fcb@(addinp), x=1 read
000EE9r 2               ;		        0 write
000EE9r 2  8E rr rr     extend:	stx	exrwfl		;save parameter
000EECr 2  20 rr rr     	jsr	clsfle		;close current extent
000EEFr 2  30 2A        	bmi	extext		;exit if not found
000EF1r 2  A0 0C        	ldy	#12		;else
000EF3r 2  B1 02        	lda	(addinp),y	;get extent
000EF5r 2  18           	clc			;and
000EF6r 2  69 01        	adc	#1		;add one
000EF8r 2  29 1F        	and	#%00011111	;see if overflow
000EFAr 2  F0 17        	beq	exteof		;eof if so
000EFCr 2  91 02        	sta	(addinp),y	;and save
000EFEr 2  20 rr rr     	jsr	fndf13		;see if next extent exists
000F01r 2  10 0B        	bpl	opnext		;if so open
000F03r 2  AD rr rr     	lda	exrwfl		;if not and is write then create
000F06r 2  D0 13        	bne	extext		;else return as eof
000F08r 2  20 rr rr     dwrtex:	jsr	mkefle		;create file
000F0Br 2  4C rr rr     	jmp	tstext		;and test
000F0Er 2  20 rr rr     opnext:	jsr	opnfle		;open
000F11r 2  10 03        tstext:	bpl	extnok		;continue if ok
000F13r 2  A9 01        exteof:	lda	#1		;else set eof
000F15r 2  60           	rts			;and return
000F16r 2  20 rr rr     extnok:	jsr	inrcct		;initialize counters
000F19r 2  A9 00        	lda	#0		;good
000F1Br 2  60           extext:	rts			;return
000F1Cr 2               ;set up next directory block
000F1Cr 2               ; input:dirnum,x=1 for update checksum
000F1Cr 2               ; returns:a=dirmod (255 if invalid),n=1 if invalid
000F1Cr 2               ; alters:alll,dirnum,dirmod
000F1Cr 2  8A           nxtdir:	txa			;save operation
000F1Dr 2  48           	pha			;on stack
000F1Er 2  EE rr rr     	inc	dirnum		;bump directory
000F21r 2  D0 03        	bne	*+5
000F23r 2  EE rr rr     	inc	dirnum+1
000F26r 2  AD rr rr     	lda	maxdir		;if not at limit continue
000F29r 2  CD rr rr     	cmp	dirnum
000F2Cr 2  AD rr rr     	lda	maxdir+1
000F2Fr 2  ED rr rr     	sbc	dirnum+1
000F32r 2  B0 05        	bcs	gtnxdr		;then continue
000F34r 2  68           	pla			;else clear stack
000F35r 2  AA           	tax			;and set x
000F36r 2  4C rr rr     	jmp	cldrnm		;set to invalid
000F39r 2  AD rr rr     gtnxdr:	lda	dirnum		;get low again
000F3Cr 2  29 03        	and	#%00000011	;look at 2 lsbs
000F3Er 2  8D rr rr     	sta	dirmod		;save mod 4
000F41r 2  0A           	asl	a		;multiply
000F42r 2  0A           	asl	a		;by
000F43r 2  0A           	asl	a		;32 to
000F44r 2  0A           	asl	a		;get pointer
000F45r 2  0A           	asl	a		;offset
000F46r 2  8D rr rr     	sta	subrec		;and save
000F49r 2  F0 05        	beq	getdir		;if zero read new
000F4Br 2  68           	pla			;else clear stack
000F4Cr 2  AA           	tax			;set x
000F4Dr 2  4C rr rr     	jmp	gotdir		;and exit
000F50r 2  20 rr rr     getdir:	jsr	drrcsu		;set up to read
000F53r 2  20 rr rr     	jsr	rdesec		;do read
000F56r 2  68           	pla			;get operation
000F57r 2  AA           	tax			;code
000F58r 2               ;;;;;;	jsr	chksop		;do it
000F58r 2  AD rr rr     gotdir:	lda	dirmod		;and return
000F5Br 2  60           exnxdr:	rts			;with number
000F5Cr 2               ;checksum operation
000F5Cr 2               ;this routine assumes calling routine has checked for
000F5Cr 2               ;valid dirnum and hence valid dirrec
000F5Cr 2               ; input:chkflg,dirrec,x (1=update else check)
000F5Cr 2               ; returns:none
000F5Cr 2               ; alters:map@(chkmap)
000F5Cr 2  2C rr rr     chksop:	bit	chkflg		;check flag
000F5Fr 2  30 FA        	bmi	exnxdr		;done if set
000F61r 2  CA           	dex			;dec code
000F62r 2  D0 09        	bne	tstchk		;if not zero test
000F64r 2  20 rr rr     	jsr	clcchk		;else calculate
000F67r 2  20 rr rr     	jsr	clcckp		;calculate pointer
000F6Ar 2  91 08        	sta	(chkpnt),y	;and save
000F6Cr 2  60           	rts			;then return
000F6Dr 2  20 rr rr     tstchk:	jsr	clcchk		;do calculation
000F70r 2  20 rr rr     	jsr	clcckp		;calculate pointer
000F73r 2  D1 08        	cmp	(chkpnt),y	;compare to old
000F75r 2  F0 E4        	beq	exnxdr		;if equal ok
000F77r 2  4C rr rr     	jmp	setron		;else set to r/o
000F7Ar 2               ;get block number
000F7Ar 2               ; input:nxtrec,blmode,fcb@(addinp),sxb,exm
000F7Ar 2               ; returns:none
000F7Ar 2               ; alters:all,blknum
000F7Ar 2  AE rr rr     getblk:	ldx	sxb		;set x according to blkscd
000F7Dr 2  AD rr rr     	lda	nxtrec		;get next record
000F80r 2  4A           gblp:	lsr	a		;divide by 2 x times
000F81r 2  CA           	dex
000F82r 2  D0 FC        	bne	gblp
000F84r 2  8D rr rr     	sta	blknum		;save previous as temp
000F87r 2               ;use extent as offset but first use sxb to create param
000F87r 2  38           	sec
000F88r 2  A9 08        	lda	#8
000F8Ar 2  ED rr rr     	sbc	sxb
000F8Dr 2  AA           	tax
000F8Er 2               ;now get extent from fcb
000F8Er 2  A0 0C        	ldy	#12
000F90r 2  B1 02        	lda	(addinp),y
000F92r 2  2D rr rr     	and	exm		;and with mask
000F95r 2  4A           	lsr	a		;shift with lsb to c
000F96r 2  2A           gbxlp:	rol	a		;now go other way
000F97r 2  CA           	dex
000F98r 2  D0 FC        	bne	gbxlp
000F9Ar 2  18           	clc			;now add saved value
000F9Br 2  6D rr rr     	adc	blknum		;back
000F9Er 2  2C rr rr     	bit	blmode		;test mode
000FA1r 2  10 01        	bpl	*+3		;skip if byte
000FA3r 2  0A           	asl	a		;else times two
000FA4r 2  18           	clc			;then add
000FA5r 2  69 10        	adc	#16		;offset into fcb
000FA7r 2  8D rr rr     	sta	fcbind		;save for later
000FAAr 2  A8           	tay			;set index
000FABr 2  B1 02        	lda	(addinp),y	;get number
000FADr 2  8D rr rr     	sta	blknum		;store
000FB0r 2  C8           	iny
000FB1r 2  A9 00        	lda	#0		;clear
000FB3r 2  2C rr rr     	bit	blmode		;test mode
000FB6r 2  10 02        	bpl	*+4		;skip if byte
000FB8r 2  B1 02        	lda	(addinp),y	;else get high
000FBAr 2  8D rr rr     	sta	blknum+1	;high byte
000FBDr 2  60           	rts			;and return
000FBEr 2               ;calculate chkpnt as function of dirrec and chkmap
000FBEr 2               ; input:dirrec,chkmap
000FBEr 2               ; returns:y=0
000FBEr 2               ; alters:y,p,chkpnt
000FBEr 2  48           clcckp:	pha			;save a
000FBFr 2  18           	clc
000FC0r 2  AD rr rr     	lda	dirrec		;add record number
000FC3r 2  6D rr rr     	adc	chkmap		;to start
000FC6r 2  85 08        	sta	chkpnt
000FC8r 2  AD rr rr     	lda	dirrec+1
000FCBr 2  6D rr rr     	adc	chkmap+1
000FCEr 2  85 09        	sta	chkpnt+1
000FD0r 2  A0 00        	ldy	#0
000FD2r 2  68           	pla			;get a back
000FD3r 2  60           	rts
000FD4r 2               ;clear directory number to $ffff
000FD4r 2               ; input:none
000FD4r 2               ; returns:a=$ff,n=1,z=0
000FD4r 2               ; alters:a,p,dirnum,dirmod
000FD4r 2  A9 FF        cldrnm:	lda	#$ff		;set to $ff
000FD6r 2  8D rr rr     	sta	dirnum
000FD9r 2  8D rr rr     	sta	dirnum+1
000FDCr 2  8D rr rr     	sta	dirmod
000FDFr 2  60           	rts
000FE0r 2               ;change allocation map
000FE0r 2               ; input:subrec,directory record @ (bufadd)
000FE0r 2               ; returns:none
000FE0r 2               ; alters:all,allocation map
000FE0r 2  18           mapdir:	clc			;add 16 to
000FE1r 2  AD rr rr     	lda	subrec		;to subrec to point
000FE4r 2  69 10        	adc	#16		;to block number field
000FE6r 2  A8           	tay			;make index
000FE7r 2  8C rr rr     lpmpdr:	sty	mpdrsy		;save index
000FEAr 2  8A           	txa			;save x
000FEBr 2  48           	pha			;operation
000FECr 2  B1 04        	lda	(bufadd),y	;get block number
000FEEr 2  8D rr rr     	sta	mpdrtm		;save in temp
000FF1r 2  C8           	iny			;bump index for word
000FF2r 2  20 rr rr     	jsr	gthibn		;get high part of number
000FF5r 2  0D rr rr     mpdrnw:	ora	mpdrtm		;see if zero
000FF8r 2  F0 0A        	beq	skpedr		;skip if zero
000FFAr 2  20 rr rr     	jsr	gthibn		;get high again
000FFDr 2  A8           	tay			;move to y
000FFEr 2  AD rr rr     	lda	mpdrtm		;get low again
001001r 2  20 rr rr     	jsr	altalc		;else alter map
001004r 2  68           skpedr:	pla			;get operation
001005r 2  AA           	tax			;back
001006r 2  AC rr rr     	ldy	mpdrsy		;get index back
001009r 2  C8           	iny			;bump it
00100Ar 2  98           	tya			;if still
00100Br 2  29 0F        	and	#%00001111	;in field
00100Dr 2  D0 D8        	bne	lpmpdr		;then loop
00100Fr 2  60           	rts			;else quit
001010r 2               ;test r/w status
001010r 2               ;does warm boot if r/o
001010r 2               ; input:curdrv,ronlst
001010r 2               ; returns:none
001010r 2               ; alters:a,x,p
001010r 2  20 rr rr     tstron:	jsr	chkron		;test bit
001013r 2  F0 1D        	beq	exttro		;exit if r/w
001015r 2  20 rr rr     	jsr	errout		;else send error
001018r 2  AD rr rr     	lda	rommvc		;point to r/o
00101Br 2  AC rr rr     	ldy	rommvc+1	;message
00101Er 2  20 rr rr     	jsr	sndstr		;send it
001021r 2  4C rr rr     	jmp	xwboot		;then abort
001024r 2               ;set current drive to r/w
001024r 2               ; input:curdrv,ronlst
001024r 2               ; returns:ronlst
001024r 2               ; alters:a,x,p,ronlst
001024r 2  AE rr rr     setrw:	ldx	curdrv		;get drive
001027r 2  BD rr rr     	lda	bitmap,x	;and mask
00102Ar 2  49 FF        	eor	#$ff		;complement
00102Cr 2  2D rr rr     	and	ronlst		;and with status
00102Fr 2  8D rr rr     	sta	ronlst		;save
001032r 2  60           exttro:	rts			;return
001033r 2               ;read sector
001033r 2  20 rr rr     rdesec:	jsr	sim+39		;do read
001036r 2               
001036r 2  4C rr rr     	jmp	chkrwe		;check for error
001039r 2               ;update checksum and directory
001039r 2  A2 01        updtck:	ldx	#1		;set for update
00103Br 2               ;;;;;	jsr	chksop		;do it
00103Br 2  A9 01        	lda	#1		;say is directory op
00103Dr 2  D0 03        	bne	secwrt		;do it
00103Fr 2               ;write sector
00103Fr 2  AD rr rr     wrtsec:	lda	pemwrtype		;get write type
001042r 2  20 rr rr     secwrt:	jsr	sim+42		;do write
001045r 2               
001045r 2  C9 00        chkrwe:	cmp	#0		;if not ok
001047r 2  F0 E9        	beq	exttro		;done if zero
001049r 2               ;read/write error
001049r 2  20 rr rr     rwerrt:	jsr	errout		;send error message
00104Cr 2  AD rr rr     	lda	bdsmvc		;point to
00104Fr 2  AC rr rr     	ldy	bdsmvc+1	;bad sector message
001052r 2  20 rr rr     	jsr	sndstr		;and send
001055r 2  20 rr rr     	jsr	getcon		;get input
001058r 2  C9 0D        	cmp	#cr		;if a cr
00105Ar 2  F0 03        	beq	ignerr		;then continue
00105Cr 2  4C rr rr     	jmp	xwboot		;else abort
00105Fr 2  4C rr rr     ignerr:	jmp	pcrlf		;crlf and return
001062r 2               ;error output routine
001062r 2               ; input:curdrv,pemmvc
001062r 2               ; returns:none
001062r 2               ; alters:all
001062r 2  AD rr rr     errout:	lda	pemmvc		;point to
001065r 2  AC rr rr     	ldy	pemmvc+1	;error message
001068r 2  20 rr rr     	jsr	sndstr		;send it
00106Br 2  AD rr rr     	lda	curdrv		;get drive number
00106Er 2  18           	clc			;add
00106Fr 2  69 41        	adc	#'A'		;ascii a
001071r 2  4C rr rr     	jmp	sndchr		;and send it
001074r 2               ;get high part of block number if word (zero if byte)
001074r 2               ; input:y=index to high,blmode,directory@(bufadd)+subrec
001074r 2               ; returns:a=high part of block number
001074r 2               ; alters:a,p,mpdrsy iff word
001074r 2  A9 00        gthibn:	lda	#0		;preset for byte
001076r 2  2C rr rr     	bit	blmode		;test mode
001079r 2  10 05        	bpl	gthiex		;done if byte
00107Br 2  B1 04        	lda	(bufadd),y	;get high
00107Dr 2  8C rr rr     	sty	mpdrsy		;alter y
001080r 2  60           gthiex:	rts
001081r 2               ;get console input
001081r 2               ; input:pndkey
001081r 2               ; returns:a=character
001081r 2               ; alters:all,pndkey
001081r 2               getcon:
001081r 2  AD rr rr     	lda	pndkey		;get pending
001084r 2  48           	pha			;save it
001085r 2  A9 00        	lda	#0		;clear
001087r 2  8D rr rr     	sta	pndkey		;pending
00108Ar 2  68           	pla			;restore
00108Br 2  D0 03        	bne	extget		;exit if not null
00108Dr 2  20 rr rr     	jsr	sim+9		;else get new
001090r 2               
001090r 2  60           extget:	rts			;and return
001091r 2               ;check keyboard status
001091r 2               ;handles <ctl-s> for freeze and <ctl-c> for boot
001091r 2               ; input:pndkey
001091r 2               ; returns:a=0 if no input or <>0 if input
001091r 2               ; alters:all,pndkey
001091r 2               kbdsts:
001091r 2  AD rr rr     	lda	pndkey		;get pending
001094r 2  D0 20        	bne	extkbd		;if there quit
001096r 2  20 rr rr     	jsr	sim+6		;else test
001099r 2  C9 00        	CMP	#$00		;if zero
00109Br 2  F0 19        	beq	extkbd		;exit
00109Dr 2  20 rr rr     	jsr	sim+9		;else get input
0010A0r 2  C9 13        	cmp	#ctls		;if not freeze
0010A2r 2  D0 0D        	bne	newpnd		;save input
0010A4r 2  20 rr rr     	jsr	sim+9		;else wait for more
0010A7r 2  C9 03        	cmp	#ctlc		;if not abort
0010A9r 2  D0 03        	bne	nowarm		;then jump
0010ABr 2  4C rr rr     	jmp	xwboot		;else do warm boot
0010AEr 2  A9 00        nowarm:	lda	#0		;clear
0010B0r 2  60           	rts			;and return
0010B1r 2  8D rr rr     newpnd:	sta	pndkey		;save
0010B4r 2  A9 FF        	lda	#$ff		;set ready
0010B6r 2               extkbd:
0010B6r 2  60           	rts			;and return
0010B7r 2               ;test character
0010B7r 2               ; input:a=character
0010B7r 2               ; returns:c=0 if control or c=1 if printing
0010B7r 2               ; alters:p
0010B7r 2  C9 0D        tstchr:	cmp	#cr		;if cr
0010B9r 2  F0 0A        	beq	chtext		;quit
0010BBr 2  C9 0A        	cmp	#lf		;if linefeed
0010BDr 2  F0 06        	beq	chtext		;quit
0010BFr 2  C9 09        	cmp	#ctli		;if tab
0010C1r 2  F0 02        	beq	chtext		;quit
0010C3r 2  C9 20        	cmp	#' '		;see if control
0010C5r 2  60           chtext:	rts			;and return
0010C6r 2               ;send string ending in $
0010C6r 2               ; input:ay=string address
0010C6r 2               ; returns:none
0010C6r 2               ; alters:all,index,sndlpe+1 and +2
0010C6r 2  8D rr rr     sndstr:	sta	sndlpe+1	;set pointer
0010C9r 2  8C rr rr     	sty	sndlpe+2
0010CCr 2  A0 00        	ldy	#0
0010CEr 2  B9 FF FF     sndlpe:	lda	$ffff,y		;get char
0010D1r 2  C9 24        	cmp	#'$'		;if terminator
0010D3r 2  F0 0C        	beq	sndext		;then exit
0010D5r 2  C8           	iny			;else bump
0010D6r 2  8C rr rr     	sty	index		;and save
0010D9r 2  20 rr rr     	jsr	sndchr		;send char
0010DCr 2  AC rr rr     	ldy	index		;get index
0010DFr 2  D0 ED        	bne	sndlpe		;and loop
0010E1r 2  60           sndext:	rts			;return
0010E2r 2               ;send char to printer if enabled
0010E2r 2               ; input:a=character,lstflg
0010E2r 2               ; returns:a=character
0010E2r 2               ; alters:x,y,p
0010E2r 2               lstout:
0010E2r 2  2C rr rr     	bit	lstflg		;test flag
0010E5r 2  10 0A        	bpl	extlst		;exit if off
0010E7r 2  2C rr rr     	bit	outflg		;test output flag
0010EAr 2  30 05        	bmi	extlst		;done if set
0010ECr 2  48           	pha			;save char
0010EDr 2  20 rr rr     	jsr	sim+15		;send
0010F0r 2  68           	pla			;get char
0010F1r 2  60           extlst:	rts			;and done
0010F2r 2               ;output a character
0010F2r 2               ; input:a=character,console definition block in sim
0010F2r 2               ; returns:none
0010F2r 2               ; alters:all,positn
0010F2r 2  20 rr rr     output:	jsr	tstchr		;test it
0010F5r 2  B0 18        	bcs	sndchr		;if not control jump
0010F7r 2  48           	pha			;else save
0010F8r 2  AD rr rr     	lda	sysdef+4	;get invert
0010FBr 2  20 rr rr     	jsr	nolist		;send to console
0010FEr 2  A9 5E        	lda	#'^'		;get arrow
001100r 2  20 rr rr     	jsr	lstout		;send to printer
001103r 2  68           	pla			;get character
001104r 2  09 40        	ora	#'A'-1		;convert to ascii
001106r 2  20 rr rr     	jsr	pchrot		;send to all
001109r 2  AD rr rr     	lda	sysdef+3	;get normal
00110Cr 2  4C rr rr     	jmp	nolist		;to console
00110Fr 2  C9 09        sndchr:	cmp	#ctli		;if not tab
001111r 2  D0 0D        	bne	pchrot		;send
001113r 2  A9 20        tabspc:	lda	#' '		;else get space
001115r 2  20 rr rr     	jsr	pchrot		;send
001118r 2  AD rr rr     	lda	positn		;get count
00111Br 2  29 07        	and	#7		;if not mod 8
00111Dr 2  D0 F4        	bne	tabspc		;loop
00111Fr 2  60           	rts			;else exit
001120r 2  48           pchrot:	pha			;save char
001121r 2  20 rr rr     	jsr	kbdsts		;test input
001124r 2  68           	pla			;restore
001125r 2  20 rr rr     	jsr	lstout		;to printer if on
001128r 2  48           nolist:	pha			;save again
001129r 2  2C rr rr     	bit	outflg		;test flag
00112Cr 2  30 03        	bmi	*+5		;done if set
00112Er 2  20 rr rr     	jsr	sim+12		;to console
001131r 2  68           	pla			;restore
001132r 2  EE rr rr     	inc	positn		;bump col
001135r 2  C9 20        	cmp	#' '		;if space or more
001137r 2  B0 26        	bcs	extchr		;is ok
001139r 2  CD rr rr     	cmp	sysdef+2	;also ok
00113Cr 2  F0 21        	beq	extchr		;if forward
00113Er 2  CE rr rr     	dec	positn		;else drop back
001141r 2  CD rr rr     	cmp	sysdef+0	;see if bs
001144r 2  D0 06        	bne	tryotr		;branch if not
001146r 2  CE rr rr     	dec	positn		;else drop again
001149r 2  30 0F        	bmi	zrocol		;zero if <0
00114Br 2  60           	rts			;else ok
00114Cr 2  C9 0D        tryotr:	cmp	#cr		;if a cr
00114Er 2  F0 0A        	beq	zrocol		;clear col
001150r 2  CD rr rr     	cmp	sysdef+7	;if a formfeed
001153r 2  F0 05        	beq	zrocol		;also clear
001155r 2  CD rr rr     	cmp	sysdef+8	;if not home
001158r 2  D0 05        	bne	extchr		;then done
00115Ar 2  A9 00        zrocol:	lda	#0		;clear
00115Cr 2  8D rr rr     	sta	positn		;column
00115Fr 2  60           extchr:	rts			;and exit
001160r 2               ;go to left and space past prompt
001160r 2               ; input:frscol,positn
001160r 2               ; returns:none
001160r 2               ; alters:positn
001160r 2  A9 0D        spcovr:	lda	#cr		;get cr
001162r 2  20 rr rr     	jsr	pchrot		;send to all
001165r 2  A9 0A        	lda	#lf		;send lf
001167r 2  20 rr rr     	jsr	lstout		;only to printer
00116Ar 2  AD rr rr     mreovr:	lda	frscol		;get first
00116Dr 2  CD rr rr     	cmp	positn		;see if there
001170r 2  F0 ED        	beq	extchr		;done if is
001172r 2  AD rr rr     	lda	sysdef+2	;get forward
001175r 2  20 rr rr     	jsr	nolist		;send it
001178r 2  4C rr rr     	jmp	mreovr		;and loop
00117Br 2               ;buffered read
00117Br 2               ; input:buffer@(addinp)
00117Br 2               ; returns:none
00117Br 2               ; alters:all,buffer@(addinp)
00117Br 2  A9 00        bufinp:	lda	#0		;clear
00117Dr 2  A0 01        	ldy	#1		;length
00117Fr 2  91 02        	sta	(addinp),y	;position in buffer
001181r 2  8C rr rr     	sty	bufpsn		;set point to 1
001184r 2  AD rr rr     	lda	positn		;get current
001187r 2  8D rr rr     	sta	frscol		;and save
00118Ar 2  20 rr rr     nxtinp:	jsr	getcon		;get input
00118Dr 2  AC rr rr     	ldy	bufpsn		;get index
001190r 2  C9 0D        	cmp	#cr		;if not a cr
001192r 2  D0 03        	bne	notcr		;then jump
001194r 2  4C rr rr     	jmp	endlin		;else done
001197r 2  C9 08        notcr:	cmp	#delete		;if not delete
001199r 2  D0 5E        	bne	ntdelt		;then jump
00119Br 2  C0 01        	cpy	#1		;else if start
00119Dr 2  F0 EB        	beq	nxtinp		;then loop
00119Fr 2  B1 02        	lda	(addinp),y	;get last
0011A1r 2  48           	pha			;save char
0011A2r 2  A0 01        	ldy	#1		;point to count
0011A4r 2  38           	sec			;set carry
0011A5r 2  B1 02        	lda	(addinp),y	;get count
0011A7r 2  E9 01        	sbc	#1		;decrement
0011A9r 2  91 02        	sta	(addinp),y	;then save
0011ABr 2  68           	pla			;restore char
0011ACr 2  CE rr rr     	dec	bufpsn		;backup pointer
0011AFr 2  C9 20        	cmp	#' '		;if space or more
0011B1r 2  B0 40        	bcs	nrmbs		;just backspace
0011B3r 2  C9 09        	cmp	#ctli		;see if tab
0011B5r 2  D0 30        	bne	ctlbs		;if not is control
0011B7r 2  38           	sec			;set flag
0011B8r 2  6E rr rr     	ror	outflg
0011BBr 2  AD rr rr     	lda	positn		;get position and save
0011BEr 2  8D rr rr     	sta	lstcol
0011C1r 2  20 rr rr     	jsr	spcovr		;else go back
0011C4r 2  20 rr rr     	jsr	rptlne		;and retype
0011C7r 2  AD rr rr     	lda	positn		;get new last position
0011CAr 2  48           	pha			;save on stack
0011CBr 2  38           	sec			;subtract to get delta
0011CCr 2  AD rr rr     	lda	lstcol
0011CFr 2  ED rr rr     	sbc	positn
0011D2r 2  8D rr rr     	sta	lstcol		;and save
0011D5r 2  0E rr rr     	asl	outflg		;clear flag
0011D8r 2  20 rr rr     bstab:	jsr	dobs		;do one
0011DBr 2  CE rr rr     	dec	lstcol		;drop count
0011DEr 2  D0 F8        	bne	bstab		;loop if more
0011E0r 2  68           	pla			;get position
0011E1r 2  8D rr rr     	sta	positn		;and set
0011E4r 2  4C rr rr     	jmp	nxtinp		;then loop
0011E7r 2  AD rr rr     ctlbs:	lda	sysdef+3	;get normal
0011EAr 2  20 rr rr     	jsr	chkbs		;bs if printing
0011EDr 2  AD rr rr     	lda	sysdef+4	;same for invert
0011F0r 2  20 rr rr     	jsr	chkbs		;then delete char itself
0011F3r 2  20 rr rr     nrmbs:	jsr	dobs		;do a backspace
0011F6r 2  4C rr rr     	jmp	nxtinp		;and loop
0011F9r 2  C9 10        ntdelt:	cmp	#ctlp		;if not ctl-p
0011FBr 2  D0 0B        	bne	ntctlp		;then jump
0011FDr 2  AD rr rr     	lda	lstflg		;else get printer flag
001200r 2  49 FF        	eor	#$ff		;complement
001202r 2  8D rr rr     	sta	lstflg		;save
001205r 2  4C rr rr     	jmp	nxtinp		;and loop
001208r 2  C9 18        ntctlp:	cmp	#ctlx		;if not ctl-x
00120Ar 2  D0 0C        	bne	ntctlx		;then jump
00120Cr 2  20 rr rr     	jsr	spcovr		;restart
00120Fr 2  AD rr rr     	lda	sysdef+1	;get clear to eol
001212r 2  20 rr rr     	jsr	nolist		;send it
001215r 2  4C rr rr     	jmp	bufinp		;and start over
001218r 2  C9 12        ntctlx:	cmp	#ctlr		;if not ctl-r
00121Ar 2  D0 09        	bne	ntctlr		;then jump
00121Cr 2  20 rr rr     	jsr	spcovr		;restart
00121Fr 2  20 rr rr     	jsr	rptlne		;retype line
001222r 2  4C rr rr     	jmp	nxtinp		;and start over
001225r 2  C8           ntctlr:	iny			;next position
001226r 2  91 02        	sta	(addinp),y	;store char
001228r 2  48           	pha			;and save
001229r 2  8C rr rr     	sty	bufpsn		;index
00122Cr 2  A0 01        	ldy	#1		;point to count
00122Er 2  98           	tya			;set a to 1
00122Fr 2  18           	clc			;then
001230r 2  71 02        	adc	(addinp),y	;add count
001232r 2  91 02        	sta	(addinp),y	;and save
001234r 2  68           	pla			;restore char
001235r 2  20 rr rr     dontsv:	jsr	output		;send char
001238r 2  AC rr rr     	ldy	bufpsn		;get index
00123Br 2  B1 02        	lda	(addinp),y	;get char
00123Dr 2  C9 03        	cmp	#ctlc		;if not ctl-c
00123Fr 2  D0 0B        	bne	ignrcc		;ignore
001241r 2  A0 01        	ldy	#1		;get count
001243r 2  B1 02        	lda	(addinp),y	;from buffer
001245r 2  C9 01        	cmp	#1		;if not at start
001247r 2  D0 03        	bne	ignrcc		;ignore
001249r 2  4C rr rr     	jmp	xwboot		;else do warm boot
00124Cr 2  A0 01        ignrcc:	ldy	#1		;get
00124Er 2  B1 02        	lda	(addinp),y	;count
001250r 2  88           	dey			;point to max
001251r 2  D1 02        	cmp	(addinp),y	;if length
001253r 2  B0 03        	bcs	lineen		;at max jump
001255r 2  4C rr rr     	jmp	nxtinp		;else loop
001258r 2  A9 0D        lineen:	lda	#cr		;get a cr
00125Ar 2  4C rr rr     endlin:	jmp	pchrot		;and send
00125Dr 2               ;cr and lf
00125Dr 2  A9 0D        pcrlf:	lda	#cr		;then a
00125Fr 2  20 rr rr     	jsr	pchrot		;cr
001262r 2  A9 0A        	lda	#lf		;and a
001264r 2  4C rr rr     	jmp	pchrot		;lf
001267r 2               ;retype line
001267r 2  AD rr rr     rptlne:	lda	bufpsn		;save point
00126Ar 2  8D rr rr     	sta	numcnt		;as count
00126Dr 2  A9 01        	lda	#1		;start position
00126Fr 2  48           	pha			;save
001270r 2  68           mrerpt:	pla			;get position
001271r 2  CE rr rr     	dec	numcnt		;count down
001274r 2  D0 01        	bne	*+3		;continue if more
001276r 2  60           	rts			;else done
001277r 2  A8           	tay			;else make index
001278r 2  C8           	iny			;and bump
001279r 2  98           	tya			;save
00127Ar 2  48           	pha			;on stack
00127Br 2  B1 02        	lda	(addinp),y	;get char
00127Dr 2  20 rr rr     	jsr	output		;send
001280r 2  4C rr rr     	jmp	mrerpt		;and loop
001283r 2               ;check for printing and backspace if needed
001283r 2  C9 20        chkbs:	cmp	#' '		;compare to space
001285r 2  90 19        	bcc	extdec		;not printing so done
001287r 2               ;do a backspace
001287r 2  AD rr rr     dobs:	lda	sysdef+0	;get backspace
00128Ar 2  48           	pha			;save it
00128Br 2  20 rr rr     	jsr	nolist		;send
00128Er 2  A9 20        	lda	#' '		;get space
001290r 2  20 rr rr     	jsr	nolist		;send
001293r 2  68           	pla			;get backspace
001294r 2  4C rr rr     	jmp	nolist		;send it
001297r 2               ;test for decimal digit
001297r 2               ;if decimal then c=0 else c=1
001297r 2  C9 30        tstdec:	cmp	#'0'		;if under 0
001299r 2  90 04        	bcc	notdec		;then not decimal
00129Br 2  C9 3A        	cmp	#'9'+1		;if 9 or under is ok
00129Dr 2  90 01        	bcc	extdec
00129Fr 2  38           notdec:	sec			;else not a match
0012A0r 2  60           extdec:	rts
0012A1r 2               ;test for hexadecimal digit
0012A1r 2               ;if hex then c=0 else c=1
0012A1r 2  20 rr rr     tsthex:	jsr	tstdec		;first try decimal
0012A4r 2  90 FA        	bcc	extdec		;ok if dec
0012A6r 2  C9 41        	cmp	#'A'		;if under A
0012A8r 2  90 F5        	bcc	notdec		;then not hex
0012AAr 2  C9 47        	cmp	#'F'+1		;set c in F compare
0012ACr 2  60           	rts
0012ADr 2               ;bump load address by 128 and return in ay
0012ADr 2  AD rr rr     adjdb:	lda	dskbuf		;get old
0012B0r 2  AC rr rr     	ldy	dskbuf+1	;address
0012B3r 2  18           	clc			;and bump
0012B4r 2  69 80        	adc	#128		;by 128
0012B6r 2  8D rr rr     	sta	dskbuf		;save low
0012B9r 2  90 04        	bcc	*+6		;then bump
0012BBr 2  C8           	iny			;and save
0012BCr 2  8C rr rr     	sty	dskbuf+1	;high as needed
0012BFr 2  60           	rts
0012C0r 2               ;move record from disk buffer to default buffer
0012C0r 2  AD rr rr     mv128:	lda	dskbuf		;get address
0012C3r 2  AC rr rr     	ldy	dskbuf+1
0012C6r 2  8D rr rr     	sta	mvfrom+1	;and set pointer
0012C9r 2  8C rr rr     	sty	mvfrom+2
0012CCr 2  A2 00        	ldx	#0		;clear index
0012CEr 2  BD FF FF     mvfrom:	lda	$ffff,x		;get byte
0012D1r 2  9D 28 01     	sta	dflbuf,x	;move it
0012D4r 2  E8           	inx
0012D5r 2  10 F7        	bpl	mvfrom		;loop until done
0012D7r 2  60           	rts
0012D8r 2               
0012D8r 2               ;relocatable vectors
0012D8r 2  4C           	.byte	$4c
0012D9r 2  rr rr        extevc:	.word	extexq-1
0012DBr 2  4C           	.byte	$4c
0012DCr 2  rr rr        sltmvc:	.word	sltmsg
0012DEr 2  4C           	.byte	$4c
0012DFr 2  rr rr        empdvc:	.word	empty
0012E1r 2  4C           	.byte	$4c
0012E2r 2  rr rr        rommvc:	.word	romsg
0012E4r 2  4C           	.byte	$4c
0012E5r 2  rr rr        bdsmvc:	.word	bdsmsg
0012E7r 2  4C           	.byte	$4c
0012E8r 2  rr rr        pemmvc:	.word	pemmsg
0012EAr 2  4C           	.byte	$4c
0012EBr 2  rr rr        dcbevc:	.word	dcb
0012EDr 2               ;relocation stopper
0012EDr 2  FF           	.byte	$ff
0012EEr 2               ;messages
0012EEr 2  20 2D 20 52  romsg:	.byte	" - R/O$"
0012F2r 2  2F 4F 24     
0012F5r 2  20 2D 20 42  bdsmsg:	.byte	" - BAD SECTOR"
0012F9r 2  41 44 20 53  
0012FDr 2  45 43 54 4F  
001302r 2  0D 0A 3C 52  	.byte	cr,lf,"<RET> TO IGNORE -- <OTHER> "
001306r 2  45 54 3E 20  
00130Ar 2  54 4F 20 49  
00131Fr 2  54 4F 20 41  	.byte	"TO ABORT$"
001323r 2  42 4F 52 54  
001327r 2  24           
001328r 2  0D 0A 50 45  pemmsg:	.byte	cr,lf,"PEM ERROR ON $"
00132Cr 2  4D 20 45 52  
001330r 2  52 4F 52 20  
001338r 2  20 2D 20 49  sltmsg:	.byte	" - INVALID DRIVE$"
00133Cr 2  4E 56 41 4C  
001340r 2  49 44 20 44  
001349r 2               
001349r 2               ;dummy fcb
001349r 2  E5           empty:	.byte	$e5
00134Ar 2               ;zero page switch enable table
00134Ar 2  00 00 00 00  swctbl:	.byte	0,0,0,0,0,0,0,0
00134Er 2  00 00 00 00  
001352r 2  00 00 01 00  	.byte	0,0,1,0,0,1,1,1
001356r 2  00 01 01 01  
00135Ar 2  01 01 01 01  	.byte	1,1,1,1,1,1,1,1
00135Er 2  01 01 01 01  
001362r 2  00 00 01 00  	.byte	0,0,1,0,0,0,0,0
001366r 2  00 00 00 00  
00136Ar 2  00 00 00 00  	.byte	0,0,0,0
00136Er 2               ;bit mask table
00136Er 2  80 40 20 10  bitmsk:	.byte	128,64,32,16,8,4,2,1
001372r 2  08 04 02 01  
001376r 2               ;bit map table
001376r 2  01 02 04 08  bitmap:	.byte	1,2,4,8,16,32,64,128
00137Ar 2  10 20 40 80  
00137Er 2               ;extent mask table (also uses 3 bytes in sabtbl
00137Er 2  00 01 03     exmtbl:	.byte	0,1,3
001381r 2               ;sab table
001381r 2  07 0F 1F 3F  sabtbl:	.byte	7,15,31,63,127
001385r 2  7F           
001386r 2               ;variable storage
001386r 2  00           skpdir:	.byte	0		;positive if no change
001387r 2  00           fcbind:	.byte	0		;index to block number
001388r 2  00           savext:	.byte	0		;save extent
001389r 2  00           frscol:	.byte	0		;first col
00138Ar 2  00           pndkey:	.byte	0		;pending input
00138Br 2  00           lstflg:	.byte	0		;printer flag
00138Cr 2  00           positn:	.byte	0		;print position
00138Dr 2  00           swcflg:	.byte	0		;zero page switch flag
00138Er 2  00 00        bytinp:	.word	0		;input value
001390r 2  00           cmdinp:	.byte	0		;input command
001391r 2  00 00        addout:	.word	0		;output address
001393r 2               bytout	=	addout		;output value
001393r 2  00           bufpsn:	.byte	0		;input buffer position
001394r 2  00           exrwfl:	.byte	0		;extend flag
001395r 2  00           tmpdrv:	.byte	0		;temporary drive number
001396r 2               ;align xqtvec on word boundary
001396r 2               	.align 2
001396r 2  00 00        xqtvec:	.word	0		;command vector
001398r 2  00 00        countr:	.word	0		;record counter
00139Ar 2  00           	.byte	0		;overflow
00139Br 2  00 00        lkdown:	.word	0		;down pnt. for block search
00139Dr 2  00 00        lookup:	.word	0		;up pnt. for block search
00139Fr 2  00           olddrv:	.byte	0		;old drive number
0013A0r 2  00           curdrv:	.byte	0		;current drive
0013A1r 2  00           lginvc:	.byte	0		;log in status
0013A2r 2  00           ronlst:	.byte	0		;read write status
0013A3r 2  00 00        dirnum:	.word	0		;directory number
0013A5r 2  00           subrec:	.byte	0		;directory offset
0013A6r 2  00 00        recnum:	.word	0		;record number
0013A8r 2               blknum	=	recnum		;block number
0013A8r 2  00           	.byte	0		;overflow
0013A9r 2  00           chrcnt:	.byte	0		;character count
0013AAr 2  00           cmppnt:	.byte	0		;comparison pointer
0013ABr 2  00           nxtrec:	.byte	0		;next record
0013ACr 2  00           numrec:	.byte	0		;number records
0013ADr 2  00 00        dirrec:	.word	0		;directory record
0013AFr 2  00           dirmod:	.byte	0		;directory mod 4
0013B0r 2  00           index:	.byte	0		;buffer index
0013B1r 2  00           numcnt:	.byte	0		;counter
0013B2r 2  00           outflg:	.byte	0		;output enable flag
0013B3r 2  00           lstcol:	.byte	0		;last column
0013B4r 2  00           mpdrsy:	.byte	0		;save for y in mapdir
0013B5r 2  00           mpdrtm:	.byte	0		;temp in mapdir
0013B6r 2  00           blmode:	.byte	0		;<128 if byte else word
0013B7r 2  00 00        maxdrc:	.word	0		;max directory record
0013B9r 2  00           sab:	.byte	0		;mask for block
0013BAr 2  00           sxb:	.byte	0		;shift for block
0013BBr 2  00 00 00     rtclk:	.byte	0,0,0		;real time clock
0013BEr 2  00 00        gpcnt:	.word	0		;gp counter
0013C0r 2  00           trkctr:	.byte	0		;track counter
0013C1r 2               ;following region is used to capture dcb
0013C1r 2               dcb:
0013C1r 2  00 00        maxblk:	.word	0		;maximum block number
0013C3r 2  00 00        sectrk:	.word	0		;sectors per track
0013C5r 2  00 00        nsystr:	.word	0		;number system tracks
0013C7r 2  00           blkscd:	.byte	0		;block size code
0013C8r 2  00 00        maxdir:	.word	0		;maximum directory number
0013CAr 2  00 00        alcmap:	.word	0		;address of allocation map
0013CCr 2  00           chkflg:	.byte	0		;check flag
0013CDr 2  00 00        chkmap:	.word	0		;address of checksum map
0013CFr 2  00           pemwrtype:	.byte	0		;write type 0=norm,1=dir,2=unalloc
0013D0r 2  00           exm:	.byte	0		;extent mask
0013D1r 2  00           cexm1f:	.byte	0		;exm complemented and 1f
0013D2r 2               ;zero page save block
0013D2r 2               varblk:
0013D2r 2  00 00        lowin:	.word	0
0013D4r 2  00 00        	.word	0		;save bufadd
0013D6r 2  00 00        	.word	0		;save alcpnt
0013D8r 2  00 00        	.word	0		;save chkpnt
0013DAr 2               
0013DAr 1               		.include "SIMNHY.ASM"
0013DAr 2               ;--------------------------------
0013DAr 2               ;dos/65 system interface module (sim)
0013DAr 2               ;--------------------------------
0013DAr 2               
0013DAr 2               		.include "MACRO.ASM"
0013DAr 3               ;__MACRO___________________________________________________________________________________________________________________
0013DAr 3               ;
0013DAr 3               ; 	Macros for the betterment of Mankind
0013DAr 3               ;________________________________________________________________________________________________________________________________
0013DAr 3               ;
0013DAr 3               
0013DAr 3               .macro          PRTDBG      message
0013DAr 3               .LOCAL p1
0013DAr 3               .LOCAL p2
0013DAr 3               .LOCAL p3
0013DAr 3               .LOCAL p4
0013DAr 3               .LOCAL p5
0013DAr 3                 .if     .paramcount <> 1
0013DAr 3                       .error  "Too few parameters for macro PRTDBG"
0013DAr 3                       .endif
0013DAr 3                       .if DEBUG=1
0013DAr 3                       PHA
0013DAr 3                       PHX
0013DAr 3                       PHY
0013DAr 3                       LDX #$00
0013DAr 3               p1:
0013DAr 3                       LDA p4,x
0013DAr 3                       INX
0013DAr 3                       CMP #'$'
0013DAr 3                       BEQ p2
0013DAr 3                       JSR WRSER1
0013DAr 3                       BRA p1
0013DAr 3               p2:
0013DAr 3                       LDA #13
0013DAr 3                       jsr WRSER1
0013DAr 3                       LDA #10
0013DAr 3                       jsr WRSER1
0013DAr 3                       PLY
0013DAr 3                       plx
0013DAr 3                       pla
0013DAr 3                       bra p5
0013DAr 3               p4:
0013DAr 3                       .BYTE message
0013DAr 3               p5:
0013DAr 3                       .endif
0013DAr 3               .endmacro
0013DAr 3               
0013DAr 2               
0013DAr 2               USESERIAL 	= 	1	; SET TO ONE SERIAL CONSOLE IO
0013DAr 2               USEFLOPPYA 	= 	0	; SET TO ONE FOR FLOPPY = "A"
0013DAr 2               USEFLOPPYB 	= 	0	; SET TO ONE FOR FLOPPY = "B"
0013DAr 2               USEIDEC 	= 	1	; SET TO ONE FOR IDE HDD="C"
0013DAr 2               USEDSKY 	= 	0	; SEND INFO TO DSKY
0013DAr 2               DEFDRV  	=	2	; SET TO DEFAULT DRIVE LETTER
0013DAr 2               USEDISKIOV1     = 	0	; Floppy and IDE card is  DISK IO V1
0013DAr 2               USEDISKIOV3     = 	0	; Floppy and IDE card is  DISK IO V3
0013DAr 2               
0013DAr 2               FLPA35		=	0	; set to 1 if floppy a is A 3.5" 80 track drive (0= 5.25" 40 track drive)
0013DAr 2               FLPB35		=	0	; set to 1 if floppy a is B 3.5" 80 track drive (0= 5.25" 40 track drive)
0013DAr 2               
0013DAr 2               
0013DAr 2               ;dos/65 system interface module (sim)
0013DAr 2               ;version 3.00
0013DAr 2               ;this version is designed to work with the N8VEM Host Processor
0013DAr 2               
0013DAr 2               ;fixed parameters
0013DAr 2               simstart:
0013DAr 2               
0013DAr 2               ;my system i/o routines in rom
0013DAr 2               
0013DAr 2               ;pem constants on entry to write
0013DAr 2               wrall	=	0		;write to allocated
0013DAr 2               wrdir	=	1		;write to directory
0013DAr 2               wrual	=	2		;write to unallocated
0013DAr 2               ;page zero and system ram assignments
0013DAr 2               dmaadr	=	$f4		;pointer for r/w
0013DAr 2               mvepnt	=	$f2		;host buffer location
0013DAr 2               OUTMSG_W =	$F0		;pointer for OutMsg
0013DAr 2               SRC	 =	$EE		;pointer for OutMsg
0013DAr 2               DEST	 =	$EC		;pointer for OutMsg
0013DAr 2               
0013DAr 2               nsects	=	(simstart-ccm)/128	;number sectors
0013DAr 2               
0013DAr 2               ;main program
0013DAr 2               ;jump vector used by pem
0013DAr 2  4C rr rr     sim:	jmp	boot		;from cold start
0013DDr 2  4C rr rr     wboote:	jmp	wboot		;from warm boot
0013E0r 2  4C rr rr     	jmp	consts		;check for input
0013E3r 2  4C rr rr     	jmp	conrde		;get input
0013E6r 2  4C rr rr     	jmp	conwrt		;send to terminal
0013E9r 2  4C rr rr     	jmp	prnwrt		;printer output
0013ECr 2  4C rr rr     	jmp	punwrt		;punch output
0013EFr 2  4C rr rr     	jmp	rdrinp		;reader input
0013F2r 2  4C rr rr     	jmp	home		;home drive
0013F5r 2  4C rr rr     	jmp	seldsk		;select disk
0013F8r 2  4C rr rr     	jmp	seltrk		;set track
0013FBr 2  4C rr rr     	jmp	selsec		;set sector
0013FEr 2  4C rr rr     	jmp	setdma		;set buffer address
001401r 2  4C rr rr     	jmp	read		;read sector
001404r 2  4C rr rr     	jmp	write		;write sector
001407r 2  A9 01        	lda	#1		;printer always ready
001409r 2  60           	rts
00140Ar 2  4C rr rr     	jmp	rdtime		;clock entry
00140Dr 2  4C rr rr     	jmp	xlate		;translate
001410r 2               
001410r 2               ;console definition block
001410r 2               sysdef:
001410r 2  08           	.byte	8		;backspace
001411r 2  01           	.byte	1		;clear to end of line
001412r 2  0C           	.byte	$c		;forward space
001413r 2  00           	.byte	0		;normal video
001414r 2  5E           	.byte	'^'		;invert video
001415r 2  18           	.byte	24		;lines per screen
001416r 2  50           	.byte	80		;char per line
001417r 2  0C           	.byte	$c		;formfeed
001418r 2  1E           	.byte	$1e		;home
001419r 2  02           	.byte	2		;clear to end of screen
00141Ar 2               
00141Ar 2               ;opening id message
00141Ar 2  0D 0A        opnmsg:	.byte	cr,lf
00141Cr 2  20 20 20 20      	.BYTE "     ____  ____  _____    _______ ______",cr,lf
001420r 2  20 5F 5F 5F  
001424r 2  5F 20 20 5F  
001446r 2  20 20 20 2F     	.BYTE "   / __ \/ __ \/ ___/  _/_/ ___// ____/",cr,lf
00144Ar 2  20 5F 5F 20  
00144Er 2  5C 2F 20 5F  
00146Fr 2  20 20 2F 20    	.BYTE "  / / / / / / /\__ \ _/_// __ \/___ \",cr,lf
001473r 2  2F 20 2F 20  
001477r 2  2F 20 2F 20  
001496r 2  20 2F 20 2F   	.BYTE " / /_/ / /_/ /___/ //_/ / /_/ /___/ /",cr,lf
00149Ar 2  5F 2F 20 2F  
00149Er 2  20 2F 5F 2F  
0014BDr 2  2F 5F 5F 5F  	.BYTE "/_____/\____//____/_/   \____/_____/",cr,lf
0014C1r 2  5F 5F 2F 5C  
0014C5r 2  5F 5F 5F 5F  
0014E3r 2  11 44 4F 53  	.byte 17,"DOS/65 ON THE NHYODYNE 3.00",cr,lf,0
0014E7r 2  2F 36 35 20  
0014EBr 2  4F 4E 20 54  
001502r 2               
001502r 2               
001502r 2               ;cold entry from loader
001502r 2               boot:
001502r 2  A2 FF        	ldx	#$ff		;set stack
001504r 2  9A           	txs			;pointer
001505r 2  D8           	cld			;set binary mode
001506r 2               
001506r 2  48 DA 5A A2  	PRTDBG "OS Starting$"
00150Ar 2  00 BD rr rr  
00150Er 2  E8 C9 24 F0  
001533r 2               
001533r 2  A9 rr         	lda	#<opnmsg	;point to message
001535r 2  A0 rr        	ldy	#>opnmsg
001537r 2  20 rr rr     	jsr	outmsg		;send it
00153Ar 2               				;set up jumps into dos/65 in page one
00153Ar 2  A2 00        setup:	ldx	#0		;clear index
00153Cr 2               				;first clear key dba variables
00153Cr 2  8E rr rr     	stx	hstact		;host buffer inactive
00153Fr 2  8E rr rr     	stx	unacnt		;clear unalloc count
001542r 2  BD rr rr     setupl:	lda	inttbl,x	;get byte
001545r 2  9D 00 01     	sta	$100,x		;insert at start
001548r 2  E8           	inx
001549r 2  E0 06        	cpx	#6
00154Br 2  D0 F5        	bne	setupl		;loop until done
00154Dr 2  A9 28        	lda	#<dflbuf	;get low buffer
00154Fr 2  A0 01        	ldy	#>dflbuf	;and high
001551r 2  20 rr rr     	jsr	setdma		;and set
001554r 2  AD rr rr     	lda	sekdsk		;get disk
001557r 2               
001557r 2               
001557r 2                 .IF USEFLOPPYA=1
001557r 2                 	PRTDBG "Init floppy A$"
001557r 2                 	lda	#0			;set zero
001557r 2               	jsr	seldsk		;and select drive zero
001557r 2               	JSR	SETUPDRIVE
001557r 2                 .ENDIF
001557r 2               
001557r 2                 .IF USEFLOPPYB=1
001557r 2                 	PRTDBG "Init floppy B$"
001557r 2                 	lda	#1		;set 1
001557r 2               	jsr	seldsk		;and select drive zero
001557r 2               	JSR	SETUPDRIVE
001557r 2                 .ENDIF
001557r 2               
001557r 2                   .IF USEIDEC=1
001557r 2  48 DA 5A A2      	PRTDBG "Init IDE$"
00155Br 2  00 BD rr rr  
00155Fr 2  E8 C9 24 F0  
001581r 2  20 rr rr         	JSR	IDE_SOFT_RESET
001584r 2                 .ENDIF
001584r 2               
001584r 2                 .IF USEDSKY=1
001584r 2                 	PRTDBG "Init DSKY$"
001584r 2                 	JSR	DSKYINIT
001584r 2                 	JSR	SEGDISPLAY
001584r 2                 .ENDIF
001584r 2               
001584r 2  A9 02        	lda	#DEFDRV		;set zero
001586r 2  20 rr rr     	jsr	seldsk		;and select drive zero
001589r 2  20 rr rr     	jsr	home		;home that drive
00158Cr 2               
00158Cr 2  00           	BRK
00158Dr 2               
00158Dr 2  48 DA 5A A2  	PRTDBG "Start CCM$"
001591r 2  00 BD rr rr  
001595r 2  E8 C9 24 F0  
0015B8r 2  4C rr rr     	jmp	ccm		;and go to ccm
0015BBr 2               ;initialization table
0015BBr 2  4C rr rr 4C  inttbl:	.byte	$4c,<wboote,>wboote,$4c,<pem,>pem
0015BFr 2  rr rr        
0015C1r 2               ;warm boot-read dos/65 back except sim and then
0015C1r 2               ; jump to ccm.
0015C1r 2               
0015C1r 2               
0015C1r 2               wboot:
0015C1r 2  A2 FF        	ldx	#$ff		;set stack
0015C3r 2  9A           	txs			;pointer
0015C4r 2  D8           	cld			;set binary mode
0015C5r 2               
0015C5r 2  4C rr rr     	jmp	setup		;go setup
0015C8r 2               
0015C8r 2               
0015C8r 2               
0015C8r 2               ;__SELDSK_________________________________________________________________________________________________
0015C8r 2               ;
0015C8r 2               ; 	PERFORM DOS/65 DISK DRIVE SELECT
0015C8r 2               ;________________________________________________________________________________________________________
0015C8r 2               ;select disk
0015C8r 2               seldsk:
0015C8r 2  29 03        	and	#3		;three lsbs only
0015CAr 2  8D rr rr     	sta	sekdsk		;save for later
0015CDr 2                .IF (USEFLOPPYA=1 | USEFLOPPYB=1)
0015CDr 2               	jsr	MOTOROFF	; TURN OFF ALL FLOPPY MOTORS
0015CDr 2                .ENDIF
0015CDr 2  AD rr rr     	LDA	sekdsk		;save for later
0015D0r 2  0A           	asl	a		;multiply by two
0015D1r 2  AA           	tax			;make an Index
0015D2r 2  BD rr rr     	lda	dcbtbl,x	;get address
0015D5r 2  BC rr rr     	ldy	dcbtbl+1,x
0015D8r 2  60           	rts
0015D9r 2               
0015D9r 2               ;table of dcb addresses
0015D9r 2  rr rr        dcbtbl:	.word	dcba
0015DBr 2  rr rr        	.word	dcbb
0015DDr 2  rr rr        	.word	dcbc
0015DFr 2               
0015DFr 2               
0015DFr 2               
0015DFr 2               ;__HOME__________________________________________________________________________________________________
0015DFr 2               ;
0015DFr 2               ; 	PERFORM DOS/65 HEAD HOME
0015DFr 2               ;________________________________________________________________________________________________________
0015DFr 2               home:
0015DFr 2  A9 00        	lda	#$00
0015E1r 2  A0 00        	ldy	#$00
0015E3r 2               
0015E3r 2               ;__SELTRK________________________________________________________________________________________________
0015E3r 2               ;
0015E3r 2               ; 	PERFORM DOS/65 SELECT TRACK
0015E3r 2               ;
0015E3r 2               ;	A=TRACK LOW BYTE
0015E3r 2               ;	Y=TRACK HIGH BYTE
0015E3r 2               ;________________________________________________________________________________________________________
0015E3r 2               seltrk:
0015E3r 2  8D rr rr     	sta	sektrk		;save number
0015E6r 2  8C rr rr     	sty	sektrk+1
0015E9r 2  60           	rts
0015EAr 2               
0015EAr 2               ;__SELSEC________________________________________________________________________________________________
0015EAr 2               ;
0015EAr 2               ; 	PERFORM DOS/65 SECTOR SELECT
0015EAr 2               ;
0015EAr 2               ;	A=SECTOR LOW BYTE
0015EAr 2               ;	Y=SECTOR HIGH BYTE
0015EAr 2               ;________________________________________________________________________________________________________
0015EAr 2               selsec:
0015EAr 2  8D rr rr     	sta	seksec		;save low and high
0015EDr 2  8C rr rr     	sty	seksec+1
0015F0r 2  60           	rts
0015F1r 2               
0015F1r 2               ;__READ__________________________________________________________________________________________________
0015F1r 2               ;
0015F1r 2               ; 	PERFORM DOS/65 SECTOR READ
0015F1r 2               ;________________________________________________________________________________________________________
0015F1r 2               read:
0015F1r 2               
0015F1r 2  20 rr rr     	JSR	CONVERT_SECTOR_DOS	;
0015F4r 2  20 rr rr     	JSR	READlow			;
0015F7r 2  C9 00        	CMP	#$00			;
0015F9r 2  D0 06        	BNE	RDABEND			;
0015FBr 2  20 rr rr     	JSR	DEBSECR			;
0015FEr 2  A9 00        	LDA	#$00			;
001600r 2  60           	RTS				;
001601r 2               RDABEND:				;
001601r 2  A9 FF        	LDA	#$FF			;
001603r 2  60           	RTS				;
001604r 2               
001604r 2               ;__READlow_______________________________________________________________________________________________
001604r 2               ;
001604r 2               ; 	PERFORM LOW LEVEL SECTOR READ
001604r 2               ;________________________________________________________________________________________________________
001604r 2               READlow:
001604r 2  AD rr rr     	LDA	sekdsk			; GET DRIVE
001607r 2  C9 00        	CMP	#$00			;
001609r 2  D0 03        	BNE	RDNOTA			;
00160Br 2                    					;
00160Br 2                 .IF USEFLOPPYA=1			;
00160Br 2                 	JSR	READFL			;
00160Br 2                 	JMP	RDlowEND		;
00160Br 2                 .ENDIF
00160Br 2               
00160Br 2  4C rr rr       	JMP	RDlowABEND		;
00160Er 2                 					;
00160Er 2               RDNOTA:					;
00160Er 2  C9 01        	CMP	#$01			;
001610r 2  D0 03        	BNE	RDNOTB			;
001612r 2               					;
001612r 2                 .IF USEFLOPPYB=1			;
001612r 2                 	JSR	READFL			;
001612r 2                 	JMP	RDlowEND		;
001612r 2                 .ELSE					;
001612r 2  4C rr rr       	JMP	RDlowABEND		;
001615r 2                 .ENDIF				;
001615r 2                 					;
001615r 2               RDNOTB:					;
001615r 2  C9 02          	CMP	#$02			;
001617r 2  D0 06        	BNE	RDNOTC			;
001619r 2               					;
001619r 2                 .IF USEIDEC=1				;
001619r 2  20 rr rr     	JSR	IDE_READ_SECTOR		;
00161Cr 2  4C rr rr     	JMP	RDlowEND		;
00161Fr 2                 .ELSE					;
00161Fr 2                 	JMP	RDlowABEND		;
00161Fr 2                 .ENDIF				;
00161Fr 2                 					;
00161Fr 2               RDNOTC:    				;
00161Fr 2  4C rr rr        	JMP	RDlowABEND		;
001622r 2                 					;
001622r 2               RDlowEND:
001622r 2  60           	RTS				;
001623r 2               RDlowABEND:				;
001623r 2  A9 FF        	LDA	#$FF			;
001625r 2  60           	RTS				;
001626r 2               
001626r 2               
001626r 2               
001626r 2               ;__WRITE_________________________________________________________________________________________________
001626r 2               ;
001626r 2               ; 	PERFORM DOS/65 SECTOR WRITE
001626r 2               ;________________________________________________________________________________________________________
001626r 2               write:
001626r 2  20 rr rr     	JSR	CONVERT_SECTOR_DOS	;
001629r 2  20 rr rr     	JSR	READlow			;
00162Cr 2  C9 00        	CMP	#$00			;
00162Er 2  D0 2B        	BNE	WRABEND			;
001630r 2  20 rr rr     	JSR	BLKSECR			;
001633r 2               					;
001633r 2  AD rr rr     	LDA	sekdsk			; GET DRIVE
001636r 2  C9 00        	CMP	#$00			;
001638r 2  D0 03        	BNE	WRNOTA			;
00163Ar 2               					;
00163Ar 2                 .IF USEFLOPPYA=1			;
00163Ar 2               	JSR	WRITEFL			;
00163Ar 2               	JMP	WREND			;
00163Ar 2                 .ENDIF
00163Ar 2                						;
00163Ar 2  4C rr rr       	JMP	WRABEND			;
00163Dr 2                 					;
00163Dr 2               WRNOTA:					;
00163Dr 2  C9 01        	CMP	#$01			;
00163Fr 2  D0 03        	BNE	WRNOTB			;
001641r 2               					;
001641r 2                 .IF USEFLOPPYB=1			;
001641r 2                 	JSR	WRITEFL			;
001641r 2               	JMP	WREND			;
001641r 2                 .ELSE					;
001641r 2  4C rr rr       	JMP	WRABEND			;
001644r 2                 .ENDIF				;
001644r 2                 					;
001644r 2               WRNOTB:					;
001644r 2  C9 02          	CMP	#$02			;
001646r 2  D0 06        	BNE	WRNOTC			;
001648r 2               					;
001648r 2                 .IF USEIDEC=1				;
001648r 2  20 rr rr     	JSR	IDE_WRITE_SECTOR	;
00164Br 2  4C rr rr     	JMP	WREND			;
00164Er 2                 .ELSE					;
00164Er 2                 	JMP	WRABEND			;
00164Er 2                 .ENDIF				;
00164Er 2                 					;
00164Er 2               WRNOTC:    				;
00164Er 2  4C rr rr        	JMP	WRABEND			;
001651r 2               					;
001651r 2               					;
001651r 2               WREND:  				;
001651r 2  C9 00        	CMP	#$00			;
001653r 2  D0 06        	BNE	WRABEND			;
001655r 2  20 rr rr     	JSR	DEBSECR			;
001658r 2  A9 00        	LDA	#$00			;
00165Ar 2  60           	RTS				;
00165Br 2               WRABEND:				;
00165Br 2  A9 FF        	LDA	#$FF			;
00165Dr 2  60           	RTS				;
00165Er 2               
00165Er 2               ;__SETDMA________________________________________________________________________________________________
00165Er 2               ;
00165Er 2               ; 	PERFORM DOS/65 BUFFER ADDRESS SELECTION
00165Er 2               ;
00165Er 2               ;	A=BUFFER LOW BYTE
00165Er 2               ;	Y=BUFFER HIGH BYTE
00165Er 2               ;________________________________________________________________________________________________________
00165Er 2               setdma:
00165Er 2  85 F4        	sta	dmaadr		;store low
001660r 2  84 F5        	sty	dmaadr+1	;and high
001662r 2  60           	rts
001663r 2               
001663r 2               
001663r 2               ;__CONSTS________________________________________________________________________________________________
001663r 2               ;
001663r 2               ; 	GET DOS/65 CONSOLE STATUS
001663r 2               ;________________________________________________________________________________________________________
001663r 2               consts:
001663r 2  4C rr rr     	jmp	SERIALSTATUS
001666r 2               
001666r 2               ;__CONRDE________________________________________________________________________________________________
001666r 2               ;
001666r 2               ; 	PERFORM DOS/65 CONSOLE READ
001666r 2               ;________________________________________________________________________________________________________
001666r 2               conrde:
001666r 2  4C rr rr     	jmp 	RDSER1W
001669r 2               
001669r 2               ;__CONWRT________________________________________________________________________________________________
001669r 2               ;
001669r 2               ; 	PERFORM DOS/65 CONSOLE WRITE
001669r 2               ;________________________________________________________________________________________________________
001669r 2               conwrt:
001669r 2  4C rr rr     	jmp 	WRSER1
00166Cr 2               
00166Cr 2               prnwrt:
00166Cr 2  60           	rts			;printer
00166Dr 2               punwrt:
00166Dr 2  60           	rts			;punch output
00166Er 2               rdrinp:
00166Er 2  60           	rts			;reader input
00166Fr 2               rdtime:
00166Fr 2  60           	rts			;read clock
001670r 2               xlate:
001670r 2  60           	rts			;sector translate
001671r 2               
001671r 2               
001671r 2               ;__OUTMSG________________________________________________________________________________________________
001671r 2               ;
001671r 2               ; 	WRITE A NULL TERMINATED STRING TO THE CONSOLE
001671r 2               ;
001671r 2               ;	A=POINTER LOW BYTE
001671r 2               ;	Y=POINTER HIGH BYTE
001671r 2               ;________________________________________________________________________________________________________
001671r 2               outmsg:				;output message
001671r 2  85 F0        	STA OUTMSG_W
001673r 2  84 F1        	STY OUTMSG_W+1
001675r 2  A0 00        	LDY #$00
001677r 2               OUTSTRLP:
001677r 2  B1 F0               	LDA (OUTMSG_W),Y 	; LOAD NEXT CHAR FROM STRING INTO ACC
001679r 2  C9 00               	CMP #$00		; IS NULL?
00167Br 2  F0 07               	BEQ ENDOUTSTR		; YES, END PRINT OUT
00167Dr 2  20 rr rr            	JSR conwrt  		; PRINT CHAR IN ACC
001680r 2  C8                  	INY      		; Y=Y+1 (BUMP INDEX)
001681r 2  4C rr rr            	JMP OUTSTRLP		; DO NEXT CHAR
001684r 2               ENDOUTSTR:
001684r 2  60                  	RTS			; RETURN
001685r 2               
001685r 2               
001685r 2               ;___CONVERT_SECTOR_DOS________________________________________________________________________________
001685r 2               ;
001685r 2               ; 	TRANSLATE SECTORS INTO ECB SERVER FORMAT
001685r 2               ;________________________________________________________________________________________________________
001685r 2               CONVERT_SECTOR_DOS:
001685r 2  AD rr rr     	LDA	sekdsk			; GET DISK #
001688r 2  C9 02        	CMP	#$02
00168Ar 2  F0 18        	BEQ	CONVERT_SECTOR_DOS1	; NOT ZERO, DO FULL TRANSLATE
00168Cr 2  AD rr rr     	LDA	sektrk			; LOAD TRACK # (LOW BYTE)
00168Fr 2  29 01        	AND	#$01			; FILTER OUT HEAD
001691r 2  8D rr rr     	STA	debhead			; STORE HEAD
001694r 2  AD rr rr     	LDA	sektrk			; SAVE TRACK IN A
001697r 2  4A           	LSR	A			; REMOVE HEAD BIT
001698r 2  8D rr rr     	STA	debcyl			; STORE IN TRACK
00169Br 2  AD rr rr     	LDA	seksec			; LOAD SECTOR # (LOW BYTE)
00169Er 2  4A           	LSR	A			;
00169Fr 2  4A           	LSR	A			; DIVIDE BY 4 (FOR BLOCKING)
0016A0r 2  8D rr rr     	STA	debsec			; STORE IN SECTOR
0016A3r 2               
0016A3r 2                 .IF USEDSKY=1
0016A3r 2                 	lda	sekdsk
0016A3r 2                 	sta	DSKYDISPLAY
0016A3r 2                 	lda	debhead
0016A3r 2                 	sta	DSKYDISPLAY+1
0016A3r 2                	lda	debcyl
0016A3r 2                 	sta	DSKYDISPLAY+2
0016A3r 2                	lda	debsec
0016A3r 2                 	sta	DSKYDISPLAY+3
0016A3r 2                 	JSR	HEXDISPLAY
0016A3r 2                 .ENDIF
0016A3r 2               
0016A3r 2  60           	RTS
0016A4r 2               
0016A4r 2               CONVERT_SECTOR_DOS1:
0016A4r 2  AD rr rr     	LDA	sektrk			; LOAD TRACK # (LOW BYTE)
0016A7r 2  8D rr rr     	STA	debtmp+1		;
0016AAr 2  AD rr rr     	LDA	seksec			; LOAD SECTOR# (LOW BYTE)
0016ADr 2  8D rr rr     	STA	debtmp			;
0016B0r 2  20 rr rr     	JSR	RRA16			; ROTATE DEBTMP RIGHT (DIVIDE BY 2)
0016B3r 2  20 rr rr     	JSR	RRA16			; ROTATE DEBTMP RIGHT (DIVIDE BY 2)
0016B6r 2  AD rr rr     	LDA	sektrk+1		; GET HIGH BYTE OF TRACK INTO A
0016B9r 2  0A           	ASL	A			;
0016BAr 2  0A           	ASL	A
0016BBr 2  0A           	ASL	A
0016BCr 2  0A           	ASL	A
0016BDr 2  0A           	ASL	A			;
0016BEr 2  0A           	ASL	A			;
0016BFr 2  18           	CLC
0016C0r 2  0D rr rr     	ORA	debtmp+1		;
0016C3r 2  8D rr rr     	STA	debtmp+1		;
0016C6r 2  AD rr rr     	LDA	sektrk+1		; GET HIGH BYTE OF TRACK INTO A
0016C9r 2  4A           	LSR	A
0016CAr 2  4A           	LSR	A
0016CBr 2  8D rr rr     	STA	debhead			;
0016CEr 2  AD rr rr     	LDA	debtmp			;
0016D1r 2  8D rr rr     	STA	debsec			; LBA REGISTER IS 00TTTTSS / 4
0016D4r 2  AD rr rr     	LDA	debtmp+1		;
0016D7r 2  8D rr rr     	STA	debcyl		 	;
0016DAr 2                 .IF USEDSKY=1
0016DAr 2                 	lda	sekdsk
0016DAr 2                 	sta	DSKYDISPLAY
0016DAr 2                 	lda	debhead
0016DAr 2                 	sta	DSKYDISPLAY+1
0016DAr 2                	lda	debcyl
0016DAr 2                 	sta	DSKYDISPLAY+2
0016DAr 2                	lda	debsec
0016DAr 2                 	sta	DSKYDISPLAY+3
0016DAr 2                 	JSR	HEXDISPLAY
0016DAr 2                 .ENDIF
0016DAr 2  60           	RTS
0016DBr 2               RRA16:
0016DBr 2  18           	CLC				; CLEAR CARRY FLAG
0016DCr 2  AD rr rr     	LDA	debtmp+1		; 16 BIT ROTATE HL WITH CARRY
0016DFr 2  6A           	ROR	A			;
0016E0r 2  8D rr rr     	STA	debtmp+1		; ROTATE HL RIGHT 1 BIT (DIVIDE BY 2)
0016E3r 2  AD rr rr     	LDA	debtmp			;
0016E6r 2  6A           	ROR	A			;
0016E7r 2  8D rr rr     	STA	debtmp			;
0016EAr 2  60           	RTS
0016EBr 2               
0016EBr 2               ;___DEBSECR______________________________________________________________________________________________
0016EBr 2               ;
0016EBr 2               ;	DEBLOCK 512 BYTE SECTOR FOR DOS/65
0016EBr 2               ;
0016EBr 2               ;________________________________________________________________________________________________________
0016EBr 2               DEBSECR:
0016EBr 2  AD rr rr     	LDA	seksec			;
0016EEr 2  29 03        	AND	#$03			; GET SECTOR INDEX
0016F0r 2  18           	CLC				;
0016F1r 2  2A           	ROL	A			;
0016F2r 2  AA           	TAX				;
0016F3r 2  BD rr rr     	LDA	DEBTAB,X		;
0016F6r 2  85 EE        	STA     SRC
0016F8r 2  E8           	INX
0016F9r 2  BD rr rr     	LDA	DEBTAB,X		;
0016FCr 2  85 EF        	STA	SRC+1			;
0016FEr 2  A5 F4        	LDA	dmaadr			;
001700r 2  85 EC        	STA	DEST			;
001702r 2  A5 F5        	LDA	dmaadr+1		;
001704r 2  85 ED        	STA	DEST+1			;
001706r 2  20 rr rr     	JSR	COPY_DOS_SECTOR		;
001709r 2  60           	RTS
00170Ar 2               
00170Ar 2               DEBTAB:
00170Ar 2  rr rr        	.word	hstbuf			;
00170Cr 2  rr rr        	.word	hstbuf+128		;
00170Er 2  rr rr        	.word	hstbuf+256		;
001710r 2  rr rr        	.word	hstbuf+384		;
001712r 2               
001712r 2               
001712r 2               ;___BLKSECR______________________________________________________________________________________________
001712r 2               ;
001712r 2               ;	BLOCK 512 BYTE SECTOR FOR DOS/65
001712r 2               ;
001712r 2               ;________________________________________________________________________________________________________
001712r 2               BLKSECR:
001712r 2  AD rr rr     	LDA	seksec			;
001715r 2  29 03        	AND	#$03			; GET SECTOR INDEX
001717r 2  18           	CLC				;
001718r 2  2A           	ROL	A			;
001719r 2  AA           	TAX				;
00171Ar 2  BD rr rr     	LDA	DEBTAB,X		;
00171Dr 2  85 EC        	STA     DEST
00171Fr 2  E8           	INX
001720r 2  BD rr rr     	LDA	DEBTAB,X		;
001723r 2  85 ED        	STA	DEST+1			;
001725r 2  A5 F4        	LDA	dmaadr			;
001727r 2  85 EE        	STA	SRC			;
001729r 2  A5 F5        	LDA	dmaadr+1		;
00172Br 2  85 EF        	STA	SRC+1			;
00172Dr 2  20 rr rr     	JSR	COPY_DOS_SECTOR		;
001730r 2  60           	RTS
001731r 2               
001731r 2               
001731r 2               ;___COPY_DOS_SECTOR______________________________________________________________________________________
001731r 2               ;
001731r 2               ;	COPY 128 BYTE SECTOR FOR DOS/65
001731r 2               ;
001731r 2               ;________________________________________________________________________________________________________
001731r 2               COPY_DOS_SECTOR:
001731r 2  A0 00        	LDY	#$00			;
001733r 2               COPY_DOS_SECTOR1:
001733r 2  B1 EE        	LDA	(SRC),Y			;
001735r 2  91 EC        	STA	(DEST),Y		;
001737r 2  C8           	INY				;
001738r 2  98           	TYA				;
001739r 2  C9 80        	CMP	#$80			;
00173Br 2  D0 F6        	BNE	COPY_DOS_SECTOR1	;
00173Dr 2  60           	RTS
00173Er 2               
00173Er 2                 .IF USESERIAL=1
00173Er 2               	.INCLUDE "DOSSER.ASM"
00173Er 3               ;__SERIAL DRIVERS________________________________________________________________________________________________________________
00173Er 3               ;
00173Er 3               ; 	Nhyodyne serial drivers for single serial port card
00173Er 3               ;
00173Er 3               ;	Entry points:
00173Er 3               ;		SERIALINIT  - called during OS init
00173Er 3               ;		RDSER1	    - read a byte from serial port ('A' POINTS TO BYTE)
00173Er 3               ;		WRSER1	    - write a byte from serial port  ('A' POINTS TO BYTE)
00173Er 3               ;		RDSER1W	    - read a byte from serial port ('A' POINTS TO BYTE, WAIT FOR INPUT)
00173Er 3               ;		SERIALSTATUS- GET UART STATUS
00173Er 3               ;________________________________________________________________________________________________________________________________
00173Er 3               ;
00173Er 3               
00173Er 3               
00173Er 3               ;*
00173Er 3               ;* HARDWARE I/O ADDRESSES
00173Er 3               ;*
00173Er 3               
00173Er 3               ; UART 16C550 SERIAL
00173Er 3               UART0       	=    	$0368           ; DATA IN/OUT
00173Er 3               UART1       	=    	$0369           ; CHECK RX
00173Er 3               UART2       	=    	$036A           ; INTERRUPTS
00173Er 3               UART3       	=    	$036B           ; LINE CONTROL
00173Er 3               UART4       	=    	$036C           ; MODEM CONTROL
00173Er 3               UART5          	=    	$036D           ; LINE STATUS
00173Er 3               UART6          	=    	$036E           ; MODEM STATUS
00173Er 3               UART7	       	=    	$036F           ; SCRATCH REG.
00173Er 3               
00173Er 3               
00173Er 3               ;__SERIALINIT____________________________________________________________________________________________________________________
00173Er 3               ;
00173Er 3               ;	INITIALIZE SERIAL PORTS
00173Er 3               ;________________________________________________________________________________________________________________________________
00173Er 3               ;
00173Er 3               SERIALINIT:
00173Er 3               ;	LDA	#$80			;
00173Er 3               ;	STA	UART3			; SET DLAB FLAG
00173Er 3               ;	LDA	#12			; SET TO 12 = 9600 BAUD
00173Er 3               ;	STA	UART0			; save baud rate
00173Er 3               ;	LDA	#00			;
00173Er 3               ;	STA	UART1			;
00173Er 3               ;	LDA	#03			;
00173Er 3               ;	STA	UART3			; SET 8 BIT DATA, 1 STOPBIT
00173Er 3               ;	STA	UART4			;
00173Er 3               
00173Er 3  60           	RTS
00173Fr 3               
00173Fr 3               
00173Fr 3               
00173Fr 3               ;__WRSER1________________________________________________________________________________________________________________________
00173Fr 3               ;
00173Fr 3               ;	WRITE CHARACTER(A) TO UART
00173Fr 3               ;________________________________________________________________________________________________________________________________
00173Fr 3               ;
00173Fr 3               WRSER1:
00173Fr 3  48           	PHA
001740r 3               WRSER1a:
001740r 3  AD 6D 03     	LDA	UART5			; READ LINE STATUS REGISTER
001743r 3  29 20        	AND	#$20			; TEST IF UART IS READY TO SEND (BIT 5)
001745r 3  C9 00        	CMP     #$00
001747r 3  F0 F7        	BEQ	WRSER1a			; NO, WAIT FOR IT
001749r 3  68           	PLA
00174Ar 3  8D 68 03     	STA	UART0			; THEN WRITE THE CHAR TO UART
00174Dr 3  60           	RTS
00174Er 3               
00174Er 3               ;__RDSER1________________________________________________________________________________________________________________________
00174Er 3               ;
00174Er 3               ;	READ CHARACTER FROM UART TO (A)
00174Er 3               ;________________________________________________________________________________________________________________________________
00174Er 3               ;
00174Er 3               RDSER1:
00174Er 3  AD 6D 03     	LDA	UART5			; READ LINE STATUS REGISTER
001751r 3  29 01        	AND	#$01			; TEST IF DATA IN RECEIVE BUFFER
001753r 3  C9 00        	CMP 	#$00
001755r 3  F0 04        	BEQ	RDSER1N			; LOOP UNTIL DATA IS READY
001757r 3  AD 68 03     	LDA	UART0			; THEN READ THE CHAR FROM THE UART
00175Ar 3  60           	RTS
00175Br 3               RDSER1N:
00175Br 3  A9 00        	LDA	#$00			;
00175Dr 3  60           	RTS				;
00175Er 3               
00175Er 3               ;__RDSER1W_______________________________________________________________________________________________________________________
00175Er 3               ;
00175Er 3               ;	READ CHARACTER FROM UART TO (A) - WAIT FOR CHAR
00175Er 3               ;________________________________________________________________________________________________________________________________
00175Er 3               ;
00175Er 3               
00175Er 3               RDSER1W:
00175Er 3  AD 6D 03     		LDA	UART5			; READ LINE STATUS REGISTER
001761r 3  29 01        		AND	#$01			; TEST IF DATA IN RECEIVE BUFFER
001763r 3  C9 00        		CMP 	#$00
001765r 3  F0 F7        		BEQ	RDSER1W			; LOOP UNTIL DATA IS READY
001767r 3  AD 68 03     		LDA	UART0			; THEN READ THE CHAR FROM THE UART
00176Ar 3  29 7F        		AND #$7F
00176Cr 3  60           		RTS
00176Dr 3               
00176Dr 3               ;__SERIALSTATUS__________________________________________________________________________________________________________________
00176Dr 3               ;
00176Dr 3               ;	READ UARD STATUS
00176Dr 3               ;________________________________________________________________________________________________________________________________
00176Dr 3               ;
00176Dr 3               SERIALSTATUS:
00176Dr 3  AD 6D 03     	LDA	UART5			; READ LINE STATUS REGISTER
001770r 3  29 01        	AND	#$01			; TEST IF DATA IN RECEIVE BUFFER
001772r 3  C9 00        	CMP 	#$00
001774r 3  F0 03        	BEQ	RDSTAT1			; NO, INDICATE NO CHAR
001776r 3  A9 FF        	LDA	#$FF			; GET DATA CHAR
001778r 3  60           	RTS
001779r 3               RDSTAT1:
001779r 3  A9 00        	LDA	#$00			; GET DATA CHAR
00177Br 3  60           	RTS
00177Cr 3               
00177Cr 3               ; end
00177Cr 3               
00177Cr 2                 .ENDIF
00177Cr 2               
00177Cr 2               
00177Cr 2                   .IF USEIDEC=1
00177Cr 2               	.INCLUDE "DOSIDE.ASM"
00177Cr 3               ;__IDE DRIVERS___________________________________________________________________________________________________________________
00177Cr 3               ;
00177Cr 3               ; 	Nhyodyne IDE disk drivers for Z80PPIDE card
00177Cr 3               ;
00177Cr 3               ;	Entry points:
00177Cr 3               ;		IDE_SOFT_RESET   - called during OS init
00177Cr 3               ;		IDE_READ_SECTOR  - read a sector from drive  ('U' POINTS TO DCB, X TO MEMORY)
00177Cr 3               ;		IDE_WRITE_SECTOR - write a sector to drive   ('U' POINTS TO DCB, X TO MEMORY)
00177Cr 3               ;________________________________________________________________________________________________________________________________
00177Cr 3               ;
00177Cr 3               PPI		=	$0360		; PORT A
00177Cr 3               ;
00177Cr 3               IDELO		=	PPI+0		; LSB
00177Cr 3               IDEHI		=	PPI+1		; MSB
00177Cr 3               IDECNTRL	=	PPI+2		; Control Signals
00177Cr 3               IDEPPIC		=	PPI+3		; CONTROL BYTE PPI 82C55
00177Cr 3               
00177Cr 3               IDE_A0_LINE	=	$01		;DIRECT FROM 8255 TO IDE INTERFACE
00177Cr 3               IDE_A1_LINE	=	$02		;DIRECT FROM 8255 TO IDE INTERFACE
00177Cr 3               IDE_A2_LINE	=	$04		;DIRECT FROM 8255 TO IDE INTERFACE
00177Cr 3               IDE_CS0_LINE	=	$08		;INVERTER BETWEEN 8255 AND IDE INTERFACE
00177Cr 3               IDE_CS1_LINE	=	$10		;INVERTER BETWEEN 8255 AND IDE INTERFACE
00177Cr 3               IDE_WR_LINE	=	$20		;INVERTER BETWEEN 8255 AND IDE INTERFACE
00177Cr 3               IDE_RD_LINE	=	$40		;INVERTER BETWEEN 8255 AND IDE INTERFACE
00177Cr 3               IDE_RST_LINE	=	$80		;INVERTER BETWEEN 8255 AND IDE INTERFACE
00177Cr 3               
00177Cr 3               IDE_DATA	=	IDE_CS0_LINE
00177Cr 3               IDE_ERR		=	IDE_CS0_LINE + IDE_A0_LINE
00177Cr 3               IDE_SEC_CNT	=	IDE_CS0_LINE + IDE_A1_LINE
00177Cr 3               IDE_SECTOR	=	IDE_CS0_LINE + IDE_A1_LINE + IDE_A0_LINE
00177Cr 3               IDE_CYL_LSB	=	IDE_CS0_LINE + IDE_A2_LINE
00177Cr 3               IDE_CYL_MSB	=	IDE_CS0_LINE + IDE_A2_LINE + IDE_A0_LINE
00177Cr 3               IDE_HEAD	=	IDE_CS0_LINE + IDE_A2_LINE + IDE_A1_LINE
00177Cr 3               IDE_COMMAND	=	IDE_CS0_LINE + IDE_A2_LINE + IDE_A1_LINE + IDE_A0_LINE
00177Cr 3               IDE_STATUS	=	IDE_CS0_LINE + IDE_A2_LINE + IDE_A1_LINE + IDE_A0_LINE
00177Cr 3               IDE_CONTROL	=	IDE_CS1_LINE + IDE_A2_LINE + IDE_A1_LINE
00177Cr 3               IDE_ASTATUS	=	IDE_CS1_LINE + IDE_A2_LINE + IDE_A1_LINE + IDE_A0_LINE
00177Cr 3               IDE_RESET	=	IDE_RST_LINE + IDE_CS0_LINE
00177Cr 3               
00177Cr 3               ;IDE COMMAND CONSTANTS.  THESE SHOULD NEVER CHANGE.
00177Cr 3               IDE_CMD_RECAL	=	$10
00177Cr 3               IDE_CMD_READ	=	$20
00177Cr 3               IDE_CMD_WRITE	=	$30
00177Cr 3               IDE_CMD_INIT	=	$91
00177Cr 3               IDE_CMD_ID	=	$EC
00177Cr 3               IDE_CMD_SPINDOWN=	$E0
00177Cr 3               IDE_CMD_SPINUP	=	$E1
00177Cr 3               
00177Cr 3               
00177Cr 3               RD_IDE_8255	=	%10010010	;IDE_8255_CTL OUT, IDE_8255_LSB/MSB INPUT
00177Cr 3               WR_IDE_8255	=	%10000000	;ALL THREE PORTS OUTPUT
00177Cr 3               
00177Cr 3  00           IDEINDEX:	.byte	$00
00177Dr 3               
00177Dr 3               ;*__IDE_READ_SECTOR___________________________________________________________________________________
00177Dr 3               ;*
00177Dr 3               ;*  READ IDE SECTOR (IN LBA) INTO BUFFER
00177Dr 3               ;*
00177Dr 3               ;*____________________________________________________________________________________________________
00177Dr 3               IDE_READ_SECTOR:
00177Dr 3  48 DA 5A A2  		PRTDBG "IDE Read Sector$"
001781r 3  00 BD rr rr  
001785r 3  E8 C9 24 F0  
0017AEr 3  AD rr rr     		LDA	debhead			; STORE CURRENT PARMS
0017B1r 3  CD rr rr     		CMP	Cdebhead		;
0017B4r 3  D0 13        		BNE	IDE_READ_SECTOR_DIRTY
0017B6r 3  AD rr rr     		LDA	debcyl			;
0017B9r 3  CD rr rr     		CMP	Cdebcyl			;
0017BCr 3  D0 0B        		BNE	IDE_READ_SECTOR_DIRTY
0017BEr 3  AD rr rr     		LDA	debsec			;
0017C1r 3  CD rr rr     		CMP	Cdebsec			;
0017C4r 3  D0 03        		BNE	IDE_READ_SECTOR_DIRTY
0017C6r 3  A9 00        		LDA	#$00			; ZERO = 1 ON RETURN = OPERATION OK
0017C8r 3  60           		RTS
0017C9r 3               
0017C9r 3               IDE_READ_SECTOR_DIRTY:
0017C9r 3  48 DA 5A A2  		PRTDBG "IDE Read Sector Buffer Dirty$"
0017CDr 3  00 BD rr rr  
0017D1r 3  E8 C9 24 F0  
001807r 3  20 rr rr     		JSR	IDE_WAIT_NOT_BUSY	;MAKE SURE DRIVE IS READY
00180Ar 3  20 rr rr     		JSR	IDE_SETUP_LBA		;TELL IT WHICH SECTOR WE WANT
00180Dr 3  A9 0F        		LDA	#IDE_COMMAND		;SELECT IDE REGISTER
00180Fr 3  A2 20        		LDX	#IDE_CMD_READ
001811r 3  20 rr rr     		JSR	IDE_WRITE		;ASK THE DRIVE TO READ IT
001814r 3  20 rr rr     		JSR	IDE_WAIT_DRQ		;WAIT UNTIL IT'S GOT THE DATA
001817r 3  20 rr rr     		JSR	IDE_READ_BUFFER		; GRAB THE 256 WORDS FROM THE BUFFER
00181Ar 3               
00181Ar 3  AD rr rr     		LDA	debhead			; STORE CURRENT PARMS
00181Dr 3  8D rr rr     		STA	Cdebhead		;
001820r 3  AD rr rr     		LDA	debcyl			;
001823r 3  8D rr rr     		STA	Cdebcyl			;
001826r 3  AD rr rr     		LDA	debsec			;
001829r 3  8D rr rr     		STA	Cdebsec			;
00182Cr 3               
00182Cr 3  A9 00        		LDA	#$00			; ZERO = 1 ON RETURN = OPERATION OK
00182Er 3  60           		RTS
00182Fr 3               
00182Fr 3               
00182Fr 3               ;*__IDE_WRITE_SECTOR__________________________________________________________________________________
00182Fr 3               ;*
00182Fr 3               ;*  WRITE IDE SECTOR (IN LBA) FROM BUFFER
00182Fr 3               ;*
00182Fr 3               ;*____________________________________________________________________________________________________
00182Fr 3               IDE_WRITE_SECTOR:
00182Fr 3  48 DA 5A A2  		PRTDBG "IDE Write Sector$"
001833r 3  00 BD rr rr  
001837r 3  E8 C9 24 F0  
001861r 3  20 rr rr     		JSR	IDE_WAIT_NOT_BUSY	;MAKE SURE DRIVE IS READY
001864r 3  20 rr rr     		JSR	IDE_SETUP_LBA		;TELL IT WHICH SECTOR WE WANT
001867r 3  A9 0F        		LDA	#IDE_COMMAND
001869r 3  A2 30        		LDX	#IDE_CMD_WRITE
00186Br 3  20 rr rr     		JSR	IDE_WRITE		;TELL DRIVE TO WRITE A SECTOR
00186Er 3  20 rr rr     		JSR	IDE_WAIT_DRQ		;WAIT UNIT IT WANTS THE DATA
001871r 3  20 rr rr     		JSR	IDE_WRITE_BUFFER	;GIVE THE DATA TO THE DRIVE
001874r 3  20 rr rr     		JSR	IDE_WAIT_NOT_BUSY	;WAIT UNTIL THE WRITE IS COMPLETE
001877r 3               
001877r 3  A9 FF        		LDA	#$FF			; STORE CURRENT PARMS
001879r 3  8D rr rr     		STA	Cdebhead		;
00187Cr 3  8D rr rr     		STA	Cdebcyl			;
00187Fr 3  8D rr rr     		STA	Cdebsec			;
001882r 3               
001882r 3  A9 00        		LDA	#$00			; ZERO = 1 ON RETURN = OPERATION OK
001884r 3  60           		RTS
001885r 3               
001885r 3               ;*__IDE_SOFT_RESET____________________________________________________________________________________
001885r 3               ;*
001885r 3               ;*  SOFT RESET IDE CHANNEL
001885r 3               ;*
001885r 3               ;*____________________________________________________________________________________________________
001885r 3               IDE_SOFT_RESET:
001885r 3  48 DA 5A A2    	PRTDBG "IDE Reset$"
001889r 3  00 BD rr rr  
00188Dr 3  E8 C9 24 F0  
0018B0r 3  A9 00        		LDA	#$00
0018B2r 3  8D rr rr     		STA	debhead
0018B5r 3  8D rr rr     		STA	debcyl
0018B8r 3  8D rr rr     		STA	debsec
0018BBr 3  A9 FF        		LDA	#$FF			;
0018BDr 3  8D rr rr     		STA	Cdebhead		;
0018C0r 3  8D rr rr     		STA	Cdebcyl			;
0018C3r 3  8D rr rr     		STA	Cdebsec			;
0018C6r 3  20 rr rr     		JSR	SET_PPI_RD
0018C9r 3  A9 88        		LDA	#IDE_RESET
0018CBr 3  8D 62 03     		STA	IDECNTRL			; ASSERT RST LINE ON IDE INTERFACE
0018CEr 3  A2 00        		LDX	#$00
0018D0r 3  48 DA 5A A2  	PRTDBG "IDE Reset Delay$"
0018D4r 3  00 BD rr rr  
0018D8r 3  E8 C9 24 F0  
001901r 3               RST_DLY:
001901r 3  CA           		DEX
001902r 3  E0 00        		CPX	#$00
001904r 3  D0 FB        		BNE	RST_DLY
001906r 3  A9 0F        		LDA	#IDE_STATUS
001908r 3  8D 62 03     		STA	IDECNTRL			; DEASSERT RST LINE ON IDE INTERFACE
00190Br 3  60           		RTS
00190Cr 3               
00190Cr 3               
00190Cr 3               ;*__IDE_WAIT_NOT_BUSY_______________________________________________________________________________
00190Cr 3               ;*
00190Cr 3               ;*  WAIT FOR IDE CHANNEL TO BECOME READY
00190Cr 3               ;*
00190Cr 3               ;*____________________________________________________________________________________________________
00190Cr 3               IDE_WAIT_NOT_BUSY:
00190Cr 3  A9 0F        		LDA	#IDE_STATUS		;WAIT FOR RDY BIT TO BE SET
00190Er 3  20 rr rr     		JSR	IDE_READ
001911r 3  8A           		TXA
001912r 3  29 80        		AND	#$80
001914r 3  D0 F6        		BNE	IDE_WAIT_NOT_BUSY
001916r 3  60           		RTS
001917r 3               
001917r 3               
001917r 3               
001917r 3               IDE_WAIT_READY:
001917r 3  A9 0F        		LDA	#IDE_STATUS		;WAIT FOR RDY BIT TO BE SET
001919r 3  20 rr rr     		JSR	IDE_READ
00191Cr 3  8A           		TXA
00191Dr 3  29 C0        		AND	#%11000000		;MASK OFF BUSY AND READY BITS
00191Fr 3  C9 40        		CMP	#%01000000		;WE WANT BUSY(7) TO BE 0 AND READY(6) TO BE 1
001921r 3  D0 F4        		BNE	IDE_WAIT_READY
001923r 3  60           		RTS
001924r 3               
001924r 3               	;WAIT FOR THE DRIVE TO BE READY TO TRANSFER DATA.
001924r 3               	;RETURNS THE DRIVE'S STATUS IN ACC
001924r 3               IDE_WAIT_DRQ:
001924r 3  A9 0F        		LDA	#IDE_STATUS		;WAIT FOR DRQ BIT TO BE SET
001926r 3  20 rr rr     		JSR	IDE_READ
001929r 3  8A           		TXA
00192Ar 3  29 88        		AND	#%10001000		; MASK OFF BUSY(7) AND DRQ(3)
00192Cr 3  C9 08        		CMP	#%00001000		; WE WANT BUSY(7) TO BE 0 AND DRQ (3) TO BE 1
00192Er 3  D0 F4        		BNE	IDE_WAIT_DRQ
001930r 3  60           		RTS
001931r 3               
001931r 3               
001931r 3               
001931r 3               ;*__IDE_READ_BUFFER___________________________________________________________________________________
001931r 3               ;*
001931r 3               ;*  READ IDE BUFFER LITTLE ENDIAN
001931r 3               ;*
001931r 3               ;*____________________________________________________________________________________________________
001931r 3               IDE_READ_BUFFER:
001931r 3  A2 00        		LDX    	#$00			; INDEX
001933r 3               IDEBUFRD:
001933r 3  8E rr rr     		STX	IDEINDEX
001936r 3  A9 08        		LDA	#IDE_DATA
001938r 3  20 rr rr     		JSR	IDE_READ
00193Br 3  8A           		TXA
00193Cr 3  AE rr rr     		LDX	IDEINDEX
00193Fr 3  9D rr rr     		STA	hstbuf,X		;
001942r 3  E8           		INX				;
001943r 3  98           		TYA				; THEN HIGH BYTE OF WORD
001944r 3  9D rr rr     		STA	hstbuf,X		;
001947r 3  E8           		INX
001948r 3  E0 00        		CPX    	#$00			;
00194Ar 3  D0 E7        		BNE	IDEBUFRD		;
00194Cr 3               IDEBUFRD1:
00194Cr 3  8E rr rr     		STX	IDEINDEX
00194Fr 3  A9 08        		LDA	#IDE_DATA
001951r 3  20 rr rr     		JSR	IDE_READ
001954r 3  8A           		TXA
001955r 3  AE rr rr     		LDX	IDEINDEX
001958r 3  9D rr rr     		STA	hstbuf+256,X		;
00195Br 3  E8           		INX				;
00195Cr 3  98           		TYA				; THEN HIGH BYTE OF WORD
00195Dr 3  9D rr rr     		STA	hstbuf+256,X		;
001960r 3  E8           		INX				;
001961r 3  E0 00        		CPX    	#$00			;
001963r 3  D0 E7        		BNE	IDEBUFRD1		;
001965r 3  60           		RTS				;
001966r 3               
001966r 3               ;*__IDE_WRITE_BUFFER___________________________________________________________________________________
001966r 3               ;*
001966r 3               ;*  WRITE IDE BUFFER LITTLE ENDIAN
001966r 3               ;*
001966r 3               ;*____________________________________________________________________________________________________
001966r 3               IDE_WRITE_BUFFER:
001966r 3  A2 00        		LDX    	#$00			; INDEX
001968r 3               IDEBUFWT:
001968r 3  8E rr rr     		STX	IDEINDEX
00196Br 3  BD rr rr     		LDA     hstbuf+1,X		; SECTORS ARE BIG ENDIAN
00196Er 3  A8           		TAY				;
00196Fr 3  BD rr rr     		LDA     hstbuf,X		; SECTORS ARE BIG ENDIAN
001972r 3  AA           		TAX
001973r 3  A9 08        		LDA	#IDE_DATA
001975r 3  20 rr rr     		JSR	IDE_WRITE
001978r 3  AE rr rr     		LDX	IDEINDEX
00197Br 3  E8           		INX				;
00197Cr 3  E8           		INX				;
00197Dr 3  E0 00        		CPX    	#$00			;
00197Fr 3  D0 E7        		BNE	IDEBUFWT		;
001981r 3  A2 00        		LDX    	#$00			; INDEX
001983r 3               IDEBUFWT1:
001983r 3  8E rr rr     		STX	IDEINDEX
001986r 3  BD rr rr     		LDA     hstbuf+257,X		; SECTORS ARE BIG ENDIAN
001989r 3  A8           		TAY
00198Ar 3  BD rr rr     		LDA     hstbuf+256,X		; SECTORS ARE BIG ENDIAN
00198Dr 3  AA           		TAX
00198Er 3  A9 08        		LDA	#IDE_DATA
001990r 3  20 rr rr     		JSR	IDE_WRITE
001993r 3  AE rr rr     		LDX	IDEINDEX
001996r 3  E8           		INX				;
001997r 3  E8           		INX				;
001998r 3  E0 00        		CPX    	#$00			;
00199Ar 3  D0 E7        		BNE	IDEBUFWT1		;
00199Cr 3  60           		RTS				;
00199Dr 3               
00199Dr 3               ;*__IDE_SETUP_LBA_____________________________________________________________________________________
00199Dr 3               ;*
00199Dr 3               ;*  SETUP LBA DATA
00199Dr 3               ;*
00199Dr 3               ;*____________________________________________________________________________________________________
00199Dr 3               IDE_SETUP_LBA:
00199Dr 3               
00199Dr 3  A0 00        		LDY	#$00
00199Fr 3  A2 E0        		LDX	#$E0			; MSB
0019A1r 3  A9 0E        		LDA	#IDE_HEAD
0019A3r 3  20 rr rr     		JSR	IDE_WRITE
0019A6r 3               
0019A6r 3  AE rr rr     		LDX    	debhead
0019A9r 3  A9 0D        		LDA	#IDE_CYL_MSB
0019ABr 3  20 rr rr     		JSR	IDE_WRITE
0019AEr 3               
0019AEr 3  AE rr rr     		LDX    	debcyl			;
0019B1r 3  A9 0C        		LDA	#IDE_CYL_LSB
0019B3r 3  20 rr rr     		JSR	IDE_WRITE
0019B6r 3               
0019B6r 3  AE rr rr     		LDX    	debsec			;
0019B9r 3  A9 0B        		LDA	#IDE_SECTOR
0019BBr 3  20 rr rr     		JSR	IDE_WRITE
0019BEr 3               
0019BEr 3  A2 01        		LDX	#$01
0019C0r 3  A9 0A        		LDA	#IDE_SEC_CNT
0019C2r 3  20 rr rr     		JSR	IDE_WRITE
0019C5r 3               
0019C5r 3  60           		RTS
0019C6r 3               
0019C6r 3               
0019C6r 3               ;-------------------------------------------------------------------------------
0019C6r 3               
0019C6r 3               ; LOW LEVEL I/O TO THE DRIVE.  THESE ARE THE ROUTINES THAT TALK
0019C6r 3               ; DIRECTLY TO THE DRIVE, VIA THE 8255 CHIP.  NORMALLY A MAIN
0019C6r 3               ; PROGRAM WOULD NOT CALL TO THESE.
0019C6r 3               
0019C6r 3               	;DO A READ BUS CYCLE TO THE DRIVE, USING THE 8255.
0019C6r 3               	;INPUT A = IDE REGSITER ADDRESS
0019C6r 3               	;OUTPUT X = LOWER BYTE READ FROM IDE DRIVE
0019C6r 3               	;OUTPUT Y = UPPER BYTE READ FROM IDE DRIVE
0019C6r 3               
0019C6r 3               IDE_READ:
0019C6r 3  20 rr rr     	JSR	SET_PPI_RD		; SETUP FOR A READ CYCLE
0019C9r 3               
0019C9r 3  8D 62 03     	STA	IDECNTRL		;DRIVE ADDRESS ONTO CONTROL LINES
0019CCr 3  09 40        	ORA	#IDE_RD_LINE		; ASSERT RD PIN
0019CEr 3  8D 62 03     	STA	IDECNTRL
0019D1r 3  48           	PHA
0019D2r 3               
0019D2r 3  AE 60 03     	LDX	IDELO			; READ LOWER BYTE
0019D5r 3  AC 61 03     	LDY	IDEHI			; READ UPPER BYTE
0019D8r 3               
0019D8r 3  68           	PLA				; RESTORE REGISTER VALUE
0019D9r 3  49 40        	EOR	#IDE_RD_LINE		; DE-ASSERT RD SIGNAL
0019DBr 3  8D 62 03     	STA	IDECNTRL
0019DEr 3  A9 0F        	LDA	#IDE_STATUS
0019E0r 3  8D 62 03     	STA	IDECNTRL		;DEASSERT ALL CONTROL PINS
0019E3r 3  60           	RTS
0019E4r 3               
0019E4r 3               
0019E4r 3               
0019E4r 3               
0019E4r 3               	;DO A WRITE BUS CYCLE TO THE DRIVE, VIA THE 8255
0019E4r 3               	;INPUT A = IDE REGISTER ADDRESS
0019E4r 3               	;INPUT REGISTER X = LSB TO WRITE
0019E4r 3               	;INPUT REGISTER Y = MSB TO WRITE
0019E4r 3               	;
0019E4r 3               
0019E4r 3               
0019E4r 3               IDE_WRITE:
0019E4r 3  20 rr rr     	JSR	SET_PPI_WR		; SETUP FOR A WRITE CYCLE
0019E7r 3               
0019E7r 3  8E 60 03     	STX	IDELO			; WRITE LOWER BYTE
0019EAr 3  8C 61 03     	STY	IDEHI			; WRITE UPPER BYTE
0019EDr 3               
0019EDr 3  8D 62 03     	STA	IDECNTRL		;DRIVE ADDRESS ONTO CONTROL LINES
0019F0r 3               
0019F0r 3  09 20        	ORA	#IDE_WR_LINE		; ASSERT WRITE PIN
0019F2r 3  8D 62 03     	STA	IDECNTRL
0019F5r 3               
0019F5r 3  49 20        	EOR	#IDE_WR_LINE		; DE ASSERT WR PIN
0019F7r 3  8D 62 03     	STA	IDECNTRL
0019FAr 3               
0019FAr 3  A9 0F        	LDA	#IDE_STATUS
0019FCr 3  8D 62 03     	STA	IDECNTRL		;DEASSERT ALL CONTROL PINS
0019FFr 3  60           	RTS
001A00r 3               
001A00r 3               
001A00r 3               ;-----------------------------------------------------------------------------------
001A00r 3               ; PPI SETUP ROUTINE TO CONFIGURE THE APPROPRIATE PPI MODE
001A00r 3               ;
001A00r 3               ;------------------------------------------------------------------------------------
001A00r 3               
001A00r 3               SET_PPI_RD:
001A00r 3  48           	PHA
001A01r 3  A9 92        	LDA	#RD_IDE_8255
001A03r 3  8D 63 03     	STA	IDEPPIC				;CONFIG 8255 CHIP, READ MODE
001A06r 3  68           	PLA
001A07r 3  60           	RTS
001A08r 3               
001A08r 3               SET_PPI_WR:
001A08r 3  48           	PHA
001A09r 3  A9 80        	LDA	#WR_IDE_8255
001A0Br 3  8D 63 03     	STA	IDEPPIC				;CONFIG 8255 CHIP, WRITE MODE
001A0Er 3  68           	PLA
001A0Fr 3  60           	RTS
001A10r 3               
001A10r 2                   .ENDIF
001A10r 2               
001A10r 2                   .IF USEFLOPPYA=1 | USEFLOPPYB=1
001A10r 2               	.INCLUDE "DOS65\\DOSFLPV3.ASM"
001A10r 2                   .ENDIF
001A10r 2               
001A10r 2                   .IF USEDSKY=1
001A10r 2                    .INCLUDE "DOS65\\DOSDSKY.ASM"
001A10r 2                   .ENDIF
001A10r 2               
001A10r 2               ;------------------------------------------------------------------------------------
001A10r 2               
001A10r 2               
001A10r 2               ;disk control blocks
001A10r 2               ;drive a (3.5" FDD)
001A10r 2               	.IF FLPA35=1
001A10r 2               dcba:	.word	350		;max block number
001A10r 2               	.word	36		;sectors per track
001A10r 2               	.word	4		;number system tracks
001A10r 2               	.byte	1		;block size = 2048
001A10r 2               	.word	127		;max directory number
001A10r 2               	.word	almpa		;address of map for a
001A10r 2               	.byte	80		;do checksums
001A10r 2               	.word	ckmpa		;checksum map
001A10r 2               	.ELSE
001A10r 2  AF 00        dcba:	.word	175		;max block number
001A12r 2  24 00        	.word	36		;sectors per track
001A14r 2  04 00        	.word	4		;number system tracks
001A16r 2  01           	.byte	1		;block size = 2048
001A17r 2  7F 00        	.word	127		;max directory number
001A19r 2  rr rr        	.word	almpa		;address of map for a
001A1Br 2  50           	.byte	80		;do checksums
001A1Cr 2  rr rr        	.word	ckmpa		;checksum map
001A1Er 2               	.endif
001A1Er 2               
001A1Er 2               	.IF FLPB35=1
001A1Er 2               dcbb:	.word	350		;max block number
001A1Er 2               	.word	36		;sectors per track
001A1Er 2               	.word	4		;number system tracks
001A1Er 2               	.byte	1		;block size = 2048
001A1Er 2               	.word	127		;max directory number
001A1Er 2               	.word	almpa		;address of map for a
001A1Er 2               	.byte	80		;do checksums
001A1Er 2               	.word	ckmpa		;checksum map
001A1Er 2               	.ELSE
001A1Er 2  AF 00        dcbb:	.word	175		;max block number
001A20r 2  24 00        	.word	36		;sectors per track
001A22r 2  04 00        	.word	4		;number system tracks
001A24r 2  01           	.byte	1		;block size = 2048
001A25r 2  7F 00        	.word	127		;max directory number
001A27r 2  rr rr        	.word	almpa		;address of map for a
001A29r 2  50           	.byte	80		;do checksums
001A2Ar 2  rr rr        	.word	ckmpa		;checksum map
001A2Cr 2               	.endif
001A2Cr 2               
001A2Cr 2               ;drive c (IDE)
001A2Cr 2  E1 07        dcbc:	.word	2017		;max block number
001A2Er 2  00 01        	.word	256		;sectors per track
001A30r 2  01 00        	.word	$0001		;number system tracks
001A32r 2  02           	.byte	2		;block size = 4096
001A33r 2  FF 01        	.word	511		;max directory number
001A35r 2  rr rr        	.word	almpc		;address of map for C
001A37r 2  50           	.byte	80		;do checksums
001A38r 2  rr rr        	.word	ckmpc		;checksum map
001A3Ar 2               ;data area
001A3Ar 2               
001A3Ar 2               
001A3Ar 2  02           sekdsk:	.byte	2		;seek disk number
001A3Br 2  00           hstwrt:	.byte	0		;0=written,1=pending host write
001A3Cr 2               
001A3Cr 2               ;allocate the following data areas to unused ram space
001A3Cr 2  00           LASTCHAR: 	.byte 0		;save sector for warm boot
001A3Dr 2  00           savsec:		.byte 0		;save sector for warm boot
001A3Er 2  00           count:		.byte 0		;counter in warm boot
001A3Fr 2  00           temp:		.byte 0		;save hstdsk for warm boot
001A40r 2  00           hstact:		.byte 0		;host active flag
001A41r 2  00           unacnt:		.byte 0		;unalloc rec cnt
001A42r 2  00 00        sektrk:		.word 0		;seek track number
001A44r 2  00 00        seksec:		.word 0		;seek sector number
001A46r 2  00           debhead:	.byte 0		; DEBLOCKED HEAD
001A47r 2  00           debcyl:		.byte 0		; DEBLOCKED CYLINDER ID
001A48r 2  00           debsec:		.byte 0		; DEBLOCKED SECTOR
001A49r 2  00 00        debtmp:		.word 0		; DEBLOCK TEMP VAR
001A4Br 2  FF           Cdebhead: 	.byte $FF		; DEBLOCKED HEAD
001A4Cr 2  FF           Cdebcyl:	.byte $FF		; DEBLOCKED CYLINDER ID
001A4Dr 2  FF           Cdebsec:	.byte $FF		; DEBLOCKED SECTOR
001A4Er 2  00           DEBDIRTY:	.byte 0		; DIRTY FLAG
001A4Fr 2               
001A4Fr 2               ;allocation maps
001A4Fr 2               ;drive a
001A4Fr 2  xx xx xx xx  almpa:		.res	45
001A53r 2  xx xx xx xx  
001A57r 2  xx xx xx xx  
001A7Cr 2               ;drive b
001A7Cr 2  xx xx xx xx  almpb:		.res	254
001A80r 2  xx xx xx xx  
001A84r 2  xx xx xx xx  
001B7Ar 2               ;drive c
001B7Ar 2  xx xx xx xx  almpc:		.res	254
001B7Er 2  xx xx xx xx  
001B82r 2  xx xx xx xx  
001C78r 2               ;checksum maps
001C78r 2               
001C78r 2               
001C78r 2               ;drive a
001C78r 2  xx xx xx xx  ckmpa:		.res	32
001C7Cr 2  xx xx xx xx  
001C80r 2  xx xx xx xx  
001C98r 2               ;drive b
001C98r 2  xx xx xx xx  ckmpb:		.res	128
001C9Cr 2  xx xx xx xx  
001CA0r 2  xx xx xx xx  
001D18r 2               ;drive c
001D18r 2  xx xx xx xx  ckmpc:		.res	128
001D1Cr 2  xx xx xx xx  
001D20r 2  xx xx xx xx  
001D98r 2               ;deblocking buffer for dba
001D98r 2  xx xx xx xx  hstbuf:		.res	512		;256 or 512 byte sectors
001D9Cr 2  xx xx xx xx  
001DA0r 2  xx xx xx xx  
001F98r 2               
001F98r 1               
001F98r 1               
001F98r 1                               .segment "VECTORS"
000000r 1  rr rr        NMIVECTOR:      .WORD   boot		;
000002r 1  rr rr        RSTVECTOR:      .WORD   boot		;
000004r 1  rr rr        INTVECTOR: 	.WORD   boot		; ROM VECTOR FOR IRQ
000006r 1               
000006r 1               	.end
